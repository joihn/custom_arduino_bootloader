   1               		.file	"StillImageHost.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.LEDs_SetAllLEDs,"ax",@progbits
  13               	LEDs_SetAllLEDs:
  14               	.LFB143:
  15               		.file 1 "../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h"
   1:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** /*
   2:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****              LUFA Library
   3:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
   5:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** */
   8:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
   9:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** /*
  10:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  12:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  21:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****   this software.
  29:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** */
  30:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  31:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** /** \file
  32:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *  \brief Board specific LED driver header for the Atmel USBKEY.
  33:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *  \copydetails Group_LEDs_USBKEY
  34:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *
  35:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *        dispatch header located in LUFA/Drivers/Board/LEDs.h.
  37:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  */
  38:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  39:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** /** \ingroup Group_LEDs
  40:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *  \defgroup Group_LEDs_USBKEY USBKEY
  41:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *  \brief Board specific LED driver header for the Atmel USBKEY.
  42:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *
  43:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *  Board specific LED driver header for the Atmel USBKEY.
  44:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *
  45:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  *  @{
  46:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h ****  */
  47:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  48:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** #ifndef __LEDS_USBKEY_H__
  49:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** #define __LEDS_USBKEY_H__
  50:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  51:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 	/* Includes: */
  52:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 		#include "../../../../Common/Common.h"
  53:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  54:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 	/* Enable C linkage for C++ Compilers: */
  55:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 		#if defined(__cplusplus)
  56:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			extern "C" {
  57:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 		#endif
  58:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  59:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 	/* Preprocessor Checks: */
  60:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 		#if !defined(__INCLUDE_FROM_LEDS_H)
  61:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			#error Do not include this file directly. Include LUFA/Drivers/Board/LEDS.h instead.
  62:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 		#endif
  63:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  64:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 	/* Public Interface - May be used in end-application: */
  65:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 		/* Macros: */
  66:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			/** LED mask for the first LED on the board. */
  67:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			#define LEDS_LED1        (1 << 4)
  68:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  69:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			/** LED mask for the second LED on the board. */
  70:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			#define LEDS_LED2        (1 << 5)
  71:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  72:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			/** LED mask for the third LED on the board. */
  73:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			#define LEDS_LED3        (1 << 7)
  74:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  75:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			/** LED mask for the fourth LED on the board. */
  76:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			#define LEDS_LED4        (1 << 6)
  77:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  78:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			/** LED mask for all the LEDs on the board. */
  79:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			#define LEDS_ALL_LEDS    (LEDS_LED1 | LEDS_LED2 | LEDS_LED3 | LEDS_LED4)
  80:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  81:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			/** LED mask for none of the board LEDs. */
  82:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			#define LEDS_NO_LEDS     0
  83:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  84:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 		/* Inline Functions: */
  85:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 		#if !defined(__DOXYGEN__)
  86:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			static inline void LEDs_Init(void)
  87:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			{
  88:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 				DDRD  |=  LEDS_ALL_LEDS;
  89:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 				PORTD &= ~LEDS_ALL_LEDS;
  90:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			}
  91:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  92:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			static inline void LEDs_TurnOnLEDs(const uint8_t LEDMask)
  93:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			{
  94:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 				PORTD |= LEDMask;
  95:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			}
  96:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
  97:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			static inline void LEDs_TurnOffLEDs(const uint8_t LEDMask)
  98:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			{
  99:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 				PORTD &= ~LEDMask;
 100:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			}
 101:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 
 102:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
 103:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			{
  16               		.loc 1 103 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 104:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
  23               		.loc 1 104 0
  24 0000 9BB1      		in r25,0xb
  25 0002 9F70      		andi r25,lo8(15)
  26 0004 892B      		or r24,r25
  27               	.LVL1:
  28 0006 8BB9      		out 0xb,r24
  29 0008 0895      		ret
  30               		.cfi_endproc
  31               	.LFE143:
  33               		.section	.text.SetupHardware,"ax",@progbits
  34               	.global	SetupHardware
  36               	SetupHardware:
  37               	.LFB148:
  38               		.file 2 "StillImageHost.c"
   1:StillImageHost.c **** /*
   2:StillImageHost.c ****              LUFA Library
   3:StillImageHost.c ****      Copyright (C) Dean Camera, 2011.
   4:StillImageHost.c **** 
   5:StillImageHost.c ****   dean [at] fourwalledcubicle [dot] com
   6:StillImageHost.c ****            www.lufa-lib.org
   7:StillImageHost.c **** */
   8:StillImageHost.c **** 
   9:StillImageHost.c **** /*
  10:StillImageHost.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:StillImageHost.c **** 
  12:StillImageHost.c ****   Permission to use, copy, modify, distribute, and sell this
  13:StillImageHost.c ****   software and its documentation for any purpose is hereby granted
  14:StillImageHost.c ****   without fee, provided that the above copyright notice appear in
  15:StillImageHost.c ****   all copies and that both that the copyright notice and this
  16:StillImageHost.c ****   permission notice and warranty disclaimer appear in supporting
  17:StillImageHost.c ****   documentation, and that the name of the author not be used in
  18:StillImageHost.c ****   advertising or publicity pertaining to distribution of the
  19:StillImageHost.c ****   software without specific, written prior permission.
  20:StillImageHost.c **** 
  21:StillImageHost.c ****   The author disclaim all warranties with regard to this
  22:StillImageHost.c ****   software, including all implied warranties of merchantability
  23:StillImageHost.c ****   and fitness.  In no event shall the author be liable for any
  24:StillImageHost.c ****   special, indirect or consequential damages or any damages
  25:StillImageHost.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:StillImageHost.c ****   in an action of contract, negligence or other tortious action,
  27:StillImageHost.c ****   arising out of or in connection with the use or performance of
  28:StillImageHost.c ****   this software.
  29:StillImageHost.c **** */
  30:StillImageHost.c **** 
  31:StillImageHost.c **** /** \file
  32:StillImageHost.c ****  *
  33:StillImageHost.c ****  *  Main source file for the StillImageHost demo. This file contains the main tasks of
  34:StillImageHost.c ****  *  the demo and is responsible for the initial application hardware configuration.
  35:StillImageHost.c ****  */
  36:StillImageHost.c **** 
  37:StillImageHost.c **** #include "StillImageHost.h"
  38:StillImageHost.c **** 
  39:StillImageHost.c **** /** Main program entry point. This routine configures the hardware required by the application, the
  40:StillImageHost.c ****  *  enters a loop to run the application tasks in sequence.
  41:StillImageHost.c ****  */
  42:StillImageHost.c **** int main(void)
  43:StillImageHost.c **** {
  44:StillImageHost.c **** 	SetupHardware();
  45:StillImageHost.c **** 
  46:StillImageHost.c **** 	puts_P(PSTR(ESC_FG_CYAN "Still Image Host Demo running.\r\n" ESC_FG_WHITE));
  47:StillImageHost.c **** 
  48:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
  49:StillImageHost.c **** 	sei();
  50:StillImageHost.c **** 
  51:StillImageHost.c **** 	for (;;)
  52:StillImageHost.c **** 	{
  53:StillImageHost.c **** 		StillImageHost_Task();
  54:StillImageHost.c **** 
  55:StillImageHost.c **** 		USB_USBTask();
  56:StillImageHost.c **** 	}
  57:StillImageHost.c **** }
  58:StillImageHost.c **** 
  59:StillImageHost.c **** /** Configures the board hardware and chip peripherals for the demo's functionality. */
  60:StillImageHost.c **** void SetupHardware(void)
  61:StillImageHost.c **** {
  39               		.loc 2 61 0
  40               		.cfi_startproc
  41               	/* prologue: function */
  42               	/* frame size = 0 */
  43               	/* stack size = 0 */
  44               	.L__stack_usage = 0
  62:StillImageHost.c **** 	/* Disable watchdog if enabled by bootloader/fuses */
  63:StillImageHost.c **** 	MCUSR &= ~(1 << WDRF);
  45               		.loc 2 63 0
  46 0000 84B7      		in r24,0x34
  47 0002 877F      		andi r24,lo8(-9)
  48 0004 84BF      		out 0x34,r24
  49               	.LBB22:
  50               	.LBB23:
  51               		.file 3 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 474:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 475:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 476:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 477:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 478:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 479:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 480:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 481:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 482:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 483:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 484:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 485:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 486:/usr/lib/avr/include/avr/wdt.h **** 		);
 487:/usr/lib/avr/include/avr/wdt.h **** 	}
 488:/usr/lib/avr/include/avr/wdt.h **** }
 489:/usr/lib/avr/include/avr/wdt.h **** 
 490:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 491:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 492:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 493:/usr/lib/avr/include/avr/wdt.h **** {
 494:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 495:/usr/lib/avr/include/avr/wdt.h **** 	{
 496:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 497:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 498:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 499:/usr/lib/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 500:/usr/lib/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 501:/usr/lib/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 502:/usr/lib/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 503:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 504:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 505:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 506:/usr/lib/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 507:/usr/lib/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 508:/usr/lib/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 509:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 510:/usr/lib/avr/include/avr/wdt.h **** 		);
 511:/usr/lib/avr/include/avr/wdt.h **** 	}
 512:/usr/lib/avr/include/avr/wdt.h **** 	else
 513:/usr/lib/avr/include/avr/wdt.h **** 	{
 514:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 515:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
  52               		.loc 3 515 0
  53               	/* #APP */
  54               	 ;  515 "/usr/lib/avr/include/avr/wdt.h" 1
  55 0006 0FB6      		in __tmp_reg__,__SREG__
  56 0008 F894      		cli
  57 000a A895      		wdr
  58 000c 8091 6000 		lds r24,96
  59 0010 8861      		ori r24,24
  60 0012 8093 6000 		sts 96,r24
  61 0016 1092 6000 		sts 96,__zero_reg__
  62 001a 0FBE      		out __SREG__,__tmp_reg__
  63               		
  64               	 ;  0 "" 2
  65               	/* #NOAPP */
  66               	.LBE23:
  67               	.LBE22:
  64:StillImageHost.c **** 	wdt_disable();
  65:StillImageHost.c **** 
  66:StillImageHost.c **** 	/* Disable Clock Division */
  67:StillImageHost.c **** 	CLKPR = (1 << CLKPCE);
  68               		.loc 2 67 0
  69 001c E1E6      		ldi r30,lo8(97)
  70 001e F0E0      		ldi r31,0
  71 0020 80E8      		ldi r24,lo8(-128)
  72 0022 8083      		st Z,r24
  68:StillImageHost.c **** 	CLKPR = 0;
  73               		.loc 2 68 0
  74 0024 1082      		st Z,__zero_reg__
  75               	.LVL2:
  76               	.LBB24:
  77               	.LBB25:
  78               		.file 4 "../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h"
   1:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** /*
   2:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****              LUFA Library
   3:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
   5:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** */
   8:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
   9:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** /*
  10:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  12:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  21:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****   this software.
  29:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** */
  30:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  31:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** /** \file
  32:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  \brief Serial USART Peripheral Driver (AVR8)
  33:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  34:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  On-chip serial USART driver for the 8-bit AVR microcontrollers.
  35:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  36:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  37:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *        dispatch header located in LUFA/Drivers/Peripheral/Serial.h.
  38:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  */
  39:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  40:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** /** \ingroup Group_Serial
  41:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  \defgroup Group_Serial_AVR8 Serial USART Peripheral Driver (AVR8)
  42:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  43:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  \section Sec_ModDescription Module Description
  44:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  On-chip serial USART driver for the 8-bit AVR microcontrollers.
  45:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  46:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  47:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *        dispatch header located in LUFA/Drivers/Peripheral/Serial.h.
  48:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  49:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  \section Sec_ExampleUsage Example Usage
  50:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  The following snippet is an example of how this module may be used within a typical
  51:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  application.
  52:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  53:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  \code
  54:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *      // Initialize the serial USART driver before first use, with 9600 baud (and no double-speed
  55:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *      Serial_Init(9600, false);
  56:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  57:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *      // Send a string through the USART
  58:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *      Serial_TxString("Test String\r\n");
  59:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  60:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *      // Receive a byte through the USART
  61:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *      uint8_t DataByte = Serial_RxByte();
  62:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  \endcode
  63:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *
  64:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  *  @{
  65:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h ****  */
  66:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  67:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** #ifndef __SERIAL_AVR8_H__
  68:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** #define __SERIAL_AVR8_H__
  69:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  70:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 	/* Includes: */
  71:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		#include "../../../Common/Common.h"
  72:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		#include "../../Misc/TerminalCodes.h"
  73:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		
  74:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		#include <stdio.h>
  75:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  76:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  77:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		#if defined(__cplusplus)
  78:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			extern "C" {
  79:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		#endif
  80:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  81:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 	/* Preprocessor Checks: */
  82:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		#if !defined(__INCLUDE_FROM_SERIAL_H) && !defined(__INCLUDE_FROM_SERIAL_C)
  83:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/Peripheral/Serial.h instead.
  84:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		#endif
  85:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  86:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 	/* Private Interface - For use in library only: */
  87:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 	#if !defined(__DOXYGEN__)
  88:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		/* External Variables: */
  89:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			extern FILE USARTSerialStream;
  90:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 	
  91:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		/* Function Prototypes: */
  92:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			int Serial_putchar(char DataByte,
  93:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			                   FILE *Stream);
  94:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			int Serial_getchar(FILE *Stream);
  95:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			int Serial_getchar_Blocking(FILE *Stream);
  96:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 	#endif
  97:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
  98:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 	/* Public Interface - May be used in end-application: */
  99:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		/* Macros: */
 100:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			/** Macro for calculating the baud value from a given baud rate when the \c U2X (double speed) b
 101:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  not set.
 102:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 103:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in] Baud  Target serial UART baud rate.
 104:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 105:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \return Closest UBRR register value for the given UART frequency.
 106:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 */
 107:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			#define SERIAL_UBBRVAL(Baud)    ((((F_CPU / 16) + (Baud / 2)) / (Baud)) - 1)
 108:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 109:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			/** Macro for calculating the baud value from a given baud rate when the \c U2X (double speed) b
 110:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  set.
 111:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 112:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in] Baud  Target serial UART baud rate.
 113:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 114:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \return Closest UBRR register value for the given UART frequency.
 115:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 */
 116:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			#define SERIAL_2X_UBBRVAL(Baud) ((((F_CPU / 8) + (Baud / 2)) / (Baud)) - 1)
 117:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 118:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		/* Function Prototypes: */
 119:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			/** Transmits a given string located in program space (FLASH) through the USART.
 120:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 121:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in] FlashStringPtr  Pointer to a string located in program space.
 122:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 */
 123:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			void Serial_SendString_P(const char* FlashStringPtr) ATTR_NON_NULL_PTR_ARG(1);
 124:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 125:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			/** Transmits a given string located in SRAM memory through the USART.
 126:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 127:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in] StringPtr  Pointer to a string located in SRAM space.
 128:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 */
 129:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			void Serial_SendString(const char* StringPtr) ATTR_NON_NULL_PTR_ARG(1);
 130:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			
 131:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			/** Transmits a given buffer located in SRAM memory through the USART.
 132:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 133:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in] Buffer  Pointer to a buffer containing the data to send.
 134:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in] Length  Length of the data to send, in bytes.
 135:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 */
 136:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			void Serial_SendData(const uint8_t* Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
 137:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 138:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 		/* Inline Functions: */
 139:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			/** Initializes the USART, ready for serial data transmission and reception. This initializes th
 140:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  standard 8-bit, no parity, 1 stop bit settings suitable for most applications.
 141:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 142:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in] BaudRate     Serial baud rate, in bits per second.
 143:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to doubl
 144:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 */
 145:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			static inline void Serial_Init(const uint32_t BaudRate,
 146:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			                               const bool DoubleSpeed)
 147:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			{
 148:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
  79               		.loc 4 148 0
  80 0026 83E3      		ldi r24,lo8(51)
  81 0028 90E0      		ldi r25,0
  82 002a 9093 CD00 		sts 204+1,r25
  83 002e 8093 CC00 		sts 204,r24
 149:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 150:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
  84               		.loc 4 150 0
  85 0032 86E0      		ldi r24,lo8(6)
  86 0034 8093 CA00 		sts 202,r24
 151:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
  87               		.loc 4 151 0
  88 0038 1092 C800 		sts 200,__zero_reg__
 152:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
  89               		.loc 4 152 0
  90 003c 88E1      		ldi r24,lo8(24)
  91 003e 8093 C900 		sts 201,r24
 153:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 154:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				DDRD  |= (1 << 3);
  92               		.loc 4 154 0
  93 0042 539A      		sbi 0xa,3
 155:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				PORTD |= (1 << 2);
  94               		.loc 4 155 0
  95 0044 5A9A      		sbi 0xb,2
  96               	.LVL3:
  97               	.LBE25:
  98               	.LBE24:
  99               	.LBB26:
 100               	.LBB27:
  88:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 				PORTD &= ~LEDS_ALL_LEDS;
 101               		.loc 1 88 0
 102 0046 8AB1      		in r24,0xa
 103 0048 806F      		ori r24,lo8(-16)
 104 004a 8AB9      		out 0xa,r24
  89:../../../../LUFA/Drivers/Board/AVR8/USBKEY/LEDs.h **** 			}
 105               		.loc 1 89 0
 106 004c 8BB1      		in r24,0xb
 107 004e 8F70      		andi r24,lo8(15)
 108 0050 8BB9      		out 0xb,r24
 109               	.LBE27:
 110               	.LBE26:
  69:StillImageHost.c **** 
  70:StillImageHost.c **** 	/* Hardware Initialization */
  71:StillImageHost.c **** 	Serial_Init(9600, false);
  72:StillImageHost.c **** 	LEDs_Init();
  73:StillImageHost.c **** 	USB_Init();
 111               		.loc 2 73 0
 112 0052 0E94 0000 		call USB_Init
 113               	.LVL4:
 114               	.LBB28:
 115               	.LBB29:
 156:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			}
 157:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 158:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			/** Turns off the USART driver, disabling and returning used hardware to their default configura
 159:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			static inline void Serial_Disable(void)
 160:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			{
 161:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				UCSR1B = 0;
 162:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				UCSR1A = 0;
 163:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				UCSR1C = 0;
 164:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 165:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				UBRR1  = 0;
 166:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 167:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				DDRD  &= ~(1 << 3);
 168:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				PORTD &= ~(1 << 2);
 169:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			}
 170:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 
 171:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			/** Creates a standard character stream from the USART so that it can be used with all the regul
 172:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  in the avr-libc \c <stdio.h> library that accept a \c FILE stream as a destination (e.g. \c 
 173:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  stream is bidirectional and can be used for both input and output functions.
 174:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 175:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  Reading data from this stream is non-blocking, i.e. in most instances, complete strings cann
 176:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  fetch, as the endpoint will not be ready at some point in the transmission, aborting the tra
 177:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  be used when the read data is processed byte-per-bye (via \c getc()) or when the user applic
 178:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  line buffering.
 179:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 180:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \param[in,out] Stream  Pointer to a FILE structure where the created stream should be placed
 181:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *                         and \c stdin will be configured to use the USART.
 182:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *
 183:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 *  \pre The USART must first be configured via a call to \ref Serial_Init() before the stream i
 184:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			 */
 185:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			static inline void Serial_CreateStream(FILE* Stream)
 186:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			{
 187:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				if (!(Stream))
 188:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				{
 189:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 					Stream = &USARTSerialStream;
 190:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 					stdin  = Stream;
 116               		.loc 4 190 0
 117 0056 A0E0      		ldi r26,lo8(__iob)
 118 0058 B0E0      		ldi r27,hi8(__iob)
 119 005a E0E0      		ldi r30,lo8(USARTSerialStream)
 120 005c F0E0      		ldi r31,hi8(USARTSerialStream)
 121 005e 1196      		adiw r26,1
 122 0060 FC93      		st X,r31
 123 0062 EE93      		st -X,r30
 191:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 					stdout = Stream;
 124               		.loc 4 191 0
 125 0064 1396      		adiw r26,2+1
 126 0066 FC93      		st X,r31
 127 0068 EE93      		st -X,r30
 128 006a 1297      		sbiw r26,2
 192:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				}
 193:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 			
 194:../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h **** 				*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
 129               		.loc 4 194 0
 130 006c 8EE0      		ldi r24,lo8(14)
 131 006e DF01      		movw r26,r30
 132               		0:
 133 0070 1D92      		st X+,__zero_reg__
 134 0072 8A95      		dec r24
 135 0074 01F4      		brne 0b
 136 0076 83E0      		ldi r24,lo8(3)
 137 0078 8383      		std Z+3,r24
 138 007a 80E0      		ldi r24,lo8(gs(Serial_putchar))
 139 007c 90E0      		ldi r25,hi8(gs(Serial_putchar))
 140 007e 9187      		std Z+9,r25
 141 0080 8087      		std Z+8,r24
 142 0082 80E0      		ldi r24,lo8(gs(Serial_getchar))
 143 0084 90E0      		ldi r25,hi8(gs(Serial_getchar))
 144 0086 9387      		std Z+11,r25
 145 0088 8287      		std Z+10,r24
 146               	.LVL5:
 147 008a 0895      		ret
 148               	.LBE29:
 149               	.LBE28:
 150               		.cfi_endproc
 151               	.LFE148:
 153               		.section	.text.EVENT_USB_Host_DeviceAttached,"ax",@progbits
 154               	.global	EVENT_USB_Host_DeviceAttached
 156               	EVENT_USB_Host_DeviceAttached:
 157               	.LFB149:
  74:StillImageHost.c **** 
  75:StillImageHost.c **** 	/* Create a stdio stream for the serial port for stdin and stdout */
  76:StillImageHost.c **** 	Serial_CreateStream(NULL);
  77:StillImageHost.c **** }
  78:StillImageHost.c **** 
  79:StillImageHost.c **** /** Event handler for the USB_DeviceAttached event. This indicates that a device has been attached 
  80:StillImageHost.c ****  *  starts the library USB task to begin the enumeration and USB management process.
  81:StillImageHost.c ****  */
  82:StillImageHost.c **** void EVENT_USB_Host_DeviceAttached(void)
  83:StillImageHost.c **** {
 158               		.loc 2 83 0
 159               		.cfi_startproc
 160               	/* prologue: function */
 161               	/* frame size = 0 */
 162               	/* stack size = 0 */
 163               	.L__stack_usage = 0
  84:StillImageHost.c **** 	puts_P(PSTR(ESC_FG_GREEN "Device Attached.\r\n" ESC_FG_WHITE));
 164               		.loc 2 84 0
 165 0000 80E0      		ldi r24,lo8(__c.4511)
 166 0002 90E0      		ldi r25,hi8(__c.4511)
 167 0004 0E94 0000 		call puts_P
 168               	.LVL6:
  85:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
 169               		.loc 2 85 0
 170 0008 80EA      		ldi r24,lo8(-96)
 171 000a 0C94 0000 		jmp LEDs_SetAllLEDs
 172               	.LVL7:
 173               		.cfi_endproc
 174               	.LFE149:
 176               		.section	.text.EVENT_USB_Host_DeviceUnattached,"ax",@progbits
 177               	.global	EVENT_USB_Host_DeviceUnattached
 179               	EVENT_USB_Host_DeviceUnattached:
 180               	.LFB150:
  86:StillImageHost.c **** }
  87:StillImageHost.c **** 
  88:StillImageHost.c **** /** Event handler for the USB_DeviceUnattached event. This indicates that a device has been removed
  89:StillImageHost.c ****  *  stops the library USB task management process.
  90:StillImageHost.c ****  */
  91:StillImageHost.c **** void EVENT_USB_Host_DeviceUnattached(void)
  92:StillImageHost.c **** {
 181               		.loc 2 92 0
 182               		.cfi_startproc
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
  93:StillImageHost.c **** 	puts_P(PSTR(ESC_FG_GREEN "\r\nDevice Unattached.\r\n" ESC_FG_WHITE));
 187               		.loc 2 93 0
 188 0000 80E0      		ldi r24,lo8(__c.4516)
 189 0002 90E0      		ldi r25,hi8(__c.4516)
 190 0004 0E94 0000 		call puts_P
 191               	.LVL8:
  94:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
 192               		.loc 2 94 0
 193 0008 80E1      		ldi r24,lo8(16)
 194 000a 0C94 0000 		jmp LEDs_SetAllLEDs
 195               	.LVL9:
 196               		.cfi_endproc
 197               	.LFE150:
 199               		.section	.text.EVENT_USB_Host_DeviceEnumerationComplete,"ax",@progbits
 200               	.global	EVENT_USB_Host_DeviceEnumerationComplete
 202               	EVENT_USB_Host_DeviceEnumerationComplete:
 203               	.LFB151:
  95:StillImageHost.c **** }
  96:StillImageHost.c **** 
  97:StillImageHost.c **** /** Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has bee
  98:StillImageHost.c ****  *  enumerated by the host and is now ready to be used by the application.
  99:StillImageHost.c ****  */
 100:StillImageHost.c **** void EVENT_USB_Host_DeviceEnumerationComplete(void)
 101:StillImageHost.c **** {
 204               		.loc 2 101 0
 205               		.cfi_startproc
 206 0000 CF93      		push r28
 207               	.LCFI0:
 208               		.cfi_def_cfa_offset 3
 209               		.cfi_offset 28, -2
 210               	/* prologue: function */
 211               	/* frame size = 0 */
 212               	/* stack size = 1 */
 213               	.L__stack_usage = 1
 102:StillImageHost.c **** 	puts_P(PSTR("Getting Config Data.\r\n"));
 214               		.loc 2 102 0
 215 0002 80E0      		ldi r24,lo8(__c.4521)
 216 0004 90E0      		ldi r25,hi8(__c.4521)
 217 0006 0E94 0000 		call puts_P
 218               	.LVL10:
 103:StillImageHost.c **** 
 104:StillImageHost.c **** 	uint8_t ErrorCode;
 105:StillImageHost.c **** 
 106:StillImageHost.c **** 	/* Get and process the configuration descriptor data */
 107:StillImageHost.c **** 	if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead)
 219               		.loc 2 107 0
 220 000a 0E94 0000 		call ProcessConfigurationDescriptor
 221               	.LVL11:
 222 000e C82F      		mov r28,r24
 223               	.LVL12:
 224 0010 8823      		tst r24
 225 0012 01F0      		breq .L6
 108:StillImageHost.c **** 	{
 109:StillImageHost.c **** 		if (ErrorCode == ControlError)
 226               		.loc 2 109 0
 227 0014 8130      		cpi r24,lo8(1)
 228 0016 01F4      		brne .L7
 110:StillImageHost.c **** 		  puts_P(PSTR(ESC_FG_RED "Control Error (Get Configuration).\r\n"));
 229               		.loc 2 110 0
 230 0018 80E0      		ldi r24,lo8(__c.4524)
 231 001a 90E0      		ldi r25,hi8(__c.4524)
 232               	.LVL13:
 233 001c 00C0      		rjmp .L10
 234               	.LVL14:
 235               	.L7:
 111:StillImageHost.c **** 		else
 112:StillImageHost.c **** 		  puts_P(PSTR(ESC_FG_RED "Invalid Device.\r\n"));
 236               		.loc 2 112 0
 237 001e 80E0      		ldi r24,lo8(__c.4526)
 238 0020 90E0      		ldi r25,hi8(__c.4526)
 239               	.LVL15:
 240               	.L10:
 241 0022 0E94 0000 		call puts_P
 242               	.LVL16:
 113:StillImageHost.c **** 
 114:StillImageHost.c **** 		printf_P(PSTR(" -- Error Code: %d\r\n" ESC_FG_WHITE), ErrorCode);
 243               		.loc 2 114 0
 244 0026 1F92      		push __zero_reg__
 245               	.LCFI1:
 246               		.cfi_def_cfa_offset 4
 247 0028 CF93      		push r28
 248               	.LCFI2:
 249               		.cfi_def_cfa_offset 5
 250 002a 80E0      		ldi r24,lo8(__c.4528)
 251 002c 90E0      		ldi r25,hi8(__c.4528)
 252               	.LVL17:
 253               	.L12:
 254 002e 9F93      		push r25
 255               	.LCFI3:
 256               		.cfi_def_cfa_offset 6
 257 0030 8F93      		push r24
 258               	.LCFI4:
 259               		.cfi_def_cfa_offset 7
 260 0032 0E94 0000 		call printf_P
 261               	.LVL18:
 115:StillImageHost.c **** 
 116:StillImageHost.c **** 		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
 262               		.loc 2 116 0
 263 0036 0F90      		pop __tmp_reg__
 264 0038 0F90      		pop __tmp_reg__
 265 003a 0F90      		pop __tmp_reg__
 266 003c 0F90      		pop __tmp_reg__
 267               	.LCFI5:
 268               		.cfi_def_cfa_offset 3
 269 003e 80E9      		ldi r24,lo8(-112)
 270 0040 00C0      		rjmp .L11
 271               	.LVL19:
 272               	.L6:
 117:StillImageHost.c **** 		return;
 118:StillImageHost.c **** 	}
 119:StillImageHost.c **** 
 120:StillImageHost.c **** 	/* Set the device configuration to the first configuration (rarely do devices use multiple configu
 121:StillImageHost.c **** 	if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) != HOST_SENDCONTROL_Successful)
 273               		.loc 2 121 0
 274 0042 81E0      		ldi r24,lo8(1)
 275               	.LVL20:
 276 0044 0E94 0000 		call USB_Host_SetDeviceConfiguration
 277               	.LVL21:
 278 0048 8823      		tst r24
 279 004a 01F0      		breq .L9
 122:StillImageHost.c **** 	{
 123:StillImageHost.c **** 		printf_P(PSTR(ESC_FG_RED "Control Error (Set Configuration).\r\n"
 280               		.loc 2 123 0
 281 004c 1F92      		push __zero_reg__
 282               	.LCFI6:
 283               		.cfi_remember_state
 284               		.cfi_def_cfa_offset 4
 285 004e 8F93      		push r24
 286               	.LCFI7:
 287               		.cfi_def_cfa_offset 5
 288 0050 80E0      		ldi r24,lo8(__c.4530)
 289 0052 90E0      		ldi r25,hi8(__c.4530)
 290               	.LVL22:
 291 0054 00C0      		rjmp .L12
 292               	.LVL23:
 293               	.L9:
 294               	.LCFI8:
 295               		.cfi_restore_state
 124:StillImageHost.c **** 		                         " -- Error Code: %d\r\n" ESC_FG_WHITE), ErrorCode);
 125:StillImageHost.c **** 
 126:StillImageHost.c **** 		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
 127:StillImageHost.c **** 		return;
 128:StillImageHost.c **** 	}
 129:StillImageHost.c **** 
 130:StillImageHost.c **** 	puts_P(PSTR("Still Image Device Enumerated.\r\n"));
 296               		.loc 2 130 0
 297 0056 80E0      		ldi r24,lo8(__c.4532)
 298 0058 90E0      		ldi r25,hi8(__c.4532)
 299               	.LVL24:
 300 005a 0E94 0000 		call puts_P
 301               	.LVL25:
 131:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_READY);
 302               		.loc 2 131 0
 303 005e 80E6      		ldi r24,lo8(96)
 304               	.L11:
 305               	/* epilogue start */
 132:StillImageHost.c **** }
 306               		.loc 2 132 0
 307 0060 CF91      		pop r28
 131:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_READY);
 308               		.loc 2 131 0
 309 0062 0C94 0000 		jmp LEDs_SetAllLEDs
 310               	.LVL26:
 311               		.cfi_endproc
 312               	.LFE151:
 314               		.section	.text.EVENT_USB_Host_HostError,"ax",@progbits
 315               	.global	EVENT_USB_Host_HostError
 317               	EVENT_USB_Host_HostError:
 318               	.LFB152:
 133:StillImageHost.c **** 
 134:StillImageHost.c **** /** Event handler for the USB_HostError event. This indicates that a hardware error occurred while 
 135:StillImageHost.c **** void EVENT_USB_Host_HostError(const uint8_t ErrorCode)
 136:StillImageHost.c **** {
 319               		.loc 2 136 0
 320               		.cfi_startproc
 321               	.LVL27:
 322               	/* prologue: function */
 323               	/* frame size = 0 */
 324               	/* stack size = 0 */
 325               	.L__stack_usage = 0
 326 0000 C82F      		mov r28,r24
 137:StillImageHost.c **** 	USB_Disable();
 327               		.loc 2 137 0
 328 0002 0E94 0000 		call USB_Disable
 329               	.LVL28:
 138:StillImageHost.c **** 
 139:StillImageHost.c **** 	printf_P(PSTR(ESC_FG_RED "Host Mode Error\r\n"
 330               		.loc 2 139 0
 331 0006 1F92      		push __zero_reg__
 332               	.LCFI9:
 333               		.cfi_def_cfa_offset 3
 334 0008 CF93      		push r28
 335               	.LCFI10:
 336               		.cfi_def_cfa_offset 4
 337 000a 80E0      		ldi r24,lo8(__c.4537)
 338 000c 90E0      		ldi r25,hi8(__c.4537)
 339 000e 9F93      		push r25
 340               	.LCFI11:
 341               		.cfi_def_cfa_offset 5
 342 0010 8F93      		push r24
 343               	.LCFI12:
 344               		.cfi_def_cfa_offset 6
 345 0012 0E94 0000 		call printf_P
 346               	.LVL29:
 140:StillImageHost.c **** 	                         " -- Error Code %d\r\n" ESC_FG_WHITE), ErrorCode);
 141:StillImageHost.c **** 
 142:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
 347               		.loc 2 142 0
 348 0016 80E9      		ldi r24,lo8(-112)
 349 0018 0E94 0000 		call LEDs_SetAllLEDs
 350               	.LVL30:
 351 001c 0F90      		pop __tmp_reg__
 352 001e 0F90      		pop __tmp_reg__
 353 0020 0F90      		pop __tmp_reg__
 354 0022 0F90      		pop __tmp_reg__
 355               	.LCFI13:
 356               		.cfi_def_cfa_offset 2
 357               	.L15:
 358 0024 00C0      		rjmp .L15
 359               		.cfi_endproc
 360               	.LFE152:
 362               		.section	.text.EVENT_USB_Host_DeviceEnumerationFailed,"ax",@progbits
 363               	.global	EVENT_USB_Host_DeviceEnumerationFailed
 365               	EVENT_USB_Host_DeviceEnumerationFailed:
 366               	.LFB153:
 143:StillImageHost.c **** 	for(;;);
 144:StillImageHost.c **** }
 145:StillImageHost.c **** 
 146:StillImageHost.c **** /** Event handler for the USB_DeviceEnumerationFailed event. This indicates that a problem occurred
 147:StillImageHost.c ****  *  enumerating an attached USB device.
 148:StillImageHost.c ****  */
 149:StillImageHost.c **** void EVENT_USB_Host_DeviceEnumerationFailed(const uint8_t ErrorCode,
 150:StillImageHost.c ****                                             const uint8_t SubErrorCode)
 151:StillImageHost.c **** {
 367               		.loc 2 151 0
 368               		.cfi_startproc
 369               	.LVL31:
 370               	/* prologue: function */
 371               	/* frame size = 0 */
 372               	/* stack size = 0 */
 373               	.L__stack_usage = 0
 152:StillImageHost.c **** 	printf_P(PSTR(ESC_FG_RED "Dev Enum Error\r\n"
 374               		.loc 2 152 0
 375 0000 9091 0000 		lds r25,USB_HostState
 376 0004 1F92      		push __zero_reg__
 377               	.LCFI14:
 378               		.cfi_def_cfa_offset 3
 379 0006 9F93      		push r25
 380               	.LCFI15:
 381               		.cfi_def_cfa_offset 4
 382 0008 1F92      		push __zero_reg__
 383               	.LCFI16:
 384               		.cfi_def_cfa_offset 5
 385 000a 6F93      		push r22
 386               	.LCFI17:
 387               		.cfi_def_cfa_offset 6
 388 000c 1F92      		push __zero_reg__
 389               	.LCFI18:
 390               		.cfi_def_cfa_offset 7
 391 000e 8F93      		push r24
 392               	.LCFI19:
 393               		.cfi_def_cfa_offset 8
 394 0010 80E0      		ldi r24,lo8(__c.4544)
 395 0012 90E0      		ldi r25,hi8(__c.4544)
 396               	.LVL32:
 397 0014 9F93      		push r25
 398               	.LCFI20:
 399               		.cfi_def_cfa_offset 9
 400 0016 8F93      		push r24
 401               	.LCFI21:
 402               		.cfi_def_cfa_offset 10
 403 0018 0E94 0000 		call printf_P
 404               	.LVL33:
 153:StillImageHost.c **** 	                         " -- Error Code %d\r\n"
 154:StillImageHost.c **** 	                         " -- Sub Error Code %d\r\n"
 155:StillImageHost.c **** 	                         " -- In State %d\r\n" ESC_FG_WHITE), ErrorCode, SubErrorCode, USB_HostSta
 156:StillImageHost.c **** 
 157:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
 405               		.loc 2 157 0
 406 001c 8DB7      		in r24,__SP_L__
 407 001e 9EB7      		in r25,__SP_H__
 408 0020 0896      		adiw r24,8
 409 0022 0FB6      		in __tmp_reg__,__SREG__
 410 0024 F894      		cli
 411 0026 9EBF      		out __SP_H__,r25
 412 0028 0FBE      		out __SREG__,__tmp_reg__
 413 002a 8DBF      		out __SP_L__,r24
 414               	.LCFI22:
 415               		.cfi_def_cfa_offset 2
 416 002c 80E9      		ldi r24,lo8(-112)
 417 002e 0C94 0000 		jmp LEDs_SetAllLEDs
 418               	.LVL34:
 419               		.cfi_endproc
 420               	.LFE153:
 422               		.section	.text.UnicodeToASCII,"ax",@progbits
 423               	.global	UnicodeToASCII
 425               	UnicodeToASCII:
 426               	.LFB155:
 158:StillImageHost.c **** }
 159:StillImageHost.c **** 
 160:StillImageHost.c **** /** Task to print device information through the serial port, and open/close a test PIMA session wi
 161:StillImageHost.c ****  *  attached Still Image device.
 162:StillImageHost.c ****  */
 163:StillImageHost.c **** void StillImageHost_Task(void)
 164:StillImageHost.c **** {
 165:StillImageHost.c **** 	if (USB_HostState != HOST_STATE_Configured)
 166:StillImageHost.c **** 	  return;
 167:StillImageHost.c **** 
 168:StillImageHost.c **** 	uint8_t ErrorCode;
 169:StillImageHost.c **** 
 170:StillImageHost.c **** 	/* Indicate device busy via the status LEDs */
 171:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
 172:StillImageHost.c **** 
 173:StillImageHost.c **** 	puts_P(PSTR("Retrieving Device Info...\r\n"));
 174:StillImageHost.c **** 
 175:StillImageHost.c **** 	PIMA_SendBlock = (PIMA_Container_t)
 176:StillImageHost.c **** 		{
 177:StillImageHost.c **** 			.DataLength    = PIMA_COMMAND_SIZE(0),
 178:StillImageHost.c **** 			.Type          = PIMA_CONTAINER_CommandBlock,
 179:StillImageHost.c **** 			.Code          = PIMA_OPERATION_GETDEVICEINFO,
 180:StillImageHost.c **** 			.TransactionID = 0x00000000,
 181:StillImageHost.c **** 			.Params        = {},
 182:StillImageHost.c **** 		};
 183:StillImageHost.c **** 
 184:StillImageHost.c **** 	/* Send the GETDEVICEINFO block */
 185:StillImageHost.c **** 	SImage_SendBlockHeader();
 186:StillImageHost.c **** 
 187:StillImageHost.c **** 	/* Receive the response data block */
 188:StillImageHost.c **** 	if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError)
 189:StillImageHost.c **** 	{
 190:StillImageHost.c **** 		ShowCommandError(ErrorCode, false);
 191:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 192:StillImageHost.c **** 		return;
 193:StillImageHost.c **** 	}
 194:StillImageHost.c **** 
 195:StillImageHost.c **** 	/* Calculate the size of the returned device info data structure */
 196:StillImageHost.c **** 	uint16_t DeviceInfoSize = (PIMA_ReceivedBlock.DataLength - PIMA_COMMAND_SIZE(0));
 197:StillImageHost.c **** 
 198:StillImageHost.c **** 	/* Create a buffer large enough to hold the entire device info */
 199:StillImageHost.c **** 	uint8_t DeviceInfo[DeviceInfoSize];
 200:StillImageHost.c **** 
 201:StillImageHost.c **** 	/* Read in the data block data (containing device info) */
 202:StillImageHost.c **** 	SImage_ReadData(DeviceInfo, DeviceInfoSize);
 203:StillImageHost.c **** 
 204:StillImageHost.c **** 	/* Once all the data has been read, the pipe must be cleared before the response can be sent */
 205:StillImageHost.c **** 	Pipe_ClearIN();
 206:StillImageHost.c **** 
 207:StillImageHost.c **** 	/* Create a pointer for walking through the info dataset */
 208:StillImageHost.c **** 	uint8_t* DeviceInfoPos = DeviceInfo;
 209:StillImageHost.c **** 
 210:StillImageHost.c **** 	/* Skip over the data before the unicode device information strings */
 211:StillImageHost.c **** 	DeviceInfoPos +=  8;                                          // Skip to VendorExtensionDesc Strin
 212:StillImageHost.c **** 	DeviceInfoPos += (1 + UNICODE_STRING_LENGTH(*DeviceInfoPos)); // Skip over VendorExtensionDesc Str
 213:StillImageHost.c **** 	DeviceInfoPos +=  2;                                          // Skip over FunctionalMode
 214:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Supported Operations Ar
 215:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Supported Events Array
 216:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Supported Device Proper
 217:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Capture Formats Array
 218:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Image Formats Array
 219:StillImageHost.c **** 
 220:StillImageHost.c **** 	/* Extract and convert the Manufacturer Unicode string to ASCII and print it through the USART */
 221:StillImageHost.c **** 	char Manufacturer[*DeviceInfoPos];
 222:StillImageHost.c **** 	UnicodeToASCII(DeviceInfoPos, Manufacturer);
 223:StillImageHost.c **** 	printf_P(PSTR("   Manufacturer: %s\r\n"), Manufacturer);
 224:StillImageHost.c **** 
 225:StillImageHost.c **** 	DeviceInfoPos += 1 + UNICODE_STRING_LENGTH(*DeviceInfoPos);   // Skip over Manufacturer String
 226:StillImageHost.c **** 
 227:StillImageHost.c **** 	/* Extract and convert the Model Unicode string to ASCII and print it through the USART */
 228:StillImageHost.c **** 	char Model[*DeviceInfoPos];
 229:StillImageHost.c **** 	UnicodeToASCII(DeviceInfoPos, Model);
 230:StillImageHost.c **** 	printf_P(PSTR("   Model: %s\r\n"), Model);
 231:StillImageHost.c **** 
 232:StillImageHost.c **** 	DeviceInfoPos += 1 + UNICODE_STRING_LENGTH(*DeviceInfoPos);   // Skip over Model String
 233:StillImageHost.c **** 
 234:StillImageHost.c **** 	/* Extract and convert the Device Version Unicode string to ASCII and print it through the USART *
 235:StillImageHost.c **** 	char DeviceVersion[*DeviceInfoPos];
 236:StillImageHost.c **** 	UnicodeToASCII(DeviceInfoPos, DeviceVersion);
 237:StillImageHost.c **** 	printf_P(PSTR("   Device Version: %s\r\n"), DeviceVersion);
 238:StillImageHost.c **** 
 239:StillImageHost.c **** 	/* Receive the final response block from the device */
 240:StillImageHost.c **** 	if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError)
 241:StillImageHost.c **** 	{
 242:StillImageHost.c **** 		ShowCommandError(ErrorCode, false);
 243:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 244:StillImageHost.c **** 		return;
 245:StillImageHost.c **** 	}
 246:StillImageHost.c **** 
 247:StillImageHost.c **** 	/* Verify that the command completed successfully */
 248:StillImageHost.c **** 	if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) || (PIMA_ReceivedBlock.Code != PIMA_
 249:StillImageHost.c **** 	{
 250:StillImageHost.c **** 		ShowCommandError(PIMA_ReceivedBlock.Code, true);
 251:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 252:StillImageHost.c **** 		return;
 253:StillImageHost.c **** 	}
 254:StillImageHost.c **** 
 255:StillImageHost.c **** 	puts_P(PSTR("Opening Session...\r\n"));
 256:StillImageHost.c **** 
 257:StillImageHost.c **** 	PIMA_SendBlock = (PIMA_Container_t)
 258:StillImageHost.c **** 		{
 259:StillImageHost.c **** 			.DataLength    = PIMA_COMMAND_SIZE(1),
 260:StillImageHost.c **** 			.Type          = PIMA_CONTAINER_CommandBlock,
 261:StillImageHost.c **** 			.Code          = PIMA_OPERATION_OPENSESSION,
 262:StillImageHost.c **** 			.TransactionID = 0x00000000,
 263:StillImageHost.c **** 			.Params        = {0x00000001},
 264:StillImageHost.c **** 		};
 265:StillImageHost.c **** 
 266:StillImageHost.c **** 	/* Send the OPENSESSION block, open a session with an ID of 0x0001 */
 267:StillImageHost.c **** 	SImage_SendBlockHeader();
 268:StillImageHost.c **** 
 269:StillImageHost.c **** 	/* Receive the response block from the device */
 270:StillImageHost.c **** 	if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError)
 271:StillImageHost.c **** 	{
 272:StillImageHost.c **** 		ShowCommandError(ErrorCode, false);
 273:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 274:StillImageHost.c **** 		return;
 275:StillImageHost.c **** 	}
 276:StillImageHost.c **** 
 277:StillImageHost.c **** 	/* Verify that the command completed successfully */
 278:StillImageHost.c **** 	if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) || (PIMA_ReceivedBlock.Code != PIMA_
 279:StillImageHost.c **** 	{
 280:StillImageHost.c **** 		ShowCommandError(PIMA_ReceivedBlock.Code, true);
 281:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 282:StillImageHost.c **** 		return;
 283:StillImageHost.c **** 	}
 284:StillImageHost.c **** 
 285:StillImageHost.c **** 	puts_P(PSTR("Closing Session...\r\n"));
 286:StillImageHost.c **** 
 287:StillImageHost.c **** 	PIMA_SendBlock = (PIMA_Container_t)
 288:StillImageHost.c **** 		{
 289:StillImageHost.c **** 			.DataLength    = PIMA_COMMAND_SIZE(1),
 290:StillImageHost.c **** 			.Type          = PIMA_CONTAINER_CommandBlock,
 291:StillImageHost.c **** 			.Code          = PIMA_OPERATION_CLOSESESSION,
 292:StillImageHost.c **** 			.TransactionID = 0x00000001,
 293:StillImageHost.c **** 			.Params        = {0x00000001},
 294:StillImageHost.c **** 		};
 295:StillImageHost.c **** 
 296:StillImageHost.c **** 	/* Send the CLOSESESSION block, close the session with an ID of 0x0001 */
 297:StillImageHost.c **** 	SImage_SendBlockHeader();
 298:StillImageHost.c **** 
 299:StillImageHost.c **** 	/* Receive the response block from the device */
 300:StillImageHost.c **** 	if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError)
 301:StillImageHost.c **** 	{
 302:StillImageHost.c **** 		ShowCommandError(ErrorCode, false);
 303:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 304:StillImageHost.c **** 		return;
 305:StillImageHost.c **** 	}
 306:StillImageHost.c **** 
 307:StillImageHost.c **** 	/* Verify that the command completed successfully */
 308:StillImageHost.c **** 	if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) || (PIMA_ReceivedBlock.Code != PIMA_
 309:StillImageHost.c **** 	{
 310:StillImageHost.c **** 		ShowCommandError(PIMA_ReceivedBlock.Code, true);
 311:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 312:StillImageHost.c **** 		return;
 313:StillImageHost.c **** 	}
 314:StillImageHost.c **** 
 315:StillImageHost.c **** 	puts_P(PSTR("Done.\r\n"));
 316:StillImageHost.c **** 
 317:StillImageHost.c **** 	/* Indicate device no longer busy */
 318:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_READY);
 319:StillImageHost.c **** 	USB_Host_SetDeviceConfiguration(0);
 320:StillImageHost.c **** }
 321:StillImageHost.c **** 
 322:StillImageHost.c **** /** Function to convert a given Unicode encoded string to ASCII. This function will only work corre
 323:StillImageHost.c ****  *  strings which contain ASCII printable characters only.
 324:StillImageHost.c ****  *
 325:StillImageHost.c ****  *  \param[in] UnicodeString  Pointer to a Unicode encoded input string
 326:StillImageHost.c ****  *  \param[out] Buffer        Pointer to a buffer where the converted ASCII string should be stored
 327:StillImageHost.c ****  */
 328:StillImageHost.c **** void UnicodeToASCII(uint8_t* UnicodeString,
 329:StillImageHost.c ****                     char* Buffer)
 330:StillImageHost.c **** {
 427               		.loc 2 330 0
 428               		.cfi_startproc
 429               	.LVL35:
 430               	/* prologue: function */
 431               	/* frame size = 0 */
 432               	/* stack size = 0 */
 433               	.L__stack_usage = 0
 331:StillImageHost.c **** 	/* Get the number of characters in the string, skip to the start of the string data */
 332:StillImageHost.c **** 	uint8_t CharactersRemaining = *(UnicodeString++);
 434               		.loc 2 332 0
 435 0000 FC01      		movw r30,r24
 436 0002 3196      		adiw r30,1
 437               	.LVL36:
 438 0004 DC01      		movw r26,r24
 439 0006 9C91      		ld r25,X
 440               	.LVL37:
 441 0008 DB01      		movw r26,r22
 442 000a 892F      		mov r24,r25
 443               	.LVL38:
 444               	.L18:
 333:StillImageHost.c **** 
 334:StillImageHost.c **** 	/* Loop through the entire unicode string */
 335:StillImageHost.c **** 	while (CharactersRemaining--)
 445               		.loc 2 335 0
 446               	.LVL39:
 447 000c 8150      		subi r24,1
 448 000e 00F0      		brcs .L20
 336:StillImageHost.c **** 	{
 337:StillImageHost.c **** 		/* Load in the next unicode character (only the lower byte, as only Unicode coded ASCII is suppor
 338:StillImageHost.c **** 		*(Buffer++) = *UnicodeString;
 449               		.loc 2 338 0
 450 0010 2081      		ld r18,Z
 451 0012 2D93      		st X+,r18
 452               	.LVL40:
 339:StillImageHost.c **** 
 340:StillImageHost.c **** 		/* Jump to the next unicode character */
 341:StillImageHost.c **** 		UnicodeString += 2;
 453               		.loc 2 341 0
 454 0014 3296      		adiw r30,2
 455               	.LVL41:
 456 0016 00C0      		rjmp .L18
 457               	.L20:
 342:StillImageHost.c **** 	}
 343:StillImageHost.c **** 
 344:StillImageHost.c **** 	/* Null terminate the string */
 345:StillImageHost.c **** 	*Buffer = 0;
 458               		.loc 2 345 0
 459 0018 FB01      		movw r30,r22
 460               	.LVL42:
 461 001a E90F      		add r30,r25
 462 001c F11D      		adc r31,__zero_reg__
 463 001e 1082      		st Z,__zero_reg__
 464 0020 0895      		ret
 465               		.cfi_endproc
 466               	.LFE155:
 468               		.section	.text.ShowCommandError,"ax",@progbits
 469               	.global	ShowCommandError
 471               	ShowCommandError:
 472               	.LFB156:
 346:StillImageHost.c **** }
 347:StillImageHost.c **** 
 348:StillImageHost.c **** /** Displays a PIMA command error via the device's serial port.
 349:StillImageHost.c ****  *
 350:StillImageHost.c ****  *  \param[in] ErrorCode          Error code of the function which failed to complete successfully
 351:StillImageHost.c ****  *  \param[in] ResponseCodeError  Indicates if the error is due to a command failed indication from
 352:StillImageHost.c ****  */
 353:StillImageHost.c **** void ShowCommandError(uint8_t ErrorCode,
 354:StillImageHost.c ****                       bool ResponseCodeError)
 355:StillImageHost.c **** {
 473               		.loc 2 355 0
 474               		.cfi_startproc
 475               	.LVL43:
 476               	/* prologue: function */
 477               	/* frame size = 0 */
 478               	/* stack size = 0 */
 479               	.L__stack_usage = 0
 356:StillImageHost.c **** 	const char* FailureType = ((ResponseCodeError) ? PSTR("Response Code != OK") : PSTR("Transaction F
 480               		.loc 2 356 0
 481 0000 6111      		cpse r22,__zero_reg__
 482 0002 00C0      		rjmp .L23
 483 0004 20E0      		ldi r18,lo8(__c.4588)
 484 0006 30E0      		ldi r19,hi8(__c.4588)
 485 0008 00C0      		rjmp .L22
 486               	.L23:
 487 000a 20E0      		ldi r18,lo8(__c.4586)
 488 000c 30E0      		ldi r19,hi8(__c.4586)
 489               	.L22:
 490               	.LVL44:
 357:StillImageHost.c **** 
 358:StillImageHost.c **** 	printf_P(PSTR(ESC_FG_RED "Command Error (%S).\r\n"
 491               		.loc 2 358 0 discriminator 4
 492 000e 1F92      		push __zero_reg__
 493               	.LCFI23:
 494               		.cfi_def_cfa_offset 3
 495 0010 8F93      		push r24
 496               	.LCFI24:
 497               		.cfi_def_cfa_offset 4
 498 0012 3F93      		push r19
 499               	.LCFI25:
 500               		.cfi_def_cfa_offset 5
 501 0014 2F93      		push r18
 502               	.LCFI26:
 503               		.cfi_def_cfa_offset 6
 504 0016 80E0      		ldi r24,lo8(__c.4590)
 505 0018 90E0      		ldi r25,hi8(__c.4590)
 506               	.LVL45:
 507 001a 9F93      		push r25
 508               	.LCFI27:
 509               		.cfi_def_cfa_offset 7
 510 001c 8F93      		push r24
 511               	.LCFI28:
 512               		.cfi_def_cfa_offset 8
 513 001e 0E94 0000 		call printf_P
 514               	.LVL46:
 359:StillImageHost.c **** 	                         " -- Error Code %d\r\n" ESC_FG_WHITE), FailureType, ErrorCode);
 360:StillImageHost.c **** 
 361:StillImageHost.c **** 	/* Indicate error via status LEDs */
 362:StillImageHost.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
 515               		.loc 2 362 0 discriminator 4
 516 0022 0F90      		pop __tmp_reg__
 517 0024 0F90      		pop __tmp_reg__
 518 0026 0F90      		pop __tmp_reg__
 519 0028 0F90      		pop __tmp_reg__
 520 002a 0F90      		pop __tmp_reg__
 521 002c 0F90      		pop __tmp_reg__
 522               	.LCFI29:
 523               		.cfi_def_cfa_offset 2
 524 002e 80E9      		ldi r24,lo8(-112)
 525 0030 0C94 0000 		jmp LEDs_SetAllLEDs
 526               	.LVL47:
 527               		.cfi_endproc
 528               	.LFE156:
 530               		.section	.text.StillImageHost_Task,"ax",@progbits
 531               	.global	StillImageHost_Task
 533               	StillImageHost_Task:
 534               	.LFB154:
 164:StillImageHost.c **** 	if (USB_HostState != HOST_STATE_Configured)
 535               		.loc 2 164 0
 536               		.cfi_startproc
 537 0000 3F92      		push r3
 538               	.LCFI30:
 539               		.cfi_def_cfa_offset 3
 540               		.cfi_offset 3, -2
 541 0002 4F92      		push r4
 542               	.LCFI31:
 543               		.cfi_def_cfa_offset 4
 544               		.cfi_offset 4, -3
 545 0004 5F92      		push r5
 546               	.LCFI32:
 547               		.cfi_def_cfa_offset 5
 548               		.cfi_offset 5, -4
 549 0006 6F92      		push r6
 550               	.LCFI33:
 551               		.cfi_def_cfa_offset 6
 552               		.cfi_offset 6, -5
 553 0008 7F92      		push r7
 554               	.LCFI34:
 555               		.cfi_def_cfa_offset 7
 556               		.cfi_offset 7, -6
 557 000a 8F92      		push r8
 558               	.LCFI35:
 559               		.cfi_def_cfa_offset 8
 560               		.cfi_offset 8, -7
 561 000c 9F92      		push r9
 562               	.LCFI36:
 563               		.cfi_def_cfa_offset 9
 564               		.cfi_offset 9, -8
 565 000e AF92      		push r10
 566               	.LCFI37:
 567               		.cfi_def_cfa_offset 10
 568               		.cfi_offset 10, -9
 569 0010 BF92      		push r11
 570               	.LCFI38:
 571               		.cfi_def_cfa_offset 11
 572               		.cfi_offset 11, -10
 573 0012 CF92      		push r12
 574               	.LCFI39:
 575               		.cfi_def_cfa_offset 12
 576               		.cfi_offset 12, -11
 577 0014 DF92      		push r13
 578               	.LCFI40:
 579               		.cfi_def_cfa_offset 13
 580               		.cfi_offset 13, -12
 581 0016 EF92      		push r14
 582               	.LCFI41:
 583               		.cfi_def_cfa_offset 14
 584               		.cfi_offset 14, -13
 585 0018 FF92      		push r15
 586               	.LCFI42:
 587               		.cfi_def_cfa_offset 15
 588               		.cfi_offset 15, -14
 589 001a 0F93      		push r16
 590               	.LCFI43:
 591               		.cfi_def_cfa_offset 16
 592               		.cfi_offset 16, -15
 593 001c 1F93      		push r17
 594               	.LCFI44:
 595               		.cfi_def_cfa_offset 17
 596               		.cfi_offset 17, -16
 597 001e CF93      		push r28
 598               	.LCFI45:
 599               		.cfi_def_cfa_offset 18
 600               		.cfi_offset 28, -17
 601 0020 DF93      		push r29
 602               	.LCFI46:
 603               		.cfi_def_cfa_offset 19
 604               		.cfi_offset 29, -18
 605 0022 CDB7      		in r28,__SP_L__
 606 0024 DEB7      		in r29,__SP_H__
 607               	.LCFI47:
 608               		.cfi_def_cfa_register 28
 609               	/* prologue: function */
 610               	/* frame size = 0 */
 611               	/* stack size = 17 */
 612               	.L__stack_usage = 17
 320:StillImageHost.c **** 
 613               		.loc 2 320 0
 614 0026 0DB7      		in r16,__SP_L__
 615 0028 1EB7      		in r17,__SP_H__
 165:StillImageHost.c **** 	  return;
 616               		.loc 2 165 0
 617 002a 8091 0000 		lds r24,USB_HostState
 618 002e 8B30      		cpi r24,lo8(11)
 619 0030 01F0      		breq .+2
 620 0032 00C0      		rjmp .L25
 171:StillImageHost.c **** 
 621               		.loc 2 171 0
 622 0034 80E2      		ldi r24,lo8(32)
 623 0036 0E94 0000 		call LEDs_SetAllLEDs
 624               	.LVL48:
 173:StillImageHost.c **** 
 625               		.loc 2 173 0
 626 003a 80E0      		ldi r24,lo8(__c.4550)
 627 003c 90E0      		ldi r25,hi8(__c.4550)
 628 003e 0E94 0000 		call puts_P
 629               	.LVL49:
 175:StillImageHost.c **** 		{
 630               		.loc 2 175 0
 631 0042 E8E1      		ldi r30,lo8(24)
 632 0044 3E2E      		mov r3,r30
 633 0046 F0E0      		ldi r31,lo8(PIMA_SendBlock)
 634 0048 8F2E      		mov r8,r31
 635 004a F0E0      		ldi r31,hi8(PIMA_SendBlock)
 636 004c 9F2E      		mov r9,r31
 637 004e F401      		movw r30,r8
 638 0050 232D      		mov r18,r3
 639               		0:
 640 0052 1192      		st Z+,__zero_reg__
 641 0054 2A95      		dec r18
 642 0056 01F4      		brne 0b
 643 0058 8CE0      		ldi r24,lo8(12)
 644 005a 90E0      		ldi r25,0
 645 005c A0E0      		ldi r26,0
 646 005e B0E0      		ldi r27,0
 647 0060 8093 0000 		sts PIMA_SendBlock,r24
 648 0064 9093 0000 		sts PIMA_SendBlock+1,r25
 649 0068 A093 0000 		sts PIMA_SendBlock+2,r26
 650 006c B093 0000 		sts PIMA_SendBlock+3,r27
 651 0070 81E0      		ldi r24,lo8(1)
 652 0072 90E0      		ldi r25,0
 653 0074 9093 0000 		sts PIMA_SendBlock+4+1,r25
 654 0078 8093 0000 		sts PIMA_SendBlock+4,r24
 655 007c 81E0      		ldi r24,lo8(1)
 656 007e 90E1      		ldi r25,lo8(16)
 657 0080 9093 0000 		sts PIMA_SendBlock+6+1,r25
 658 0084 8093 0000 		sts PIMA_SendBlock+6,r24
 185:StillImageHost.c **** 
 659               		.loc 2 185 0
 660 0088 0E94 0000 		call SImage_SendBlockHeader
 661               	.LVL50:
 188:StillImageHost.c **** 	{
 662               		.loc 2 188 0
 663 008c 0E94 0000 		call SImage_ReceiveBlockHeader
 664               	.LVL51:
 665 0090 8111      		cpse r24,__zero_reg__
 666 0092 00C0      		rjmp .L38
 196:StillImageHost.c **** 
 667               		.loc 2 196 0
 668 0094 6091 0000 		lds r22,PIMA_ReceivedBlock
 669 0098 7091 0000 		lds r23,PIMA_ReceivedBlock+1
 670 009c 6C50      		subi r22,12
 671 009e 7109      		sbc r23,__zero_reg__
 672               	.LVL52:
 199:StillImageHost.c **** 
 673               		.loc 2 199 0
 674 00a0 4DB7      		in r20,__SP_L__
 675 00a2 5EB7      		in r21,__SP_H__
 676 00a4 461B      		sub r20,r22
 677 00a6 570B      		sbc r21,r23
 678 00a8 0FB6      		in __tmp_reg__,__SREG__
 679 00aa F894      		cli
 680 00ac 5EBF      		out __SP_H__,r21
 681 00ae 0FBE      		out __SREG__,__tmp_reg__
 682 00b0 4DBF      		out __SP_L__,r20
 683 00b2 8DB7      		in r24,__SP_L__
 684 00b4 9EB7      		in r25,__SP_H__
 685               	.LVL53:
 686 00b6 0196      		adiw r24,1
 687 00b8 7C01      		movw r14,r24
 688               	.LVL54:
 202:StillImageHost.c **** 
 689               		.loc 2 202 0
 690 00ba 0E94 0000 		call SImage_ReadData
 691               	.LVL55:
 692               	.LBB30:
 693               	.LBB31:
 694               		.file 5 "../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h"
   1:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
   2:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****              LUFA Library
   3:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   5:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
   8:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   9:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
  10:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  12:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  21:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   this software.
  29:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
  30:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  31:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \file
  32:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief USB Pipe definitions for the AVR8 microcontrollers.
  33:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \copydetails Group_PipeManagement_AVR8
  34:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  35:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  38:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  39:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeRW
  40:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeRW_AVR8 Pipe Data Reading and Writing (AVR8)
  41:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe data read/write definitions for the Atmel AVR8 architecture.
  42:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  43:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to p
  44:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  45:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  46:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePrimitiveRW
  47:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePrimitiveRW_AVR8 Read/Write of Primitive Data Types (AVR8)
  48:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe primitive data read/write definitions for the Atmel AVR8 architecture.
  49:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  50:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  51:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  from and to pipes.
  52:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  53:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  54:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePacketManagement
  55:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePacketManagement_AVR8 Pipe Packet Management (AVR8)
  56:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe packet management definitions for the Atmel AVR8 architecture.
  57:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  58:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to packet management of pipes.
  59:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  60:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  61:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeControlReq
  62:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeControlReq_AVR8 Pipe Control Request Management (AVR8)
  63:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe control request management definitions for the Atmel AVR8 architecture.
  64:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  65:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Module for host mode request processing. This module allows for the transmission of standard, c
  66:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  vendor control requests to the default control endpoint of an attached device while in host mod
  67:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  68:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \see Chapter 9 of the USB 2.0 specification.
  69:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  70:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  71:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeManagement
  72:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeManagement_AVR8 Pipe Management (AVR8)
  73:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe management definitions for the Atmel AVR8 architecture.
  74:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  75:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  This module contains functions, macros and enums related to pipe management when in USB Host mo
  76:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  module contains the pipe management macros, as well as pipe interrupt and data send/receive fun
  77:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  for various data types.
  78:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  79:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  @{
  80:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  81:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  82:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #ifndef __PIPE_AVR8_H__
  83:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #define __PIPE_AVR8_H__
  84:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  85:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Includes: */
  86:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../../../../Common/Common.h"
  87:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../USBTask.h"
  88:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  89:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  90:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if defined(__cplusplus)
  91:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			extern "C" {
  92:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  93:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  94:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Preprocessor Checks: */
  95:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  96:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  97:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  98:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  99:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 100:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Macros: */
 101:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Error Flag Masks */
 102:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 103:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an overflow error occurred in the pipe o
 104:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_OVERFLOW         (1 << 6)
 105:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 106:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an underflow error occurred in the pipe 
 107:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_UNDERFLOW        (1 << 5)
 108:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 109:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a CRC error occurred in the pipe on the 
 110:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_CRC16            (1 << 4)
 111:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 112:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware timeout error occurred in the
 113:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_TIMEOUT          (1 << 3)
 114:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 115:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware PID error occurred in the pip
 116:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_PID              (1 << 2)
 117:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 118:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data PID error occurred in th
 119:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATAPID          (1 << 1)
 120:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 121:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data toggle error occurred in
 122:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATATGL          (1 << 0)
 123:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 124:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 125:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Token Masks */
 126:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 127:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a SETUP token (for CONTROL t
 128:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which will trigger a control request on the attached device when data is written to the pipe
 129:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 130:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_SETUP                (0 << PTOKEN0)
 131:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 132:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a IN token (for non-CONTROL 
 133:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from device to host.
 134:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 135:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_IN                   (1 << PTOKEN0)
 136:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 137:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a OUT token (for non-CONTROL
 138:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from host to device.
 139:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 140:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_OUT                  (2 << PTOKEN0)
 141:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 142:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			
 143:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Bank Mode Masks */
 144:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 145:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 146:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have one single bank, which requires less USB FIFO memory but results in slower trans
 147:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  only one USB device (the AVR or the attached device) can access the pipe's bank at the one t
 148:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 149:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_SINGLE                (0 << EPBK0)
 150:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 151:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 152:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have two banks, which requires more USB FIFO memory but results in faster transfers a
 153:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  USB device (the AVR or the attached device) can access one bank while the other accesses the
 154:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  bank.
 155:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 156:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_DOUBLE                (1 << EPBK0)
 157:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 158:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 159:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Default size of the default control pipe's bank, until altered by the Endpoint0Size value
 160:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  in the device descriptor of the attached device.
 161:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 162:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_CONTROLPIPE_DEFAULT_SIZE   64
 163:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 164:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Total number of pipes (including the default control pipe at address 0) which may be used in
 165:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the device. Different USB AVR models support different amounts of pipes, this value reflects
 166:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the maximum number of pipes for the currently selected AVR model.
 167:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 168:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOTAL_PIPES                7
 169:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 170:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Size in bytes of the largest pipe bank size possible in the device. Not all banks on each AV
 171:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  model supports the largest bank size possible on the device; different pipe numbers support
 172:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  different maximum bank sizes. This value reflects the largest possible bank of any pipe on t
 173:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected USB AVR model.
 174:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 175:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_MAX_SIZE                   256
 176:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 177:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Enums: */
 178:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enum for the possible error return codes of the \ref Pipe_WaitUntilReady() function.
 179:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 180:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 181:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 182:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			enum Pipe_WaitUntilReady_ErrorCodes_t
 183:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 184:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_NoError                 = 0, /**< Pipe ready for next packet, no error. */
 185:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_PipeStalled             = 1,	/**< The device stalled the pipe while waiting. */
 186:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host while wa
 187:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_Timeout                 = 3, /**< The device failed to accept or send the next p
 188:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   within the software timeout period set by the
 189:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   \ref USB_STREAM_TIMEOUT_MS macro.
 190:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             */
 191:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			};
 192:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 193:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Inline Functions: */
 194:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Indicates the number of bytes currently stored in the current pipes's selected bank.
 195:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 196:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \note The return width of this function may differ, depending on the maximum pipe bank size
 197:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *        of the selected AVR model.
 198:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 199:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 200:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 201:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
 202:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 203:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 204:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void)
 205:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 206:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return UPBCX;
 207:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 208:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 209:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Returns the pipe address of the currently selected pipe. This is typically used to save the
 210:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected pipe number so that it can be restored after another pipe has been manipu
 211:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 212:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Index of the currently selected pipe.
 213:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 214:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 215:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void)
 216:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 217:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPNUM & PIPE_PIPENUM_MASK);
 218:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 219:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 220:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Selects the given pipe number. Any pipe operations which do not require the pipe number to b
 221:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicated will operate on the currently selected pipe.
 222:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 223:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to select.
 224:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 225:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 226:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
 227:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPNUM = PipeNumber;
 229:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 230:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 231:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Resets the desired pipe, including the pipe banks and flags.
 232:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 233:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to reset.
 234:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 235:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 236:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber)
 237:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 238:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = (1 << PipeNumber);
 239:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = 0;
 240:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 241:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 242:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enables the currently selected pipe so that data can be sent and received through it to and 
 243:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  an attached device.
 244:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 245:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePi
 246:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 247:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
 248:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void)
 249:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 250:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << PEN);
 251:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 252:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 253:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Disables the currently selected pipe so that data cannot be sent and received through it to 
 254:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  from an attached device.
 255:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 256:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
 257:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void)
 258:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 259:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << PEN);
 260:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 261:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 262:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is enabled, but not necessarily configured.
 263:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 264:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 * \return Boolean \c true if the currently selected pipe is enabled, \c false otherwise.
 265:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 266:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 267:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void)
 268:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 269:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPCONX & (1 << PEN)) ? true : false);
 270:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 271:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 272:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Gets the current pipe token, indicating the pipe's data direction and type.
 273:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 274:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
 275:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 276:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 277:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void)
 278:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 279:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPCFG0X & (0x03 << PTOKEN0));
 280:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 281:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 282:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the token for the currently selected pipe to one of the tokens specified by the \c PIPE
 283:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  masks. This can be used on CONTROL type pipes, to allow for bidirectional transfer of data d
 284:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  control requests, or on regular pipes to allow for half-duplex bidirectional data transfer t
 285:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which have two endpoints of opposite direction sharing the same endpoint address within the 
 286:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 287:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
 288:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 289:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
 290:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token)
 291:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 292:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
 293:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 294:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 295:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
 296:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
 297:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void)
 298:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 299:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << INMODE);
 300:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 301:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 302:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to only allow the specified number of IN requests to 
 303:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  accepted by the pipe before it is automatically frozen.
 304:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 305:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] TotalINRequests  Total number of IN requests that the pipe may receive before fre
 306:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 307:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests) ATTR_ALWAYS_INLINE;
 308:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests)
 309:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 310:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << INMODE);
 311:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINRQX = TotalINRequests;
 312:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 313:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 314:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is configured.
 315:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 316:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
 317:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 318:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 319:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void)
 320:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 321:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPSTAX & (1 << CFGOK)) ? true : false);
 322:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 323:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 324:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Retrieves the endpoint address of the endpoint within the attached device that the currently
 325:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipe is bound to.
 326:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 327:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Endpoint address the currently selected pipe is bound to.
 328:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 329:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INL
 330:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
 331:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
 333:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 334:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 335:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 336:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the period between interrupts for an INTERRUPT type pipe to a specified number of milli
 337:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 338:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Milliseconds  Number of milliseconds between each pipe poll.
 339:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 340:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds) ATTR_ALWAYS_INLINE;
 341:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds)
 342:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 343:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG2X = Milliseconds;
 344:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 345:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 346:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Returns a mask indicating which pipe's interrupt periods have elapsed, indicating that the p
 347:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  be serviced.
 348:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 349:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Mask whose bits indicate which pipes have interrupted.
 350:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 351:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeInterrupts(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 352:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeInterrupts(void)
 353:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 354:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return UPINT;
 355:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 356:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 357:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the specified pipe number has interrupted (valid only for INTERRUPT type
 358:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipes).
 359:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 360:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe whose interrupt flag should be tested.
 361:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 362:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the specified pipe has interrupted, \c false otherwise.
 363:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 364:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_HasPipeInterrupted(const uint8_t PipeNumber) ATTR_WARN_UNUSED_RESULT ATT
 365:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_HasPipeInterrupted(const uint8_t PipeNumber)
 366:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 367:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINT & (1 << PipeNumber)) ? true : false);
 368:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 369:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 370:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
 371:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
 372:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Unfreeze(void)
 373:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << PFREEZE);
 375:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 376:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 377:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
 378:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
 379:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Freeze(void)
 380:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << PFREEZE);
 382:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 383:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 384:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is frozen, and not able to accept data.
 385:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 386:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the currently selected pipe is frozen, \c false otherwise.
 387:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 388:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsFrozen(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 389:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsFrozen(void)
 390:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 391:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPCONX & (1 << PFREEZE)) ? true : false);
 392:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 393:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 394:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Clears the error flags for the currently selected pipe. */
 395:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
 396:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearError(void)
 397:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 398:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPERRX = 0;
 399:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~(1 << PERRI);
 400:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 401:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 402:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the master pipe error flag is set for the currently selected pipe, indicating 
 403:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  some sort of hardware error has occurred on the pipe.
 404:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 405:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \see \ref Pipe_GetErrorFlags() macro for information on retrieving the exact error flag.
 406:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 407:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if an error has occurred on the selected pipe, \c false otherwise.
 408:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 409:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 410:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsError(void)
 411:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 412:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << PERRI)) ? true : false);
 413:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 414:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 415:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Gets a mask of the hardware error flags which have occurred on the currently selected pipe. 
 416:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  value can then be masked against the \c PIPE_ERRORFLAG_* masks to determine what error has o
 417:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 418:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return  Mask comprising of \c PIPE_ERRORFLAG_* bits indicating what error has occurred on t
 419:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 420:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetErrorFlags(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 421:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetErrorFlags(void)
 422:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 423:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPERRX & (PIPE_ERRORFLAG_CRC16 | PIPE_ERRORFLAG_TIMEOUT |
 424:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                   PIPE_ERRORFLAG_PID   | PIPE_ERRORFLAG_DATAPID |
 425:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                   PIPE_ERRORFLAG_DATATGL)) |
 426:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        (UPSTAX & (PIPE_ERRORFLAG_OVERFLOW | PIPE_ERRORFLAG_UNDERFLOW)));
 427:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 428:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			
 429:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Retrieves the number of busy banks in the currently selected pipe, which have been queued fo
 430:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  transmission via the \ref Pipe_ClearOUT() command, or are awaiting acknowledgement via the
 431:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ref Pipe_ClearIN() command.
 432:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 433:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 434:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 435:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Total number of busy banks in the selected pipe.
 436:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 437:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBusyBanks(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 438:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBusyBanks(void)
 439:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 440:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPSTAX & (0x03 << NBUSYBK0));
 441:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 442:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 443:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe may be read from (if data is waiting in the pipe
 444:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  bank and the pipe is an IN direction, or if the bank is not yet full if the pipe is an OUT
 445:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  direction). This function will return false if an error has occurred in the pipe, or if the 
 446:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  is an IN direction and no packet (or an empty packet) has been received, or if the pipe is a
 447:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  direction and the pipe bank is full.
 448:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 449:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \note This function is not valid on CONTROL type pipes.
 450:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 451:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 452:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 453:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the currently selected pipe may be read from or written to, depen
 454:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *          on its direction.
 455:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 456:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 457:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsReadWriteAllowed(void)
 458:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 459:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << RWAL)) ? true : false);
 460:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 461:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 462:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if a packet has been received on the currently selected IN pipe from the attached
 463:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 464:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 465:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 466:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
 467:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 468:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 469:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsINReceived(void)
 470:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 471:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << RXINI)) ? true : false);
 472:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 473:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 474:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected OUT pipe is ready to send an OUT packet to the attached
 475:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 476:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 477:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 478:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
 479:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 480:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 481:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsOUTReady(void)
 482:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 483:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << TXOUTI)) ? true : false);
 484:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 485:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 486:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if no SETUP request is currently being sent to the attached device on the selecte
 487:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  CONTROL type pipe.
 488:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 489:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 490:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 491:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the current pipe is ready for a SETUP packet, \c false otherwise.
 492:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 493:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsSETUPSent(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 494:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsSETUPSent(void)
 495:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 496:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << TXSTPI)) ? true : false);
 497:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 498:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 499:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sends the currently selected CONTROL type pipe's contents to the device as a SETUP packet.
 500:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 501:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 502:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 503:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearSETUP(void) ATTR_ALWAYS_INLINE;
 504:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearSETUP(void)
 505:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 506:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~((1 << TXSTPI) | (1 << FIFOCON));
 507:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 508:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 509:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Acknowledges the reception of a setup IN request from the attached device on the currently s
 510:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipe, freeing the bank ready for the next packet.
 511:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 512:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 513:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 514:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
 515:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearIN(void)
 516:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 517:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
 695               		.loc 5 517 0
 696 00be 8091 A600 		lds r24,166
 697 00c2 8E77      		andi r24,lo8(126)
 698 00c4 8093 A600 		sts 166,r24
 699               	.LVL56:
 700 00c8 F701      		movw r30,r14
 701 00ca 2085      		ldd r18,Z+8
 702 00cc C701      		movw r24,r14
 703 00ce 820F      		add r24,r18
 704 00d0 911D      		adc r25,__zero_reg__
 705 00d2 820F      		add r24,r18
 706 00d4 911D      		adc r25,__zero_reg__
 707               	.LBE31:
 708               	.LBE30:
 212:StillImageHost.c **** 	DeviceInfoPos +=  2;                                          // Skip over FunctionalMode
 709               		.loc 2 212 0
 710 00d6 FC01      		movw r30,r24
 711 00d8 3996      		adiw r30,9
 712               	.LVL57:
 713 00da 8281      		ldd r24,Z+2
 714 00dc 9381      		ldd r25,Z+3
 715 00de 880F      		lsl r24
 716 00e0 991F      		rol r25
 717 00e2 0696      		adiw r24,6
 214:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Supported Events Array
 718               		.loc 2 214 0
 719 00e4 E80F      		add r30,r24
 720 00e6 F91F      		adc r31,r25
 721               	.LVL58:
 215:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Supported Device Proper
 722               		.loc 2 215 0
 723 00e8 2081      		ld r18,Z
 724 00ea 3181      		ldd r19,Z+1
 725 00ec 220F      		lsl r18
 726 00ee 331F      		rol r19
 727 00f0 2C5F      		subi r18,-4
 728 00f2 3F4F      		sbci r19,-1
 729 00f4 E20F      		add r30,r18
 730 00f6 F31F      		adc r31,r19
 731               	.LVL59:
 216:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Capture Formats Array
 732               		.loc 2 216 0
 733 00f8 2081      		ld r18,Z
 734 00fa 3181      		ldd r19,Z+1
 735 00fc 220F      		lsl r18
 736 00fe 331F      		rol r19
 737 0100 2C5F      		subi r18,-4
 738 0102 3F4F      		sbci r19,-1
 739 0104 E20F      		add r30,r18
 740 0106 F31F      		adc r31,r19
 741               	.LVL60:
 217:StillImageHost.c **** 	DeviceInfoPos += (4 + (*(uint32_t*)DeviceInfoPos << 1));      // Skip over Image Formats Array
 742               		.loc 2 217 0
 743 0108 2081      		ld r18,Z
 744 010a 3181      		ldd r19,Z+1
 745 010c 220F      		lsl r18
 746 010e 331F      		rol r19
 747 0110 2C5F      		subi r18,-4
 748 0112 3F4F      		sbci r19,-1
 749 0114 E20F      		add r30,r18
 750 0116 F31F      		adc r31,r19
 751               	.LVL61:
 218:StillImageHost.c **** 
 752               		.loc 2 218 0
 753 0118 8081      		ld r24,Z
 754 011a 9181      		ldd r25,Z+1
 755 011c 880F      		lsl r24
 756 011e 991F      		rol r25
 757 0120 0496      		adiw r24,4
 758 0122 7F01      		movw r14,r30
 759               	.LVL62:
 760 0124 E80E      		add r14,r24
 761 0126 F91E      		adc r15,r25
 762               	.LVL63:
 221:StillImageHost.c **** 	UnicodeToASCII(DeviceInfoPos, Manufacturer);
 763               		.loc 2 221 0
 764 0128 F701      		movw r30,r14
 765 012a 8081      		ld r24,Z
 766 012c 2DB7      		in r18,__SP_L__
 767 012e 3EB7      		in r19,__SP_H__
 768 0130 281B      		sub r18,r24
 769 0132 3109      		sbc r19,__zero_reg__
 770 0134 0FB6      		in __tmp_reg__,__SREG__
 771 0136 F894      		cli
 772 0138 3EBF      		out __SP_H__,r19
 773 013a 0FBE      		out __SREG__,__tmp_reg__
 774 013c 2DBF      		out __SP_L__,r18
 775               	.LVL64:
 776 013e 4DB7      		in r20,__SP_L__
 777 0140 5EB7      		in r21,__SP_H__
 778 0142 4F5F      		subi r20,-1
 779 0144 5F4F      		sbci r21,-1
 780 0146 6A01      		movw r12,r20
 781               	.LVL65:
 222:StillImageHost.c **** 	printf_P(PSTR("   Manufacturer: %s\r\n"), Manufacturer);
 782               		.loc 2 222 0
 783 0148 BA01      		movw r22,r20
 784 014a C701      		movw r24,r14
 785 014c 0E94 0000 		call UnicodeToASCII
 786               	.LVL66:
 223:StillImageHost.c **** 
 787               		.loc 2 223 0
 788 0150 DF92      		push r13
 789 0152 CF92      		push r12
 790 0154 80E0      		ldi r24,lo8(__c.4557)
 791 0156 90E0      		ldi r25,hi8(__c.4557)
 792 0158 9F93      		push r25
 793 015a 8F93      		push r24
 794 015c 0E94 0000 		call printf_P
 795               	.LVL67:
 225:StillImageHost.c **** 
 796               		.loc 2 225 0
 797 0160 F701      		movw r30,r14
 798 0162 2081      		ld r18,Z
 799 0164 C701      		movw r24,r14
 800 0166 820F      		add r24,r18
 801 0168 911D      		adc r25,__zero_reg__
 802 016a 820F      		add r24,r18
 803 016c 911D      		adc r25,__zero_reg__
 804 016e 9C01      		movw r18,r24
 805 0170 2F5F      		subi r18,-1
 806 0172 3F4F      		sbci r19,-1
 807 0174 7901      		movw r14,r18
 808               	.LVL68:
 228:StillImageHost.c **** 	UnicodeToASCII(DeviceInfoPos, Model);
 809               		.loc 2 228 0
 810 0176 F901      		movw r30,r18
 811 0178 8081      		ld r24,Z
 812 017a 0F90      		pop __tmp_reg__
 813 017c 0F90      		pop __tmp_reg__
 814 017e 0F90      		pop __tmp_reg__
 815 0180 0F90      		pop __tmp_reg__
 816 0182 2DB7      		in r18,__SP_L__
 817 0184 3EB7      		in r19,__SP_H__
 818 0186 281B      		sub r18,r24
 819 0188 3109      		sbc r19,__zero_reg__
 820 018a 0FB6      		in __tmp_reg__,__SREG__
 821 018c F894      		cli
 822 018e 3EBF      		out __SP_H__,r19
 823 0190 0FBE      		out __SREG__,__tmp_reg__
 824 0192 2DBF      		out __SP_L__,r18
 825 0194 4DB7      		in r20,__SP_L__
 826 0196 5EB7      		in r21,__SP_H__
 827 0198 4F5F      		subi r20,-1
 828 019a 5F4F      		sbci r21,-1
 829 019c 6A01      		movw r12,r20
 830               	.LVL69:
 229:StillImageHost.c **** 	printf_P(PSTR("   Model: %s\r\n"), Model);
 831               		.loc 2 229 0
 832 019e BA01      		movw r22,r20
 833 01a0 C701      		movw r24,r14
 834 01a2 0E94 0000 		call UnicodeToASCII
 835               	.LVL70:
 230:StillImageHost.c **** 
 836               		.loc 2 230 0
 837 01a6 DF92      		push r13
 838 01a8 CF92      		push r12
 839 01aa 80E0      		ldi r24,lo8(__c.4560)
 840 01ac 90E0      		ldi r25,hi8(__c.4560)
 841 01ae 9F93      		push r25
 842 01b0 8F93      		push r24
 843 01b2 0E94 0000 		call printf_P
 844               	.LVL71:
 232:StillImageHost.c **** 
 845               		.loc 2 232 0
 846 01b6 F701      		movw r30,r14
 847 01b8 2081      		ld r18,Z
 848 01ba C701      		movw r24,r14
 849 01bc 820F      		add r24,r18
 850 01be 911D      		adc r25,__zero_reg__
 851 01c0 820F      		add r24,r18
 852 01c2 911D      		adc r25,__zero_reg__
 853 01c4 0196      		adiw r24,1
 854               	.LVL72:
 235:StillImageHost.c **** 	UnicodeToASCII(DeviceInfoPos, DeviceVersion);
 855               		.loc 2 235 0
 856 01c6 FC01      		movw r30,r24
 857 01c8 2081      		ld r18,Z
 858 01ca 0F90      		pop __tmp_reg__
 859 01cc 0F90      		pop __tmp_reg__
 860 01ce 0F90      		pop __tmp_reg__
 861 01d0 0F90      		pop __tmp_reg__
 862 01d2 4DB7      		in r20,__SP_L__
 863 01d4 5EB7      		in r21,__SP_H__
 864 01d6 421B      		sub r20,r18
 865 01d8 5109      		sbc r21,__zero_reg__
 866 01da 0FB6      		in __tmp_reg__,__SREG__
 867 01dc F894      		cli
 868 01de 5EBF      		out __SP_H__,r21
 869 01e0 0FBE      		out __SREG__,__tmp_reg__
 870 01e2 4DBF      		out __SP_L__,r20
 871 01e4 EDB7      		in r30,__SP_L__
 872 01e6 FEB7      		in r31,__SP_H__
 873 01e8 3196      		adiw r30,1
 874 01ea 7F01      		movw r14,r30
 875               	.LVL73:
 236:StillImageHost.c **** 	printf_P(PSTR("   Device Version: %s\r\n"), DeviceVersion);
 876               		.loc 2 236 0
 877 01ec BF01      		movw r22,r30
 878 01ee 0E94 0000 		call UnicodeToASCII
 879               	.LVL74:
 237:StillImageHost.c **** 
 880               		.loc 2 237 0
 881 01f2 FF92      		push r15
 882 01f4 EF92      		push r14
 883 01f6 80E0      		ldi r24,lo8(__c.4563)
 884 01f8 90E0      		ldi r25,hi8(__c.4563)
 885 01fa 9F93      		push r25
 886 01fc 8F93      		push r24
 887 01fe 0E94 0000 		call printf_P
 888               	.LVL75:
 240:StillImageHost.c **** 	{
 889               		.loc 2 240 0
 890 0202 0E94 0000 		call SImage_ReceiveBlockHeader
 891               	.LVL76:
 892 0206 0F90      		pop __tmp_reg__
 893 0208 0F90      		pop __tmp_reg__
 894 020a 0F90      		pop __tmp_reg__
 895 020c 0F90      		pop __tmp_reg__
 896 020e 8111      		cpse r24,__zero_reg__
 897 0210 00C0      		rjmp .L38
 248:StillImageHost.c **** 	{
 898               		.loc 2 248 0
 899 0212 8091 0000 		lds r24,PIMA_ReceivedBlock+4
 900 0216 9091 0000 		lds r25,PIMA_ReceivedBlock+4+1
 901               	.LVL77:
 902 021a 0397      		sbiw r24,3
 903 021c 01F0      		breq .+2
 904 021e 00C0      		rjmp .L34
 248:StillImageHost.c **** 	{
 905               		.loc 2 248 0 is_stmt 0 discriminator 1
 906 0220 E090 0000 		lds r14,PIMA_ReceivedBlock+6
 907 0224 F090 0000 		lds r15,PIMA_ReceivedBlock+6+1
 908               	.LVL78:
 909 0228 F1E0      		ldi r31,1
 910 022a EF16      		cp r14,r31
 911 022c F104      		cpc r15,__zero_reg__
 912 022e 01F0      		breq .+2
 913 0230 00C0      		rjmp .L34
 255:StillImageHost.c **** 
 914               		.loc 2 255 0 is_stmt 1
 915 0232 80E0      		ldi r24,lo8(__c.4565)
 916 0234 90E0      		ldi r25,hi8(__c.4565)
 917 0236 0E94 0000 		call puts_P
 918               	.LVL79:
 257:StillImageHost.c **** 		{
 919               		.loc 2 257 0
 920 023a F401      		movw r30,r8
 921 023c 232D      		mov r18,r3
 922               		0:
 923 023e 1192      		st Z+,__zero_reg__
 924 0240 2A95      		dec r18
 925 0242 01F4      		brne 0b
 926 0244 80E1      		ldi r24,lo8(16)
 927 0246 482E      		mov r4,r24
 928 0248 512C      		mov r5,__zero_reg__
 929 024a 612C      		mov r6,__zero_reg__
 930 024c 712C      		mov r7,__zero_reg__
 931 024e 4092 0000 		sts PIMA_SendBlock,r4
 932 0252 5092 0000 		sts PIMA_SendBlock+1,r5
 933 0256 6092 0000 		sts PIMA_SendBlock+2,r6
 934 025a 7092 0000 		sts PIMA_SendBlock+3,r7
 935 025e F092 0000 		sts PIMA_SendBlock+4+1,r15
 936 0262 E092 0000 		sts PIMA_SendBlock+4,r14
 937 0266 82E0      		ldi r24,lo8(2)
 938 0268 90E1      		ldi r25,lo8(16)
 939 026a 9093 0000 		sts PIMA_SendBlock+6+1,r25
 940 026e 8093 0000 		sts PIMA_SendBlock+6,r24
 941 0272 C12C      		mov r12,__zero_reg__
 942 0274 D12C      		mov r13,__zero_reg__
 943 0276 7601      		movw r14,r12
 944 0278 C394      		inc r12
 945               	.LVL80:
 946 027a C092 0000 		sts PIMA_SendBlock+12,r12
 947 027e D092 0000 		sts PIMA_SendBlock+12+1,r13
 948 0282 E092 0000 		sts PIMA_SendBlock+12+2,r14
 949 0286 F092 0000 		sts PIMA_SendBlock+12+3,r15
 267:StillImageHost.c **** 
 950               		.loc 2 267 0
 951 028a 0E94 0000 		call SImage_SendBlockHeader
 952               	.LVL81:
 270:StillImageHost.c **** 	{
 953               		.loc 2 270 0
 954 028e 0E94 0000 		call SImage_ReceiveBlockHeader
 955               	.LVL82:
 956 0292 8111      		cpse r24,__zero_reg__
 957 0294 00C0      		rjmp .L38
 278:StillImageHost.c **** 	{
 958               		.loc 2 278 0
 959 0296 8091 0000 		lds r24,PIMA_ReceivedBlock+4
 960 029a 9091 0000 		lds r25,PIMA_ReceivedBlock+4+1
 961               	.LVL83:
 962 029e 0397      		sbiw r24,3
 963 02a0 01F0      		breq .+2
 964 02a2 00C0      		rjmp .L34
 278:StillImageHost.c **** 	{
 965               		.loc 2 278 0 is_stmt 0 discriminator 1
 966 02a4 A090 0000 		lds r10,PIMA_ReceivedBlock+6
 967 02a8 B090 0000 		lds r11,PIMA_ReceivedBlock+6+1
 968 02ac 31E0      		ldi r19,1
 969 02ae A316      		cp r10,r19
 970 02b0 B104      		cpc r11,__zero_reg__
 971 02b2 01F4      		brne .L34
 285:StillImageHost.c **** 
 972               		.loc 2 285 0 is_stmt 1
 973 02b4 80E0      		ldi r24,lo8(__c.4568)
 974 02b6 90E0      		ldi r25,hi8(__c.4568)
 975 02b8 0E94 0000 		call puts_P
 976               	.LVL84:
 287:StillImageHost.c **** 		{
 977               		.loc 2 287 0
 978 02bc F401      		movw r30,r8
 979               		0:
 980 02be 1192      		st Z+,__zero_reg__
 981 02c0 3A94      		dec r3
 982 02c2 01F4      		brne 0b
 983 02c4 4092 0000 		sts PIMA_SendBlock,r4
 984 02c8 5092 0000 		sts PIMA_SendBlock+1,r5
 985 02cc 6092 0000 		sts PIMA_SendBlock+2,r6
 986 02d0 7092 0000 		sts PIMA_SendBlock+3,r7
 987 02d4 B092 0000 		sts PIMA_SendBlock+4+1,r11
 988 02d8 A092 0000 		sts PIMA_SendBlock+4,r10
 989 02dc 83E0      		ldi r24,lo8(3)
 990 02de 90E1      		ldi r25,lo8(16)
 991 02e0 9093 0000 		sts PIMA_SendBlock+6+1,r25
 992 02e4 8093 0000 		sts PIMA_SendBlock+6,r24
 993 02e8 C092 0000 		sts PIMA_SendBlock+8,r12
 994 02ec D092 0000 		sts PIMA_SendBlock+8+1,r13
 995 02f0 E092 0000 		sts PIMA_SendBlock+8+2,r14
 996 02f4 F092 0000 		sts PIMA_SendBlock+8+3,r15
 997 02f8 C092 0000 		sts PIMA_SendBlock+12,r12
 998 02fc D092 0000 		sts PIMA_SendBlock+12+1,r13
 999 0300 E092 0000 		sts PIMA_SendBlock+12+2,r14
 1000 0304 F092 0000 		sts PIMA_SendBlock+12+3,r15
 297:StillImageHost.c **** 
 1001               		.loc 2 297 0
 1002 0308 0E94 0000 		call SImage_SendBlockHeader
 1003               	.LVL85:
 300:StillImageHost.c **** 	{
 1004               		.loc 2 300 0
 1005 030c 0E94 0000 		call SImage_ReceiveBlockHeader
 1006               	.LVL86:
 1007 0310 8823      		tst r24
 1008 0312 01F0      		breq .L33
 1009               	.LVL87:
 1010               	.L38:
 302:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 1011               		.loc 2 302 0
 1012 0314 60E0      		ldi r22,0
 1013 0316 00C0      		rjmp .L37
 1014               	.LVL88:
 1015               	.L33:
 308:StillImageHost.c **** 	{
 1016               		.loc 2 308 0
 1017 0318 8091 0000 		lds r24,PIMA_ReceivedBlock+4
 1018 031c 9091 0000 		lds r25,PIMA_ReceivedBlock+4+1
 1019               	.LVL89:
 1020 0320 0397      		sbiw r24,3
 1021 0322 01F4      		brne .L34
 308:StillImageHost.c **** 	{
 1022               		.loc 2 308 0 is_stmt 0 discriminator 1
 1023 0324 8091 0000 		lds r24,PIMA_ReceivedBlock+6
 1024 0328 9091 0000 		lds r25,PIMA_ReceivedBlock+6+1
 1025 032c 0197      		sbiw r24,1
 1026 032e 01F0      		breq .L35
 1027               	.L34:
 310:StillImageHost.c **** 		USB_Host_SetDeviceConfiguration(0);
 1028               		.loc 2 310 0 is_stmt 1
 1029 0330 61E0      		ldi r22,lo8(1)
 1030 0332 8091 0000 		lds r24,PIMA_ReceivedBlock+6
 1031               	.LVL90:
 1032               	.L37:
 1033 0336 0E94 0000 		call ShowCommandError
 1034               	.LVL91:
 1035 033a 00C0      		rjmp .L39
 1036               	.LVL92:
 1037               	.L35:
 315:StillImageHost.c **** 
 1038               		.loc 2 315 0
 1039 033c 80E0      		ldi r24,lo8(__c.4571)
 1040 033e 90E0      		ldi r25,hi8(__c.4571)
 1041 0340 0E94 0000 		call puts_P
 1042               	.LVL93:
 318:StillImageHost.c **** 	USB_Host_SetDeviceConfiguration(0);
 1043               		.loc 2 318 0
 1044 0344 80E6      		ldi r24,lo8(96)
 1045 0346 0E94 0000 		call LEDs_SetAllLEDs
 1046               	.LVL94:
 1047               	.L39:
 319:StillImageHost.c **** }
 1048               		.loc 2 319 0
 1049 034a 80E0      		ldi r24,0
 1050 034c 0E94 0000 		call USB_Host_SetDeviceConfiguration
 1051               	.LVL95:
 1052               	.L25:
 166:StillImageHost.c **** 
 1053               		.loc 2 166 0
 1054 0350 0FB6      		in __tmp_reg__,__SREG__
 1055 0352 F894      		cli
 1056 0354 1EBF      		out __SP_H__,r17
 1057 0356 0FBE      		out __SREG__,__tmp_reg__
 1058 0358 0DBF      		out __SP_L__,r16
 320:StillImageHost.c **** 
 1059               		.loc 2 320 0
 1060 035a 0FB6      		in __tmp_reg__,__SREG__
 1061 035c F894      		cli
 1062 035e 1EBF      		out __SP_H__,r17
 1063 0360 0FBE      		out __SREG__,__tmp_reg__
 1064 0362 0DBF      		out __SP_L__,r16
 1065               	/* epilogue start */
 1066 0364 DF91      		pop r29
 1067 0366 CF91      		pop r28
 1068 0368 1F91      		pop r17
 1069 036a 0F91      		pop r16
 1070 036c FF90      		pop r15
 1071 036e EF90      		pop r14
 1072 0370 DF90      		pop r13
 1073 0372 CF90      		pop r12
 1074 0374 BF90      		pop r11
 1075 0376 AF90      		pop r10
 1076 0378 9F90      		pop r9
 1077 037a 8F90      		pop r8
 1078 037c 7F90      		pop r7
 1079 037e 6F90      		pop r6
 1080 0380 5F90      		pop r5
 1081 0382 4F90      		pop r4
 1082 0384 3F90      		pop r3
 1083 0386 0895      		ret
 1084               		.cfi_endproc
 1085               	.LFE154:
 1087               		.section	.text.startup.main,"ax",@progbits
 1088               	.global	main
 1090               	main:
 1091               	.LFB147:
  43:StillImageHost.c **** 	SetupHardware();
 1092               		.loc 2 43 0
 1093               		.cfi_startproc
 1094               	/* prologue: function */
 1095               	/* frame size = 0 */
 1096               	/* stack size = 0 */
 1097               	.L__stack_usage = 0
  44:StillImageHost.c **** 
 1098               		.loc 2 44 0
 1099 0000 0E94 0000 		call SetupHardware
 1100               	.LVL96:
  46:StillImageHost.c **** 
 1101               		.loc 2 46 0
 1102 0004 80E0      		ldi r24,lo8(__c.4502)
 1103 0006 90E0      		ldi r25,hi8(__c.4502)
 1104 0008 0E94 0000 		call puts_P
 1105               	.LVL97:
  48:StillImageHost.c **** 	sei();
 1106               		.loc 2 48 0
 1107 000c 80E1      		ldi r24,lo8(16)
 1108 000e 0E94 0000 		call LEDs_SetAllLEDs
 1109               	.LVL98:
  49:StillImageHost.c **** 
 1110               		.loc 2 49 0
 1111               	/* #APP */
 1112               	 ;  49 "StillImageHost.c" 1
 1113 0012 7894      		sei
 1114               	 ;  0 "" 2
 1115               	/* #NOAPP */
 1116               	.L41:
  53:StillImageHost.c **** 
 1117               		.loc 2 53 0 discriminator 1
 1118 0014 0E94 0000 		call StillImageHost_Task
 1119               	.LVL99:
  55:StillImageHost.c **** 	}
 1120               		.loc 2 55 0 discriminator 1
 1121 0018 0E94 0000 		call USB_USBTask
 1122               	.LVL100:
 1123 001c 00C0      		rjmp .L41
 1124               		.cfi_endproc
 1125               	.LFE147:
 1127               		.section	.progmem.data,"a",@progbits
 1130               	__c.4590:
 1131 0000 1B5B 3331 		.string	"\033[31mCommand Error (%S).\r\n -- Error Code %d\r\n\033[37m"
 1131      6D43 6F6D 
 1131      6D61 6E64 
 1131      2045 7272 
 1131      6F72 2028 
 1134               	__c.4588:
 1135 0033 5472 616E 		.string	"Transaction Fail"
 1135      7361 6374 
 1135      696F 6E20 
 1135      4661 696C 
 1135      00
 1138               	__c.4586:
 1139 0044 5265 7370 		.string	"Response Code != OK"
 1139      6F6E 7365 
 1139      2043 6F64 
 1139      6520 213D 
 1139      204F 4B00 
 1142               	__c.4571:
 1143 0058 446F 6E65 		.string	"Done.\r\n"
 1143      2E0D 0A00 
 1146               	__c.4568:
 1147 0060 436C 6F73 		.string	"Closing Session...\r\n"
 1147      696E 6720 
 1147      5365 7373 
 1147      696F 6E2E 
 1147      2E2E 0D0A 
 1150               	__c.4565:
 1151 0075 4F70 656E 		.string	"Opening Session...\r\n"
 1151      696E 6720 
 1151      5365 7373 
 1151      696F 6E2E 
 1151      2E2E 0D0A 
 1154               	__c.4563:
 1155 008a 2020 2044 		.string	"   Device Version: %s\r\n"
 1155      6576 6963 
 1155      6520 5665 
 1155      7273 696F 
 1155      6E3A 2025 
 1158               	__c.4560:
 1159 00a2 2020 204D 		.string	"   Model: %s\r\n"
 1159      6F64 656C 
 1159      3A20 2573 
 1159      0D0A 00
 1162               	__c.4557:
 1163 00b1 2020 204D 		.string	"   Manufacturer: %s\r\n"
 1163      616E 7566 
 1163      6163 7475 
 1163      7265 723A 
 1163      2025 730D 
 1166               	__c.4550:
 1167 00c7 5265 7472 		.string	"Retrieving Device Info...\r\n"
 1167      6965 7669 
 1167      6E67 2044 
 1167      6576 6963 
 1167      6520 496E 
 1170               	__c.4544:
 1171 00e3 1B5B 3331 		.string	"\033[31mDev Enum Error\r\n -- Error Code %d\r\n -- Sub Error Code %d\r\n -- In State %d\r
 1171      6D44 6576 
 1171      2045 6E75 
 1171      6D20 4572 
 1171      726F 720D 
 1174               	__c.4537:
 1175 0139 1B5B 3331 		.string	"\033[31mHost Mode Error\r\n -- Error Code %d\r\n\033[37m"
 1175      6D48 6F73 
 1175      7420 4D6F 
 1175      6465 2045 
 1175      7272 6F72 
 1178               	__c.4532:
 1179 0168 5374 696C 		.string	"Still Image Device Enumerated.\r\n"
 1179      6C20 496D 
 1179      6167 6520 
 1179      4465 7669 
 1179      6365 2045 
 1182               	__c.4530:
 1183 0189 1B5B 3331 		.string	"\033[31mControl Error (Set Configuration).\r\n -- Error Code: %d\r\n\033[37m"
 1183      6D43 6F6E 
 1183      7472 6F6C 
 1183      2045 7272 
 1183      6F72 2028 
 1186               	__c.4528:
 1187 01cc 202D 2D20 		.string	" -- Error Code: %d\r\n\033[37m"
 1187      4572 726F 
 1187      7220 436F 
 1187      6465 3A20 
 1187      2564 0D0A 
 1190               	__c.4526:
 1191 01e6 1B5B 3331 		.string	"\033[31mInvalid Device.\r\n"
 1191      6D49 6E76 
 1191      616C 6964 
 1191      2044 6576 
 1191      6963 652E 
 1194               	__c.4524:
 1195 01fd 1B5B 3331 		.string	"\033[31mControl Error (Get Configuration).\r\n"
 1195      6D43 6F6E 
 1195      7472 6F6C 
 1195      2045 7272 
 1195      6F72 2028 
 1198               	__c.4521:
 1199 0227 4765 7474 		.string	"Getting Config Data.\r\n"
 1199      696E 6720 
 1199      436F 6E66 
 1199      6967 2044 
 1199      6174 612E 
 1202               	__c.4516:
 1203 023e 1B5B 3332 		.string	"\033[32m\r\nDevice Unattached.\r\n\033[37m"
 1203      6D0D 0A44 
 1203      6576 6963 
 1203      6520 556E 
 1203      6174 7461 
 1206               	__c.4511:
 1207 025f 1B5B 3332 		.string	"\033[32mDevice Attached.\r\n\033[37m"
 1207      6D44 6576 
 1207      6963 6520 
 1207      4174 7461 
 1207      6368 6564 
 1210               	__c.4502:
 1211 027c 1B5B 3336 		.string	"\033[36mStill Image Host Demo running.\r\n\033[37m"
 1211      6D53 7469 
 1211      6C6C 2049 
 1211      6D61 6765 
 1211      2048 6F73 
 1212               		.text
 1213               	.Letext0:
 1214               		.file 6 "/usr/lib/avr/include/stdint.h"
 1215               		.file 7 "/usr/lib/avr/include/stdio.h"
 1216               		.file 8 "../../../../LUFA/Drivers/USB/Core/AVR8/../Host.h"
 1217               		.file 9 "../../../../LUFA/Drivers/USB/Core/AVR8/../HostStandardReq.h"
 1218               		.file 10 "../../../../LUFA/Drivers/USB/Core/AVR8/../PipeStream.h"
 1219               		.file 11 "../../../../LUFA/Drivers/USB/Class/Host/../Common/StillImage.h"
 1220               		.file 12 "ConfigDescriptor.h"
 1221               		.file 13 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
 1222               		.file 14 "Lib/StillImageCommands.h"
 1223               		.file 15 "../../../../LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 StillImageHost.c
     /tmp/cc1xi1vz.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc1xi1vz.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc1xi1vz.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc1xi1vz.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc1xi1vz.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc1xi1vz.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc1xi1vz.s:13     .text.LEDs_SetAllLEDs:0000000000000000 LEDs_SetAllLEDs
     /tmp/cc1xi1vz.s:36     .text.SetupHardware:0000000000000000 SetupHardware
     /tmp/cc1xi1vz.s:156    .text.EVENT_USB_Host_DeviceAttached:0000000000000000 EVENT_USB_Host_DeviceAttached
     /tmp/cc1xi1vz.s:1206   .progmem.data:000000000000025f __c.4511
     /tmp/cc1xi1vz.s:179    .text.EVENT_USB_Host_DeviceUnattached:0000000000000000 EVENT_USB_Host_DeviceUnattached
     /tmp/cc1xi1vz.s:1202   .progmem.data:000000000000023e __c.4516
     /tmp/cc1xi1vz.s:202    .text.EVENT_USB_Host_DeviceEnumerationComplete:0000000000000000 EVENT_USB_Host_DeviceEnumerationComplete
     /tmp/cc1xi1vz.s:1198   .progmem.data:0000000000000227 __c.4521
     /tmp/cc1xi1vz.s:1194   .progmem.data:00000000000001fd __c.4524
     /tmp/cc1xi1vz.s:1190   .progmem.data:00000000000001e6 __c.4526
     /tmp/cc1xi1vz.s:1186   .progmem.data:00000000000001cc __c.4528
     /tmp/cc1xi1vz.s:1182   .progmem.data:0000000000000189 __c.4530
     /tmp/cc1xi1vz.s:1178   .progmem.data:0000000000000168 __c.4532
     /tmp/cc1xi1vz.s:317    .text.EVENT_USB_Host_HostError:0000000000000000 EVENT_USB_Host_HostError
     /tmp/cc1xi1vz.s:1174   .progmem.data:0000000000000139 __c.4537
     /tmp/cc1xi1vz.s:365    .text.EVENT_USB_Host_DeviceEnumerationFailed:0000000000000000 EVENT_USB_Host_DeviceEnumerationFailed
     /tmp/cc1xi1vz.s:1170   .progmem.data:00000000000000e3 __c.4544
     /tmp/cc1xi1vz.s:425    .text.UnicodeToASCII:0000000000000000 UnicodeToASCII
     /tmp/cc1xi1vz.s:471    .text.ShowCommandError:0000000000000000 ShowCommandError
     /tmp/cc1xi1vz.s:1134   .progmem.data:0000000000000033 __c.4588
     /tmp/cc1xi1vz.s:1138   .progmem.data:0000000000000044 __c.4586
     /tmp/cc1xi1vz.s:1130   .progmem.data:0000000000000000 __c.4590
     /tmp/cc1xi1vz.s:533    .text.StillImageHost_Task:0000000000000000 StillImageHost_Task
     /tmp/cc1xi1vz.s:1166   .progmem.data:00000000000000c7 __c.4550
     /tmp/cc1xi1vz.s:1162   .progmem.data:00000000000000b1 __c.4557
     /tmp/cc1xi1vz.s:1158   .progmem.data:00000000000000a2 __c.4560
     /tmp/cc1xi1vz.s:1154   .progmem.data:000000000000008a __c.4563
     /tmp/cc1xi1vz.s:1150   .progmem.data:0000000000000075 __c.4565
     /tmp/cc1xi1vz.s:1146   .progmem.data:0000000000000060 __c.4568
     /tmp/cc1xi1vz.s:1142   .progmem.data:0000000000000058 __c.4571
     /tmp/cc1xi1vz.s:1090   .text.startup.main:0000000000000000 main
     /tmp/cc1xi1vz.s:1210   .progmem.data:000000000000027c __c.4502

UNDEFINED SYMBOLS
USB_Init
__iob
USARTSerialStream
Serial_putchar
Serial_getchar
puts_P
ProcessConfigurationDescriptor
printf_P
USB_Host_SetDeviceConfiguration
USB_Disable
USB_HostState
PIMA_SendBlock
SImage_SendBlockHeader
SImage_ReceiveBlockHeader
PIMA_ReceivedBlock
SImage_ReadData
USB_USBTask
