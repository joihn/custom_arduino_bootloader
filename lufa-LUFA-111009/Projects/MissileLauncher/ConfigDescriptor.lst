   1               		.file	"ConfigDescriptor.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.DComp_NextHIDInterface,"ax",@progbits
  12               	.global	DComp_NextHIDInterface
  14               	DComp_NextHIDInterface:
  15               	.LFB145:
  16               		.file 1 "ConfigDescriptor.c"
   1:ConfigDescriptor.c **** /*
   2:ConfigDescriptor.c ****              LUFA Library
   3:ConfigDescriptor.c ****      Copyright (C) Dean Camera, 2011.
   4:ConfigDescriptor.c **** 
   5:ConfigDescriptor.c ****   dean [at] fourwalledcubicle [dot] com
   6:ConfigDescriptor.c ****            www.lufa-lib.org
   7:ConfigDescriptor.c **** */
   8:ConfigDescriptor.c **** 
   9:ConfigDescriptor.c **** /*
  10:ConfigDescriptor.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:ConfigDescriptor.c **** 
  12:ConfigDescriptor.c ****   Permission to use, copy, modify, distribute, and sell this
  13:ConfigDescriptor.c ****   software and its documentation for any purpose is hereby granted
  14:ConfigDescriptor.c ****   without fee, provided that the above copyright notice appear in
  15:ConfigDescriptor.c ****   all copies and that both that the copyright notice and this
  16:ConfigDescriptor.c ****   permission notice and warranty disclaimer appear in supporting
  17:ConfigDescriptor.c ****   documentation, and that the name of the author not be used in
  18:ConfigDescriptor.c ****   advertising or publicity pertaining to distribution of the
  19:ConfigDescriptor.c ****   software without specific, written prior permission.
  20:ConfigDescriptor.c **** 
  21:ConfigDescriptor.c ****   The author disclaim all warranties with regard to this
  22:ConfigDescriptor.c ****   software, including all implied warranties of merchantability
  23:ConfigDescriptor.c ****   and fitness.  In no event shall the author be liable for any
  24:ConfigDescriptor.c ****   special, indirect or consequential damages or any damages
  25:ConfigDescriptor.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:ConfigDescriptor.c ****   in an action of contract, negligence or other tortious action,
  27:ConfigDescriptor.c ****   arising out of or in connection with the use or performance of
  28:ConfigDescriptor.c ****   this software.
  29:ConfigDescriptor.c **** */
  30:ConfigDescriptor.c **** 
  31:ConfigDescriptor.c **** /** \file
  32:ConfigDescriptor.c ****  *
  33:ConfigDescriptor.c ****  *  USB Device Configuration Descriptor processing routines, to determine the correct pipe configur
  34:ConfigDescriptor.c ****  *  needed to communication with an attached USB device. Descriptors are special  computer-readable
  35:ConfigDescriptor.c ****  *  which the host requests upon device enumeration, to determine the device's capabilities and fun
  36:ConfigDescriptor.c ****  */
  37:ConfigDescriptor.c **** 
  38:ConfigDescriptor.c **** #include "ConfigDescriptor.h"
  39:ConfigDescriptor.c **** 
  40:ConfigDescriptor.c **** /** Reads and processes an attached device's descriptors, to determine compatibility and pipe confi
  41:ConfigDescriptor.c ****  *  routine will read in the entire configuration descriptor, and configure the hosts pipes to corr
  42:ConfigDescriptor.c ****  *  with compatible devices.
  43:ConfigDescriptor.c ****  *
  44:ConfigDescriptor.c ****  *  This routine searches for a HID interface descriptor containing at least one Interrupt type IN 
  45:ConfigDescriptor.c ****  *
  46:ConfigDescriptor.c ****  *  \return An error code from the GenericHIDHost_GetConfigDescriptorDataCodes_t enum.
  47:ConfigDescriptor.c ****  */
  48:ConfigDescriptor.c **** uint8_t ProcessConfigurationDescriptor(void)
  49:ConfigDescriptor.c **** {
  50:ConfigDescriptor.c **** 	uint8_t  ConfigDescriptorData[512];
  51:ConfigDescriptor.c **** 	void*    CurrConfigLocation = ConfigDescriptorData;
  52:ConfigDescriptor.c **** 	uint16_t CurrConfigBytesRem;
  53:ConfigDescriptor.c **** 
  54:ConfigDescriptor.c **** 	USB_Descriptor_Interface_t* HIDInterface    = NULL;
  55:ConfigDescriptor.c **** 	USB_Descriptor_Endpoint_t*  DataINEndpoint  = NULL;
  56:ConfigDescriptor.c **** 	USB_Descriptor_Endpoint_t*  DataOUTEndpoint = NULL;
  57:ConfigDescriptor.c **** 
  58:ConfigDescriptor.c **** 	/* Retrieve the entire configuration descriptor into the allocated buffer */
  59:ConfigDescriptor.c **** 	switch (USB_Host_GetDeviceConfigDescriptor(1, &CurrConfigBytesRem, ConfigDescriptorData, sizeof(Co
  60:ConfigDescriptor.c **** 	{
  61:ConfigDescriptor.c **** 		case HOST_GETCONFIG_Successful:
  62:ConfigDescriptor.c **** 			break;
  63:ConfigDescriptor.c **** 		case HOST_GETCONFIG_InvalidData:
  64:ConfigDescriptor.c **** 			return InvalidConfigDataReturned;
  65:ConfigDescriptor.c **** 		case HOST_GETCONFIG_BuffOverflow:
  66:ConfigDescriptor.c **** 			return DescriptorTooLarge;
  67:ConfigDescriptor.c **** 		default:
  68:ConfigDescriptor.c **** 			return ControlError;
  69:ConfigDescriptor.c **** 	}
  70:ConfigDescriptor.c **** 
  71:ConfigDescriptor.c **** 	while (!(DataINEndpoint) || !(DataOUTEndpoint))
  72:ConfigDescriptor.c **** 	{
  73:ConfigDescriptor.c **** 		/* See if we've found a likely compatible interface, and if there is an endpoint within that inte
  74:ConfigDescriptor.c **** 		if (!(HIDInterface) ||
  75:ConfigDescriptor.c **** 		    USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
  76:ConfigDescriptor.c **** 		                              DComp_NextHIDInterfaceDataEndpoint) != DESCRIPTOR_SEARCH_COMP_Found
  77:ConfigDescriptor.c **** 		{
  78:ConfigDescriptor.c **** 			/* Not all HID devices have an OUT endpoint - if we've reached the end of the HID descriptor
  79:ConfigDescriptor.c **** 			 * but only found the mandatory IN endpoint, it's safe to continue with the device enumeration *
  80:ConfigDescriptor.c **** 			if (DataINEndpoint)
  81:ConfigDescriptor.c **** 			  break;
  82:ConfigDescriptor.c **** 
  83:ConfigDescriptor.c **** 			/* Get the next HID interface from the configuration descriptor */
  84:ConfigDescriptor.c **** 			if (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
  85:ConfigDescriptor.c **** 										  DComp_NextHIDInterface) != DESCRIPTOR_SEARCH_COMP_Found)
  86:ConfigDescriptor.c **** 			{
  87:ConfigDescriptor.c **** 				/* Descriptor not found, error out */
  88:ConfigDescriptor.c **** 				return NoCompatibleInterfaceFound;
  89:ConfigDescriptor.c **** 			}
  90:ConfigDescriptor.c **** 
  91:ConfigDescriptor.c **** 			/* Save the interface in case we need to refer back to it later */
  92:ConfigDescriptor.c **** 			HIDInterface = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_Interface_t);
  93:ConfigDescriptor.c **** 
  94:ConfigDescriptor.c **** 			/* Clear any found endpoints */
  95:ConfigDescriptor.c **** 			DataOUTEndpoint = NULL;
  96:ConfigDescriptor.c **** 
  97:ConfigDescriptor.c **** 			/* Skip the remainder of the loop as we have not found an endpoint yet */
  98:ConfigDescriptor.c **** 			continue;
  99:ConfigDescriptor.c **** 		}
 100:ConfigDescriptor.c **** 
 101:ConfigDescriptor.c **** 		/* Retrieve the endpoint address from the endpoint descriptor */
 102:ConfigDescriptor.c **** 		USB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_End
 103:ConfigDescriptor.c **** 
 104:ConfigDescriptor.c **** 		/* If the endpoint is a IN type endpoint */
 105:ConfigDescriptor.c **** 		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
 106:ConfigDescriptor.c **** 		  DataINEndpoint  = EndpointData;
 107:ConfigDescriptor.c **** 		else
 108:ConfigDescriptor.c **** 		  DataOUTEndpoint = EndpointData;
 109:ConfigDescriptor.c **** 	}
 110:ConfigDescriptor.c **** 
 111:ConfigDescriptor.c **** 	/* Configure the HID data IN pipe */
 112:ConfigDescriptor.c **** 	Pipe_ConfigurePipe(HID_DATA_IN_PIPE, EP_TYPE_INTERRUPT, PIPE_TOKEN_IN,
 113:ConfigDescriptor.c **** 	                   DataINEndpoint->EndpointAddress, DataINEndpoint->EndpointSize, PIPE_BANK_SINGLE
 114:ConfigDescriptor.c **** 	Pipe_SetInterruptPeriod(DataINEndpoint->PollingIntervalMS);
 115:ConfigDescriptor.c **** 
 116:ConfigDescriptor.c **** 	/* Check if the HID interface contained an optional OUT data endpoint */
 117:ConfigDescriptor.c **** 	if (DataOUTEndpoint)
 118:ConfigDescriptor.c **** 	{
 119:ConfigDescriptor.c **** 		/* Configure the HID data OUT pipe */
 120:ConfigDescriptor.c **** 		Pipe_ConfigurePipe(HID_DATA_OUT_PIPE, EP_TYPE_INTERRUPT, PIPE_TOKEN_OUT,
 121:ConfigDescriptor.c **** 						   DataOUTEndpoint->EndpointAddress, DataOUTEndpoint->EndpointSize, PIPE_BANK_SINGLE);
 122:ConfigDescriptor.c **** 	}
 123:ConfigDescriptor.c **** 
 124:ConfigDescriptor.c **** 	/* Valid data found, return success */
 125:ConfigDescriptor.c **** 	return SuccessfulConfigRead;
 126:ConfigDescriptor.c **** }
 127:ConfigDescriptor.c **** 
 128:ConfigDescriptor.c **** /** Descriptor comparator function. This comparator function is can be called while processing an a
 129:ConfigDescriptor.c ****  *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort
 130:ConfigDescriptor.c ****  *  descriptor processing if an incompatible descriptor configuration is found.
 131:ConfigDescriptor.c ****  *
 132:ConfigDescriptor.c ****  *  This comparator searches for the next Interface descriptor of the correct HID Class value.
 133:ConfigDescriptor.c ****  *
 134:ConfigDescriptor.c ****  *  \return A value from the DSEARCH_Return_ErrorCodes_t enum
 135:ConfigDescriptor.c ****  */
 136:ConfigDescriptor.c **** uint8_t DComp_NextHIDInterface(void* CurrentDescriptor)
 137:ConfigDescriptor.c **** {
  17               		.loc 1 137 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 138:ConfigDescriptor.c **** 	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);
 139:ConfigDescriptor.c **** 
 140:ConfigDescriptor.c **** 	/* Determine if the current descriptor is an interface descriptor */
 141:ConfigDescriptor.c **** 	if (Header->Type == DTYPE_Interface)
  24               		.loc 1 141 0
  25 0000 FC01      		movw r30,r24
  26 0002 2181      		ldd r18,Z+1
  27 0004 2430      		cpi r18,lo8(4)
  28 0006 01F4      		brne .L4
  29               	.LBB5:
 142:ConfigDescriptor.c **** 	{
 143:ConfigDescriptor.c **** 		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Interf
 144:ConfigDescriptor.c **** 
 145:ConfigDescriptor.c **** 		/* Check the HID descriptor class and protocol, break out if correct class/protocol interface fou
 146:ConfigDescriptor.c **** 		if (Interface->Class == HID_CLASS)
  30               		.loc 1 146 0
  31 0008 8581      		ldd r24,Z+5
  32               	.LVL1:
  33 000a 8330      		cpi r24,lo8(3)
  34 000c 01F4      		brne .L4
 147:ConfigDescriptor.c **** 		{
 148:ConfigDescriptor.c **** 			/* Indicate that the descriptor being searched for has been found */
 149:ConfigDescriptor.c **** 			return DESCRIPTOR_SEARCH_Found;
  35               		.loc 1 149 0
  36 000e 80E0      		ldi r24,0
  37 0010 0895      		ret
  38               	.L4:
  39               	.LBE5:
 150:ConfigDescriptor.c **** 		}
 151:ConfigDescriptor.c **** 	}
 152:ConfigDescriptor.c **** 
 153:ConfigDescriptor.c **** 	/* Current descriptor does not match what this comparator is looking for */
 154:ConfigDescriptor.c **** 	return DESCRIPTOR_SEARCH_NotFound;
  40               		.loc 1 154 0
  41 0012 82E0      		ldi r24,lo8(2)
 155:ConfigDescriptor.c **** }
  42               		.loc 1 155 0
  43 0014 0895      		ret
  44               		.cfi_endproc
  45               	.LFE145:
  47               		.section	.text.DComp_NextHIDInterfaceDataEndpoint,"ax",@progbits
  48               	.global	DComp_NextHIDInterfaceDataEndpoint
  50               	DComp_NextHIDInterfaceDataEndpoint:
  51               	.LFB146:
 156:ConfigDescriptor.c **** 
 157:ConfigDescriptor.c **** /** Descriptor comparator function. This comparator function is can be called while processing an a
 158:ConfigDescriptor.c ****  *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort
 159:ConfigDescriptor.c ****  *  descriptor processing if an incompatible descriptor configuration is found.
 160:ConfigDescriptor.c ****  *
 161:ConfigDescriptor.c ****  *  This comparator searches for the next Endpoint descriptor inside the current interface descript
 162:ConfigDescriptor.c ****  *  aborting the search if another interface descriptor is found before the required endpoint.
 163:ConfigDescriptor.c ****  *
 164:ConfigDescriptor.c ****  *  \return A value from the DSEARCH_Return_ErrorCodes_t enum
 165:ConfigDescriptor.c ****  */
 166:ConfigDescriptor.c **** uint8_t DComp_NextHIDInterfaceDataEndpoint(void* CurrentDescriptor)
 167:ConfigDescriptor.c **** {
  52               		.loc 1 167 0
  53               		.cfi_startproc
  54               	.LVL2:
  55               	/* prologue: function */
  56               	/* frame size = 0 */
  57               	/* stack size = 0 */
  58               	.L__stack_usage = 0
 168:ConfigDescriptor.c **** 	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);
 169:ConfigDescriptor.c **** 
 170:ConfigDescriptor.c **** 	/* Determine the type of the current descriptor */
 171:ConfigDescriptor.c **** 	if (Header->Type == DTYPE_Endpoint)
  59               		.loc 1 171 0
  60 0000 FC01      		movw r30,r24
  61 0002 8181      		ldd r24,Z+1
  62               	.LVL3:
  63 0004 8530      		cpi r24,lo8(5)
  64 0006 01F0      		breq .L8
 172:ConfigDescriptor.c **** 	{
 173:ConfigDescriptor.c **** 		/* Indicate that the descriptor being searched for has been found */
 174:ConfigDescriptor.c **** 		return DESCRIPTOR_SEARCH_Found;
 175:ConfigDescriptor.c **** 	}
 176:ConfigDescriptor.c **** 	else if (Header->Type == DTYPE_Interface)
  65               		.loc 1 176 0
  66 0008 8430      		cpi r24,lo8(4)
  67 000a 01F0      		breq .L9
 177:ConfigDescriptor.c **** 	{
 178:ConfigDescriptor.c **** 		/* Indicate that the search has failed prematurely and should be aborted */
 179:ConfigDescriptor.c **** 		return DESCRIPTOR_SEARCH_Fail;
 180:ConfigDescriptor.c **** 	}
 181:ConfigDescriptor.c **** 	else
 182:ConfigDescriptor.c **** 	{
 183:ConfigDescriptor.c **** 		/* Current descriptor does not match what this comparator is looking for */
 184:ConfigDescriptor.c **** 		return DESCRIPTOR_SEARCH_NotFound;
  68               		.loc 1 184 0
  69 000c 82E0      		ldi r24,lo8(2)
  70 000e 0895      		ret
  71               	.L8:
 174:ConfigDescriptor.c **** 	}
  72               		.loc 1 174 0
  73 0010 80E0      		ldi r24,0
  74 0012 0895      		ret
  75               	.L9:
 179:ConfigDescriptor.c **** 	}
  76               		.loc 1 179 0
  77 0014 81E0      		ldi r24,lo8(1)
 185:ConfigDescriptor.c **** 	}
 186:ConfigDescriptor.c **** }
  78               		.loc 1 186 0
  79 0016 0895      		ret
  80               		.cfi_endproc
  81               	.LFE146:
  83               		.section	.text.ProcessConfigurationDescriptor,"ax",@progbits
  84               	.global	ProcessConfigurationDescriptor
  86               	ProcessConfigurationDescriptor:
  87               	.LFB144:
  49:ConfigDescriptor.c **** 	uint8_t  ConfigDescriptorData[512];
  88               		.loc 1 49 0
  89               		.cfi_startproc
  90 0000 AF92      		push r10
  91               	.LCFI0:
  92               		.cfi_def_cfa_offset 3
  93               		.cfi_offset 10, -2
  94 0002 BF92      		push r11
  95               	.LCFI1:
  96               		.cfi_def_cfa_offset 4
  97               		.cfi_offset 11, -3
  98 0004 CF92      		push r12
  99               	.LCFI2:
 100               		.cfi_def_cfa_offset 5
 101               		.cfi_offset 12, -4
 102 0006 DF92      		push r13
 103               	.LCFI3:
 104               		.cfi_def_cfa_offset 6
 105               		.cfi_offset 13, -5
 106 0008 EF92      		push r14
 107               	.LCFI4:
 108               		.cfi_def_cfa_offset 7
 109               		.cfi_offset 14, -6
 110 000a FF92      		push r15
 111               	.LCFI5:
 112               		.cfi_def_cfa_offset 8
 113               		.cfi_offset 15, -7
 114 000c 0F93      		push r16
 115               	.LCFI6:
 116               		.cfi_def_cfa_offset 9
 117               		.cfi_offset 16, -8
 118 000e 1F93      		push r17
 119               	.LCFI7:
 120               		.cfi_def_cfa_offset 10
 121               		.cfi_offset 17, -9
 122 0010 CF93      		push r28
 123               	.LCFI8:
 124               		.cfi_def_cfa_offset 11
 125               		.cfi_offset 28, -10
 126 0012 DF93      		push r29
 127               	.LCFI9:
 128               		.cfi_def_cfa_offset 12
 129               		.cfi_offset 29, -11
 130 0014 CDB7      		in r28,__SP_L__
 131 0016 DEB7      		in r29,__SP_H__
 132               	.LCFI10:
 133               		.cfi_def_cfa_register 28
 134 0018 C450      		subi r28,4
 135 001a D240      		sbci r29,2
 136               	.LCFI11:
 137               		.cfi_def_cfa_offset 528
 138 001c 0FB6      		in __tmp_reg__,__SREG__
 139 001e F894      		cli
 140 0020 DEBF      		out __SP_H__,r29
 141 0022 0FBE      		out __SREG__,__tmp_reg__
 142 0024 CDBF      		out __SP_L__,r28
 143               	/* prologue: function */
 144               	/* frame size = 516 */
 145               	/* stack size = 526 */
 146               	.L__stack_usage = 526
  51:ConfigDescriptor.c **** 	uint16_t CurrConfigBytesRem;
 147               		.loc 1 51 0
 148 0026 AE01      		movw r20,r28
 149 0028 4F5F      		subi r20,-1
 150 002a 5F4F      		sbci r21,-1
 151 002c CD5F      		subi r28,lo8(-515)
 152 002e DD4F      		sbci r29,hi8(-515)
 153 0030 5983      		std Y+1,r21
 154 0032 4883      		st Y,r20
 155 0034 C350      		subi r28,lo8(515)
 156 0036 D240      		sbci r29,hi8(515)
 157               	.LVL4:
  59:ConfigDescriptor.c **** 	{
 158               		.loc 1 59 0
 159 0038 20E0      		ldi r18,0
 160 003a 32E0      		ldi r19,lo8(2)
 161 003c BE01      		movw r22,r28
 162 003e 6F5F      		subi r22,-1
 163 0040 7D4F      		sbci r23,-3
 164 0042 81E0      		ldi r24,lo8(1)
 165 0044 0E94 0000 		call USB_Host_GetDeviceConfigDescriptor
 166               	.LVL5:
 167 0048 F82E      		mov r15,r24
 168 004a 85E0      		ldi r24,lo8(5)
 169 004c F816      		cp r15,r24
 170 004e 01F0      		breq .L12
 171 0050 E6E0      		ldi r30,lo8(6)
 172 0052 FE16      		cp r15,r30
 173 0054 01F4      		brne .+2
 174 0056 00C0      		rjmp .L24
 175 0058 F110      		cpse r15,__zero_reg__
 176 005a 00C0      		rjmp .L35
 177 005c A12C      		mov r10,__zero_reg__
 178 005e B12C      		mov r11,__zero_reg__
 179 0060 C12C      		mov r12,__zero_reg__
 180 0062 D12C      		mov r13,__zero_reg__
 181 0064 00E0      		ldi r16,0
 182 0066 10E0      		ldi r17,0
 183 0068 00C0      		rjmp .L15
 184               	.L12:
  66:ConfigDescriptor.c **** 		default:
 185               		.loc 1 66 0
 186 006a 22E0      		ldi r18,lo8(2)
 187 006c F22E      		mov r15,r18
 188 006e 00C0      		rjmp .L36
 189               	.L35:
  68:ConfigDescriptor.c **** 	}
 190               		.loc 1 68 0
 191 0070 FF24      		clr r15
 192 0072 F394      		inc r15
 193 0074 00C0      		rjmp .L36
 194               	.LVL6:
 195               	.L20:
 196               	.LBB6:
  74:ConfigDescriptor.c **** 		    USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
 197               		.loc 1 74 0
 198 0076 0115      		cp r16,__zero_reg__
 199 0078 1105      		cpc r17,__zero_reg__
 200 007a 01F0      		breq .L17
 201               	.L23:
  75:ConfigDescriptor.c **** 		                              DComp_NextHIDInterfaceDataEndpoint) != DESCRIPTOR_SEARCH_COMP_Found
 202               		.loc 1 75 0 discriminator 1
 203 007c 40E0      		ldi r20,lo8(gs(DComp_NextHIDInterfaceDataEndpoint))
 204 007e 50E0      		ldi r21,hi8(gs(DComp_NextHIDInterfaceDataEndpoint))
 205 0080 BE01      		movw r22,r28
 206 0082 6D5F      		subi r22,-3
 207 0084 7D4F      		sbci r23,-3
 208 0086 CE01      		movw r24,r28
 209 0088 8F5F      		subi r24,-1
 210 008a 9D4F      		sbci r25,-3
 211 008c 0E94 0000 		call USB_GetNextDescriptorComp
 212               	.LVL7:
  74:ConfigDescriptor.c **** 		    USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
 213               		.loc 1 74 0 discriminator 1
 214 0090 8823      		tst r24
 215 0092 01F4      		brne .+2
 216 0094 00C0      		rjmp .L16
  80:ConfigDescriptor.c **** 			  break;
 217               		.loc 1 80 0
 218 0096 C114      		cp r12,__zero_reg__
 219 0098 D104      		cpc r13,__zero_reg__
 220 009a 01F4      		brne .L22
 221               	.L17:
  84:ConfigDescriptor.c **** 										  DComp_NextHIDInterface) != DESCRIPTOR_SEARCH_COMP_Found)
 222               		.loc 1 84 0
 223 009c 40E0      		ldi r20,lo8(gs(DComp_NextHIDInterface))
 224 009e 50E0      		ldi r21,hi8(gs(DComp_NextHIDInterface))
 225 00a0 BE01      		movw r22,r28
 226 00a2 6D5F      		subi r22,-3
 227 00a4 7D4F      		sbci r23,-3
 228 00a6 CE01      		movw r24,r28
 229 00a8 8F5F      		subi r24,-1
 230 00aa 9D4F      		sbci r25,-3
 231 00ac 0E94 0000 		call USB_GetNextDescriptorComp
 232               	.LVL8:
 233 00b0 8111      		cpse r24,__zero_reg__
 234 00b2 00C0      		rjmp .L25
  92:ConfigDescriptor.c **** 
 235               		.loc 1 92 0
 236 00b4 CD5F      		subi r28,lo8(-515)
 237 00b6 DD4F      		sbci r29,hi8(-515)
 238 00b8 0881      		ld r16,Y
 239 00ba 1981      		ldd r17,Y+1
 240 00bc C350      		subi r28,lo8(515)
 241 00be D240      		sbci r29,hi8(515)
 242               	.LVL9:
  95:ConfigDescriptor.c **** 
 243               		.loc 1 95 0
 244 00c0 A12C      		mov r10,__zero_reg__
 245 00c2 B12C      		mov r11,__zero_reg__
  98:ConfigDescriptor.c **** 		}
 246               		.loc 1 98 0
 247 00c4 E0E0      		ldi r30,0
 248 00c6 F0E0      		ldi r31,0
 249               	.LVL10:
 250               	.L19:
 105:ConfigDescriptor.c **** 		  DataINEndpoint  = EndpointData;
 251               		.loc 1 105 0
 252 00c8 6F01      		movw r12,r30
 253               	.LVL11:
 254               	.L15:
 255               	.LBE6:
  71:ConfigDescriptor.c **** 	{
 256               		.loc 1 71 0
 257 00ca C114      		cp r12,__zero_reg__
 258 00cc D104      		cpc r13,__zero_reg__
 259 00ce 01F0      		breq .L20
  71:ConfigDescriptor.c **** 	{
 260               		.loc 1 71 0 is_stmt 0 discriminator 1
 261 00d0 A114      		cp r10,__zero_reg__
 262 00d2 B104      		cpc r11,__zero_reg__
 263 00d4 01F0      		breq .L21
 264               	.L22:
 112:ConfigDescriptor.c **** 	                   DataINEndpoint->EndpointAddress, DataINEndpoint->EndpointSize, PIPE_BANK_SINGLE
 265               		.loc 1 112 0 is_stmt 1
 266 00d6 F601      		movw r30,r12
 267 00d8 0481      		ldd r16,Z+4
 268 00da 1581      		ldd r17,Z+5
 269               	.LVL12:
 270 00dc E12C      		mov r14,__zero_reg__
 271 00de 2281      		ldd r18,Z+2
 272 00e0 40E1      		ldi r20,lo8(16)
 273 00e2 63E0      		ldi r22,lo8(3)
 274 00e4 81E0      		ldi r24,lo8(1)
 275 00e6 0E94 0000 		call Pipe_ConfigurePipe
 276               	.LVL13:
 114:ConfigDescriptor.c **** 
 277               		.loc 1 114 0
 278 00ea F601      		movw r30,r12
 279 00ec 8681      		ldd r24,Z+6
 280               	.LVL14:
 281               	.LBB7:
 282               	.LBB8:
 283               		.file 2 "../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h"
   1:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
   2:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****              LUFA Library
   3:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   5:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****            www.lufa-lib.org
   7:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
   8:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   9:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
  10:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  12:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  21:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   this software.
  29:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
  30:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  31:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \file
  32:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief USB Pipe definitions for the AVR8 microcontrollers.
  33:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \copydetails Group_PipeManagement_AVR8
  34:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  35:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  38:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  39:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeRW
  40:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeRW_AVR8 Pipe Data Reading and Writing (AVR8)
  41:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe data read/write definitions for the Atmel AVR8 architecture.
  42:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  43:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to p
  44:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  45:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  46:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePrimitiveRW
  47:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePrimitiveRW_AVR8 Read/Write of Primitive Data Types (AVR8)
  48:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe primitive data read/write definitions for the Atmel AVR8 architecture.
  49:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  50:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  51:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  from and to pipes.
  52:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  53:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  54:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePacketManagement
  55:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePacketManagement_AVR8 Pipe Packet Management (AVR8)
  56:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe packet management definitions for the Atmel AVR8 architecture.
  57:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  58:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to packet management of pipes.
  59:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  60:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  61:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeControlReq
  62:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeControlReq_AVR8 Pipe Control Request Management (AVR8)
  63:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe control request management definitions for the Atmel AVR8 architecture.
  64:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  65:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Module for host mode request processing. This module allows for the transmission of standard, c
  66:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  vendor control requests to the default control endpoint of an attached device while in host mod
  67:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  68:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \see Chapter 9 of the USB 2.0 specification.
  69:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  70:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  71:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeManagement
  72:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeManagement_AVR8 Pipe Management (AVR8)
  73:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe management definitions for the Atmel AVR8 architecture.
  74:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  75:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  This module contains functions, macros and enums related to pipe management when in USB Host mo
  76:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  module contains the pipe management macros, as well as pipe interrupt and data send/receive fun
  77:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  for various data types.
  78:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  79:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  @{
  80:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  81:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  82:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #ifndef __PIPE_AVR8_H__
  83:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #define __PIPE_AVR8_H__
  84:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  85:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Includes: */
  86:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../../../../Common/Common.h"
  87:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../USBTask.h"
  88:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  89:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  90:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if defined(__cplusplus)
  91:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			extern "C" {
  92:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  93:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  94:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Preprocessor Checks: */
  95:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  96:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  97:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  98:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  99:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 100:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Macros: */
 101:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Error Flag Masks */
 102:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 103:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an overflow error occurred in the pipe o
 104:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_OVERFLOW         (1 << 6)
 105:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 106:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an underflow error occurred in the pipe 
 107:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_UNDERFLOW        (1 << 5)
 108:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 109:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a CRC error occurred in the pipe on the 
 110:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_CRC16            (1 << 4)
 111:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 112:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware timeout error occurred in the
 113:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_TIMEOUT          (1 << 3)
 114:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 115:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware PID error occurred in the pip
 116:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_PID              (1 << 2)
 117:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 118:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data PID error occurred in th
 119:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATAPID          (1 << 1)
 120:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 121:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data toggle error occurred in
 122:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATATGL          (1 << 0)
 123:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 124:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 125:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Token Masks */
 126:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 127:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a SETUP token (for CONTROL t
 128:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which will trigger a control request on the attached device when data is written to the pipe
 129:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 130:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_SETUP                (0 << PTOKEN0)
 131:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 132:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a IN token (for non-CONTROL 
 133:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from device to host.
 134:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 135:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_IN                   (1 << PTOKEN0)
 136:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 137:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a OUT token (for non-CONTROL
 138:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from host to device.
 139:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 140:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_OUT                  (2 << PTOKEN0)
 141:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 142:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			
 143:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Bank Mode Masks */
 144:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 145:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 146:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have one single bank, which requires less USB FIFO memory but results in slower trans
 147:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  only one USB device (the AVR or the attached device) can access the pipe's bank at the one t
 148:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 149:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_SINGLE                (0 << EPBK0)
 150:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 151:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 152:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have two banks, which requires more USB FIFO memory but results in faster transfers a
 153:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  USB device (the AVR or the attached device) can access one bank while the other accesses the
 154:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  bank.
 155:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 156:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_DOUBLE                (1 << EPBK0)
 157:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 158:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 159:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Default size of the default control pipe's bank, until altered by the Endpoint0Size value
 160:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  in the device descriptor of the attached device.
 161:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 162:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_CONTROLPIPE_DEFAULT_SIZE   64
 163:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 164:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Total number of pipes (including the default control pipe at address 0) which may be used in
 165:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the device. Different USB AVR models support different amounts of pipes, this value reflects
 166:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the maximum number of pipes for the currently selected AVR model.
 167:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 168:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOTAL_PIPES                7
 169:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 170:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Size in bytes of the largest pipe bank size possible in the device. Not all banks on each AV
 171:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  model supports the largest bank size possible on the device; different pipe numbers support
 172:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  different maximum bank sizes. This value reflects the largest possible bank of any pipe on t
 173:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected USB AVR model.
 174:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 175:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_MAX_SIZE                   256
 176:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 177:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Enums: */
 178:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enum for the possible error return codes of the \ref Pipe_WaitUntilReady() function.
 179:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 180:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 181:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 182:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			enum Pipe_WaitUntilReady_ErrorCodes_t
 183:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 184:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_NoError                 = 0, /**< Pipe ready for next packet, no error. */
 185:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_PipeStalled             = 1,	/**< The device stalled the pipe while waiting. */
 186:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host while wa
 187:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_Timeout                 = 3, /**< The device failed to accept or send the next p
 188:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   within the software timeout period set by the
 189:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   \ref USB_STREAM_TIMEOUT_MS macro.
 190:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             */
 191:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			};
 192:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 193:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Inline Functions: */
 194:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Indicates the number of bytes currently stored in the current pipes's selected bank.
 195:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 196:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \note The return width of this function may differ, depending on the maximum pipe bank size
 197:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *        of the selected AVR model.
 198:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 199:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 200:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 201:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
 202:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 203:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 204:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void)
 205:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 206:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return UPBCX;
 207:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 208:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 209:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Returns the pipe address of the currently selected pipe. This is typically used to save the
 210:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected pipe number so that it can be restored after another pipe has been manipu
 211:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 212:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Index of the currently selected pipe.
 213:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 214:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 215:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void)
 216:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 217:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPNUM & PIPE_PIPENUM_MASK);
 218:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 219:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 220:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Selects the given pipe number. Any pipe operations which do not require the pipe number to b
 221:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicated will operate on the currently selected pipe.
 222:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 223:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to select.
 224:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 225:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 226:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
 227:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 228:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPNUM = PipeNumber;
 229:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 230:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 231:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Resets the desired pipe, including the pipe banks and flags.
 232:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 233:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to reset.
 234:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 235:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 236:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber)
 237:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 238:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = (1 << PipeNumber);
 239:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = 0;
 240:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 241:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 242:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enables the currently selected pipe so that data can be sent and received through it to and 
 243:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  an attached device.
 244:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 245:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePi
 246:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 247:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
 248:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void)
 249:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 250:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << PEN);
 251:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 252:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 253:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Disables the currently selected pipe so that data cannot be sent and received through it to 
 254:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  from an attached device.
 255:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 256:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
 257:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void)
 258:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 259:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << PEN);
 260:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 261:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 262:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is enabled, but not necessarily configured.
 263:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 264:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 * \return Boolean \c true if the currently selected pipe is enabled, \c false otherwise.
 265:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 266:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 267:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void)
 268:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 269:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPCONX & (1 << PEN)) ? true : false);
 270:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 271:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 272:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Gets the current pipe token, indicating the pipe's data direction and type.
 273:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 274:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
 275:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 276:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 277:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void)
 278:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 279:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPCFG0X & (0x03 << PTOKEN0));
 280:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 281:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 282:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the token for the currently selected pipe to one of the tokens specified by the \c PIPE
 283:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  masks. This can be used on CONTROL type pipes, to allow for bidirectional transfer of data d
 284:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  control requests, or on regular pipes to allow for half-duplex bidirectional data transfer t
 285:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which have two endpoints of opposite direction sharing the same endpoint address within the 
 286:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 287:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
 288:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 289:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
 290:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token)
 291:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 292:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
 293:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 294:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 295:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
 296:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
 297:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void)
 298:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 299:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << INMODE);
 300:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 301:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 302:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to only allow the specified number of IN requests to 
 303:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  accepted by the pipe before it is automatically frozen.
 304:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 305:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] TotalINRequests  Total number of IN requests that the pipe may receive before fre
 306:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 307:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests) ATTR_ALWAYS_INLINE;
 308:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests)
 309:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 310:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << INMODE);
 311:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINRQX = TotalINRequests;
 312:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 313:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 314:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is configured.
 315:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 316:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
 317:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 318:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 319:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void)
 320:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 321:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPSTAX & (1 << CFGOK)) ? true : false);
 322:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 323:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 324:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Retrieves the endpoint address of the endpoint within the attached device that the currently
 325:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipe is bound to.
 326:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 327:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Endpoint address the currently selected pipe is bound to.
 328:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 329:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INL
 330:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
 331:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 332:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
 333:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 334:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 335:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 336:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the period between interrupts for an INTERRUPT type pipe to a specified number of milli
 337:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 338:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Milliseconds  Number of milliseconds between each pipe poll.
 339:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 340:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds) ATTR_ALWAYS_INLINE;
 341:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds)
 342:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 343:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG2X = Milliseconds;
 284               		.loc 2 343 0
 285 00ee 8093 AD00 		sts 173,r24
 286               	.LVL15:
 287               	.LBE8:
 288               	.LBE7:
 117:ConfigDescriptor.c **** 	{
 289               		.loc 1 117 0
 290 00f2 A114      		cp r10,__zero_reg__
 291 00f4 B104      		cpc r11,__zero_reg__
 292 00f6 01F0      		breq .L36
 120:ConfigDescriptor.c **** 						   DataOUTEndpoint->EndpointAddress, DataOUTEndpoint->EndpointSize, PIPE_BANK_SINGLE);
 293               		.loc 1 120 0
 294 00f8 F501      		movw r30,r10
 295 00fa 0481      		ldd r16,Z+4
 296 00fc 1581      		ldd r17,Z+5
 297 00fe E12C      		mov r14,__zero_reg__
 298 0100 2281      		ldd r18,Z+2
 299 0102 40E2      		ldi r20,lo8(32)
 300 0104 63E0      		ldi r22,lo8(3)
 301 0106 82E0      		ldi r24,lo8(2)
 302 0108 0E94 0000 		call Pipe_ConfigurePipe
 303               	.LVL16:
 304 010c 00C0      		rjmp .L36
 305               	.LVL17:
 306               	.L24:
  64:ConfigDescriptor.c **** 		case HOST_GETCONFIG_BuffOverflow:
 307               		.loc 1 64 0
 308 010e 93E0      		ldi r25,lo8(3)
 309 0110 F92E      		mov r15,r25
 310 0112 00C0      		rjmp .L36
 311               	.LVL18:
 312               	.L16:
 313               	.LBB9:
 102:ConfigDescriptor.c **** 
 314               		.loc 1 102 0
 315 0114 CD5F      		subi r28,lo8(-515)
 316 0116 DD4F      		sbci r29,hi8(-515)
 317 0118 E881      		ld r30,Y
 318 011a F981      		ldd r31,Y+1
 319 011c C350      		subi r28,lo8(515)
 320 011e D240      		sbci r29,hi8(515)
 321               	.LVL19:
 105:ConfigDescriptor.c **** 		  DataINEndpoint  = EndpointData;
 322               		.loc 1 105 0
 323 0120 8281      		ldd r24,Z+2
 324 0122 87FD      		sbrc r24,7
 325 0124 00C0      		rjmp .L19
 108:ConfigDescriptor.c **** 	}
 326               		.loc 1 108 0
 327 0126 5F01      		movw r10,r30
 328               	.LVL20:
 105:ConfigDescriptor.c **** 		  DataINEndpoint  = EndpointData;
 329               		.loc 1 105 0
 330 0128 F601      		movw r30,r12
 331               	.LVL21:
 332 012a 00C0      		rjmp .L19
 333               	.LVL22:
 334               	.L25:
  88:ConfigDescriptor.c **** 			}
 335               		.loc 1 88 0
 336 012c 84E0      		ldi r24,lo8(4)
 337 012e F82E      		mov r15,r24
 338 0130 00C0      		rjmp .L36
 339               	.L21:
  74:ConfigDescriptor.c **** 		    USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
 340               		.loc 1 74 0
 341 0132 0115      		cp r16,__zero_reg__
 342 0134 1105      		cpc r17,__zero_reg__
 343 0136 01F0      		breq .+2
 344 0138 00C0      		rjmp .L23
 345 013a 00C0      		rjmp .L22
 346               	.LVL23:
 347               	.L36:
 348               	.LBE9:
 126:ConfigDescriptor.c **** 
 349               		.loc 1 126 0
 350 013c 8F2D      		mov r24,r15
 351               	/* epilogue start */
 352 013e CC5F      		subi r28,-4
 353 0140 DD4F      		sbci r29,-3
 354 0142 0FB6      		in __tmp_reg__,__SREG__
 355 0144 F894      		cli
 356 0146 DEBF      		out __SP_H__,r29
 357 0148 0FBE      		out __SREG__,__tmp_reg__
 358 014a CDBF      		out __SP_L__,r28
 359 014c DF91      		pop r29
 360 014e CF91      		pop r28
 361 0150 1F91      		pop r17
 362 0152 0F91      		pop r16
 363 0154 FF90      		pop r15
 364 0156 EF90      		pop r14
 365 0158 DF90      		pop r13
 366 015a CF90      		pop r12
 367 015c BF90      		pop r11
 368 015e AF90      		pop r10
 369 0160 0895      		ret
 370               		.cfi_endproc
 371               	.LFE144:
 373               		.text
 374               	.Letext0:
 375               		.file 3 "/usr/lib/avr/include/stdint.h"
 376               		.file 4 "../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../StdDescriptors.h"
 377               		.file 5 "../../LUFA/Drivers/USB/Core/ConfigDescriptor.h"
 378               		.file 6 "ConfigDescriptor.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ConfigDescriptor.c
     /tmp/ccinkoSO.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccinkoSO.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccinkoSO.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccinkoSO.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccinkoSO.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccinkoSO.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccinkoSO.s:14     .text.DComp_NextHIDInterface:0000000000000000 DComp_NextHIDInterface
     /tmp/ccinkoSO.s:50     .text.DComp_NextHIDInterfaceDataEndpoint:0000000000000000 DComp_NextHIDInterfaceDataEndpoint
     /tmp/ccinkoSO.s:86     .text.ProcessConfigurationDescriptor:0000000000000000 ProcessConfigurationDescriptor

UNDEFINED SYMBOLS
USB_Host_GetDeviceConfigDescriptor
USB_GetNextDescriptorComp
Pipe_ConfigurePipe
