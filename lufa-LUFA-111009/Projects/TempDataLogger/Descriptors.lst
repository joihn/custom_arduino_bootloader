   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB139:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /* On some devices, there is a factory set internal serial number which can be automatically sent t
  41:Descriptors.c ****  * the device's serial number when the Device Descriptor's .SerialNumStrIndex entry is set to USE_I
  42:Descriptors.c ****  * This allows the host to track a device across insertions on different ports, allowing them to re
  43:Descriptors.c ****  * resources like COM port numbers and drivers. On demos using this feature, give a warning on unsu
  44:Descriptors.c ****  * so that the user can supply their own serial number descriptor instead or remove the USE_INTERNA
  45:Descriptors.c ****  * from the Device Descriptor (forcing the host to generate a serial number for each device from th
  46:Descriptors.c ****  * port location).
  47:Descriptors.c ****  */
  48:Descriptors.c **** #if (USE_INTERNAL_SERIAL == NO_DESCRIPTOR)
  49:Descriptors.c **** 	#warning USE_INTERNAL_SERIAL is not available on this AVR - please manually construct a device ser
  50:Descriptors.c **** #endif
  51:Descriptors.c **** 
  52:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  53:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  54:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  55:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  56:Descriptors.c ****  *  more details on HID report descriptors.
  57:Descriptors.c ****  */
  58:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM GenericReport[] =
  59:Descriptors.c **** {
  60:Descriptors.c **** 	/* Use the HID class driver's standard Vendor HID report.
  61:Descriptors.c **** 	 *  Vendor Usage Page: 1
  62:Descriptors.c **** 	 *  Vendor Collection Usage: 1
  63:Descriptors.c **** 	 *  Vendor Report IN Usage: 2
  64:Descriptors.c **** 	 *  Vendor Report OUT Usage: 3
  65:Descriptors.c **** 	 *  Vendor Report Size: GENERIC_REPORT_SIZE
  66:Descriptors.c **** 	 */
  67:Descriptors.c **** 	HID_DESCRIPTOR_VENDOR(0x00, 0x01, 0x02, 0x03, GENERIC_REPORT_SIZE)
  68:Descriptors.c **** };
  69:Descriptors.c **** 
  70:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  71:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  72:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  73:Descriptors.c ****  *  process begins.
  74:Descriptors.c ****  */
  75:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  76:Descriptors.c **** {
  77:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  78:Descriptors.c **** 
  79:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  80:Descriptors.c **** 	.Class                  = USB_CSCP_NoDeviceClass,
  81:Descriptors.c **** 	.SubClass               = USB_CSCP_NoDeviceSubclass,
  82:Descriptors.c **** 	.Protocol               = USB_CSCP_NoDeviceProtocol,
  83:Descriptors.c **** 
  84:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  85:Descriptors.c **** 
  86:Descriptors.c **** 	.VendorID               = 0x03EB,
  87:Descriptors.c **** 	.ProductID              = 0x2063,
  88:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
  89:Descriptors.c **** 
  90:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
  91:Descriptors.c **** 	.ProductStrIndex        = 0x02,
  92:Descriptors.c **** 	.SerialNumStrIndex      = USE_INTERNAL_SERIAL,
  93:Descriptors.c **** 
  94:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  95:Descriptors.c **** };
  96:Descriptors.c **** 
  97:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
  98:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
  99:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 100:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 101:Descriptors.c ****  */
 102:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
 103:Descriptors.c **** {
 104:Descriptors.c **** 	.Config =
 105:Descriptors.c **** 		{
 106:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 107:Descriptors.c **** 
 108:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 109:Descriptors.c **** 			.TotalInterfaces        = 2,
 110:Descriptors.c **** 
 111:Descriptors.c **** 			.ConfigurationNumber    = 1,
 112:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 113:Descriptors.c **** 
 114:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 115:Descriptors.c **** 
 116:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 117:Descriptors.c **** 		},
 118:Descriptors.c **** 
 119:Descriptors.c **** 	.MS_Interface =
 120:Descriptors.c **** 		{
 121:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 122:Descriptors.c **** 
 123:Descriptors.c **** 			.InterfaceNumber        = 0,
 124:Descriptors.c **** 			.AlternateSetting       = 0,
 125:Descriptors.c **** 
 126:Descriptors.c **** 			.TotalEndpoints         = 2,
 127:Descriptors.c **** 
 128:Descriptors.c **** 			.Class                  = MS_CSCP_MassStorageClass,
 129:Descriptors.c **** 			.SubClass               = MS_CSCP_SCSITransparentSubclass,
 130:Descriptors.c **** 			.Protocol               = MS_CSCP_BulkOnlyTransportProtocol,
 131:Descriptors.c **** 
 132:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 133:Descriptors.c **** 		},
 134:Descriptors.c **** 
 135:Descriptors.c **** 	.MS_DataInEndpoint =
 136:Descriptors.c **** 		{
 137:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 138:Descriptors.c **** 
 139:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | MASS_STORAGE_IN_EPNUM),
 140:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 141:Descriptors.c **** 			.EndpointSize           = MASS_STORAGE_IO_EPSIZE,
 142:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 143:Descriptors.c **** 		},
 144:Descriptors.c **** 
 145:Descriptors.c **** 	.MS_DataOutEndpoint =
 146:Descriptors.c **** 		{
 147:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 148:Descriptors.c **** 
 149:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | MASS_STORAGE_OUT_EPNUM),
 150:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 151:Descriptors.c **** 			.EndpointSize           = MASS_STORAGE_IO_EPSIZE,
 152:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 153:Descriptors.c **** 		},
 154:Descriptors.c **** 
 155:Descriptors.c **** 	.HID_Interface =
 156:Descriptors.c **** 		{
 157:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 158:Descriptors.c **** 
 159:Descriptors.c **** 			.InterfaceNumber        = 1,
 160:Descriptors.c **** 			.AlternateSetting       = 0,
 161:Descriptors.c **** 
 162:Descriptors.c **** 			.TotalEndpoints         = 1,
 163:Descriptors.c **** 
 164:Descriptors.c **** 			.Class                  = HID_CSCP_HIDClass,
 165:Descriptors.c **** 			.SubClass               = HID_CSCP_NonBootSubclass,
 166:Descriptors.c **** 			.Protocol               = HID_CSCP_NonBootProtocol,
 167:Descriptors.c **** 
 168:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 169:Descriptors.c **** 		},
 170:Descriptors.c **** 
 171:Descriptors.c **** 	.HID_GenericHID =
 172:Descriptors.c **** 		{
 173:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_HID_t), .Type = HID_DTYPE_HID},
 174:Descriptors.c **** 
 175:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 176:Descriptors.c **** 			.CountryCode            = 0x00,
 177:Descriptors.c **** 			.TotalReportDescriptors = 1,
 178:Descriptors.c **** 			.HIDReportType          = HID_DTYPE_Report,
 179:Descriptors.c **** 			.HIDReportLength        = sizeof(GenericReport)
 180:Descriptors.c **** 		},
 181:Descriptors.c **** 
 182:Descriptors.c **** 	.HID_ReportINEndpoint =
 183:Descriptors.c **** 		{
 184:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 185:Descriptors.c **** 
 186:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | GENERIC_IN_EPNUM),
 187:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 188:Descriptors.c **** 			.EndpointSize           = GENERIC_EPSIZE,
 189:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 190:Descriptors.c **** 		},
 191:Descriptors.c **** };
 192:Descriptors.c **** 
 193:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 194:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 195:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 196:Descriptors.c ****  */
 197:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 198:Descriptors.c **** {
 199:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 200:Descriptors.c **** 
 201:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 202:Descriptors.c **** };
 203:Descriptors.c **** 
 204:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 205:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 206:Descriptors.c ****  *  Descriptor.
 207:Descriptors.c ****  */
 208:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 209:Descriptors.c **** {
 210:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(11), .Type = DTYPE_String},
 211:Descriptors.c **** 
 212:Descriptors.c **** 	.UnicodeString          = L"Dean Camera"
 213:Descriptors.c **** };
 214:Descriptors.c **** 
 215:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 216:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 217:Descriptors.c ****  *  Descriptor.
 218:Descriptors.c ****  */
 219:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 220:Descriptors.c **** {
 221:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(22), .Type = DTYPE_String},
 222:Descriptors.c **** 
 223:Descriptors.c **** 	.UnicodeString          = L"Temperature Datalogger"
 224:Descriptors.c **** };
 225:Descriptors.c **** 
 226:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 227:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 228:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 229:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 230:Descriptors.c ****  *  USB host.
 231:Descriptors.c ****  */
 232:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 233:Descriptors.c ****                                     const uint8_t wIndex,
 234:Descriptors.c ****                                     const void** const DescriptorAddress)
 235:Descriptors.c **** {
  17               		.loc 1 235 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 236:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 237:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 238:Descriptors.c **** 
 239:Descriptors.c **** 	const void* Address = NULL;
 240:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 241:Descriptors.c **** 
 242:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 242 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2330      		cpi r18,3
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 00F4      		brsh .L4
  31 000c 2130      		cpi r18,1
  32 000e 3105      		cpc r19,__zero_reg__
  33 0010 01F0      		breq .L5
  34 0012 2230      		cpi r18,2
  35 0014 3105      		cpc r19,__zero_reg__
  36 0016 01F4      		brne .L14
  37               	.LVL1:
 243:Descriptors.c **** 	{
 244:Descriptors.c **** 		case DTYPE_Device:
 245:Descriptors.c **** 			Address = &DeviceDescriptor;
 246:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 247:Descriptors.c **** 			break;
 248:Descriptors.c **** 		case DTYPE_Configuration:
 249:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 250:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  38               		.loc 1 250 0
  39 0018 89E3      		ldi r24,lo8(57)
  40 001a 90E0      		ldi r25,0
  41               	.LVL2:
 249:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  42               		.loc 1 249 0
  43 001c 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  44 001e 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 251:Descriptors.c **** 			break;
  45               		.loc 1 251 0
  46 0020 00C0      		rjmp .L2
  47               	.LVL3:
  48               	.L4:
 242:Descriptors.c **** 	{
  49               		.loc 1 242 0
  50 0022 2132      		cpi r18,33
  51 0024 3105      		cpc r19,__zero_reg__
  52 0026 01F0      		breq .L7
  53 0028 2232      		cpi r18,34
  54 002a 3105      		cpc r19,__zero_reg__
  55 002c 01F4      		brne .L14
  56               	.LVL4:
 252:Descriptors.c **** 		case DTYPE_String:
 253:Descriptors.c **** 			switch (DescriptorNumber)
 254:Descriptors.c **** 			{
 255:Descriptors.c **** 				case 0x00:
 256:Descriptors.c **** 					Address = &LanguageString;
 257:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 258:Descriptors.c **** 					break;
 259:Descriptors.c **** 				case 0x01:
 260:Descriptors.c **** 					Address = &ManufacturerString;
 261:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 262:Descriptors.c **** 					break;
 263:Descriptors.c **** 				case 0x02:
 264:Descriptors.c **** 					Address = &ProductString;
 265:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 266:Descriptors.c **** 					break;
 267:Descriptors.c **** 			}
 268:Descriptors.c **** 
 269:Descriptors.c **** 			break;
 270:Descriptors.c **** 		case HID_DTYPE_HID:
 271:Descriptors.c **** 			Address = &ConfigurationDescriptor.HID_GenericHID;
 272:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);
 273:Descriptors.c **** 			break;
 274:Descriptors.c **** 		case HID_DTYPE_Report:
 275:Descriptors.c **** 			Address = &GenericReport;
 276:Descriptors.c **** 			Size    = sizeof(GenericReport);
  57               		.loc 1 276 0
  58 002e 80E2      		ldi r24,lo8(32)
  59 0030 90E0      		ldi r25,0
  60               	.LVL5:
 275:Descriptors.c **** 			Size    = sizeof(GenericReport);
  61               		.loc 1 275 0
  62 0032 20E0      		ldi r18,lo8(GenericReport)
  63 0034 30E0      		ldi r19,hi8(GenericReport)
 277:Descriptors.c **** 			break;
  64               		.loc 1 277 0
  65 0036 00C0      		rjmp .L2
  66               	.LVL6:
  67               	.L5:
 246:Descriptors.c **** 			break;
  68               		.loc 1 246 0
  69 0038 82E1      		ldi r24,lo8(18)
  70 003a 90E0      		ldi r25,0
  71               	.LVL7:
 245:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  72               		.loc 1 245 0
  73 003c 20E0      		ldi r18,lo8(DeviceDescriptor)
  74 003e 30E0      		ldi r19,hi8(DeviceDescriptor)
  75 0040 00C0      		rjmp .L2
  76               	.LVL8:
  77               	.L3:
 253:Descriptors.c **** 			{
  78               		.loc 1 253 0
  79 0042 9927      		clr r25
  80               	.LVL9:
  81 0044 8130      		cpi r24,1
  82 0046 9105      		cpc r25,__zero_reg__
  83 0048 01F0      		breq .L9
  84 004a 00F0      		brlo .L10
  85 004c 0297      		sbiw r24,2
  86 004e 01F4      		brne .L14
  87               	.LVL10:
  88               	.LBB2:
 265:Descriptors.c **** 					break;
  89               		.loc 1 265 0
  90 0050 E0E0      		ldi r30,lo8(ProductString)
  91 0052 F0E0      		ldi r31,hi8(ProductString)
  92 0054 00C0      		rjmp .L15
  93               	.LVL11:
  94               	.L10:
  95               	.LBE2:
  96               	.LBB3:
 257:Descriptors.c **** 					break;
  97               		.loc 1 257 0
  98 0056 E0E0      		ldi r30,lo8(LanguageString)
  99 0058 F0E0      		ldi r31,hi8(LanguageString)
 100 005a 00C0      		rjmp .L15
 101               	.LVL12:
 102               	.L9:
 103               	.LBE3:
 104               	.LBB4:
 261:Descriptors.c **** 					break;
 105               		.loc 1 261 0
 106 005c E0E0      		ldi r30,lo8(ManufacturerString)
 107 005e F0E0      		ldi r31,hi8(ManufacturerString)
 108               	.LVL13:
 109               	.L15:
 110               	.LBE4:
 111               	.LBB5:
 265:Descriptors.c **** 					break;
 112               		.loc 1 265 0
 113               	/* #APP */
 114               	 ;  265 "Descriptors.c" 1
 115 0060 8491      		lpm r24, Z
 116               		
 117               	 ;  0 "" 2
 118               	.LVL14:
 119               	/* #NOAPP */
 120               	.LBE5:
 121 0062 90E0      		ldi r25,0
 122               	.LVL15:
 264:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 123               		.loc 1 264 0
 124 0064 9F01      		movw r18,r30
 266:Descriptors.c **** 			}
 125               		.loc 1 266 0
 126 0066 00C0      		rjmp .L2
 127               	.LVL16:
 128               	.L7:
 272:Descriptors.c **** 			break;
 129               		.loc 1 272 0
 130 0068 89E0      		ldi r24,lo8(9)
 131 006a 90E0      		ldi r25,0
 132               	.LVL17:
 271:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);
 133               		.loc 1 271 0
 134 006c 20E0      		ldi r18,lo8(ConfigurationDescriptor+41)
 135 006e 30E0      		ldi r19,hi8(ConfigurationDescriptor+41)
 136               	.LVL18:
 273:Descriptors.c **** 		case HID_DTYPE_Report:
 137               		.loc 1 273 0
 138 0070 00C0      		rjmp .L2
 139               	.LVL19:
 140               	.L14:
 240:Descriptors.c **** 
 141               		.loc 1 240 0
 142 0072 80E0      		ldi r24,0
 143 0074 90E0      		ldi r25,0
 239:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 144               		.loc 1 239 0
 145 0076 20E0      		ldi r18,0
 146 0078 30E0      		ldi r19,0
 147               	.LVL20:
 148               	.L2:
 278:Descriptors.c **** 	}
 279:Descriptors.c **** 
 280:Descriptors.c **** 	*DescriptorAddress = Address;
 149               		.loc 1 280 0
 150 007a FA01      		movw r30,r20
 151 007c 3183      		std Z+1,r19
 152 007e 2083      		st Z,r18
 281:Descriptors.c **** 	return Size;
 282:Descriptors.c **** }
 153               		.loc 1 282 0
 154 0080 0895      		ret
 155               		.cfi_endproc
 156               	.LFE139:
 158               	.global	ProductString
 159               		.section	.progmem.data,"a",@progbits
 162               	ProductString:
 163 0000 2E        		.byte	46
 164 0001 03        		.byte	3
 165 0002 5400      		.string	"T"
 166 0004 6500      		.string	"e"
 167 0006 6D00      		.string	"m"
 168 0008 7000      		.string	"p"
 169 000a 6500      		.string	"e"
 170 000c 7200      		.string	"r"
 171 000e 6100      		.string	"a"
 172 0010 7400      		.string	"t"
 173 0012 7500      		.string	"u"
 174 0014 7200      		.string	"r"
 175 0016 6500      		.string	"e"
 176 0018 2000      		.string	" "
 177 001a 4400      		.string	"D"
 178 001c 6100      		.string	"a"
 179 001e 7400      		.string	"t"
 180 0020 6100      		.string	"a"
 181 0022 6C00      		.string	"l"
 182 0024 6F00      		.string	"o"
 183 0026 6700      		.string	"g"
 184 0028 6700      		.string	"g"
 185 002a 6500      		.string	"e"
 186 002c 7200      		.string	"r"
 187 002e 00        		.string	""
 188 002f 00        		.string	""
 189               	.global	ManufacturerString
 192               	ManufacturerString:
 193 0030 18        		.byte	24
 194 0031 03        		.byte	3
 195 0032 4400      		.string	"D"
 196 0034 6500      		.string	"e"
 197 0036 6100      		.string	"a"
 198 0038 6E00      		.string	"n"
 199 003a 2000      		.string	" "
 200 003c 4300      		.string	"C"
 201 003e 6100      		.string	"a"
 202 0040 6D00      		.string	"m"
 203 0042 6500      		.string	"e"
 204 0044 7200      		.string	"r"
 205 0046 6100      		.string	"a"
 206 0048 00        		.string	""
 207 0049 00        		.string	""
 208               	.global	LanguageString
 211               	LanguageString:
 212 004a 04        		.byte	4
 213 004b 03        		.byte	3
 214 004c 0904      		.word	1033
 215               	.global	ConfigurationDescriptor
 218               	ConfigurationDescriptor:
 219 004e 09        		.byte	9
 220 004f 02        		.byte	2
 221 0050 3900      		.word	57
 222 0052 02        		.byte	2
 223 0053 01        		.byte	1
 224 0054 00        		.byte	0
 225 0055 C0        		.byte	-64
 226 0056 32        		.byte	50
 227 0057 09        		.byte	9
 228 0058 04        		.byte	4
 229 0059 00        		.byte	0
 230 005a 00        		.byte	0
 231 005b 02        		.byte	2
 232 005c 08        		.byte	8
 233 005d 06        		.byte	6
 234 005e 50        		.byte	80
 235 005f 00        		.byte	0
 236 0060 07        		.byte	7
 237 0061 05        		.byte	5
 238 0062 83        		.byte	-125
 239 0063 02        		.byte	2
 240 0064 4000      		.word	64
 241 0066 01        		.byte	1
 242 0067 07        		.byte	7
 243 0068 05        		.byte	5
 244 0069 04        		.byte	4
 245 006a 02        		.byte	2
 246 006b 4000      		.word	64
 247 006d 01        		.byte	1
 248 006e 09        		.byte	9
 249 006f 04        		.byte	4
 250 0070 01        		.byte	1
 251 0071 00        		.byte	0
 252 0072 01        		.byte	1
 253 0073 03        		.byte	3
 254 0074 00        		.byte	0
 255 0075 00        		.byte	0
 256 0076 00        		.byte	0
 257 0077 09        		.byte	9
 258 0078 21        		.byte	33
 259 0079 1101      		.word	273
 260 007b 00        		.byte	0
 261 007c 01        		.byte	1
 262 007d 22        		.byte	34
 263 007e 2000      		.word	32
 264 0080 07        		.byte	7
 265 0081 05        		.byte	5
 266 0082 81        		.byte	-127
 267 0083 03        		.byte	3
 268 0084 1000      		.word	16
 269 0086 01        		.byte	1
 270               	.global	DeviceDescriptor
 273               	DeviceDescriptor:
 274 0087 12        		.byte	18
 275 0088 01        		.byte	1
 276 0089 1001      		.word	272
 277 008b 00        		.byte	0
 278 008c 00        		.byte	0
 279 008d 00        		.byte	0
 280 008e 08        		.byte	8
 281 008f EB03      		.word	1003
 282 0091 6320      		.word	8291
 283 0093 0100      		.word	1
 284 0095 01        		.byte	1
 285 0096 02        		.byte	2
 286 0097 DC        		.byte	-36
 287 0098 01        		.byte	1
 288               	.global	GenericReport
 291               	GenericReport:
 292 0099 06        		.byte	6
 293 009a 00        		.byte	0
 294 009b FF        		.byte	-1
 295 009c 09        		.byte	9
 296 009d 01        		.byte	1
 297 009e A1        		.byte	-95
 298 009f 01        		.byte	1
 299 00a0 09        		.byte	9
 300 00a1 02        		.byte	2
 301 00a2 15        		.byte	21
 302 00a3 00        		.byte	0
 303 00a4 25        		.byte	37
 304 00a5 FF        		.byte	-1
 305 00a6 75        		.byte	117
 306 00a7 08        		.byte	8
 307 00a8 95        		.byte	-107
 308 00a9 07        		.byte	7
 309 00aa 81        		.byte	-127
 310 00ab 02        		.byte	2
 311 00ac 09        		.byte	9
 312 00ad 03        		.byte	3
 313 00ae 15        		.byte	21
 314 00af 00        		.byte	0
 315 00b0 25        		.byte	37
 316 00b1 FF        		.byte	-1
 317 00b2 75        		.byte	117
 318 00b3 08        		.byte	8
 319 00b4 95        		.byte	-107
 320 00b5 07        		.byte	7
 321 00b6 91        		.byte	-111
 322 00b7 02        		.byte	2
 323 00b8 C0        		.byte	-64
 324               		.text
 325               	.Letext0:
 326               		.file 2 "/usr/lib/avr/include/stdint.h"
 327               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 328               		.file 4 "../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 329               		.file 5 "../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 330               		.file 6 "../../LUFA/Drivers/USB/Class/Device/../Common/MassStorage.h"
 331               		.file 7 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/cc74fY7o.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc74fY7o.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc74fY7o.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc74fY7o.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc74fY7o.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc74fY7o.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc74fY7o.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/cc74fY7o.s:218    .progmem.data:000000000000004e ConfigurationDescriptor
     /tmp/cc74fY7o.s:291    .progmem.data:0000000000000099 GenericReport
     /tmp/cc74fY7o.s:273    .progmem.data:0000000000000087 DeviceDescriptor
     /tmp/cc74fY7o.s:162    .progmem.data:0000000000000000 ProductString
     /tmp/cc74fY7o.s:211    .progmem.data:000000000000004a LanguageString
     /tmp/cc74fY7o.s:192    .progmem.data:0000000000000030 ManufacturerString

NO UNDEFINED SYMBOLS
