   1               		.file	"Ethernet.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.Ethernet_ProcessPacket,"ax",@progbits
  12               	.global	Ethernet_ProcessPacket
  14               	Ethernet_ProcessPacket:
  15               	.LFB104:
  16               		.file 1 "Lib/Ethernet.c"
   1:Lib/Ethernet.c **** /*
   2:Lib/Ethernet.c ****              LUFA Library
   3:Lib/Ethernet.c ****      Copyright (C) Dean Camera, 2011.
   4:Lib/Ethernet.c **** 
   5:Lib/Ethernet.c ****   dean [at] fourwalledcubicle [dot] com
   6:Lib/Ethernet.c ****            www.lufa-lib.org
   7:Lib/Ethernet.c **** */
   8:Lib/Ethernet.c **** 
   9:Lib/Ethernet.c **** /*
  10:Lib/Ethernet.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Lib/Ethernet.c **** 
  12:Lib/Ethernet.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Lib/Ethernet.c ****   software and its documentation for any purpose is hereby granted
  14:Lib/Ethernet.c ****   without fee, provided that the above copyright notice appear in
  15:Lib/Ethernet.c ****   all copies and that both that the copyright notice and this
  16:Lib/Ethernet.c ****   permission notice and warranty disclaimer appear in supporting
  17:Lib/Ethernet.c ****   documentation, and that the name of the author not be used in
  18:Lib/Ethernet.c ****   advertising or publicity pertaining to distribution of the
  19:Lib/Ethernet.c ****   software without specific, written prior permission.
  20:Lib/Ethernet.c **** 
  21:Lib/Ethernet.c ****   The author disclaim all warranties with regard to this
  22:Lib/Ethernet.c ****   software, including all implied warranties of merchantability
  23:Lib/Ethernet.c ****   and fitness.  In no event shall the author be liable for any
  24:Lib/Ethernet.c ****   special, indirect or consequential damages or any damages
  25:Lib/Ethernet.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Lib/Ethernet.c ****   in an action of contract, negligence or other tortious action,
  27:Lib/Ethernet.c ****   arising out of or in connection with the use or performance of
  28:Lib/Ethernet.c ****   this software.
  29:Lib/Ethernet.c **** */
  30:Lib/Ethernet.c **** 
  31:Lib/Ethernet.c **** /** \file
  32:Lib/Ethernet.c ****  *
  33:Lib/Ethernet.c ****  *  Ethernet frame packet handling routines. This protocol handles the processing of raw Ethernet
  34:Lib/Ethernet.c ****  *  frames sent and received, deferring the processing of sub-packet protocols to the appropriate
  35:Lib/Ethernet.c ****  *  protocol handlers, such as DHCP or ARP.
  36:Lib/Ethernet.c ****  */
  37:Lib/Ethernet.c **** 
  38:Lib/Ethernet.c **** #include "Ethernet.h"
  39:Lib/Ethernet.c **** 
  40:Lib/Ethernet.c **** /** Constant for convenience when checking against or setting a MAC address to the virtual server M
  41:Lib/Ethernet.c **** const MAC_Address_t ServerMACAddress    = {SERVER_MAC_ADDRESS};
  42:Lib/Ethernet.c **** 
  43:Lib/Ethernet.c **** /** Constant for convenience when checking against or setting an IP address to the virtual server I
  44:Lib/Ethernet.c **** const IP_Address_t  ServerIPAddress     = {SERVER_IP_ADDRESS};
  45:Lib/Ethernet.c **** 
  46:Lib/Ethernet.c **** /** Constant for convenience when checking against or setting a MAC address to the broadcast MAC ad
  47:Lib/Ethernet.c **** const MAC_Address_t BroadcastMACAddress = {BROADCAST_MAC_ADDRESS};
  48:Lib/Ethernet.c **** 
  49:Lib/Ethernet.c **** /** Constant for convenience when checking against or setting a IP address to the broadcast IP addr
  50:Lib/Ethernet.c **** const IP_Address_t  BroadcastIPAddress  = {BROADCAST_IP_ADDRESS};
  51:Lib/Ethernet.c **** 
  52:Lib/Ethernet.c **** /** Constant for convenience when checking against or setting an IP address to the client (host) IP
  53:Lib/Ethernet.c **** const IP_Address_t  ClientIPAddress     = {CLIENT_IP_ADDRESS};
  54:Lib/Ethernet.c **** 
  55:Lib/Ethernet.c **** 
  56:Lib/Ethernet.c **** /** Processes an incoming Ethernet frame, and writes the appropriate response to the output Etherne
  57:Lib/Ethernet.c ****  *  frame buffer if the sub protocol handlers create a valid response.
  58:Lib/Ethernet.c ****  */
  59:Lib/Ethernet.c **** void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
  60:Lib/Ethernet.c ****                             Ethernet_Frame_Info_t* const FrameOUT)
  61:Lib/Ethernet.c **** {
  17               		.loc 1 61 0
  18               		.cfi_startproc
  19               	.LVL0:
  20 0000 EF92      		push r14
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 14, -2
  24 0002 FF92      		push r15
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 15, -3
  28 0004 0F93      		push r16
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 16, -4
  32 0006 1F93      		push r17
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 17, -5
  36 0008 CF93      		push r28
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 28, -6
  40 000a DF93      		push r29
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 29, -7
  44               	/* prologue: function */
  45               	/* frame size = 0 */
  46               	/* stack size = 6 */
  47               	.L__stack_usage = 6
  48 000c EC01      		movw r28,r24
  49 000e 8B01      		movw r16,r22
  62:Lib/Ethernet.c **** 	DecodeEthernetFrameHeader(FrameIN->FrameData);
  50               		.loc 1 62 0
  51 0010 0E94 0000 		call DecodeEthernetFrameHeader
  52               	.LVL1:
  63:Lib/Ethernet.c **** 
  64:Lib/Ethernet.c **** 	/* Cast the incoming Ethernet frame to the Ethernet header type */
  65:Lib/Ethernet.c **** 	Ethernet_Frame_Header_t* FrameINHeader  = (Ethernet_Frame_Header_t*)&FrameIN->FrameData;
  66:Lib/Ethernet.c **** 	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
  67:Lib/Ethernet.c **** 
  68:Lib/Ethernet.c **** 	int16_t                  RetSize        = NO_RESPONSE;
  69:Lib/Ethernet.c **** 
  70:Lib/Ethernet.c **** 	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II 
  71:Lib/Ethernet.c **** 	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
  53               		.loc 1 71 0
  54 0014 46E0      		ldi r20,lo8(6)
  55 0016 50E0      		ldi r21,0
  56 0018 60E0      		ldi r22,lo8(ServerMACAddress)
  57 001a 70E0      		ldi r23,hi8(ServerMACAddress)
  58 001c CE01      		movw r24,r28
  59 001e 0E94 0000 		call memcmp
  60               	.LVL2:
  61 0022 9E01      		movw r18,r28
  62 0024 2452      		subi r18,36
  63 0026 3A4F      		sbci r19,-6
  64 0028 7901      		movw r14,r18
  65 002a 892B      		or r24,r25
  66 002c 01F0      		breq .L2
  72:Lib/Ethernet.c **** 	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
  67               		.loc 1 72 0 discriminator 1
  68 002e 46E0      		ldi r20,lo8(6)
  69 0030 50E0      		ldi r21,0
  70 0032 60E0      		ldi r22,lo8(BroadcastMACAddress)
  71 0034 70E0      		ldi r23,hi8(BroadcastMACAddress)
  72 0036 CE01      		movw r24,r28
  73 0038 0E94 0000 		call memcmp
  74               	.LVL3:
  71:Lib/Ethernet.c **** 	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
  75               		.loc 1 71 0 discriminator 1
  76 003c 892B      		or r24,r25
  77 003e 01F0      		breq .+2
  78 0040 00C0      		rjmp .L4
  79               	.L2:
  80               	.LVL4:
  81               	.LBB10:
  82               	.LBB11:
  83               	.LBB12:
  84               	.LBB13:
  85               		.file 2 "../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h"
   1:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /*
   2:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****              LUFA Library
   3:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
   5:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** */
   8:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
   9:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /*
  10:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  12:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  21:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   this software.
  29:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** */
  30:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  31:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /** \file
  32:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \brief Endianness and Byte Ordering macros and functions.
  33:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *
  34:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \copydetails Group_Endianness
  35:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  */
  36:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  37:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /** \ingroup Group_Endianness
  38:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \defgroup Group_ByteSwapping Byte Reordering
  39:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \brief Macros and functions for forced byte reordering.
  40:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  */
  41:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  42:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /** \ingroup Group_Endianness
  43:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \defgroup Group_EndianConversion Endianness Conversion
  44:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \brief Macros and functions for automatic endianness conversion.
  45:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  */
  46:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  47:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /** \ingroup Group_Common
  48:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \defgroup Group_Endianness Endianness and Byte Ordering
  49:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \brief Convenience macros and functions relating to byte (re-)ordering
  50:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *
  51:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  Common library convenience macros and functions relating to byte (re-)ordering.
  52:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *
  53:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  @{
  54:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  */
  55:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  56:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** #ifndef __LUFA_ENDIANNESS_H__
  57:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** #define __LUFA_ENDIANNESS_H__
  58:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  59:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 	/* Enable C linkage for C++ Compilers: */
  60:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#if defined(__cplusplus)
  61:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			extern "C" {
  62:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#endif
  63:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  64:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 	/* Preprocessor Checks: */
  65:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#if !defined(__INCLUDE_FROM_COMMON_H)
  66:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#error Do not include this file directly. Include LUFA/Common/Common.h instead to gain this func
  67:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#endif
  68:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		
  69:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#if !(defined(ARCH_BIG_ENDIAN) || defined(ARCH_LITTLE_ENDIAN))
  70:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#error ARCH_BIG_ENDIAN or ARCH_LITTLE_ENDIAN not set for the specified architecture.
  71:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#endif
  72:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  73:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 	/* Public Interface - May be used in end-application: */
  74:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		/* Macros: */
  75:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			/** Swaps the byte ordering of a 16-bit value at compile-time. Do not use this macro for swappin
  76:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  of dynamic values computed at runtime, use \ref SwapEndian_16() instead. The result of this 
  77:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  inside struct or other variable initializers outside of a function, something that is not po
  78:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  inline function variant.
  79:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  80:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
  81:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  82:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \param[in] x  16-bit value whose byte ordering is to be swapped.
  83:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  84:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \return Input value with the byte ordering reversed.
  85:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 */
  86:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#define SWAPENDIAN_16(x)            (uint16_t)((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))
  87:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  88:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			/** Swaps the byte ordering of a 32-bit value at compile-time. Do not use this macro for swappin
  89:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  of dynamic values computed at runtime- use \ref SwapEndian_32() instead. The result of this 
  90:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  inside struct or other variable initializers outside of a function, something that is not po
  91:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  inline function variant.
  92:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  93:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
  94:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  95:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \param[in] x  32-bit value whose byte ordering is to be swapped.
  96:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  97:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \return Input value with the byte ordering reversed.
  98:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 */
  99:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#define SWAPENDIAN_32(x)            (uint32_t)((((x) & 0xFF000000UL) >> 24UL) | (((x) & 0x00FF00
 100:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			                                               (((x) & 0x0000FF00UL) << 8UL)  | (((x) & 0x000000
 101:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 102:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#if defined(ARCH_BIG_ENDIAN) && !defined(le16_to_cpu)
 103:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define le16_to_cpu(x)           SwapEndian_16(x)
 104:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define le32_to_cpu(x)           SwapEndian_32(x)
 105:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define be16_to_cpu(x)           (x)
 106:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define be32_to_cpu(x)           (x)
 107:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_le16(x)           SwapEndian_16(x)
 108:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_le32(x)           SwapEndian_32(x)
 109:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_be16(x)           (x)
 110:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_be32(x)           (x)
 111:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define LE16_TO_CPU(x)           SWAPENDIAN_16(x)
 112:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define LE32_TO_CPU(x)           SWAPENDIAN_32(x)
 113:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define BE16_TO_CPU(x)           (x)
 114:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define BE32_TO_CPU(x)           (x)
 115:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_LE16(x)           SWAPENDIAN_16(x)
 116:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_LE32(x)           SWAPENDIAN_32(x)
 117:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_BE16(x)           (x)
 118:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_BE32(x)           (x)			
 119:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#elif !defined(le16_to_cpu)
 120:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** \name Run-time endianness conversion */
 121:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				//@{
 122:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			
 123:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 16-bit piece of data and the
 124:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 125:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 126:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 127:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 128:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 129:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref LE16_TO_CPU instead.
 130:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 131:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 132:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 133:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 134:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 135:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 136:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 137:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define le16_to_cpu(x)           (x)
 138:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 139:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 32-bit piece of data and the
 140:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 141:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 142:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 143:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 144:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 145:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref LE32_TO_CPU instead.
 146:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 147:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 148:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 149:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 150:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 151:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 152:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 153:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define le32_to_cpu(x)           (x)
 154:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 155:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 16-bit piece of data and the
 156:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 157:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 158:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 159:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 160:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 161:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref BE16_TO_CPU instead.
 162:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 163:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 164:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 165:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 166:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 167:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 168:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 169:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define be16_to_cpu(x)           SwapEndian_16(x)
 170:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 171:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 32-bit piece of data and the
 172:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 173:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 174:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 175:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 176:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 177:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref BE32_TO_CPU instead.
 178:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 179:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 180:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 181:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 182:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 183:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 184:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 185:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define be32_to_cpu(x)           SwapEndian_32(x)
 186:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 187:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 188:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 189:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 190:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 191:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 192:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 193:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_LE16 instead.
 194:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 195:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 196:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 197:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 198:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 199:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 200:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 201:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_le16(x)           (x)
 202:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 203:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 204:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 205:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 206:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 207:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 208:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 209:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_LE32 instead.
 210:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 211:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 212:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 213:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 214:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 215:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 216:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 217:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_le32(x)           (x)
 218:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 219:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 220:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 221:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 222:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 223:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 224:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 225:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_BE16 instead.
 226:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 227:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 228:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 229:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 230:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 231:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 232:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 233:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_be16(x)           SwapEndian_16(x)
 234:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 235:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 236:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 237:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 238:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 239:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 240:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 241:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_BE32 instead.
 242:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 243:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 244:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 245:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 246:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 247:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 248:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 249:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_be32(x)           SwapEndian_32(x)
 250:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 251:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				//@}
 252:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 253:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** \name Compile-time endianness conversion */
 254:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				//@{
 255:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 256:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 16-bit piece of data and the
 257:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 258:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 259:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 260:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 261:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run time endianness
 262:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref le16_to_cpu instead.
 263:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 264:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 265:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 266:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 267:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 268:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 269:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 270:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define LE16_TO_CPU(x)           (x)
 271:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 272:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 32-bit piece of data and the
 273:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 274:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 275:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 276:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 277:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run time endianness
 278:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref le32_to_cpu instead.
 279:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 280:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 281:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 282:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 283:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 284:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 285:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 286:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define LE32_TO_CPU(x)           (x)
 287:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 288:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 16-bit piece of data and the
 289:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 290:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 291:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 292:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 293:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 294:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref be16_to_cpu instead.
 295:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 296:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 297:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 298:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 299:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 300:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 301:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 302:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define BE16_TO_CPU(x)           SWAPENDIAN_16(x)
 303:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 304:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 32-bit piece of data and the
 305:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 306:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 307:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 308:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 309:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 310:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref be32_to_cpu instead.
 311:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 312:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 313:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 314:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 315:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 316:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 317:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 318:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define BE32_TO_CPU(x)           SWAPENDIAN_32(x)
 319:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 320:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 321:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 322:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 323:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 324:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 325:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 326:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_le16 instead.
 327:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 328:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 329:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 330:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 331:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 332:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 333:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 334:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_LE16(x)           (x)
 335:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 336:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 337:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 338:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 339:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 340:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 341:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 342:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_le32 instead.
 343:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 344:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 345:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 346:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 347:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 348:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 349:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 350:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_LE32(x)           (x)
 351:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 352:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 353:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 354:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 355:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 356:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 357:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 358:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_be16 instead.
 359:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 360:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 361:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 362:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 363:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 364:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 365:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 366:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_BE16(x)           SWAPENDIAN_16(x)
 367:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 368:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 369:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 370:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 371:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 372:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 373:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 374:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_be32 instead.
 375:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 376:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 377:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 378:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 379:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 380:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 381:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 382:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_BE32(x)           SWAPENDIAN_32(x)
 383:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 384:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				//! @}
 385:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#endif
 386:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 387:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		/* Inline Functions: */
 388:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			/** Function to reverse the byte ordering of the individual bytes in a 16 bit value.
 389:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 390:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
 391:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 392:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \param[in] Word  Word of data whose bytes are to be swapped.
 393:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 394:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \return Input data with the individual bytes reversed.
 395:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 */
 396:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
 397:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			static inline uint16_t SwapEndian_16(const uint16_t Word)
 398:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			{
 399:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				if (GCC_IS_COMPILE_CONST(Word))
 400:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				  return SWAPENDIAN_16(Word);
 401:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			
 402:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				uint8_t Temp;
 403:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 404:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				union
 405:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				{
 406:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 					uint16_t Word;
 407:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 					uint8_t  Bytes[2];
 408:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				} Data;
 409:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 410:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Word = Word;
 411:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 412:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Temp = Data.Bytes[0];
 413:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Bytes[0] = Data.Bytes[1];
 414:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Bytes[1] = Temp;
 415:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 416:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				return Data.Word;
  86               		.loc 2 416 0
  87 0042 F701      		movw r30,r14
  88 0044 8181      		ldd r24,Z+1
  89 0046 9081      		ld r25,Z
  90               	.LVL5:
  91               	.LBE13:
  92               	.LBE12:
  93               	.LBE11:
  94               	.LBE10:
  95               		.loc 1 72 0
  96 0048 8130      		cpi r24,1
  97 004a 9640      		sbci r25,6
  98 004c 00F0      		brlo .L4
  99               	.LVL6:
 100               	.LBB14:
 101               	.LBB15:
 102               	.LBB16:
 103               	.LBB17:
 104               		.loc 2 416 0
 105 004e 8D85      		ldd r24,Y+13
 106 0050 9C85      		ldd r25,Y+12
 107               	.LVL7:
 108               	.LBE17:
 109               	.LBE16:
 110               	.LBE15:
 111               	.LBE14:
  73:Lib/Ethernet.c **** 		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
  74:Lib/Ethernet.c **** 	{
  75:Lib/Ethernet.c **** 		/* Process the packet depending on its protocol */
  76:Lib/Ethernet.c **** 		switch (SwapEndian_16(FrameINHeader->EtherType))
 112               		.loc 1 76 0
 113 0052 8115      		cp r24,__zero_reg__
 114 0054 28E0      		ldi r18,8
 115 0056 9207      		cpc r25,r18
 116 0058 01F0      		breq .L5
 117 005a 8630      		cpi r24,6
 118 005c 9840      		sbci r25,8
 119 005e 01F4      		brne .L4
  77:Lib/Ethernet.c **** 		{
  78:Lib/Ethernet.c **** 			case ETHERTYPE_ARP:
  79:Lib/Ethernet.c **** 				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
  80:Lib/Ethernet.c **** 				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
 120               		.loc 1 80 0
 121 0060 B801      		movw r22,r16
 122 0062 625F      		subi r22,-14
 123 0064 7F4F      		sbci r23,-1
  79:Lib/Ethernet.c **** 				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
 124               		.loc 1 79 0
 125 0066 CE01      		movw r24,r28
 126 0068 0E96      		adiw r24,14
 127 006a 0E94 0000 		call ARP_ProcessARPPacket
 128               	.LVL8:
  81:Lib/Ethernet.c **** 				break;
 129               		.loc 1 81 0
 130 006e 00C0      		rjmp .L7
 131               	.LVL9:
 132               	.L5:
  82:Lib/Ethernet.c **** 			case ETHERTYPE_IPV4:
  83:Lib/Ethernet.c **** 				RetSize = IP_ProcessIPPacket(FrameIN,
 133               		.loc 1 83 0
 134 0070 A801      		movw r20,r16
 135 0072 425F      		subi r20,-14
 136 0074 5F4F      		sbci r21,-1
 137 0076 BE01      		movw r22,r28
 138 0078 625F      		subi r22,-14
 139 007a 7F4F      		sbci r23,-1
 140 007c CE01      		movw r24,r28
 141 007e 0E94 0000 		call IP_ProcessIPPacket
 142               	.LVL10:
 143               	.L7:
  84:Lib/Ethernet.c **** 				                             &FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
  85:Lib/Ethernet.c **** 				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
  86:Lib/Ethernet.c **** 				break;
  87:Lib/Ethernet.c **** 		}
  88:Lib/Ethernet.c **** 
  89:Lib/Ethernet.c **** 		/* Protocol processing routine has filled a response, complete the ethernet frame header */
  90:Lib/Ethernet.c **** 		if (RetSize > 0)
 144               		.loc 1 90 0
 145 0082 1816      		cp __zero_reg__,r24
 146 0084 1906      		cpc __zero_reg__,r25
 147 0086 04F4      		brge .L8
  91:Lib/Ethernet.c **** 		{
  92:Lib/Ethernet.c **** 			/* Fill out the response Ethernet frame header */
  93:Lib/Ethernet.c **** 			FrameOUTHeader->Source          = ServerMACAddress;
 148               		.loc 1 93 0
 149 0088 26E0      		ldi r18,lo8(6)
 150 008a E0E0      		ldi r30,lo8(ServerMACAddress)
 151 008c F0E0      		ldi r31,hi8(ServerMACAddress)
 152 008e D801      		movw r26,r16
 153 0090 1696      		adiw r26,6
 154               		0:
 155 0092 0190      		ld r0,Z+
 156 0094 0D92      		st X+,r0
 157 0096 2A95      		dec r18
 158 0098 01F4      		brne 0b
  94:Lib/Ethernet.c **** 			FrameOUTHeader->Destination     = FrameINHeader->Source;
 159               		.loc 1 94 0
 160 009a 26E0      		ldi r18,lo8(6)
 161 009c FE01      		movw r30,r28
 162 009e 3696      		adiw r30,6
 163 00a0 D801      		movw r26,r16
 164               		0:
 165 00a2 0190      		ld r0,Z+
 166 00a4 0D92      		st X+,r0
 167 00a6 2A95      		dec r18
 168 00a8 01F4      		brne 0b
  95:Lib/Ethernet.c **** 			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
 169               		.loc 1 95 0
 170 00aa 2C85      		ldd r18,Y+12
 171 00ac 3D85      		ldd r19,Y+13
 172 00ae F801      		movw r30,r16
 173 00b0 3587      		std Z+13,r19
 174 00b2 2487      		std Z+12,r18
  96:Lib/Ethernet.c **** 
  97:Lib/Ethernet.c **** 			/* Set the response length in the buffer and indicate that a response is ready to be sent */
  98:Lib/Ethernet.c **** 			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
 175               		.loc 1 98 0
 176 00b4 E452      		subi r30,36
 177 00b6 FA4F      		sbci r31,-6
 178 00b8 0E96      		adiw r24,14
 179               	.LVL11:
 180 00ba 9183      		std Z+1,r25
 181 00bc 8083      		st Z,r24
 182 00be 00C0      		rjmp .L4
 183               	.LVL12:
 184               	.L8:
  99:Lib/Ethernet.c **** 		}
 100:Lib/Ethernet.c **** 	}
 101:Lib/Ethernet.c **** 
 102:Lib/Ethernet.c **** 	/* Check if the packet was processed */
 103:Lib/Ethernet.c **** 	if (RetSize != NO_PROCESS)
 185               		.loc 1 103 0
 186 00c0 0196      		adiw r24,1
 187 00c2 01F0      		breq .L1
 188               	.LVL13:
 189               	.L4:
 104:Lib/Ethernet.c **** 	{
 105:Lib/Ethernet.c **** 		/* Clear the frame buffer */
 106:Lib/Ethernet.c **** 		FrameIN->FrameLength = 0;
 190               		.loc 1 106 0
 191 00c4 F701      		movw r30,r14
 192 00c6 1182      		std Z+1,__zero_reg__
 193 00c8 1082      		st Z,__zero_reg__
 194               	.L1:
 195               	/* epilogue start */
 107:Lib/Ethernet.c **** 	}
 108:Lib/Ethernet.c **** }
 196               		.loc 1 108 0
 197 00ca DF91      		pop r29
 198 00cc CF91      		pop r28
 199               	.LVL14:
 200 00ce 1F91      		pop r17
 201 00d0 0F91      		pop r16
 202               	.LVL15:
 203 00d2 FF90      		pop r15
 204 00d4 EF90      		pop r14
 205               	.LVL16:
 206 00d6 0895      		ret
 207               		.cfi_endproc
 208               	.LFE104:
 210               		.section	.text.Ethernet_Checksum16,"ax",@progbits
 211               	.global	Ethernet_Checksum16
 213               	Ethernet_Checksum16:
 214               	.LFB105:
 109:Lib/Ethernet.c **** 
 110:Lib/Ethernet.c **** /** Calculates the appropriate ethernet checksum, consisting of the addition of the one's
 111:Lib/Ethernet.c ****  *  compliment of each word, complimented.
 112:Lib/Ethernet.c ****  *
 113:Lib/Ethernet.c ****  *  \param[in] Data   Pointer to the packet buffer data whose checksum must be calculated
 114:Lib/Ethernet.c ****  *  \param[in] Bytes  Number of bytes in the data buffer to process
 115:Lib/Ethernet.c ****  *
 116:Lib/Ethernet.c ****  *  \return A 16-bit Ethernet checksum value
 117:Lib/Ethernet.c ****  */
 118:Lib/Ethernet.c **** uint16_t Ethernet_Checksum16(void* Data,
 119:Lib/Ethernet.c ****                              uint16_t Bytes)
 120:Lib/Ethernet.c **** {
 215               		.loc 1 120 0
 216               		.cfi_startproc
 217               	.LVL17:
 218 0000 CF93      		push r28
 219               	.LCFI6:
 220               		.cfi_def_cfa_offset 3
 221               		.cfi_offset 28, -2
 222 0002 DF93      		push r29
 223               	.LCFI7:
 224               		.cfi_def_cfa_offset 4
 225               		.cfi_offset 29, -3
 226               	/* prologue: function */
 227               	/* frame size = 0 */
 228               	/* stack size = 2 */
 229               	.L__stack_usage = 2
 230               	.LVL18:
 231               	.LBB18:
 121:Lib/Ethernet.c **** 	uint16_t* Words    = (uint16_t*)Data;
 122:Lib/Ethernet.c **** 	uint32_t  Checksum = 0;
 123:Lib/Ethernet.c **** 
 124:Lib/Ethernet.c **** 	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
 232               		.loc 1 124 0
 233 0004 9B01      		movw r18,r22
 234 0006 3695      		lsr r19
 235 0008 2795      		ror r18
 236 000a E0E0      		ldi r30,0
 237 000c F0E0      		ldi r31,0
 238               	.LBE18:
 122:Lib/Ethernet.c **** 
 239               		.loc 1 122 0
 240 000e 40E0      		ldi r20,0
 241 0010 50E0      		ldi r21,0
 242 0012 BA01      		movw r22,r20
 243               	.LVL19:
 244               	.L16:
 245               	.LBB19:
 246               		.loc 1 124 0 discriminator 1
 247 0014 E217      		cp r30,r18
 248 0016 F307      		cpc r31,r19
 249 0018 01F0      		breq .L18
 125:Lib/Ethernet.c **** 	  Checksum += Words[CurrWord];
 250               		.loc 1 125 0 discriminator 3
 251 001a EC01      		movw r28,r24
 252 001c A991      		ld r26,Y+
 253 001e B991      		ld r27,Y+
 254 0020 CE01      		movw r24,r28
 255 0022 4A0F      		add r20,r26
 256 0024 5B1F      		adc r21,r27
 257 0026 611D      		adc r22,__zero_reg__
 258 0028 711D      		adc r23,__zero_reg__
 259               	.LVL20:
 124:Lib/Ethernet.c **** 	  Checksum += Words[CurrWord];
 260               		.loc 1 124 0 discriminator 3
 261 002a 3196      		adiw r30,1
 262               	.LVL21:
 263 002c 00C0      		rjmp .L16
 264               	.L18:
 265               	.LBE19:
 126:Lib/Ethernet.c **** 
 127:Lib/Ethernet.c **** 	while (Checksum & 0xFFFF0000)
 266               		.loc 1 127 0
 267 002e DB01      		movw r26,r22
 268 0030 CA01      		movw r24,r20
 269 0032 8827      		clr r24
 270 0034 9927      		clr r25
 271 0036 892B      		or r24,r25
 272 0038 8A2B      		or r24,r26
 273 003a 8B2B      		or r24,r27
 274 003c 01F0      		breq .L20
 128:Lib/Ethernet.c **** 	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
 275               		.loc 1 128 0
 276 003e DB01      		movw r26,r22
 277 0040 CA01      		movw r24,r20
 278 0042 AA27      		clr r26
 279 0044 BB27      		clr r27
 280 0046 AB01      		movw r20,r22
 281 0048 6627      		clr r22
 282 004a 7727      		clr r23
 283               	.LVL22:
 284 004c 480F      		add r20,r24
 285 004e 591F      		adc r21,r25
 286 0050 6A1F      		adc r22,r26
 287 0052 7B1F      		adc r23,r27
 288               	.LVL23:
 289 0054 00C0      		rjmp .L18
 290               	.L20:
 129:Lib/Ethernet.c **** 
 130:Lib/Ethernet.c **** 	return ~Checksum;
 291               		.loc 1 130 0
 292 0056 CA01      		movw r24,r20
 293 0058 8095      		com r24
 294 005a 9095      		com r25
 295               	/* epilogue start */
 131:Lib/Ethernet.c **** }
 296               		.loc 1 131 0
 297 005c DF91      		pop r29
 298 005e CF91      		pop r28
 299 0060 0895      		ret
 300               		.cfi_endproc
 301               	.LFE105:
 303               	.global	ClientIPAddress
 304               		.section	.rodata
 307               	ClientIPAddress:
 308 0000 0A        		.byte	10
 309 0001 00        		.byte	0
 310 0002 00        		.byte	0
 311 0003 01        		.byte	1
 312               	.global	BroadcastIPAddress
 315               	BroadcastIPAddress:
 316 0004 FF        		.byte	-1
 317 0005 FF        		.byte	-1
 318 0006 FF        		.byte	-1
 319 0007 FF        		.byte	-1
 320               	.global	BroadcastMACAddress
 323               	BroadcastMACAddress:
 324 0008 FF        		.byte	-1
 325 0009 FF        		.byte	-1
 326 000a FF        		.byte	-1
 327 000b FF        		.byte	-1
 328 000c FF        		.byte	-1
 329 000d FF        		.byte	-1
 330               	.global	ServerIPAddress
 333               	ServerIPAddress:
 334 000e 0A        		.byte	10
 335 000f 00        		.byte	0
 336 0010 00        		.byte	0
 337 0011 02        		.byte	2
 338               	.global	ServerMACAddress
 341               	ServerMACAddress:
 342 0012 00        		.byte	0
 343 0013 01        		.byte	1
 344 0014 00        		.byte	0
 345 0015 01        		.byte	1
 346 0016 00        		.byte	0
 347 0017 01        		.byte	1
 348               		.text
 349               	.Letext0:
 350               		.file 3 "/usr/lib/avr/include/stdint.h"
 351               		.file 4 "/usr/lib/avr/include/stdio.h"
 352               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/RNDIS.h"
 353               		.file 6 "Lib/EthernetProtocols.h"
 354               		.file 7 "Lib/Ethernet.h"
 355               		.file 8 "../../../../LUFA/Drivers/USB/Class/Device/../../Core/USBTask.h"
 356               		.file 9 "../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h"
 357               		.file 10 "Lib/ProtocolDecoders.h"
 358               		.file 11 "/usr/lib/avr/include/string.h"
 359               		.file 12 "Lib/ARP.h"
 360               		.file 13 "Lib/IP.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Ethernet.c
     /tmp/ccRzVDzB.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccRzVDzB.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccRzVDzB.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccRzVDzB.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccRzVDzB.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccRzVDzB.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccRzVDzB.s:14     .text.Ethernet_ProcessPacket:0000000000000000 Ethernet_ProcessPacket
     /tmp/ccRzVDzB.s:341    .rodata:0000000000000012 ServerMACAddress
     /tmp/ccRzVDzB.s:323    .rodata:0000000000000008 BroadcastMACAddress
     /tmp/ccRzVDzB.s:213    .text.Ethernet_Checksum16:0000000000000000 Ethernet_Checksum16
     /tmp/ccRzVDzB.s:307    .rodata:0000000000000000 ClientIPAddress
     /tmp/ccRzVDzB.s:315    .rodata:0000000000000004 BroadcastIPAddress
     /tmp/ccRzVDzB.s:333    .rodata:000000000000000e ServerIPAddress

UNDEFINED SYMBOLS
DecodeEthernetFrameHeader
memcmp
ARP_ProcessARPPacket
IP_ProcessIPPacket
__do_copy_data
