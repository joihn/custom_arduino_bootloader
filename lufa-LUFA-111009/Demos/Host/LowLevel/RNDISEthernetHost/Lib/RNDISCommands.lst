   1               		.file	"RNDISCommands.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.RNDIS_SendEncapsulatedCommand,"ax",@progbits
  12               	.global	RNDIS_SendEncapsulatedCommand
  14               	RNDIS_SendEncapsulatedCommand:
  15               	.LFB147:
  16               		.file 1 "Lib/RNDISCommands.c"
   1:Lib/RNDISCommands.c **** /*
   2:Lib/RNDISCommands.c ****              LUFA Library
   3:Lib/RNDISCommands.c ****      Copyright (C) Dean Camera, 2011.
   4:Lib/RNDISCommands.c **** 
   5:Lib/RNDISCommands.c ****   dean [at] fourwalledcubicle [dot] com
   6:Lib/RNDISCommands.c ****            www.lufa-lib.org
   7:Lib/RNDISCommands.c **** */
   8:Lib/RNDISCommands.c **** 
   9:Lib/RNDISCommands.c **** /*
  10:Lib/RNDISCommands.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Lib/RNDISCommands.c **** 
  12:Lib/RNDISCommands.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Lib/RNDISCommands.c ****   software and its documentation for any purpose is hereby granted
  14:Lib/RNDISCommands.c ****   without fee, provided that the above copyright notice appear in
  15:Lib/RNDISCommands.c ****   all copies and that both that the copyright notice and this
  16:Lib/RNDISCommands.c ****   permission notice and warranty disclaimer appear in supporting
  17:Lib/RNDISCommands.c ****   documentation, and that the name of the author not be used in
  18:Lib/RNDISCommands.c ****   advertising or publicity pertaining to distribution of the
  19:Lib/RNDISCommands.c ****   software without specific, written prior permission.
  20:Lib/RNDISCommands.c **** 
  21:Lib/RNDISCommands.c ****   The author disclaim all warranties with regard to this
  22:Lib/RNDISCommands.c ****   software, including all implied warranties of merchantability
  23:Lib/RNDISCommands.c ****   and fitness.  In no event shall the author be liable for any
  24:Lib/RNDISCommands.c ****   special, indirect or consequential damages or any damages
  25:Lib/RNDISCommands.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Lib/RNDISCommands.c ****   in an action of contract, negligence or other tortious action,
  27:Lib/RNDISCommands.c ****   arising out of or in connection with the use or performance of
  28:Lib/RNDISCommands.c ****   this software.
  29:Lib/RNDISCommands.c **** */
  30:Lib/RNDISCommands.c **** 
  31:Lib/RNDISCommands.c **** /** \file
  32:Lib/RNDISCommands.c ****  *
  33:Lib/RNDISCommands.c ****  *  RNDIS Device commands, to issue RNDIS commands to the device for
  34:Lib/RNDISCommands.c ****  *  the control and data transfer between the host and RNDIS device.
  35:Lib/RNDISCommands.c ****  */
  36:Lib/RNDISCommands.c **** 
  37:Lib/RNDISCommands.c **** #include "RNDISCommands.h"
  38:Lib/RNDISCommands.c **** 
  39:Lib/RNDISCommands.c **** /** Current RNDIS Request ID, for associating sent commands with received data */
  40:Lib/RNDISCommands.c **** uint32_t RequestID = 0;
  41:Lib/RNDISCommands.c **** 
  42:Lib/RNDISCommands.c **** 
  43:Lib/RNDISCommands.c **** /** Function to send the given encapsulated RNDIS command to the device.
  44:Lib/RNDISCommands.c ****  *
  45:Lib/RNDISCommands.c ****  *  \param[in] Buffer  Source command data buffer to send to the device
  46:Lib/RNDISCommands.c ****  *  \param[in] Length   Number of bytes to send
  47:Lib/RNDISCommands.c ****  *
  48:Lib/RNDISCommands.c ****  *  \return A value from the USB_Host_SendControlErrorCodes_t enum
  49:Lib/RNDISCommands.c ****  */
  50:Lib/RNDISCommands.c **** uint8_t RNDIS_SendEncapsulatedCommand(void* const Buffer,
  51:Lib/RNDISCommands.c ****                                       const uint16_t Length)
  52:Lib/RNDISCommands.c **** {
  17               		.loc 1 52 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  53:Lib/RNDISCommands.c **** 	USB_ControlRequest = (USB_Request_Header_t)
  24               		.loc 1 53 0
  25 0000 E0E0      		ldi r30,lo8(USB_ControlRequest)
  26 0002 F0E0      		ldi r31,hi8(USB_ControlRequest)
  27 0004 21E2      		ldi r18,lo8(33)
  28 0006 2083      		st Z,r18
  29 0008 1182      		std Z+1,__zero_reg__
  30 000a 1382      		std Z+3,__zero_reg__
  31 000c 1282      		std Z+2,__zero_reg__
  32 000e 1582      		std Z+5,__zero_reg__
  33 0010 1482      		std Z+4,__zero_reg__
  34 0012 7783      		std Z+7,r23
  35 0014 6683      		std Z+6,r22
  36               	.LVL1:
  37               	.LBB18:
  38               	.LBB19:
  39               		.file 2 "../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h"
   1:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
   2:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****              LUFA Library
   3:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   5:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
   8:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   9:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
  10:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  12:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  21:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   this software.
  29:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
  30:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  31:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \file
  32:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief USB Pipe definitions for the AVR8 microcontrollers.
  33:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \copydetails Group_PipeManagement_AVR8
  34:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  35:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  38:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  39:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeRW
  40:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeRW_AVR8 Pipe Data Reading and Writing (AVR8)
  41:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe data read/write definitions for the Atmel AVR8 architecture.
  42:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  43:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to p
  44:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  45:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  46:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePrimitiveRW
  47:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePrimitiveRW_AVR8 Read/Write of Primitive Data Types (AVR8)
  48:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe primitive data read/write definitions for the Atmel AVR8 architecture.
  49:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  50:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  51:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  from and to pipes.
  52:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  53:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  54:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePacketManagement
  55:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePacketManagement_AVR8 Pipe Packet Management (AVR8)
  56:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe packet management definitions for the Atmel AVR8 architecture.
  57:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  58:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to packet management of pipes.
  59:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  60:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  61:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeControlReq
  62:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeControlReq_AVR8 Pipe Control Request Management (AVR8)
  63:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe control request management definitions for the Atmel AVR8 architecture.
  64:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  65:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Module for host mode request processing. This module allows for the transmission of standard, c
  66:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  vendor control requests to the default control endpoint of an attached device while in host mod
  67:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  68:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \see Chapter 9 of the USB 2.0 specification.
  69:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  70:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  71:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeManagement
  72:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeManagement_AVR8 Pipe Management (AVR8)
  73:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe management definitions for the Atmel AVR8 architecture.
  74:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  75:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  This module contains functions, macros and enums related to pipe management when in USB Host mo
  76:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  module contains the pipe management macros, as well as pipe interrupt and data send/receive fun
  77:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  for various data types.
  78:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  79:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  @{
  80:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  81:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  82:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #ifndef __PIPE_AVR8_H__
  83:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #define __PIPE_AVR8_H__
  84:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  85:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Includes: */
  86:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../../../../Common/Common.h"
  87:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../USBTask.h"
  88:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  89:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  90:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if defined(__cplusplus)
  91:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			extern "C" {
  92:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  93:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  94:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Preprocessor Checks: */
  95:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  96:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  97:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  98:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  99:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 100:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Macros: */
 101:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Error Flag Masks */
 102:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 103:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an overflow error occurred in the pipe o
 104:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_OVERFLOW         (1 << 6)
 105:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 106:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an underflow error occurred in the pipe 
 107:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_UNDERFLOW        (1 << 5)
 108:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 109:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a CRC error occurred in the pipe on the 
 110:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_CRC16            (1 << 4)
 111:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 112:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware timeout error occurred in the
 113:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_TIMEOUT          (1 << 3)
 114:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 115:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware PID error occurred in the pip
 116:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_PID              (1 << 2)
 117:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 118:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data PID error occurred in th
 119:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATAPID          (1 << 1)
 120:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 121:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data toggle error occurred in
 122:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATATGL          (1 << 0)
 123:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 124:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 125:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Token Masks */
 126:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 127:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a SETUP token (for CONTROL t
 128:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which will trigger a control request on the attached device when data is written to the pipe
 129:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 130:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_SETUP                (0 << PTOKEN0)
 131:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 132:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a IN token (for non-CONTROL 
 133:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from device to host.
 134:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 135:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_IN                   (1 << PTOKEN0)
 136:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 137:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a OUT token (for non-CONTROL
 138:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from host to device.
 139:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 140:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_OUT                  (2 << PTOKEN0)
 141:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 142:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			
 143:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Bank Mode Masks */
 144:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 145:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 146:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have one single bank, which requires less USB FIFO memory but results in slower trans
 147:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  only one USB device (the AVR or the attached device) can access the pipe's bank at the one t
 148:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 149:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_SINGLE                (0 << EPBK0)
 150:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 151:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 152:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have two banks, which requires more USB FIFO memory but results in faster transfers a
 153:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  USB device (the AVR or the attached device) can access one bank while the other accesses the
 154:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  bank.
 155:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 156:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_DOUBLE                (1 << EPBK0)
 157:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 158:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 159:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Default size of the default control pipe's bank, until altered by the Endpoint0Size value
 160:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  in the device descriptor of the attached device.
 161:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 162:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_CONTROLPIPE_DEFAULT_SIZE   64
 163:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 164:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Total number of pipes (including the default control pipe at address 0) which may be used in
 165:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the device. Different USB AVR models support different amounts of pipes, this value reflects
 166:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the maximum number of pipes for the currently selected AVR model.
 167:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 168:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOTAL_PIPES                7
 169:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 170:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Size in bytes of the largest pipe bank size possible in the device. Not all banks on each AV
 171:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  model supports the largest bank size possible on the device; different pipe numbers support
 172:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  different maximum bank sizes. This value reflects the largest possible bank of any pipe on t
 173:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected USB AVR model.
 174:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 175:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_MAX_SIZE                   256
 176:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 177:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Enums: */
 178:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enum for the possible error return codes of the \ref Pipe_WaitUntilReady() function.
 179:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 180:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 181:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 182:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			enum Pipe_WaitUntilReady_ErrorCodes_t
 183:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 184:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_NoError                 = 0, /**< Pipe ready for next packet, no error. */
 185:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_PipeStalled             = 1,	/**< The device stalled the pipe while waiting. */
 186:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host while wa
 187:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_Timeout                 = 3, /**< The device failed to accept or send the next p
 188:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   within the software timeout period set by the
 189:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   \ref USB_STREAM_TIMEOUT_MS macro.
 190:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             */
 191:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			};
 192:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 193:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Inline Functions: */
 194:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Indicates the number of bytes currently stored in the current pipes's selected bank.
 195:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 196:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \note The return width of this function may differ, depending on the maximum pipe bank size
 197:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *        of the selected AVR model.
 198:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 199:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 200:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 201:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
 202:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 203:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 204:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void)
 205:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 206:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return UPBCX;
 207:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 208:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 209:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Returns the pipe address of the currently selected pipe. This is typically used to save the
 210:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected pipe number so that it can be restored after another pipe has been manipu
 211:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 212:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Index of the currently selected pipe.
 213:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 214:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 215:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void)
 216:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 217:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPNUM & PIPE_PIPENUM_MASK);
 218:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 219:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 220:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Selects the given pipe number. Any pipe operations which do not require the pipe number to b
 221:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicated will operate on the currently selected pipe.
 222:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 223:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to select.
 224:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 225:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 226:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
 227:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPNUM = PipeNumber;
  40               		.loc 2 228 0
  41 0016 1092 A700 		sts 167,__zero_reg__
  42               	.LVL2:
  43               	.LBE19:
  44               	.LBE18:
  54:Lib/RNDISCommands.c **** 		{
  55:Lib/RNDISCommands.c **** 			.bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
  56:Lib/RNDISCommands.c **** 			.bRequest      = RNDIS_REQ_SendEncapsulatedCommand,
  57:Lib/RNDISCommands.c **** 			.wValue        = 0,
  58:Lib/RNDISCommands.c **** 			.wIndex        = 0,
  59:Lib/RNDISCommands.c **** 			.wLength       = Length,
  60:Lib/RNDISCommands.c **** 		};
  61:Lib/RNDISCommands.c **** 
  62:Lib/RNDISCommands.c **** 	/* Select the control pipe for the request transfer */
  63:Lib/RNDISCommands.c **** 	Pipe_SelectPipe(PIPE_CONTROLPIPE);
  64:Lib/RNDISCommands.c **** 
  65:Lib/RNDISCommands.c **** 	return USB_Host_SendControlRequest(Buffer);
  45               		.loc 1 65 0
  46 001a 0C94 0000 		jmp USB_Host_SendControlRequest
  47               	.LVL3:
  48               		.cfi_endproc
  49               	.LFE147:
  51               		.section	.text.RNDIS_GetEncapsulatedResponse,"ax",@progbits
  52               	.global	RNDIS_GetEncapsulatedResponse
  54               	RNDIS_GetEncapsulatedResponse:
  55               	.LFB148:
  66:Lib/RNDISCommands.c **** }
  67:Lib/RNDISCommands.c **** 
  68:Lib/RNDISCommands.c **** /** Function to receive the given encapsulated RNDIS response from the device.
  69:Lib/RNDISCommands.c ****  *
  70:Lib/RNDISCommands.c ****  *  \param[out] Buffer  Destination command data buffer to write read data from the device to
  71:Lib/RNDISCommands.c ****  *  \param[in] Length   Number of bytes to read
  72:Lib/RNDISCommands.c ****  *
  73:Lib/RNDISCommands.c ****  *  \return A value from the USB_Host_SendControlErrorCodes_t enum
  74:Lib/RNDISCommands.c ****  */
  75:Lib/RNDISCommands.c **** uint8_t RNDIS_GetEncapsulatedResponse(void* const Buffer,
  76:Lib/RNDISCommands.c ****                                       const uint16_t Length)
  77:Lib/RNDISCommands.c **** {
  56               		.loc 1 77 0
  57               		.cfi_startproc
  58               	.LVL4:
  59               	/* prologue: function */
  60               	/* frame size = 0 */
  61               	/* stack size = 0 */
  62               	.L__stack_usage = 0
  78:Lib/RNDISCommands.c **** 	USB_ControlRequest = (USB_Request_Header_t)
  63               		.loc 1 78 0
  64 0000 E0E0      		ldi r30,lo8(USB_ControlRequest)
  65 0002 F0E0      		ldi r31,hi8(USB_ControlRequest)
  66 0004 21EA      		ldi r18,lo8(-95)
  67 0006 2083      		st Z,r18
  68 0008 21E0      		ldi r18,lo8(1)
  69 000a 2183      		std Z+1,r18
  70 000c 1382      		std Z+3,__zero_reg__
  71 000e 1282      		std Z+2,__zero_reg__
  72 0010 1582      		std Z+5,__zero_reg__
  73 0012 1482      		std Z+4,__zero_reg__
  74 0014 7783      		std Z+7,r23
  75 0016 6683      		std Z+6,r22
  76               	.LVL5:
  77               	.LBB20:
  78               	.LBB21:
  79               		.loc 2 228 0
  80 0018 1092 A700 		sts 167,__zero_reg__
  81               	.LVL6:
  82               	.LBE21:
  83               	.LBE20:
  79:Lib/RNDISCommands.c **** 		{
  80:Lib/RNDISCommands.c **** 			.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
  81:Lib/RNDISCommands.c **** 			.bRequest      = RNDIS_REQ_GetEncapsulatedResponse,
  82:Lib/RNDISCommands.c **** 			.wValue        = 0,
  83:Lib/RNDISCommands.c **** 			.wIndex        = 0,
  84:Lib/RNDISCommands.c **** 			.wLength       = Length,
  85:Lib/RNDISCommands.c **** 		};
  86:Lib/RNDISCommands.c **** 
  87:Lib/RNDISCommands.c **** 	/* Select the control pipe for the request transfer */
  88:Lib/RNDISCommands.c **** 	Pipe_SelectPipe(PIPE_CONTROLPIPE);
  89:Lib/RNDISCommands.c **** 
  90:Lib/RNDISCommands.c **** 	return USB_Host_SendControlRequest(Buffer);
  84               		.loc 1 90 0
  85 001c 0C94 0000 		jmp USB_Host_SendControlRequest
  86               	.LVL7:
  87               		.cfi_endproc
  88               	.LFE148:
  90               		.section	.text.RNDIS_SendKeepAlive,"ax",@progbits
  91               	.global	RNDIS_SendKeepAlive
  93               	RNDIS_SendKeepAlive:
  94               	.LFB149:
  91:Lib/RNDISCommands.c **** }
  92:Lib/RNDISCommands.c **** 
  93:Lib/RNDISCommands.c **** /** Sends a RNDIS KEEPALIVE command to the device, to ensure that it does not enter standby mode af
  94:Lib/RNDISCommands.c ****  *  of long inactivity.
  95:Lib/RNDISCommands.c ****  *
  96:Lib/RNDISCommands.c ****  *  \return A value from the USB_Host_SendControlErrorCodes_t enum or RNDIS_COMMAND_FAILED if the d
  97:Lib/RNDISCommands.c ****  *          logical command failure
  98:Lib/RNDISCommands.c ****  */
  99:Lib/RNDISCommands.c **** uint8_t RNDIS_SendKeepAlive(void)
 100:Lib/RNDISCommands.c **** {
  95               		.loc 1 100 0
  96               		.cfi_startproc
  97 0000 CF93      		push r28
  98               	.LCFI0:
  99               		.cfi_def_cfa_offset 3
 100               		.cfi_offset 28, -2
 101 0002 DF93      		push r29
 102               	.LCFI1:
 103               		.cfi_def_cfa_offset 4
 104               		.cfi_offset 29, -3
 105 0004 CDB7      		in r28,__SP_L__
 106 0006 DEB7      		in r29,__SP_H__
 107               	.LCFI2:
 108               		.cfi_def_cfa_register 28
 109 0008 6C97      		sbiw r28,28
 110               	.LCFI3:
 111               		.cfi_def_cfa_offset 32
 112 000a 0FB6      		in __tmp_reg__,__SREG__
 113 000c F894      		cli
 114 000e DEBF      		out __SP_H__,r29
 115 0010 0FBE      		out __SREG__,__tmp_reg__
 116 0012 CDBF      		out __SP_L__,r28
 117               	/* prologue: function */
 118               	/* frame size = 28 */
 119               	/* stack size = 30 */
 120               	.L__stack_usage = 30
 101:Lib/RNDISCommands.c **** 	uint8_t ErrorCode;
 102:Lib/RNDISCommands.c **** 
 103:Lib/RNDISCommands.c **** 	RNDIS_KeepAlive_Message_t  KeepAliveMessage;
 104:Lib/RNDISCommands.c **** 	RNDIS_KeepAlive_Complete_t KeepAliveMessageResponse;
 105:Lib/RNDISCommands.c **** 
 106:Lib/RNDISCommands.c **** 	KeepAliveMessage.MessageType     = REMOTE_NDIS_KEEPALIVE_MSG;
 121               		.loc 1 106 0
 122 0014 88E0      		ldi r24,lo8(8)
 123 0016 90E0      		ldi r25,0
 124 0018 A0E0      		ldi r26,0
 125 001a B0E0      		ldi r27,0
 126 001c 898B      		std Y+17,r24
 127 001e 9A8B      		std Y+18,r25
 128 0020 AB8B      		std Y+19,r26
 129 0022 BC8B      		std Y+20,r27
 107:Lib/RNDISCommands.c **** 	KeepAliveMessage.MessageLength   = sizeof(RNDIS_KeepAlive_Message_t);
 130               		.loc 1 107 0
 131 0024 8CE0      		ldi r24,lo8(12)
 132 0026 90E0      		ldi r25,0
 133 0028 A0E0      		ldi r26,0
 134 002a B0E0      		ldi r27,0
 135 002c 8D8B      		std Y+21,r24
 136 002e 9E8B      		std Y+22,r25
 137 0030 AF8B      		std Y+23,r26
 138 0032 B88F      		std Y+24,r27
 108:Lib/RNDISCommands.c **** 	KeepAliveMessage.RequestId       = RequestID++;
 139               		.loc 1 108 0
 140 0034 8091 0000 		lds r24,RequestID
 141 0038 9091 0000 		lds r25,RequestID+1
 142 003c A091 0000 		lds r26,RequestID+2
 143 0040 B091 0000 		lds r27,RequestID+3
 144 0044 AC01      		movw r20,r24
 145 0046 BD01      		movw r22,r26
 146 0048 4F5F      		subi r20,-1
 147 004a 5F4F      		sbci r21,-1
 148 004c 6F4F      		sbci r22,-1
 149 004e 7F4F      		sbci r23,-1
 150 0050 4093 0000 		sts RequestID,r20
 151 0054 5093 0000 		sts RequestID+1,r21
 152 0058 6093 0000 		sts RequestID+2,r22
 153 005c 7093 0000 		sts RequestID+3,r23
 154 0060 898F      		std Y+25,r24
 155 0062 9A8F      		std Y+26,r25
 156 0064 AB8F      		std Y+27,r26
 157 0066 BC8F      		std Y+28,r27
 109:Lib/RNDISCommands.c **** 
 110:Lib/RNDISCommands.c **** 	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(&KeepAliveMessage,
 158               		.loc 1 110 0
 159 0068 6CE0      		ldi r22,lo8(12)
 160 006a 70E0      		ldi r23,0
 161 006c CE01      		movw r24,r28
 162 006e 4196      		adiw r24,17
 163 0070 0E94 0000 		call RNDIS_SendEncapsulatedCommand
 164               	.LVL8:
 165 0074 8111      		cpse r24,__zero_reg__
 166 0076 00C0      		rjmp .L4
 111:Lib/RNDISCommands.c **** 	                                               sizeof(RNDIS_KeepAlive_Message_t))) != HOST_SENDCON
 112:Lib/RNDISCommands.c **** 	{
 113:Lib/RNDISCommands.c **** 		return ErrorCode;
 114:Lib/RNDISCommands.c **** 	}
 115:Lib/RNDISCommands.c **** 
 116:Lib/RNDISCommands.c **** 	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(&KeepAliveMessageResponse,
 167               		.loc 1 116 0
 168 0078 60E1      		ldi r22,lo8(16)
 169 007a 70E0      		ldi r23,0
 170 007c CE01      		movw r24,r28
 171               	.LVL9:
 172 007e 0196      		adiw r24,1
 173 0080 0E94 0000 		call RNDIS_GetEncapsulatedResponse
 174               	.LVL10:
 175               	.L4:
 176               	/* epilogue start */
 117:Lib/RNDISCommands.c **** 	                                               sizeof(RNDIS_KeepAlive_Complete_t))) != HOST_SENDCO
 118:Lib/RNDISCommands.c **** 	{
 119:Lib/RNDISCommands.c **** 		return ErrorCode;
 120:Lib/RNDISCommands.c **** 	}
 121:Lib/RNDISCommands.c **** 
 122:Lib/RNDISCommands.c **** 	return HOST_SENDCONTROL_Successful;
 123:Lib/RNDISCommands.c **** }
 177               		.loc 1 123 0
 178 0084 6C96      		adiw r28,28
 179 0086 0FB6      		in __tmp_reg__,__SREG__
 180 0088 F894      		cli
 181 008a DEBF      		out __SP_H__,r29
 182 008c 0FBE      		out __SREG__,__tmp_reg__
 183 008e CDBF      		out __SP_L__,r28
 184 0090 DF91      		pop r29
 185 0092 CF91      		pop r28
 186 0094 0895      		ret
 187               		.cfi_endproc
 188               	.LFE149:
 190               		.section	.text.RNDIS_InitializeDevice,"ax",@progbits
 191               	.global	RNDIS_InitializeDevice
 193               	RNDIS_InitializeDevice:
 194               	.LFB150:
 124:Lib/RNDISCommands.c **** 
 125:Lib/RNDISCommands.c **** /** Initializes the attached RNDIS device's RNDIS interface.
 126:Lib/RNDISCommands.c ****  *
 127:Lib/RNDISCommands.c ****  *  \param[in] HostMaxPacketSize  Size of the packet buffer on the host
 128:Lib/RNDISCommands.c ****  *  \param[out] DeviceMaxPacketSize   Pointer to where the packet buffer size of the device is to b
 129:Lib/RNDISCommands.c ****  *
 130:Lib/RNDISCommands.c ****  *  \return A value from the USB_Host_SendControlErrorCodes_t enum or RNDIS_COMMAND_FAILED if the d
 131:Lib/RNDISCommands.c ****  *          logical command failure
 132:Lib/RNDISCommands.c ****  */
 133:Lib/RNDISCommands.c **** uint8_t RNDIS_InitializeDevice(const uint16_t HostMaxPacketSize,
 134:Lib/RNDISCommands.c ****                                uint16_t* const DeviceMaxPacketSize)
 135:Lib/RNDISCommands.c **** {
 195               		.loc 1 135 0
 196               		.cfi_startproc
 197               	.LVL11:
 198 0000 CF92      		push r12
 199               	.LCFI4:
 200               		.cfi_def_cfa_offset 3
 201               		.cfi_offset 12, -2
 202 0002 DF92      		push r13
 203               	.LCFI5:
 204               		.cfi_def_cfa_offset 4
 205               		.cfi_offset 13, -3
 206 0004 EF92      		push r14
 207               	.LCFI6:
 208               		.cfi_def_cfa_offset 5
 209               		.cfi_offset 14, -4
 210 0006 FF92      		push r15
 211               	.LCFI7:
 212               		.cfi_def_cfa_offset 6
 213               		.cfi_offset 15, -5
 214 0008 0F93      		push r16
 215               	.LCFI8:
 216               		.cfi_def_cfa_offset 7
 217               		.cfi_offset 16, -6
 218 000a 1F93      		push r17
 219               	.LCFI9:
 220               		.cfi_def_cfa_offset 8
 221               		.cfi_offset 17, -7
 222 000c CF93      		push r28
 223               	.LCFI10:
 224               		.cfi_def_cfa_offset 9
 225               		.cfi_offset 28, -8
 226 000e DF93      		push r29
 227               	.LCFI11:
 228               		.cfi_def_cfa_offset 10
 229               		.cfi_offset 29, -9
 230 0010 CDB7      		in r28,__SP_L__
 231 0012 DEB7      		in r29,__SP_H__
 232               	.LCFI12:
 233               		.cfi_def_cfa_register 28
 234 0014 CC54      		subi r28,76
 235 0016 D109      		sbc r29,__zero_reg__
 236               	.LCFI13:
 237               		.cfi_def_cfa_offset 86
 238 0018 0FB6      		in __tmp_reg__,__SREG__
 239 001a F894      		cli
 240 001c DEBF      		out __SP_H__,r29
 241 001e 0FBE      		out __SREG__,__tmp_reg__
 242 0020 CDBF      		out __SP_L__,r28
 243               	/* prologue: function */
 244               	/* frame size = 76 */
 245               	/* stack size = 84 */
 246               	.L__stack_usage = 84
 247 0022 8B01      		movw r16,r22
 136:Lib/RNDISCommands.c **** 	uint8_t ErrorCode;
 137:Lib/RNDISCommands.c **** 
 138:Lib/RNDISCommands.c **** 	RNDIS_Initialize_Message_t  InitMessage;
 139:Lib/RNDISCommands.c **** 	RNDIS_Initialize_Complete_t InitMessageResponse;
 140:Lib/RNDISCommands.c **** 
 141:Lib/RNDISCommands.c **** 	InitMessage.MessageType     = REMOTE_NDIS_INITIALIZE_MSG;
 248               		.loc 1 141 0
 249 0024 42E0      		ldi r20,lo8(2)
 250 0026 50E0      		ldi r21,0
 251 0028 60E0      		ldi r22,0
 252 002a 70E0      		ldi r23,0
 253 002c 4DAB      		std Y+53,r20
 254 002e 5EAB      		std Y+54,r21
 255 0030 6FAB      		std Y+55,r22
 256 0032 78AF      		std Y+56,r23
 142:Lib/RNDISCommands.c **** 	InitMessage.MessageLength   = sizeof(RNDIS_Initialize_Message_t);
 257               		.loc 1 142 0
 258 0034 48E1      		ldi r20,lo8(24)
 259 0036 50E0      		ldi r21,0
 260 0038 60E0      		ldi r22,0
 261 003a 70E0      		ldi r23,0
 262 003c 49AF      		std Y+57,r20
 263 003e 5AAF      		std Y+58,r21
 264 0040 6BAF      		std Y+59,r22
 265 0042 7CAF      		std Y+60,r23
 143:Lib/RNDISCommands.c **** 	InitMessage.RequestId       = RequestID++;
 266               		.loc 1 143 0
 267 0044 4091 0000 		lds r20,RequestID
 268 0048 5091 0000 		lds r21,RequestID+1
 269 004c 6091 0000 		lds r22,RequestID+2
 270 0050 7091 0000 		lds r23,RequestID+3
 271 0054 6A01      		movw r12,r20
 272 0056 7B01      		movw r14,r22
 273 0058 2FEF      		ldi r18,-1
 274 005a C21A      		sub r12,r18
 275 005c D20A      		sbc r13,r18
 276 005e E20A      		sbc r14,r18
 277 0060 F20A      		sbc r15,r18
 278 0062 C092 0000 		sts RequestID,r12
 279 0066 D092 0000 		sts RequestID+1,r13
 280 006a E092 0000 		sts RequestID+2,r14
 281 006e F092 0000 		sts RequestID+3,r15
 282 0072 2196      		adiw r28,61-60
 283 0074 4CAF      		std Y+60,r20
 284 0076 5DAF      		std Y+61,r21
 285 0078 6EAF      		std Y+62,r22
 286 007a 7FAF      		std Y+63,r23
 287 007c 2197      		sbiw r28,61-60
 144:Lib/RNDISCommands.c **** 
 145:Lib/RNDISCommands.c **** 	InitMessage.MajorVersion    = REMOTE_NDIS_VERSION_MAJOR;
 288               		.loc 1 145 0
 289 007e 41E0      		ldi r20,lo8(1)
 290 0080 50E0      		ldi r21,0
 291 0082 60E0      		ldi r22,0
 292 0084 70E0      		ldi r23,0
 293 0086 2596      		adiw r28,65-60
 294 0088 4CAF      		std Y+60,r20
 295 008a 5DAF      		std Y+61,r21
 296 008c 6EAF      		std Y+62,r22
 297 008e 7FAF      		std Y+63,r23
 298 0090 2597      		sbiw r28,65-60
 146:Lib/RNDISCommands.c **** 	InitMessage.MinorVersion    = REMOTE_NDIS_VERSION_MINOR;
 299               		.loc 1 146 0
 300 0092 2996      		adiw r28,69-60
 301 0094 1CAE      		std Y+60,__zero_reg__
 302 0096 1DAE      		std Y+61,__zero_reg__
 303 0098 1EAE      		std Y+62,__zero_reg__
 304 009a 1FAE      		std Y+63,__zero_reg__
 305 009c 2997      		sbiw r28,69-60
 147:Lib/RNDISCommands.c **** 	InitMessage.MaxTransferSize = HostMaxPacketSize;
 306               		.loc 1 147 0
 307 009e A0E0      		ldi r26,0
 308 00a0 B0E0      		ldi r27,0
 309 00a2 2D96      		adiw r28,73-60
 310 00a4 8CAF      		std Y+60,r24
 311 00a6 9DAF      		std Y+61,r25
 312 00a8 AEAF      		std Y+62,r26
 313 00aa BFAF      		std Y+63,r27
 314 00ac 2D97      		sbiw r28,73-60
 148:Lib/RNDISCommands.c **** 
 149:Lib/RNDISCommands.c **** 	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(&InitMessage,
 315               		.loc 1 149 0
 316 00ae 68E1      		ldi r22,lo8(24)
 317 00b0 70E0      		ldi r23,0
 318               	.LVL12:
 319 00b2 CE01      		movw r24,r28
 320               	.LVL13:
 321 00b4 C596      		adiw r24,53
 322 00b6 0E94 0000 		call RNDIS_SendEncapsulatedCommand
 323               	.LVL14:
 324 00ba 8111      		cpse r24,__zero_reg__
 325 00bc 00C0      		rjmp .L8
 150:Lib/RNDISCommands.c **** 	                                               sizeof(RNDIS_Initialize_Message_t))) != HOST_SENDCO
 151:Lib/RNDISCommands.c **** 	{
 152:Lib/RNDISCommands.c **** 		return ErrorCode;
 153:Lib/RNDISCommands.c **** 	}
 154:Lib/RNDISCommands.c **** 
 155:Lib/RNDISCommands.c **** 	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(&InitMessageResponse,
 326               		.loc 1 155 0
 327 00be 64E3      		ldi r22,lo8(52)
 328 00c0 70E0      		ldi r23,0
 329 00c2 CE01      		movw r24,r28
 330               	.LVL15:
 331 00c4 0196      		adiw r24,1
 332 00c6 0E94 0000 		call RNDIS_GetEncapsulatedResponse
 333               	.LVL16:
 334 00ca 8111      		cpse r24,__zero_reg__
 335 00cc 00C0      		rjmp .L8
 156:Lib/RNDISCommands.c **** 	                                               sizeof(RNDIS_Initialize_Complete_t))) != HOST_SENDC
 157:Lib/RNDISCommands.c **** 	{
 158:Lib/RNDISCommands.c **** 		return ErrorCode;
 159:Lib/RNDISCommands.c **** 	}
 160:Lib/RNDISCommands.c **** 
 161:Lib/RNDISCommands.c **** 	if (InitMessageResponse.Status != REMOTE_NDIS_STATUS_SUCCESS)
 336               		.loc 1 161 0
 337 00ce 8D85      		ldd r24,Y+13
 338 00d0 9E85      		ldd r25,Y+14
 339 00d2 AF85      		ldd r26,Y+15
 340 00d4 B889      		ldd r27,Y+16
 341               	.LVL17:
 342 00d6 892B      		or r24,r25
 343 00d8 8A2B      		or r24,r26
 344 00da 8B2B      		or r24,r27
 345 00dc 01F4      		brne .L11
 162:Lib/RNDISCommands.c **** 	  return RNDIS_COMMAND_FAILED;
 163:Lib/RNDISCommands.c **** 
 164:Lib/RNDISCommands.c **** 	*DeviceMaxPacketSize = InitMessageResponse.MaxTransferSize;
 346               		.loc 1 164 0
 347 00de 8DA1      		ldd r24,Y+37
 348 00e0 9EA1      		ldd r25,Y+38
 349 00e2 F801      		movw r30,r16
 350 00e4 9183      		std Z+1,r25
 351 00e6 8083      		st Z,r24
 165:Lib/RNDISCommands.c **** 
 166:Lib/RNDISCommands.c **** 	return HOST_SENDCONTROL_Successful;
 352               		.loc 1 166 0
 353 00e8 80E0      		ldi r24,0
 354 00ea 00C0      		rjmp .L8
 355               	.L11:
 162:Lib/RNDISCommands.c **** 	  return RNDIS_COMMAND_FAILED;
 356               		.loc 1 162 0
 357 00ec 80EC      		ldi r24,lo8(-64)
 358               	.L8:
 359               	/* epilogue start */
 167:Lib/RNDISCommands.c **** }
 360               		.loc 1 167 0
 361 00ee C45B      		subi r28,-76
 362 00f0 DF4F      		sbci r29,-1
 363 00f2 0FB6      		in __tmp_reg__,__SREG__
 364 00f4 F894      		cli
 365 00f6 DEBF      		out __SP_H__,r29
 366 00f8 0FBE      		out __SREG__,__tmp_reg__
 367 00fa CDBF      		out __SP_L__,r28
 368 00fc DF91      		pop r29
 369 00fe CF91      		pop r28
 370 0100 1F91      		pop r17
 371 0102 0F91      		pop r16
 372               	.LVL18:
 373 0104 FF90      		pop r15
 374 0106 EF90      		pop r14
 375 0108 DF90      		pop r13
 376 010a CF90      		pop r12
 377 010c 0895      		ret
 378               		.cfi_endproc
 379               	.LFE150:
 381               		.section	.text.RNDIS_SetRNDISProperty,"ax",@progbits
 382               	.global	RNDIS_SetRNDISProperty
 384               	RNDIS_SetRNDISProperty:
 385               	.LFB151:
 168:Lib/RNDISCommands.c **** 
 169:Lib/RNDISCommands.c **** /** Sets a given RNDIS property of an attached RNDIS device.
 170:Lib/RNDISCommands.c ****  *
 171:Lib/RNDISCommands.c ****  *  \param[in] Oid  OID number of the parameter to set
 172:Lib/RNDISCommands.c ****  *  \param[in] Buffer  Pointer to where the property data is to be sourced from
 173:Lib/RNDISCommands.c ****  *  \param[in] Length  Length in bytes of the property data to sent to the device
 174:Lib/RNDISCommands.c ****  *
 175:Lib/RNDISCommands.c ****  *  \return A value from the USB_Host_SendControlErrorCodes_t enum or RNDIS_COMMAND_FAILED if the d
 176:Lib/RNDISCommands.c ****  *          logical command failure
 177:Lib/RNDISCommands.c ****  */
 178:Lib/RNDISCommands.c **** uint8_t RNDIS_SetRNDISProperty(const uint32_t Oid,
 179:Lib/RNDISCommands.c ****                                void* Buffer,
 180:Lib/RNDISCommands.c ****                                const uint16_t Length)
 181:Lib/RNDISCommands.c **** {
 386               		.loc 1 181 0
 387               		.cfi_startproc
 388               	.LVL19:
 389 0000 6F92      		push r6
 390               	.LCFI14:
 391               		.cfi_def_cfa_offset 3
 392               		.cfi_offset 6, -2
 393 0002 7F92      		push r7
 394               	.LCFI15:
 395               		.cfi_def_cfa_offset 4
 396               		.cfi_offset 7, -3
 397 0004 8F92      		push r8
 398               	.LCFI16:
 399               		.cfi_def_cfa_offset 5
 400               		.cfi_offset 8, -4
 401 0006 9F92      		push r9
 402               	.LCFI17:
 403               		.cfi_def_cfa_offset 6
 404               		.cfi_offset 9, -5
 405 0008 AF92      		push r10
 406               	.LCFI18:
 407               		.cfi_def_cfa_offset 7
 408               		.cfi_offset 10, -6
 409 000a BF92      		push r11
 410               	.LCFI19:
 411               		.cfi_def_cfa_offset 8
 412               		.cfi_offset 11, -7
 413 000c CF92      		push r12
 414               	.LCFI20:
 415               		.cfi_def_cfa_offset 9
 416               		.cfi_offset 12, -8
 417 000e DF92      		push r13
 418               	.LCFI21:
 419               		.cfi_def_cfa_offset 10
 420               		.cfi_offset 13, -9
 421 0010 EF92      		push r14
 422               	.LCFI22:
 423               		.cfi_def_cfa_offset 11
 424               		.cfi_offset 14, -10
 425 0012 FF92      		push r15
 426               	.LCFI23:
 427               		.cfi_def_cfa_offset 12
 428               		.cfi_offset 15, -11
 429 0014 0F93      		push r16
 430               	.LCFI24:
 431               		.cfi_def_cfa_offset 13
 432               		.cfi_offset 16, -12
 433 0016 1F93      		push r17
 434               	.LCFI25:
 435               		.cfi_def_cfa_offset 14
 436               		.cfi_offset 17, -13
 437 0018 CF93      		push r28
 438               	.LCFI26:
 439               		.cfi_def_cfa_offset 15
 440               		.cfi_offset 28, -14
 441 001a DF93      		push r29
 442               	.LCFI27:
 443               		.cfi_def_cfa_offset 16
 444               		.cfi_offset 29, -15
 445 001c CDB7      		in r28,__SP_L__
 446 001e DEB7      		in r29,__SP_H__
 447               	.LCFI28:
 448               		.cfi_def_cfa_register 28
 449 0020 6097      		sbiw r28,16
 450               	.LCFI29:
 451               		.cfi_def_cfa_offset 32
 452 0022 0FB6      		in __tmp_reg__,__SREG__
 453 0024 F894      		cli
 454 0026 DEBF      		out __SP_H__,r29
 455 0028 0FBE      		out __SREG__,__tmp_reg__
 456 002a CDBF      		out __SP_L__,r28
 457               	/* prologue: function */
 458               	/* frame size = 16 */
 459               	/* stack size = 30 */
 460               	.L__stack_usage = 30
 461 002c 4B01      		movw r8,r22
 462 002e 5C01      		movw r10,r24
 463 0030 3A01      		movw r6,r20
 182:Lib/RNDISCommands.c **** 	uint8_t ErrorCode;
 183:Lib/RNDISCommands.c **** 
 184:Lib/RNDISCommands.c **** 	struct
 185:Lib/RNDISCommands.c **** 	{
 186:Lib/RNDISCommands.c **** 		RNDIS_Set_Message_t SetMessage;
 187:Lib/RNDISCommands.c **** 		uint8_t             ContiguousBuffer[Length];
 188:Lib/RNDISCommands.c **** 	} SetMessageData;
 189:Lib/RNDISCommands.c **** 
 190:Lib/RNDISCommands.c **** 	RNDIS_Set_Complete_t SetMessageResponse;
 191:Lib/RNDISCommands.c **** 
 192:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.MessageType    = REMOTE_NDIS_SET_MSG;
 193:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.MessageLength  = sizeof(RNDIS_Set_Message_t) + Length;
 194:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.RequestId      = RequestID++;
 195:Lib/RNDISCommands.c **** 
 196:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.Oid            = Oid;
 197:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.InformationBufferLength = Length;
 198:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.InformationBufferOffset = (sizeof(RNDIS_Set_Message_t) - sizeof(RNDIS_Me
 199:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.DeviceVcHandle = 0;
 200:Lib/RNDISCommands.c **** 
 201:Lib/RNDISCommands.c **** 	memcpy(&SetMessageData.ContiguousBuffer, Buffer, Length);
 202:Lib/RNDISCommands.c **** 
 203:Lib/RNDISCommands.c **** 	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(&SetMessageData,
 204:Lib/RNDISCommands.c **** 	                                               SetMessageData.SetMessage.MessageLength)) != HOST_S
 205:Lib/RNDISCommands.c **** 	{
 206:Lib/RNDISCommands.c **** 		return ErrorCode;
 207:Lib/RNDISCommands.c **** 	}
 208:Lib/RNDISCommands.c **** 
 209:Lib/RNDISCommands.c **** 	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(&SetMessageResponse,
 210:Lib/RNDISCommands.c **** 	                                               sizeof(RNDIS_Set_Complete_t))) != HOST_SENDCONTROL_
 211:Lib/RNDISCommands.c **** 	{
 212:Lib/RNDISCommands.c **** 		return ErrorCode;
 213:Lib/RNDISCommands.c **** 	}
 214:Lib/RNDISCommands.c **** 
 215:Lib/RNDISCommands.c **** 	if (SetMessageResponse.Status != REMOTE_NDIS_STATUS_SUCCESS)
 216:Lib/RNDISCommands.c **** 	  return RNDIS_COMMAND_FAILED;
 217:Lib/RNDISCommands.c **** 
 218:Lib/RNDISCommands.c **** 	return HOST_SENDCONTROL_Successful;
 219:Lib/RNDISCommands.c **** }
 464               		.loc 1 219 0
 465 0032 CDB6      		in r12,__SP_L__
 466 0034 DEB6      		in r13,__SP_H__
 467               	.LVL20:
 188:Lib/RNDISCommands.c **** 
 468               		.loc 1 188 0
 469 0036 7901      		movw r14,r18
 470 0038 8CE1      		ldi r24,28
 471 003a E80E      		add r14,r24
 472 003c F11C      		adc r15,__zero_reg__
 473 003e EDB7      		in r30,__SP_L__
 474 0040 FEB7      		in r31,__SP_H__
 475 0042 EE19      		sub r30,r14
 476 0044 FF09      		sbc r31,r15
 477 0046 0FB6      		in __tmp_reg__,__SREG__
 478 0048 F894      		cli
 479 004a FEBF      		out __SP_H__,r31
 480 004c 0FBE      		out __SREG__,__tmp_reg__
 481 004e EDBF      		out __SP_L__,r30
 482 0050 0DB7      		in r16,__SP_L__
 483 0052 1EB7      		in r17,__SP_H__
 484 0054 0F5F      		subi r16,-1
 485 0056 1F4F      		sbci r17,-1
 486               	.LVL21:
 192:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.MessageLength  = sizeof(RNDIS_Set_Message_t) + Length;
 487               		.loc 1 192 0
 488 0058 85E0      		ldi r24,lo8(5)
 489 005a 90E0      		ldi r25,0
 490 005c A0E0      		ldi r26,0
 491 005e B0E0      		ldi r27,0
 492 0060 8183      		std Z+1,r24
 493 0062 9283      		std Z+2,r25
 494 0064 A383      		std Z+3,r26
 495 0066 B483      		std Z+4,r27
 193:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.RequestId      = RequestID++;
 496               		.loc 1 193 0
 497 0068 C701      		movw r24,r14
 498 006a A0E0      		ldi r26,0
 499 006c B0E0      		ldi r27,0
 500 006e F801      		movw r30,r16
 501 0070 8483      		std Z+4,r24
 502 0072 9583      		std Z+5,r25
 503 0074 A683      		std Z+6,r26
 504 0076 B783      		std Z+7,r27
 194:Lib/RNDISCommands.c **** 
 505               		.loc 1 194 0
 506 0078 8091 0000 		lds r24,RequestID
 507 007c 9091 0000 		lds r25,RequestID+1
 508 0080 A091 0000 		lds r26,RequestID+2
 509 0084 B091 0000 		lds r27,RequestID+3
 510 0088 AC01      		movw r20,r24
 511 008a BD01      		movw r22,r26
 512               	.LVL22:
 513 008c 4F5F      		subi r20,-1
 514 008e 5F4F      		sbci r21,-1
 515 0090 6F4F      		sbci r22,-1
 516 0092 7F4F      		sbci r23,-1
 517 0094 4093 0000 		sts RequestID,r20
 518 0098 5093 0000 		sts RequestID+1,r21
 519 009c 6093 0000 		sts RequestID+2,r22
 520 00a0 7093 0000 		sts RequestID+3,r23
 521 00a4 8087      		std Z+8,r24
 522 00a6 9187      		std Z+9,r25
 523 00a8 A287      		std Z+10,r26
 524 00aa B387      		std Z+11,r27
 196:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.InformationBufferLength = Length;
 525               		.loc 1 196 0
 526 00ac 8486      		std Z+12,r8
 527 00ae 9586      		std Z+13,r9
 528 00b0 A686      		std Z+14,r10
 529 00b2 B786      		std Z+15,r11
 197:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.InformationBufferOffset = (sizeof(RNDIS_Set_Message_t) - sizeof(RNDIS_Me
 530               		.loc 1 197 0
 531 00b4 C901      		movw r24,r18
 532 00b6 A0E0      		ldi r26,0
 533 00b8 B0E0      		ldi r27,0
 534 00ba 808B      		std Z+16,r24
 535 00bc 918B      		std Z+17,r25
 536 00be A28B      		std Z+18,r26
 537 00c0 B38B      		std Z+19,r27
 198:Lib/RNDISCommands.c **** 	SetMessageData.SetMessage.DeviceVcHandle = 0;
 538               		.loc 1 198 0
 539 00c2 84E1      		ldi r24,lo8(20)
 540 00c4 90E0      		ldi r25,0
 541 00c6 A0E0      		ldi r26,0
 542 00c8 B0E0      		ldi r27,0
 543 00ca 848B      		std Z+20,r24
 544 00cc 958B      		std Z+21,r25
 545 00ce A68B      		std Z+22,r26
 546 00d0 B78B      		std Z+23,r27
 199:Lib/RNDISCommands.c **** 
 547               		.loc 1 199 0
 548 00d2 108E      		std Z+24,__zero_reg__
 549 00d4 118E      		std Z+25,__zero_reg__
 550 00d6 128E      		std Z+26,__zero_reg__
 551 00d8 138E      		std Z+27,__zero_reg__
 201:Lib/RNDISCommands.c **** 
 552               		.loc 1 201 0
 553 00da 8DB7      		in r24,__SP_L__
 554 00dc 9EB7      		in r25,__SP_H__
 555 00de 4D96      		adiw r24,29
 556 00e0 A901      		movw r20,r18
 557 00e2 B301      		movw r22,r6
 558               	.LVL23:
 559 00e4 0E94 0000 		call memcpy
 560               	.LVL24:
 203:Lib/RNDISCommands.c **** 	                                               SetMessageData.SetMessage.MessageLength)) != HOST_S
 561               		.loc 1 203 0
 562 00e8 B701      		movw r22,r14
 563 00ea C801      		movw r24,r16
 564 00ec 0E94 0000 		call RNDIS_SendEncapsulatedCommand
 565               	.LVL25:
 566 00f0 8111      		cpse r24,__zero_reg__
 567 00f2 00C0      		rjmp .L13
 209:Lib/RNDISCommands.c **** 	                                               sizeof(RNDIS_Set_Complete_t))) != HOST_SENDCONTROL_
 568               		.loc 1 209 0
 569 00f4 60E1      		ldi r22,lo8(16)
 570 00f6 70E0      		ldi r23,0
 571 00f8 CE01      		movw r24,r28
 572               	.LVL26:
 573 00fa 0196      		adiw r24,1
 574 00fc 0E94 0000 		call RNDIS_GetEncapsulatedResponse
 575               	.LVL27:
 576 0100 8111      		cpse r24,__zero_reg__
 577 0102 00C0      		rjmp .L13
 215:Lib/RNDISCommands.c **** 	  return RNDIS_COMMAND_FAILED;
 578               		.loc 1 215 0
 579 0104 8D85      		ldd r24,Y+13
 580 0106 9E85      		ldd r25,Y+14
 581 0108 AF85      		ldd r26,Y+15
 582 010a B889      		ldd r27,Y+16
 583               	.LVL28:
 584 010c 892B      		or r24,r25
 585 010e 8A2B      		or r24,r26
 586 0110 8B2B      		or r24,r27
 587 0112 01F4      		brne .L16
 218:Lib/RNDISCommands.c **** }
 588               		.loc 1 218 0
 589 0114 80E0      		ldi r24,0
 590 0116 00C0      		rjmp .L13
 591               	.L16:
 216:Lib/RNDISCommands.c **** 
 592               		.loc 1 216 0
 593 0118 80EC      		ldi r24,lo8(-64)
 594               	.L13:
 595               		.loc 1 219 0
 596 011a 0FB6      		in __tmp_reg__,__SREG__
 597 011c F894      		cli
 598 011e DEBE      		out __SP_H__,r13
 599 0120 0FBE      		out __SREG__,__tmp_reg__
 600 0122 CDBE      		out __SP_L__,r12
 601               	/* epilogue start */
 602 0124 6096      		adiw r28,16
 603 0126 0FB6      		in __tmp_reg__,__SREG__
 604 0128 F894      		cli
 605 012a DEBF      		out __SP_H__,r29
 606 012c 0FBE      		out __SREG__,__tmp_reg__
 607 012e CDBF      		out __SP_L__,r28
 608 0130 DF91      		pop r29
 609 0132 CF91      		pop r28
 610 0134 1F91      		pop r17
 611 0136 0F91      		pop r16
 612               	.LVL29:
 613 0138 FF90      		pop r15
 614 013a EF90      		pop r14
 615               	.LVL30:
 616 013c DF90      		pop r13
 617 013e CF90      		pop r12
 618               	.LVL31:
 619 0140 BF90      		pop r11
 620 0142 AF90      		pop r10
 621 0144 9F90      		pop r9
 622 0146 8F90      		pop r8
 623               	.LVL32:
 624 0148 7F90      		pop r7
 625 014a 6F90      		pop r6
 626               	.LVL33:
 627 014c 0895      		ret
 628               		.cfi_endproc
 629               	.LFE151:
 631               		.section	.text.RNDIS_QueryRNDISProperty,"ax",@progbits
 632               	.global	RNDIS_QueryRNDISProperty
 634               	RNDIS_QueryRNDISProperty:
 635               	.LFB152:
 220:Lib/RNDISCommands.c **** 
 221:Lib/RNDISCommands.c **** /** Gets a given RNDIS property of an attached RNDIS device.
 222:Lib/RNDISCommands.c ****  *
 223:Lib/RNDISCommands.c ****  *  \param[in] Oid  OID number of the parameter to get
 224:Lib/RNDISCommands.c ****  *  \param[in] Buffer  Pointer to where the property data is to be written to
 225:Lib/RNDISCommands.c ****  *  \param[in] MaxLength  Length in bytes of the destination buffer size
 226:Lib/RNDISCommands.c ****  *
 227:Lib/RNDISCommands.c ****  *  \return A value from the USB_Host_SendControlErrorCodes_t enum or RNDIS_COMMAND_FAILED if the d
 228:Lib/RNDISCommands.c ****  *          logical command failure
 229:Lib/RNDISCommands.c ****  */
 230:Lib/RNDISCommands.c **** uint8_t RNDIS_QueryRNDISProperty(const uint32_t Oid,
 231:Lib/RNDISCommands.c ****                                  void* Buffer,
 232:Lib/RNDISCommands.c ****                                  const uint16_t MaxLength)
 233:Lib/RNDISCommands.c **** {
 636               		.loc 1 233 0
 637               		.cfi_startproc
 638               	.LVL34:
 639 0000 4F92      		push r4
 640               	.LCFI30:
 641               		.cfi_def_cfa_offset 3
 642               		.cfi_offset 4, -2
 643 0002 5F92      		push r5
 644               	.LCFI31:
 645               		.cfi_def_cfa_offset 4
 646               		.cfi_offset 5, -3
 647 0004 6F92      		push r6
 648               	.LCFI32:
 649               		.cfi_def_cfa_offset 5
 650               		.cfi_offset 6, -4
 651 0006 7F92      		push r7
 652               	.LCFI33:
 653               		.cfi_def_cfa_offset 6
 654               		.cfi_offset 7, -5
 655 0008 8F92      		push r8
 656               	.LCFI34:
 657               		.cfi_def_cfa_offset 7
 658               		.cfi_offset 8, -6
 659 000a 9F92      		push r9
 660               	.LCFI35:
 661               		.cfi_def_cfa_offset 8
 662               		.cfi_offset 9, -7
 663 000c AF92      		push r10
 664               	.LCFI36:
 665               		.cfi_def_cfa_offset 9
 666               		.cfi_offset 10, -8
 667 000e BF92      		push r11
 668               	.LCFI37:
 669               		.cfi_def_cfa_offset 10
 670               		.cfi_offset 11, -9
 671 0010 CF92      		push r12
 672               	.LCFI38:
 673               		.cfi_def_cfa_offset 11
 674               		.cfi_offset 12, -10
 675 0012 DF92      		push r13
 676               	.LCFI39:
 677               		.cfi_def_cfa_offset 12
 678               		.cfi_offset 13, -11
 679 0014 EF92      		push r14
 680               	.LCFI40:
 681               		.cfi_def_cfa_offset 13
 682               		.cfi_offset 14, -12
 683 0016 FF92      		push r15
 684               	.LCFI41:
 685               		.cfi_def_cfa_offset 14
 686               		.cfi_offset 15, -13
 687 0018 0F93      		push r16
 688               	.LCFI42:
 689               		.cfi_def_cfa_offset 15
 690               		.cfi_offset 16, -14
 691 001a 1F93      		push r17
 692               	.LCFI43:
 693               		.cfi_def_cfa_offset 16
 694               		.cfi_offset 17, -15
 695 001c CF93      		push r28
 696               	.LCFI44:
 697               		.cfi_def_cfa_offset 17
 698               		.cfi_offset 28, -16
 699 001e DF93      		push r29
 700               	.LCFI45:
 701               		.cfi_def_cfa_offset 18
 702               		.cfi_offset 29, -17
 703 0020 CDB7      		in r28,__SP_L__
 704 0022 DEB7      		in r29,__SP_H__
 705               	.LCFI46:
 706               		.cfi_def_cfa_register 28
 707 0024 6C97      		sbiw r28,28
 708               	.LCFI47:
 709               		.cfi_def_cfa_offset 46
 710 0026 0FB6      		in __tmp_reg__,__SREG__
 711 0028 F894      		cli
 712 002a DEBF      		out __SP_H__,r29
 713 002c 0FBE      		out __SREG__,__tmp_reg__
 714 002e CDBF      		out __SP_L__,r28
 715               	/* prologue: function */
 716               	/* frame size = 28 */
 717               	/* stack size = 44 */
 718               	.L__stack_usage = 44
 719 0030 2B01      		movw r4,r22
 720 0032 3C01      		movw r6,r24
 721 0034 4A01      		movw r8,r20
 722 0036 7901      		movw r14,r18
 234:Lib/RNDISCommands.c **** 	uint8_t ErrorCode;
 235:Lib/RNDISCommands.c **** 
 236:Lib/RNDISCommands.c **** 	RNDIS_Query_Message_t QueryMessage;
 237:Lib/RNDISCommands.c **** 
 238:Lib/RNDISCommands.c **** 	struct
 239:Lib/RNDISCommands.c **** 	{
 240:Lib/RNDISCommands.c **** 		RNDIS_Query_Complete_t QueryMessageResponse;
 241:Lib/RNDISCommands.c **** 		uint8_t                ContiguousBuffer[MaxLength];
 242:Lib/RNDISCommands.c **** 	} QueryMessageResponseData;
 243:Lib/RNDISCommands.c **** 
 244:Lib/RNDISCommands.c **** 	QueryMessage.MessageType    = REMOTE_NDIS_QUERY_MSG;
 245:Lib/RNDISCommands.c **** 	QueryMessage.MessageLength  = sizeof(RNDIS_Query_Message_t);
 246:Lib/RNDISCommands.c **** 	QueryMessage.RequestId      = RequestID++;
 247:Lib/RNDISCommands.c **** 
 248:Lib/RNDISCommands.c **** 	QueryMessage.Oid            = Oid;
 249:Lib/RNDISCommands.c **** 	QueryMessage.InformationBufferLength = 0;
 250:Lib/RNDISCommands.c **** 	QueryMessage.InformationBufferOffset = 0;
 251:Lib/RNDISCommands.c **** 	QueryMessage.DeviceVcHandle = 0;
 252:Lib/RNDISCommands.c **** 
 253:Lib/RNDISCommands.c **** 	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(&QueryMessage,
 254:Lib/RNDISCommands.c **** 	                                               sizeof(RNDIS_Query_Message_t))) != HOST_SENDCONTROL
 255:Lib/RNDISCommands.c **** 	{
 256:Lib/RNDISCommands.c **** 		return ErrorCode;
 257:Lib/RNDISCommands.c **** 	}
 258:Lib/RNDISCommands.c **** 
 259:Lib/RNDISCommands.c **** 	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(&QueryMessageResponseData,
 260:Lib/RNDISCommands.c **** 	                                               sizeof(QueryMessageResponseData))) != HOST_SENDCONT
 261:Lib/RNDISCommands.c **** 	{
 262:Lib/RNDISCommands.c **** 		return ErrorCode;
 263:Lib/RNDISCommands.c **** 	}
 264:Lib/RNDISCommands.c **** 
 265:Lib/RNDISCommands.c **** 	if (QueryMessageResponseData.QueryMessageResponse.Status != REMOTE_NDIS_STATUS_SUCCESS)
 266:Lib/RNDISCommands.c **** 	  return RNDIS_COMMAND_FAILED;
 267:Lib/RNDISCommands.c **** 
 268:Lib/RNDISCommands.c **** 	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);
 269:Lib/RNDISCommands.c **** 
 270:Lib/RNDISCommands.c **** 	return HOST_SENDCONTROL_Successful;
 271:Lib/RNDISCommands.c **** }
 723               		.loc 1 271 0
 724 0038 ADB6      		in r10,__SP_L__
 725 003a BEB6      		in r11,__SP_H__
 726               	.LVL35:
 242:Lib/RNDISCommands.c **** 
 727               		.loc 1 242 0
 728 003c 6901      		movw r12,r18
 729 003e 88E1      		ldi r24,24
 730 0040 C80E      		add r12,r24
 731 0042 D11C      		adc r13,__zero_reg__
 732 0044 EDB7      		in r30,__SP_L__
 733 0046 FEB7      		in r31,__SP_H__
 734 0048 EC19      		sub r30,r12
 735 004a FD09      		sbc r31,r13
 736 004c 0FB6      		in __tmp_reg__,__SREG__
 737 004e F894      		cli
 738 0050 FEBF      		out __SP_H__,r31
 739 0052 0FBE      		out __SREG__,__tmp_reg__
 740 0054 EDBF      		out __SP_L__,r30
 741 0056 0DB7      		in r16,__SP_L__
 742 0058 1EB7      		in r17,__SP_H__
 743 005a 0F5F      		subi r16,-1
 744 005c 1F4F      		sbci r17,-1
 745               	.LVL36:
 244:Lib/RNDISCommands.c **** 	QueryMessage.MessageLength  = sizeof(RNDIS_Query_Message_t);
 746               		.loc 1 244 0
 747 005e 84E0      		ldi r24,lo8(4)
 748 0060 90E0      		ldi r25,0
 749 0062 A0E0      		ldi r26,0
 750 0064 B0E0      		ldi r27,0
 751 0066 8983      		std Y+1,r24
 752 0068 9A83      		std Y+2,r25
 753 006a AB83      		std Y+3,r26
 754 006c BC83      		std Y+4,r27
 245:Lib/RNDISCommands.c **** 	QueryMessage.RequestId      = RequestID++;
 755               		.loc 1 245 0
 756 006e 8CE1      		ldi r24,lo8(28)
 757 0070 90E0      		ldi r25,0
 758 0072 A0E0      		ldi r26,0
 759 0074 B0E0      		ldi r27,0
 760 0076 8D83      		std Y+5,r24
 761 0078 9E83      		std Y+6,r25
 762 007a AF83      		std Y+7,r26
 763 007c B887      		std Y+8,r27
 246:Lib/RNDISCommands.c **** 
 764               		.loc 1 246 0
 765 007e 8091 0000 		lds r24,RequestID
 766 0082 9091 0000 		lds r25,RequestID+1
 767 0086 A091 0000 		lds r26,RequestID+2
 768 008a B091 0000 		lds r27,RequestID+3
 769 008e AC01      		movw r20,r24
 770 0090 BD01      		movw r22,r26
 771               	.LVL37:
 772 0092 4F5F      		subi r20,-1
 773 0094 5F4F      		sbci r21,-1
 774 0096 6F4F      		sbci r22,-1
 775 0098 7F4F      		sbci r23,-1
 776 009a 4093 0000 		sts RequestID,r20
 777 009e 5093 0000 		sts RequestID+1,r21
 778 00a2 6093 0000 		sts RequestID+2,r22
 779 00a6 7093 0000 		sts RequestID+3,r23
 780 00aa 8987      		std Y+9,r24
 781 00ac 9A87      		std Y+10,r25
 782 00ae AB87      		std Y+11,r26
 783 00b0 BC87      		std Y+12,r27
 248:Lib/RNDISCommands.c **** 	QueryMessage.InformationBufferLength = 0;
 784               		.loc 1 248 0
 785 00b2 4D86      		std Y+13,r4
 786 00b4 5E86      		std Y+14,r5
 787 00b6 6F86      		std Y+15,r6
 788 00b8 788A      		std Y+16,r7
 249:Lib/RNDISCommands.c **** 	QueryMessage.InformationBufferOffset = 0;
 789               		.loc 1 249 0
 790 00ba 198A      		std Y+17,__zero_reg__
 791 00bc 1A8A      		std Y+18,__zero_reg__
 792 00be 1B8A      		std Y+19,__zero_reg__
 793 00c0 1C8A      		std Y+20,__zero_reg__
 250:Lib/RNDISCommands.c **** 	QueryMessage.DeviceVcHandle = 0;
 794               		.loc 1 250 0
 795 00c2 1D8A      		std Y+21,__zero_reg__
 796 00c4 1E8A      		std Y+22,__zero_reg__
 797 00c6 1F8A      		std Y+23,__zero_reg__
 798 00c8 188E      		std Y+24,__zero_reg__
 251:Lib/RNDISCommands.c **** 
 799               		.loc 1 251 0
 800 00ca 198E      		std Y+25,__zero_reg__
 801 00cc 1A8E      		std Y+26,__zero_reg__
 802 00ce 1B8E      		std Y+27,__zero_reg__
 803 00d0 1C8E      		std Y+28,__zero_reg__
 253:Lib/RNDISCommands.c **** 	                                               sizeof(RNDIS_Query_Message_t))) != HOST_SENDCONTROL
 804               		.loc 1 253 0
 805 00d2 6CE1      		ldi r22,lo8(28)
 806 00d4 70E0      		ldi r23,0
 807               	.LVL38:
 808 00d6 CE01      		movw r24,r28
 809 00d8 0196      		adiw r24,1
 810 00da 0E94 0000 		call RNDIS_SendEncapsulatedCommand
 811               	.LVL39:
 812 00de 8111      		cpse r24,__zero_reg__
 813 00e0 00C0      		rjmp .L18
 259:Lib/RNDISCommands.c **** 	                                               sizeof(QueryMessageResponseData))) != HOST_SENDCONT
 814               		.loc 1 259 0
 815 00e2 B601      		movw r22,r12
 816 00e4 C801      		movw r24,r16
 817               	.LVL40:
 818 00e6 0E94 0000 		call RNDIS_GetEncapsulatedResponse
 819               	.LVL41:
 820 00ea 8111      		cpse r24,__zero_reg__
 821 00ec 00C0      		rjmp .L18
 265:Lib/RNDISCommands.c **** 	  return RNDIS_COMMAND_FAILED;
 822               		.loc 1 265 0
 823 00ee F801      		movw r30,r16
 824 00f0 8485      		ldd r24,Z+12
 825 00f2 9585      		ldd r25,Z+13
 826 00f4 A685      		ldd r26,Z+14
 827 00f6 B785      		ldd r27,Z+15
 828               	.LVL42:
 829 00f8 892B      		or r24,r25
 830 00fa 8A2B      		or r24,r26
 831 00fc 8B2B      		or r24,r27
 832 00fe 01F4      		brne .L21
 268:Lib/RNDISCommands.c **** 
 833               		.loc 1 268 0
 834 0100 B801      		movw r22,r16
 835 0102 685E      		subi r22,-24
 836 0104 7F4F      		sbci r23,-1
 837 0106 A701      		movw r20,r14
 838 0108 C401      		movw r24,r8
 839 010a 0E94 0000 		call memcpy
 840               	.LVL43:
 270:Lib/RNDISCommands.c **** }
 841               		.loc 1 270 0
 842 010e 80E0      		ldi r24,0
 843 0110 00C0      		rjmp .L18
 844               	.L21:
 266:Lib/RNDISCommands.c **** 
 845               		.loc 1 266 0
 846 0112 80EC      		ldi r24,lo8(-64)
 847               	.L18:
 848               		.loc 1 271 0
 849 0114 0FB6      		in __tmp_reg__,__SREG__
 850 0116 F894      		cli
 851 0118 BEBE      		out __SP_H__,r11
 852 011a 0FBE      		out __SREG__,__tmp_reg__
 853 011c ADBE      		out __SP_L__,r10
 854               	/* epilogue start */
 855 011e 6C96      		adiw r28,28
 856 0120 0FB6      		in __tmp_reg__,__SREG__
 857 0122 F894      		cli
 858 0124 DEBF      		out __SP_H__,r29
 859 0126 0FBE      		out __SREG__,__tmp_reg__
 860 0128 CDBF      		out __SP_L__,r28
 861 012a DF91      		pop r29
 862 012c CF91      		pop r28
 863 012e 1F91      		pop r17
 864 0130 0F91      		pop r16
 865               	.LVL44:
 866 0132 FF90      		pop r15
 867 0134 EF90      		pop r14
 868               	.LVL45:
 869 0136 DF90      		pop r13
 870 0138 CF90      		pop r12
 871               	.LVL46:
 872 013a BF90      		pop r11
 873 013c AF90      		pop r10
 874               	.LVL47:
 875 013e 9F90      		pop r9
 876 0140 8F90      		pop r8
 877               	.LVL48:
 878 0142 7F90      		pop r7
 879 0144 6F90      		pop r6
 880 0146 5F90      		pop r5
 881 0148 4F90      		pop r4
 882               	.LVL49:
 883 014a 0895      		ret
 884               		.cfi_endproc
 885               	.LFE152:
 887               		.section	.text.RNDIS_GetPacketLength,"ax",@progbits
 888               	.global	RNDIS_GetPacketLength
 890               	RNDIS_GetPacketLength:
 891               	.LFB153:
 272:Lib/RNDISCommands.c **** 
 273:Lib/RNDISCommands.c **** /** Retrieves the size of a received packet, discarding the remainder of the RNDIS packet header to
 274:Lib/RNDISCommands.c ****  *  packet contents for processing by the host.
 275:Lib/RNDISCommands.c ****  *
 276:Lib/RNDISCommands.c ****  *  \param[out] PacketLength  Size of the packet currently in the pipe
 277:Lib/RNDISCommands.c ****  *
 278:Lib/RNDISCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum
 279:Lib/RNDISCommands.c ****  */
 280:Lib/RNDISCommands.c **** uint8_t RNDIS_GetPacketLength(uint16_t* const PacketLength)
 281:Lib/RNDISCommands.c **** {
 892               		.loc 1 281 0
 893               		.cfi_startproc
 894               	.LVL50:
 895 0000 0F93      		push r16
 896               	.LCFI48:
 897               		.cfi_def_cfa_offset 3
 898               		.cfi_offset 16, -2
 899 0002 1F93      		push r17
 900               	.LCFI49:
 901               		.cfi_def_cfa_offset 4
 902               		.cfi_offset 17, -3
 903 0004 CF93      		push r28
 904               	.LCFI50:
 905               		.cfi_def_cfa_offset 5
 906               		.cfi_offset 28, -4
 907 0006 DF93      		push r29
 908               	.LCFI51:
 909               		.cfi_def_cfa_offset 6
 910               		.cfi_offset 29, -5
 911 0008 CDB7      		in r28,__SP_L__
 912 000a DEB7      		in r29,__SP_H__
 913               	.LCFI52:
 914               		.cfi_def_cfa_register 28
 915 000c AC97      		sbiw r28,44
 916               	.LCFI53:
 917               		.cfi_def_cfa_offset 50
 918 000e 0FB6      		in __tmp_reg__,__SREG__
 919 0010 F894      		cli
 920 0012 DEBF      		out __SP_H__,r29
 921 0014 0FBE      		out __SREG__,__tmp_reg__
 922 0016 CDBF      		out __SP_L__,r28
 923               	/* prologue: function */
 924               	/* frame size = 44 */
 925               	/* stack size = 48 */
 926               	.L__stack_usage = 48
 927 0018 FC01      		movw r30,r24
 928               	.LVL51:
 929               	.LBB22:
 930               	.LBB23:
 931               		.loc 2 228 0
 932 001a 81E0      		ldi r24,lo8(1)
 933               	.LVL52:
 934 001c 8093 A700 		sts 167,r24
 935               	.LVL53:
 936               	.LBE23:
 937               	.LBE22:
 938               	.LBB24:
 939               	.LBB25:
 229:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 230:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 231:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Resets the desired pipe, including the pipe banks and flags.
 232:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 233:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to reset.
 234:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 235:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 236:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber)
 237:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 238:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = (1 << PipeNumber);
 239:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = 0;
 240:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 241:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 242:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enables the currently selected pipe so that data can be sent and received through it to and 
 243:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  an attached device.
 244:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 245:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePi
 246:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 247:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
 248:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void)
 249:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 250:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << PEN);
 251:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 252:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 253:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Disables the currently selected pipe so that data cannot be sent and received through it to 
 254:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  from an attached device.
 255:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 256:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
 257:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void)
 258:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 259:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << PEN);
 260:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 261:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 262:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is enabled, but not necessarily configured.
 263:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 264:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 * \return Boolean \c true if the currently selected pipe is enabled, \c false otherwise.
 265:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 266:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 267:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void)
 268:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 269:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPCONX & (1 << PEN)) ? true : false);
 270:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 271:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 272:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Gets the current pipe token, indicating the pipe's data direction and type.
 273:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 274:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
 275:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 276:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 277:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void)
 278:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 279:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPCFG0X & (0x03 << PTOKEN0));
 280:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 281:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 282:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the token for the currently selected pipe to one of the tokens specified by the \c PIPE
 283:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  masks. This can be used on CONTROL type pipes, to allow for bidirectional transfer of data d
 284:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  control requests, or on regular pipes to allow for half-duplex bidirectional data transfer t
 285:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which have two endpoints of opposite direction sharing the same endpoint address within the 
 286:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 287:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
 288:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 289:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
 290:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token)
 291:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 292:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
 940               		.loc 2 292 0
 941 0020 9091 AA00 		lds r25,170
 942 0024 9F7C      		andi r25,lo8(-49)
 943 0026 9061      		ori r25,lo8(16)
 944 0028 9093 AA00 		sts 170,r25
 945               	.LVL54:
 946               	.LBE25:
 947               	.LBE24:
 948               	.LBB26:
 949               	.LBB27:
 293:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 294:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 295:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
 296:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
 297:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void)
 298:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 299:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << INMODE);
 300:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 301:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 302:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to only allow the specified number of IN requests to 
 303:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  accepted by the pipe before it is automatically frozen.
 304:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 305:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] TotalINRequests  Total number of IN requests that the pipe may receive before fre
 306:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 307:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests) ATTR_ALWAYS_INLINE;
 308:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests)
 309:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 310:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << INMODE);
 311:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINRQX = TotalINRequests;
 312:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 313:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 314:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is configured.
 315:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 316:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
 317:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 318:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 319:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void)
 320:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 321:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPSTAX & (1 << CFGOK)) ? true : false);
 322:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 323:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 324:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Retrieves the endpoint address of the endpoint within the attached device that the currently
 325:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipe is bound to.
 326:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 327:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Endpoint address the currently selected pipe is bound to.
 328:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 329:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INL
 330:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
 331:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
 333:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 334:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 335:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 336:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the period between interrupts for an INTERRUPT type pipe to a specified number of milli
 337:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 338:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Milliseconds  Number of milliseconds between each pipe poll.
 339:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 340:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds) ATTR_ALWAYS_INLINE;
 341:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds)
 342:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 343:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG2X = Milliseconds;
 344:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 345:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 346:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Returns a mask indicating which pipe's interrupt periods have elapsed, indicating that the p
 347:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  be serviced.
 348:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 349:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Mask whose bits indicate which pipes have interrupted.
 350:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 351:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeInterrupts(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 352:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeInterrupts(void)
 353:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 354:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return UPINT;
 355:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 356:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 357:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the specified pipe number has interrupted (valid only for INTERRUPT type
 358:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipes).
 359:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 360:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe whose interrupt flag should be tested.
 361:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 362:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the specified pipe has interrupted, \c false otherwise.
 363:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 364:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_HasPipeInterrupted(const uint8_t PipeNumber) ATTR_WARN_UNUSED_RESULT ATT
 365:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_HasPipeInterrupted(const uint8_t PipeNumber)
 366:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 367:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINT & (1 << PipeNumber)) ? true : false);
 368:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 369:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 370:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
 371:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
 372:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Unfreeze(void)
 373:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << PFREEZE);
 950               		.loc 2 374 0
 951 002c 8091 A900 		lds r24,169
 952 0030 8F7B      		andi r24,lo8(-65)
 953 0032 8093 A900 		sts 169,r24
 954               	.LBE27:
 955               	.LBE26:
 956               	.LBB28:
 957               	.LBB29:
 375:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 376:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 377:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
 378:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
 379:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Freeze(void)
 380:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << PFREEZE);
 382:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 383:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 384:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is frozen, and not able to accept data.
 385:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 386:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the currently selected pipe is frozen, \c false otherwise.
 387:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 388:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsFrozen(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 389:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsFrozen(void)
 390:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 391:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPCONX & (1 << PFREEZE)) ? true : false);
 392:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 393:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 394:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Clears the error flags for the currently selected pipe. */
 395:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
 396:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearError(void)
 397:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 398:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPERRX = 0;
 399:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~(1 << PERRI);
 400:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 401:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 402:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the master pipe error flag is set for the currently selected pipe, indicating 
 403:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  some sort of hardware error has occurred on the pipe.
 404:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 405:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \see \ref Pipe_GetErrorFlags() macro for information on retrieving the exact error flag.
 406:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 407:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if an error has occurred on the selected pipe, \c false otherwise.
 408:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 409:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 410:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsError(void)
 411:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 412:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << PERRI)) ? true : false);
 413:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 414:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 415:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Gets a mask of the hardware error flags which have occurred on the currently selected pipe. 
 416:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  value can then be masked against the \c PIPE_ERRORFLAG_* masks to determine what error has o
 417:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 418:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return  Mask comprising of \c PIPE_ERRORFLAG_* bits indicating what error has occurred on t
 419:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 420:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetErrorFlags(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 421:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetErrorFlags(void)
 422:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 423:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPERRX & (PIPE_ERRORFLAG_CRC16 | PIPE_ERRORFLAG_TIMEOUT |
 424:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                   PIPE_ERRORFLAG_PID   | PIPE_ERRORFLAG_DATAPID |
 425:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                   PIPE_ERRORFLAG_DATATGL)) |
 426:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        (UPSTAX & (PIPE_ERRORFLAG_OVERFLOW | PIPE_ERRORFLAG_UNDERFLOW)));
 427:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 428:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			
 429:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Retrieves the number of busy banks in the currently selected pipe, which have been queued fo
 430:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  transmission via the \ref Pipe_ClearOUT() command, or are awaiting acknowledgement via the
 431:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ref Pipe_ClearIN() command.
 432:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 433:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 434:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 435:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Total number of busy banks in the selected pipe.
 436:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 437:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBusyBanks(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 438:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBusyBanks(void)
 439:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 440:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPSTAX & (0x03 << NBUSYBK0));
 441:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 442:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 443:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe may be read from (if data is waiting in the pipe
 444:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  bank and the pipe is an IN direction, or if the bank is not yet full if the pipe is an OUT
 445:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  direction). This function will return false if an error has occurred in the pipe, or if the 
 446:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  is an IN direction and no packet (or an empty packet) has been received, or if the pipe is a
 447:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  direction and the pipe bank is full.
 448:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 449:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \note This function is not valid on CONTROL type pipes.
 450:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 451:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 452:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 453:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the currently selected pipe may be read from or written to, depen
 454:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *          on its direction.
 455:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 456:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 457:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsReadWriteAllowed(void)
 458:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 459:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << RWAL)) ? true : false);
 958               		.loc 2 459 0
 959 0036 9091 A600 		lds r25,166
 960               	.LBE29:
 961               	.LBE28:
 282:Lib/RNDISCommands.c **** 	uint8_t ErrorCode;
 283:Lib/RNDISCommands.c **** 
 284:Lib/RNDISCommands.c **** 	Pipe_SelectPipe(RNDIS_DATA_IN_PIPE);
 285:Lib/RNDISCommands.c **** 	Pipe_SetPipeToken(PIPE_TOKEN_IN);
 286:Lib/RNDISCommands.c **** 	Pipe_Unfreeze();
 287:Lib/RNDISCommands.c **** 
 288:Lib/RNDISCommands.c **** 	if (!(Pipe_IsReadWriteAllowed()))
 962               		.loc 1 288 0
 963 003a 892F      		mov r24,r25
 964 003c 8072      		andi r24,lo8(32)
 965 003e 95FD      		sbrc r25,5
 966 0040 00C0      		rjmp .L23
 289:Lib/RNDISCommands.c **** 	{
 290:Lib/RNDISCommands.c **** 		*PacketLength = 0;
 967               		.loc 1 290 0
 968 0042 1182      		std Z+1,__zero_reg__
 969 0044 1082      		st Z,__zero_reg__
 970               	.LBB30:
 971               	.LBB31:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 972               		.loc 2 381 0
 973 0046 9091 A900 		lds r25,169
 974 004a 9064      		ori r25,lo8(64)
 975 004c 9093 A900 		sts 169,r25
 976               	.LBE31:
 977               	.LBE30:
 291:Lib/RNDISCommands.c **** 		Pipe_Freeze();
 292:Lib/RNDISCommands.c **** 		return PIPE_RWSTREAM_NoError;
 978               		.loc 1 292 0
 979 0050 00C0      		rjmp .L24
 980               	.L23:
 981 0052 8F01      		movw r16,r30
 293:Lib/RNDISCommands.c **** 	}
 294:Lib/RNDISCommands.c **** 
 295:Lib/RNDISCommands.c **** 	RNDIS_Packet_Message_t DeviceMessage;
 296:Lib/RNDISCommands.c **** 
 297:Lib/RNDISCommands.c **** 	if ((ErrorCode = Pipe_Read_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t), NULL)) != PIP
 982               		.loc 1 297 0
 983 0054 40E0      		ldi r20,0
 984 0056 50E0      		ldi r21,0
 985 0058 6CE2      		ldi r22,lo8(44)
 986 005a 70E0      		ldi r23,0
 987 005c CE01      		movw r24,r28
 988 005e 0196      		adiw r24,1
 989 0060 0E94 0000 		call Pipe_Read_Stream_LE
 990               	.LVL55:
 991 0064 8111      		cpse r24,__zero_reg__
 992 0066 00C0      		rjmp .L24
 298:Lib/RNDISCommands.c **** 	{
 299:Lib/RNDISCommands.c **** 		return ErrorCode;
 300:Lib/RNDISCommands.c **** 	}
 301:Lib/RNDISCommands.c **** 
 302:Lib/RNDISCommands.c **** 	*PacketLength = (uint16_t)DeviceMessage.DataLength;
 993               		.loc 1 302 0
 994 0068 8D85      		ldd r24,Y+13
 995 006a 9E85      		ldd r25,Y+14
 996               	.LVL56:
 997 006c F801      		movw r30,r16
 998 006e 9183      		std Z+1,r25
 999 0070 8083      		st Z,r24
 303:Lib/RNDISCommands.c **** 
 304:Lib/RNDISCommands.c **** 	Pipe_Discard_Stream(DeviceMessage.DataOffset - (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Mess
 1000               		.loc 1 304 0
 1001 0072 8985      		ldd r24,Y+9
 1002 0074 9A85      		ldd r25,Y+10
 1003 0076 60E0      		ldi r22,0
 1004 0078 70E0      		ldi r23,0
 1005 007a 8497      		sbiw r24,36
 1006 007c 0E94 0000 		call Pipe_Discard_Stream
 1007               	.LVL57:
 1008               	.LBB32:
 1009               	.LBB33:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 1010               		.loc 2 381 0
 1011 0080 8091 A900 		lds r24,169
 1012 0084 8064      		ori r24,lo8(64)
 1013 0086 8093 A900 		sts 169,r24
 1014               	.LBE33:
 1015               	.LBE32:
 305:Lib/RNDISCommands.c **** 	                    NULL);
 306:Lib/RNDISCommands.c **** 
 307:Lib/RNDISCommands.c **** 	Pipe_Freeze();
 308:Lib/RNDISCommands.c **** 
 309:Lib/RNDISCommands.c **** 	return PIPE_RWSTREAM_NoError;
 1016               		.loc 1 309 0
 1017 008a 80E0      		ldi r24,0
 1018               	.LVL58:
 1019               	.L24:
 1020               	/* epilogue start */
 310:Lib/RNDISCommands.c **** }
 1021               		.loc 1 310 0
 1022 008c AC96      		adiw r28,44
 1023 008e 0FB6      		in __tmp_reg__,__SREG__
 1024 0090 F894      		cli
 1025 0092 DEBF      		out __SP_H__,r29
 1026 0094 0FBE      		out __SREG__,__tmp_reg__
 1027 0096 CDBF      		out __SP_L__,r28
 1028 0098 DF91      		pop r29
 1029 009a CF91      		pop r28
 1030 009c 1F91      		pop r17
 1031 009e 0F91      		pop r16
 1032 00a0 0895      		ret
 1033               		.cfi_endproc
 1034               	.LFE153:
 1036               	.global	RequestID
 1037               		.section .bss
 1040               	RequestID:
 1041 0000 0000 0000 		.zero	4
 1042               		.text
 1043               	.Letext0:
 1044               		.file 3 "/usr/lib/avr/include/stdint.h"
 1045               		.file 4 "/usr/lib/avr/include/stdio.h"
 1046               		.file 5 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 1047               		.file 6 "../../../../LUFA/Drivers/USB/Core/AVR8/../HostStandardReq.h"
 1048               		.file 7 "../../../../LUFA/Drivers/USB/Core/AVR8/../PipeStream.h"
 1049               		.file 8 "../../../../LUFA/Drivers/USB/Class/Host/../Common/RNDIS.h"
 1050               		.file 9 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
 1051               		.file 10 "../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h"
 1052               		.file 11 "../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/PipeStream_AVR8.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 RNDISCommands.c
     /tmp/cc35APJc.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc35APJc.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc35APJc.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc35APJc.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc35APJc.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc35APJc.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc35APJc.s:14     .text.RNDIS_SendEncapsulatedCommand:0000000000000000 RNDIS_SendEncapsulatedCommand
     /tmp/cc35APJc.s:54     .text.RNDIS_GetEncapsulatedResponse:0000000000000000 RNDIS_GetEncapsulatedResponse
     /tmp/cc35APJc.s:93     .text.RNDIS_SendKeepAlive:0000000000000000 RNDIS_SendKeepAlive
     /tmp/cc35APJc.s:1040   .bss:0000000000000000 RequestID
     /tmp/cc35APJc.s:193    .text.RNDIS_InitializeDevice:0000000000000000 RNDIS_InitializeDevice
     /tmp/cc35APJc.s:384    .text.RNDIS_SetRNDISProperty:0000000000000000 RNDIS_SetRNDISProperty
     /tmp/cc35APJc.s:634    .text.RNDIS_QueryRNDISProperty:0000000000000000 RNDIS_QueryRNDISProperty
     /tmp/cc35APJc.s:890    .text.RNDIS_GetPacketLength:0000000000000000 RNDIS_GetPacketLength

UNDEFINED SYMBOLS
USB_ControlRequest
USB_Host_SendControlRequest
memcpy
Pipe_Read_Stream_LE
Pipe_Discard_Stream
__do_clear_bss
