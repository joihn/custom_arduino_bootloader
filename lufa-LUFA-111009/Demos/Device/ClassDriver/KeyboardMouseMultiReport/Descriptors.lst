   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB97:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  41:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  42:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  43:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  44:Descriptors.c ****  *  more details on HID report descriptors.
  45:Descriptors.c ****  *
  46:Descriptors.c ****  *  This descriptor describes the multiple possible reports of the HID interface's report structure
  47:Descriptors.c ****  */
  48:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM HIDReport[] =
  49:Descriptors.c **** {
  50:Descriptors.c **** 	/* Mouse Report */
  51:Descriptors.c **** 	HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  52:Descriptors.c **** 	HID_RI_USAGE(8, 0x02), /* Mouse */
  53:Descriptors.c **** 	HID_RI_COLLECTION(8, 0x01), /* Application */
  54:Descriptors.c **** 		HID_RI_REPORT_ID(8, HID_REPORTID_MouseReport),
  55:Descriptors.c **** 	    HID_RI_USAGE(8, 0x01), /* Pointer */
  56:Descriptors.c **** 	    HID_RI_COLLECTION(8, 0x00), /* Physical */
  57:Descriptors.c **** 	        HID_RI_USAGE_PAGE(8, 0x09), /* Button */
  58:Descriptors.c **** 	        HID_RI_USAGE_MINIMUM(8, 0x01),
  59:Descriptors.c **** 	        HID_RI_USAGE_MAXIMUM(8, 0x03),
  60:Descriptors.c **** 	        HID_RI_LOGICAL_MINIMUM(8, 0x00),
  61:Descriptors.c **** 	        HID_RI_LOGICAL_MAXIMUM(8, 0x01),
  62:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x03),
  63:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x01),
  64:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE),
  65:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x01),
  66:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x05),
  67:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_CONSTANT),
  68:Descriptors.c **** 	        HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  69:Descriptors.c **** 	        HID_RI_USAGE(8, 0x30), /* Usage X */
  70:Descriptors.c **** 	        HID_RI_USAGE(8, 0x31), /* Usage Y */
  71:Descriptors.c **** 	        HID_RI_LOGICAL_MINIMUM(8, -1),
  72:Descriptors.c **** 	        HID_RI_LOGICAL_MAXIMUM(8, 1),
  73:Descriptors.c **** 	        HID_RI_PHYSICAL_MINIMUM(8, -1),
  74:Descriptors.c **** 	        HID_RI_PHYSICAL_MAXIMUM(8, 1),
  75:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x02),
  76:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x08),
  77:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_RELATIVE),
  78:Descriptors.c **** 	    HID_RI_END_COLLECTION(0),
  79:Descriptors.c **** 	HID_RI_END_COLLECTION(0),
  80:Descriptors.c **** 	
  81:Descriptors.c **** 	/* Keyboard Report */
  82:Descriptors.c **** 	HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  83:Descriptors.c **** 	HID_RI_USAGE(8, 0x06), /* Keyboard */
  84:Descriptors.c **** 	HID_RI_COLLECTION(8, 0x01), /* Application */
  85:Descriptors.c **** 		HID_RI_REPORT_ID(8, HID_REPORTID_KeyboardReport),
  86:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x07), /* Key Codes */
  87:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0xE0), /* Keyboard Left Control */
  88:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0xE7), /* Keyboard Right GUI */
  89:Descriptors.c **** 	    HID_RI_LOGICAL_MINIMUM(8, 0x00),
  90:Descriptors.c **** 	    HID_RI_LOGICAL_MAXIMUM(8, 0x01),
  91:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x01),
  92:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x08),
  93:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE),
  94:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x01),
  95:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x08),
  96:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_CONSTANT),
  97:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x08), /* LEDs */
  98:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0x01), /* Num Lock */
  99:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0x05), /* Kana */
 100:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x05),
 101:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x01),
 102:Descriptors.c **** 	    HID_RI_OUTPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE | HID_IOF_NON_VOLATILE),
 103:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x01),
 104:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x03),
 105:Descriptors.c **** 	    HID_RI_OUTPUT(8, HID_IOF_CONSTANT),
 106:Descriptors.c **** 	    HID_RI_LOGICAL_MINIMUM(8, 0x00),
 107:Descriptors.c **** 	    HID_RI_LOGICAL_MAXIMUM(8, 0x65),
 108:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x07), /* Keyboard */
 109:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0x00), /* Reserved (no event indicated) */
 110:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0x65), /* Keyboard Application */
 111:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x06),
 112:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x08),
 113:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_ARRAY | HID_IOF_ABSOLUTE),
 114:Descriptors.c **** 	HID_RI_END_COLLECTION(0),
 115:Descriptors.c **** };
 116:Descriptors.c **** 
 117:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
 118:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
 119:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
 120:Descriptors.c ****  *  process begins.
 121:Descriptors.c ****  */
 122:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
 123:Descriptors.c **** {
 124:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
 125:Descriptors.c **** 
 126:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
 127:Descriptors.c **** 	.Class                  = USB_CSCP_NoDeviceClass,
 128:Descriptors.c **** 	.SubClass               = USB_CSCP_NoDeviceSubclass,
 129:Descriptors.c **** 	.Protocol               = USB_CSCP_NoDeviceProtocol,
 130:Descriptors.c **** 
 131:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
 132:Descriptors.c **** 
 133:Descriptors.c **** 	.VendorID               = 0x03EB,
 134:Descriptors.c **** 	.ProductID              = 0x2066,
 135:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
 136:Descriptors.c **** 
 137:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
 138:Descriptors.c **** 	.ProductStrIndex        = 0x02,
 139:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
 140:Descriptors.c **** 
 141:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
 142:Descriptors.c **** };
 143:Descriptors.c **** 
 144:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
 145:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
 146:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 147:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 148:Descriptors.c ****  */
 149:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
 150:Descriptors.c **** {
 151:Descriptors.c **** 	.Config =
 152:Descriptors.c **** 		{
 153:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 154:Descriptors.c **** 
 155:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 156:Descriptors.c **** 			.TotalInterfaces        = 1,
 157:Descriptors.c **** 
 158:Descriptors.c **** 			.ConfigurationNumber    = 1,
 159:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 160:Descriptors.c **** 
 161:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 162:Descriptors.c **** 
 163:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 164:Descriptors.c **** 		},
 165:Descriptors.c **** 
 166:Descriptors.c **** 	.HID_Interface =
 167:Descriptors.c **** 		{
 168:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 169:Descriptors.c **** 
 170:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 171:Descriptors.c **** 			.AlternateSetting       = 0x00,
 172:Descriptors.c **** 
 173:Descriptors.c **** 			.TotalEndpoints         = 1,
 174:Descriptors.c **** 
 175:Descriptors.c **** 			.Class                  = HID_CSCP_HIDClass,
 176:Descriptors.c **** 			.SubClass               = HID_CSCP_NonBootSubclass,
 177:Descriptors.c **** 			.Protocol               = HID_CSCP_NonBootProtocol,
 178:Descriptors.c **** 
 179:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 180:Descriptors.c **** 		},
 181:Descriptors.c **** 
 182:Descriptors.c **** 	.HID_HIDData =
 183:Descriptors.c **** 		{
 184:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_HID_t), .Type = HID_DTYPE_HID},
 185:Descriptors.c **** 
 186:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 187:Descriptors.c **** 			.CountryCode            = 0x00,
 188:Descriptors.c **** 			.TotalReportDescriptors = 1,
 189:Descriptors.c **** 			.HIDReportType          = HID_DTYPE_Report,
 190:Descriptors.c **** 			.HIDReportLength        = sizeof(HIDReport)
 191:Descriptors.c **** 		},
 192:Descriptors.c **** 
 193:Descriptors.c **** 	.HID_ReportINEndpoint =
 194:Descriptors.c **** 		{
 195:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 196:Descriptors.c **** 
 197:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | HID_IN_EPNUM),
 198:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 199:Descriptors.c **** 			.EndpointSize           = HID_EPSIZE,
 200:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 201:Descriptors.c **** 		},
 202:Descriptors.c **** };
 203:Descriptors.c **** 
 204:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 205:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 206:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 207:Descriptors.c ****  */
 208:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 209:Descriptors.c **** {
 210:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 211:Descriptors.c **** 
 212:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 213:Descriptors.c **** };
 214:Descriptors.c **** 
 215:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 216:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 217:Descriptors.c ****  *  Descriptor.
 218:Descriptors.c ****  */
 219:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 220:Descriptors.c **** {
 221:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(11), .Type = DTYPE_String},
 222:Descriptors.c **** 
 223:Descriptors.c **** 	.UnicodeString          = L"Dean Camera"
 224:Descriptors.c **** };
 225:Descriptors.c **** 
 226:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 227:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 228:Descriptors.c ****  *  Descriptor.
 229:Descriptors.c ****  */
 230:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 231:Descriptors.c **** {
 232:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(26), .Type = DTYPE_String},
 233:Descriptors.c **** 
 234:Descriptors.c **** 	.UnicodeString          = L"LUFA Multi HID Report Demo"
 235:Descriptors.c **** };
 236:Descriptors.c **** 
 237:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 238:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 239:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 240:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 241:Descriptors.c ****  *  USB host.
 242:Descriptors.c ****  */
 243:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 244:Descriptors.c ****                                     const uint8_t wIndex,
 245:Descriptors.c ****                                     const void** const DescriptorAddress)
 246:Descriptors.c **** {
  17               		.loc 1 246 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 247:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 248:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 249:Descriptors.c **** 
 250:Descriptors.c **** 	const void* Address = NULL;
 251:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 252:Descriptors.c **** 
 253:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 253 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2330      		cpi r18,3
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 00F4      		brsh .L4
  31 000c 2130      		cpi r18,1
  32 000e 3105      		cpc r19,__zero_reg__
  33 0010 01F0      		breq .L5
  34 0012 2230      		cpi r18,2
  35 0014 3105      		cpc r19,__zero_reg__
  36 0016 01F4      		brne .L14
  37               	.LVL1:
 254:Descriptors.c **** 	{
 255:Descriptors.c **** 		case DTYPE_Device:
 256:Descriptors.c **** 			Address = &DeviceDescriptor;
 257:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 258:Descriptors.c **** 			break;
 259:Descriptors.c **** 		case DTYPE_Configuration:
 260:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 261:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  38               		.loc 1 261 0
  39 0018 82E2      		ldi r24,lo8(34)
  40 001a 90E0      		ldi r25,0
  41               	.LVL2:
 260:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  42               		.loc 1 260 0
  43 001c 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  44 001e 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 262:Descriptors.c **** 			break;
  45               		.loc 1 262 0
  46 0020 00C0      		rjmp .L2
  47               	.LVL3:
  48               	.L4:
 253:Descriptors.c **** 	{
  49               		.loc 1 253 0
  50 0022 2132      		cpi r18,33
  51 0024 3105      		cpc r19,__zero_reg__
  52 0026 01F0      		breq .L7
  53 0028 2232      		cpi r18,34
  54 002a 3105      		cpc r19,__zero_reg__
  55 002c 01F4      		brne .L14
  56               	.LVL4:
 263:Descriptors.c **** 		case DTYPE_String:
 264:Descriptors.c **** 			switch (DescriptorNumber)
 265:Descriptors.c **** 			{
 266:Descriptors.c **** 				case 0x00:
 267:Descriptors.c **** 					Address = &LanguageString;
 268:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 269:Descriptors.c **** 					break;
 270:Descriptors.c **** 				case 0x01:
 271:Descriptors.c **** 					Address = &ManufacturerString;
 272:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 273:Descriptors.c **** 					break;
 274:Descriptors.c **** 				case 0x02:
 275:Descriptors.c **** 					Address = &ProductString;
 276:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 277:Descriptors.c **** 					break;
 278:Descriptors.c **** 			}
 279:Descriptors.c **** 
 280:Descriptors.c **** 			break;
 281:Descriptors.c **** 		case HID_DTYPE_HID:
 282:Descriptors.c **** 			Address = &ConfigurationDescriptor.HID_HIDData;
 283:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);			
 284:Descriptors.c **** 			break;
 285:Descriptors.c **** 		case HID_DTYPE_Report:
 286:Descriptors.c **** 			Address = &HIDReport;
 287:Descriptors.c **** 			Size    = sizeof(HIDReport);
  57               		.loc 1 287 0
  58 002e 89E7      		ldi r24,lo8(121)
  59 0030 90E0      		ldi r25,0
  60               	.LVL5:
 286:Descriptors.c **** 			Size    = sizeof(HIDReport);
  61               		.loc 1 286 0
  62 0032 20E0      		ldi r18,lo8(HIDReport)
  63 0034 30E0      		ldi r19,hi8(HIDReport)
 288:Descriptors.c **** 			break;
  64               		.loc 1 288 0
  65 0036 00C0      		rjmp .L2
  66               	.LVL6:
  67               	.L5:
 257:Descriptors.c **** 			break;
  68               		.loc 1 257 0
  69 0038 82E1      		ldi r24,lo8(18)
  70 003a 90E0      		ldi r25,0
  71               	.LVL7:
 256:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  72               		.loc 1 256 0
  73 003c 20E0      		ldi r18,lo8(DeviceDescriptor)
  74 003e 30E0      		ldi r19,hi8(DeviceDescriptor)
  75 0040 00C0      		rjmp .L2
  76               	.LVL8:
  77               	.L3:
 264:Descriptors.c **** 			{
  78               		.loc 1 264 0
  79 0042 9927      		clr r25
  80               	.LVL9:
  81 0044 8130      		cpi r24,1
  82 0046 9105      		cpc r25,__zero_reg__
  83 0048 01F0      		breq .L9
  84 004a 00F0      		brlo .L10
  85 004c 0297      		sbiw r24,2
  86 004e 01F4      		brne .L14
  87               	.LVL10:
  88               	.LBB2:
 276:Descriptors.c **** 					break;
  89               		.loc 1 276 0
  90 0050 E0E0      		ldi r30,lo8(ProductString)
  91 0052 F0E0      		ldi r31,hi8(ProductString)
  92 0054 00C0      		rjmp .L15
  93               	.LVL11:
  94               	.L10:
  95               	.LBE2:
  96               	.LBB3:
 268:Descriptors.c **** 					break;
  97               		.loc 1 268 0
  98 0056 E0E0      		ldi r30,lo8(LanguageString)
  99 0058 F0E0      		ldi r31,hi8(LanguageString)
 100 005a 00C0      		rjmp .L15
 101               	.LVL12:
 102               	.L9:
 103               	.LBE3:
 104               	.LBB4:
 272:Descriptors.c **** 					break;
 105               		.loc 1 272 0
 106 005c E0E0      		ldi r30,lo8(ManufacturerString)
 107 005e F0E0      		ldi r31,hi8(ManufacturerString)
 108               	.LVL13:
 109               	.L15:
 110               	.LBE4:
 111               	.LBB5:
 276:Descriptors.c **** 					break;
 112               		.loc 1 276 0
 113               	/* #APP */
 114               	 ;  276 "Descriptors.c" 1
 115 0060 8491      		lpm r24, Z
 116               		
 117               	 ;  0 "" 2
 118               	.LVL14:
 119               	/* #NOAPP */
 120               	.LBE5:
 121 0062 90E0      		ldi r25,0
 122               	.LVL15:
 275:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 123               		.loc 1 275 0
 124 0064 9F01      		movw r18,r30
 277:Descriptors.c **** 			}
 125               		.loc 1 277 0
 126 0066 00C0      		rjmp .L2
 127               	.LVL16:
 128               	.L7:
 283:Descriptors.c **** 			break;
 129               		.loc 1 283 0
 130 0068 89E0      		ldi r24,lo8(9)
 131 006a 90E0      		ldi r25,0
 132               	.LVL17:
 282:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);			
 133               		.loc 1 282 0
 134 006c 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
 135 006e 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
 136               	.LVL18:
 284:Descriptors.c **** 		case HID_DTYPE_Report:
 137               		.loc 1 284 0
 138 0070 00C0      		rjmp .L2
 139               	.LVL19:
 140               	.L14:
 251:Descriptors.c **** 
 141               		.loc 1 251 0
 142 0072 80E0      		ldi r24,0
 143 0074 90E0      		ldi r25,0
 250:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 144               		.loc 1 250 0
 145 0076 20E0      		ldi r18,0
 146 0078 30E0      		ldi r19,0
 147               	.LVL20:
 148               	.L2:
 289:Descriptors.c **** 	}
 290:Descriptors.c **** 
 291:Descriptors.c **** 	*DescriptorAddress = Address;
 149               		.loc 1 291 0
 150 007a FA01      		movw r30,r20
 151 007c 3183      		std Z+1,r19
 152 007e 2083      		st Z,r18
 292:Descriptors.c **** 	return Size;
 293:Descriptors.c **** }
 153               		.loc 1 293 0
 154 0080 0895      		ret
 155               		.cfi_endproc
 156               	.LFE97:
 158               	.global	ProductString
 159               		.section	.progmem.data,"a",@progbits
 162               	ProductString:
 163 0000 36        		.byte	54
 164 0001 03        		.byte	3
 165 0002 4C00      		.string	"L"
 166 0004 5500      		.string	"U"
 167 0006 4600      		.string	"F"
 168 0008 4100      		.string	"A"
 169 000a 2000      		.string	" "
 170 000c 4D00      		.string	"M"
 171 000e 7500      		.string	"u"
 172 0010 6C00      		.string	"l"
 173 0012 7400      		.string	"t"
 174 0014 6900      		.string	"i"
 175 0016 2000      		.string	" "
 176 0018 4800      		.string	"H"
 177 001a 4900      		.string	"I"
 178 001c 4400      		.string	"D"
 179 001e 2000      		.string	" "
 180 0020 5200      		.string	"R"
 181 0022 6500      		.string	"e"
 182 0024 7000      		.string	"p"
 183 0026 6F00      		.string	"o"
 184 0028 7200      		.string	"r"
 185 002a 7400      		.string	"t"
 186 002c 2000      		.string	" "
 187 002e 4400      		.string	"D"
 188 0030 6500      		.string	"e"
 189 0032 6D00      		.string	"m"
 190 0034 6F00      		.string	"o"
 191 0036 00        		.string	""
 192 0037 00        		.string	""
 193               	.global	ManufacturerString
 196               	ManufacturerString:
 197 0038 18        		.byte	24
 198 0039 03        		.byte	3
 199 003a 4400      		.string	"D"
 200 003c 6500      		.string	"e"
 201 003e 6100      		.string	"a"
 202 0040 6E00      		.string	"n"
 203 0042 2000      		.string	" "
 204 0044 4300      		.string	"C"
 205 0046 6100      		.string	"a"
 206 0048 6D00      		.string	"m"
 207 004a 6500      		.string	"e"
 208 004c 7200      		.string	"r"
 209 004e 6100      		.string	"a"
 210 0050 00        		.string	""
 211 0051 00        		.string	""
 212               	.global	LanguageString
 215               	LanguageString:
 216 0052 04        		.byte	4
 217 0053 03        		.byte	3
 218 0054 0904      		.word	1033
 219               	.global	ConfigurationDescriptor
 222               	ConfigurationDescriptor:
 223 0056 09        		.byte	9
 224 0057 02        		.byte	2
 225 0058 2200      		.word	34
 226 005a 01        		.byte	1
 227 005b 01        		.byte	1
 228 005c 00        		.byte	0
 229 005d C0        		.byte	-64
 230 005e 32        		.byte	50
 231 005f 09        		.byte	9
 232 0060 04        		.byte	4
 233 0061 00        		.byte	0
 234 0062 00        		.byte	0
 235 0063 01        		.byte	1
 236 0064 03        		.byte	3
 237 0065 00        		.byte	0
 238 0066 00        		.byte	0
 239 0067 00        		.byte	0
 240 0068 09        		.byte	9
 241 0069 21        		.byte	33
 242 006a 1101      		.word	273
 243 006c 00        		.byte	0
 244 006d 01        		.byte	1
 245 006e 22        		.byte	34
 246 006f 7900      		.word	121
 247 0071 07        		.byte	7
 248 0072 05        		.byte	5
 249 0073 81        		.byte	-127
 250 0074 03        		.byte	3
 251 0075 0800      		.word	8
 252 0077 01        		.byte	1
 253               	.global	DeviceDescriptor
 256               	DeviceDescriptor:
 257 0078 12        		.byte	18
 258 0079 01        		.byte	1
 259 007a 1001      		.word	272
 260 007c 00        		.byte	0
 261 007d 00        		.byte	0
 262 007e 00        		.byte	0
 263 007f 08        		.byte	8
 264 0080 EB03      		.word	1003
 265 0082 6620      		.word	8294
 266 0084 0100      		.word	1
 267 0086 01        		.byte	1
 268 0087 02        		.byte	2
 269 0088 00        		.byte	0
 270 0089 01        		.byte	1
 271               	.global	HIDReport
 274               	HIDReport:
 275 008a 05        		.byte	5
 276 008b 01        		.byte	1
 277 008c 09        		.byte	9
 278 008d 02        		.byte	2
 279 008e A1        		.byte	-95
 280 008f 01        		.byte	1
 281 0090 85        		.byte	-123
 282 0091 01        		.byte	1
 283 0092 09        		.byte	9
 284 0093 01        		.byte	1
 285 0094 A1        		.byte	-95
 286 0095 00        		.byte	0
 287 0096 05        		.byte	5
 288 0097 09        		.byte	9
 289 0098 19        		.byte	25
 290 0099 01        		.byte	1
 291 009a 29        		.byte	41
 292 009b 03        		.byte	3
 293 009c 15        		.byte	21
 294 009d 00        		.byte	0
 295 009e 25        		.byte	37
 296 009f 01        		.byte	1
 297 00a0 95        		.byte	-107
 298 00a1 03        		.byte	3
 299 00a2 75        		.byte	117
 300 00a3 01        		.byte	1
 301 00a4 81        		.byte	-127
 302 00a5 02        		.byte	2
 303 00a6 95        		.byte	-107
 304 00a7 01        		.byte	1
 305 00a8 75        		.byte	117
 306 00a9 05        		.byte	5
 307 00aa 81        		.byte	-127
 308 00ab 01        		.byte	1
 309 00ac 05        		.byte	5
 310 00ad 01        		.byte	1
 311 00ae 09        		.byte	9
 312 00af 30        		.byte	48
 313 00b0 09        		.byte	9
 314 00b1 31        		.byte	49
 315 00b2 15        		.byte	21
 316 00b3 FF        		.byte	-1
 317 00b4 25        		.byte	37
 318 00b5 01        		.byte	1
 319 00b6 35        		.byte	53
 320 00b7 FF        		.byte	-1
 321 00b8 45        		.byte	69
 322 00b9 01        		.byte	1
 323 00ba 95        		.byte	-107
 324 00bb 02        		.byte	2
 325 00bc 75        		.byte	117
 326 00bd 08        		.byte	8
 327 00be 81        		.byte	-127
 328 00bf 06        		.byte	6
 329 00c0 C0        		.byte	-64
 330 00c1 C0        		.byte	-64
 331 00c2 05        		.byte	5
 332 00c3 01        		.byte	1
 333 00c4 09        		.byte	9
 334 00c5 06        		.byte	6
 335 00c6 A1        		.byte	-95
 336 00c7 01        		.byte	1
 337 00c8 85        		.byte	-123
 338 00c9 02        		.byte	2
 339 00ca 05        		.byte	5
 340 00cb 07        		.byte	7
 341 00cc 19        		.byte	25
 342 00cd E0        		.byte	-32
 343 00ce 29        		.byte	41
 344 00cf E7        		.byte	-25
 345 00d0 15        		.byte	21
 346 00d1 00        		.byte	0
 347 00d2 25        		.byte	37
 348 00d3 01        		.byte	1
 349 00d4 75        		.byte	117
 350 00d5 01        		.byte	1
 351 00d6 95        		.byte	-107
 352 00d7 08        		.byte	8
 353 00d8 81        		.byte	-127
 354 00d9 02        		.byte	2
 355 00da 95        		.byte	-107
 356 00db 01        		.byte	1
 357 00dc 75        		.byte	117
 358 00dd 08        		.byte	8
 359 00de 81        		.byte	-127
 360 00df 01        		.byte	1
 361 00e0 05        		.byte	5
 362 00e1 08        		.byte	8
 363 00e2 19        		.byte	25
 364 00e3 01        		.byte	1
 365 00e4 29        		.byte	41
 366 00e5 05        		.byte	5
 367 00e6 95        		.byte	-107
 368 00e7 05        		.byte	5
 369 00e8 75        		.byte	117
 370 00e9 01        		.byte	1
 371 00ea 91        		.byte	-111
 372 00eb 02        		.byte	2
 373 00ec 95        		.byte	-107
 374 00ed 01        		.byte	1
 375 00ee 75        		.byte	117
 376 00ef 03        		.byte	3
 377 00f0 91        		.byte	-111
 378 00f1 01        		.byte	1
 379 00f2 15        		.byte	21
 380 00f3 00        		.byte	0
 381 00f4 25        		.byte	37
 382 00f5 65        		.byte	101
 383 00f6 05        		.byte	5
 384 00f7 07        		.byte	7
 385 00f8 19        		.byte	25
 386 00f9 00        		.byte	0
 387 00fa 29        		.byte	41
 388 00fb 65        		.byte	101
 389 00fc 95        		.byte	-107
 390 00fd 06        		.byte	6
 391 00fe 75        		.byte	117
 392 00ff 08        		.byte	8
 393 0100 81        		.byte	-127
 394 0101 00        		.byte	0
 395 0102 C0        		.byte	-64
 396               		.comm	HID_Report_IDs,1,1
 397               		.text
 398               	.Letext0:
 399               		.file 2 "/usr/lib/avr/include/stdint.h"
 400               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 401               		.file 4 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 402               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 403               		.file 6 "Descriptors.h"
 404               		.file 7 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccvMEhJa.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccvMEhJa.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccvMEhJa.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccvMEhJa.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccvMEhJa.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccvMEhJa.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccvMEhJa.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccvMEhJa.s:222    .progmem.data:0000000000000056 ConfigurationDescriptor
     /tmp/ccvMEhJa.s:274    .progmem.data:000000000000008a HIDReport
     /tmp/ccvMEhJa.s:256    .progmem.data:0000000000000078 DeviceDescriptor
     /tmp/ccvMEhJa.s:162    .progmem.data:0000000000000000 ProductString
     /tmp/ccvMEhJa.s:215    .progmem.data:0000000000000052 LanguageString
     /tmp/ccvMEhJa.s:196    .progmem.data:0000000000000038 ManufacturerString
                            *COM*:0000000000000001 HID_Report_IDs

UNDEFINED SYMBOLS
__do_clear_bss
