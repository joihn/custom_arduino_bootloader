   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB97:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c ****   Copyright 2010  Denver Gingerich (denver [at] ossguy [dot] com)
  12:Descriptors.c **** 
  13:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  14:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  15:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  16:Descriptors.c ****   all copies and that both that the copyright notice and this
  17:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  18:Descriptors.c ****   documentation, and that the name of the author not be used in
  19:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  20:Descriptors.c ****   software without specific, written prior permission.
  21:Descriptors.c **** 
  22:Descriptors.c ****   The author disclaim all warranties with regard to this
  23:Descriptors.c ****   software, including all implied warranties of merchantability
  24:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  25:Descriptors.c ****   special, indirect or consequential damages or any damages
  26:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  27:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  28:Descriptors.c ****   arising out of or in connection with the use or performance of
  29:Descriptors.c ****   this software.
  30:Descriptors.c **** */
  31:Descriptors.c **** 
  32:Descriptors.c **** /** \file
  33:Descriptors.c ****  *
  34:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  35:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  36:Descriptors.c ****  *  the device's capabilities and functions.
  37:Descriptors.c ****  */
  38:Descriptors.c **** 
  39:Descriptors.c **** #include "Descriptors.h"
  40:Descriptors.c **** 
  41:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  42:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  43:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  44:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  45:Descriptors.c ****  *  more details on HID report descriptors.
  46:Descriptors.c ****  */
  47:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM KeyboardReport[] =
  48:Descriptors.c **** {
  49:Descriptors.c **** 	HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  50:Descriptors.c **** 	HID_RI_USAGE(8, 0x06), /* Keyboard */
  51:Descriptors.c **** 	HID_RI_COLLECTION(8, 0x01), /* Application */
  52:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x07), /* Key Codes */
  53:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0xE0), /* Keyboard Left Control */
  54:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0xE7), /* Keyboard Right GUI */
  55:Descriptors.c **** 	    HID_RI_LOGICAL_MINIMUM(8, 0x00),
  56:Descriptors.c **** 	    HID_RI_LOGICAL_MAXIMUM(8, 0x01),
  57:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x01),
  58:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x08),
  59:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE),
  60:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x01),
  61:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x08),
  62:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_CONSTANT),
  63:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x08), /* LEDs */
  64:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0x01), /* Num Lock */
  65:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0x05), /* Kana */
  66:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x05),
  67:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x01),
  68:Descriptors.c **** 	    HID_RI_OUTPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE | HID_IOF_NON_VOLATILE),
  69:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x01),
  70:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x03),
  71:Descriptors.c **** 	    HID_RI_OUTPUT(8, HID_IOF_CONSTANT),
  72:Descriptors.c **** 	    HID_RI_LOGICAL_MINIMUM(8, 0x00),
  73:Descriptors.c **** 	    HID_RI_LOGICAL_MAXIMUM(8, 0x65),
  74:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x07), /* Keyboard */
  75:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0x00), /* Reserved (no event indicated) */
  76:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0x65), /* Keyboard Application */
  77:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x06),
  78:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x08),
  79:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_ARRAY | HID_IOF_ABSOLUTE),
  80:Descriptors.c **** 	HID_RI_END_COLLECTION(0),
  81:Descriptors.c **** };
  82:Descriptors.c **** 
  83:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  84:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  85:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  86:Descriptors.c ****  *  process begins.
  87:Descriptors.c ****  */
  88:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  89:Descriptors.c **** {
  90:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  91:Descriptors.c **** 
  92:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  93:Descriptors.c **** 	.Class                  = USB_CSCP_NoDeviceClass,
  94:Descriptors.c **** 	.SubClass               = USB_CSCP_NoDeviceSubclass,
  95:Descriptors.c **** 	.Protocol               = USB_CSCP_NoDeviceProtocol,
  96:Descriptors.c **** 
  97:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  98:Descriptors.c **** 
  99:Descriptors.c **** 	.VendorID               = 0x03EB,
 100:Descriptors.c **** 	.ProductID              = 0x2042,
 101:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
 102:Descriptors.c **** 
 103:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
 104:Descriptors.c **** 	.ProductStrIndex        = 0x02,
 105:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
 106:Descriptors.c **** 
 107:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
 108:Descriptors.c **** };
 109:Descriptors.c **** 
 110:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
 111:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
 112:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 113:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 114:Descriptors.c ****  */
 115:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
 116:Descriptors.c **** {
 117:Descriptors.c **** 	.Config =
 118:Descriptors.c **** 		{
 119:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 120:Descriptors.c **** 
 121:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 122:Descriptors.c **** 			.TotalInterfaces        = 1,
 123:Descriptors.c **** 
 124:Descriptors.c **** 			.ConfigurationNumber    = 1,
 125:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 126:Descriptors.c **** 
 127:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 128:Descriptors.c **** 
 129:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 130:Descriptors.c **** 		},
 131:Descriptors.c **** 
 132:Descriptors.c **** 	.HID_Interface =
 133:Descriptors.c **** 		{
 134:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 135:Descriptors.c **** 
 136:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 137:Descriptors.c **** 			.AlternateSetting       = 0x00,
 138:Descriptors.c **** 
 139:Descriptors.c **** 			.TotalEndpoints         = 2,
 140:Descriptors.c **** 
 141:Descriptors.c **** 			.Class                  = HID_CSCP_HIDClass,
 142:Descriptors.c **** 			.SubClass               = HID_CSCP_BootSubclass,
 143:Descriptors.c **** 			.Protocol               = HID_CSCP_KeyboardBootProtocol,
 144:Descriptors.c **** 
 145:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 146:Descriptors.c **** 		},
 147:Descriptors.c **** 
 148:Descriptors.c **** 	.HID_KeyboardHID =
 149:Descriptors.c **** 		{
 150:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_HID_t), .Type = HID_DTYPE_HID},
 151:Descriptors.c **** 
 152:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 153:Descriptors.c **** 			.CountryCode            = 0x00,
 154:Descriptors.c **** 			.TotalReportDescriptors = 1,
 155:Descriptors.c **** 			.HIDReportType          = HID_DTYPE_Report,
 156:Descriptors.c **** 			.HIDReportLength        = sizeof(KeyboardReport)
 157:Descriptors.c **** 		},
 158:Descriptors.c **** 
 159:Descriptors.c **** 	.HID_ReportINEndpoint =
 160:Descriptors.c **** 		{
 161:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 162:Descriptors.c **** 
 163:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | KEYBOARD_IN_EPNUM),
 164:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 165:Descriptors.c **** 			.EndpointSize           = KEYBOARD_EPSIZE,
 166:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 167:Descriptors.c **** 		},
 168:Descriptors.c **** 
 169:Descriptors.c **** 	.HID_ReportOUTEndpoint =
 170:Descriptors.c **** 		{
 171:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 172:Descriptors.c **** 
 173:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | KEYBOARD_OUT_EPNUM),
 174:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 175:Descriptors.c **** 			.EndpointSize           = KEYBOARD_EPSIZE,
 176:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 177:Descriptors.c **** 		}
 178:Descriptors.c **** };
 179:Descriptors.c **** 
 180:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 181:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 182:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 183:Descriptors.c ****  */
 184:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 185:Descriptors.c **** {
 186:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 187:Descriptors.c **** 
 188:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 189:Descriptors.c **** };
 190:Descriptors.c **** 
 191:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 192:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 193:Descriptors.c ****  *  Descriptor.
 194:Descriptors.c ****  */
 195:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 196:Descriptors.c **** {
 197:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(11), .Type = DTYPE_String},
 198:Descriptors.c **** 
 199:Descriptors.c **** 	.UnicodeString          = L"Dean Camera"
 200:Descriptors.c **** };
 201:Descriptors.c **** 
 202:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 203:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 204:Descriptors.c ****  *  Descriptor.
 205:Descriptors.c ****  */
 206:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 207:Descriptors.c **** {
 208:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(18), .Type = DTYPE_String},
 209:Descriptors.c **** 
 210:Descriptors.c **** 	.UnicodeString          = L"LUFA Keyboard Demo"
 211:Descriptors.c **** };
 212:Descriptors.c **** 
 213:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 214:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 215:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 216:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 217:Descriptors.c ****  *  USB host.
 218:Descriptors.c ****  */
 219:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 220:Descriptors.c ****                                     const uint8_t wIndex,
 221:Descriptors.c ****                                     const void** const DescriptorAddress)
 222:Descriptors.c **** {
  17               		.loc 1 222 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 223:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 224:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 225:Descriptors.c **** 
 226:Descriptors.c **** 	const void* Address = NULL;
 227:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 228:Descriptors.c **** 
 229:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 229 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2330      		cpi r18,3
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 00F4      		brsh .L4
  31 000c 2130      		cpi r18,1
  32 000e 3105      		cpc r19,__zero_reg__
  33 0010 01F0      		breq .L5
  34 0012 2230      		cpi r18,2
  35 0014 3105      		cpc r19,__zero_reg__
  36 0016 01F4      		brne .L14
  37               	.LVL1:
 230:Descriptors.c **** 	{
 231:Descriptors.c **** 		case DTYPE_Device:
 232:Descriptors.c **** 			Address = &DeviceDescriptor;
 233:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 234:Descriptors.c **** 			break;
 235:Descriptors.c **** 		case DTYPE_Configuration:
 236:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 237:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  38               		.loc 1 237 0
  39 0018 89E2      		ldi r24,lo8(41)
  40 001a 90E0      		ldi r25,0
  41               	.LVL2:
 236:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  42               		.loc 1 236 0
  43 001c 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  44 001e 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 238:Descriptors.c **** 			break;
  45               		.loc 1 238 0
  46 0020 00C0      		rjmp .L2
  47               	.LVL3:
  48               	.L4:
 229:Descriptors.c **** 	{
  49               		.loc 1 229 0
  50 0022 2132      		cpi r18,33
  51 0024 3105      		cpc r19,__zero_reg__
  52 0026 01F0      		breq .L7
  53 0028 2232      		cpi r18,34
  54 002a 3105      		cpc r19,__zero_reg__
  55 002c 01F4      		brne .L14
  56               	.LVL4:
 239:Descriptors.c **** 		case DTYPE_String:
 240:Descriptors.c **** 			switch (DescriptorNumber)
 241:Descriptors.c **** 			{
 242:Descriptors.c **** 				case 0x00:
 243:Descriptors.c **** 					Address = &LanguageString;
 244:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 245:Descriptors.c **** 					break;
 246:Descriptors.c **** 				case 0x01:
 247:Descriptors.c **** 					Address = &ManufacturerString;
 248:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 249:Descriptors.c **** 					break;
 250:Descriptors.c **** 				case 0x02:
 251:Descriptors.c **** 					Address = &ProductString;
 252:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 253:Descriptors.c **** 					break;
 254:Descriptors.c **** 			}
 255:Descriptors.c **** 
 256:Descriptors.c **** 			break;
 257:Descriptors.c **** 		case HID_DTYPE_HID:
 258:Descriptors.c **** 			Address = &ConfigurationDescriptor.HID_KeyboardHID;
 259:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);
 260:Descriptors.c **** 			break;
 261:Descriptors.c **** 		case HID_DTYPE_Report:
 262:Descriptors.c **** 			Address = &KeyboardReport;
 263:Descriptors.c **** 			Size    = sizeof(KeyboardReport);
  57               		.loc 1 263 0
  58 002e 8FE3      		ldi r24,lo8(63)
  59 0030 90E0      		ldi r25,0
  60               	.LVL5:
 262:Descriptors.c **** 			Size    = sizeof(KeyboardReport);
  61               		.loc 1 262 0
  62 0032 20E0      		ldi r18,lo8(KeyboardReport)
  63 0034 30E0      		ldi r19,hi8(KeyboardReport)
 264:Descriptors.c **** 			break;
  64               		.loc 1 264 0
  65 0036 00C0      		rjmp .L2
  66               	.LVL6:
  67               	.L5:
 233:Descriptors.c **** 			break;
  68               		.loc 1 233 0
  69 0038 82E1      		ldi r24,lo8(18)
  70 003a 90E0      		ldi r25,0
  71               	.LVL7:
 232:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  72               		.loc 1 232 0
  73 003c 20E0      		ldi r18,lo8(DeviceDescriptor)
  74 003e 30E0      		ldi r19,hi8(DeviceDescriptor)
  75 0040 00C0      		rjmp .L2
  76               	.LVL8:
  77               	.L3:
 240:Descriptors.c **** 			{
  78               		.loc 1 240 0
  79 0042 9927      		clr r25
  80               	.LVL9:
  81 0044 8130      		cpi r24,1
  82 0046 9105      		cpc r25,__zero_reg__
  83 0048 01F0      		breq .L9
  84 004a 00F0      		brlo .L10
  85 004c 0297      		sbiw r24,2
  86 004e 01F4      		brne .L14
  87               	.LVL10:
  88               	.LBB2:
 252:Descriptors.c **** 					break;
  89               		.loc 1 252 0
  90 0050 E0E0      		ldi r30,lo8(ProductString)
  91 0052 F0E0      		ldi r31,hi8(ProductString)
  92 0054 00C0      		rjmp .L15
  93               	.LVL11:
  94               	.L10:
  95               	.LBE2:
  96               	.LBB3:
 244:Descriptors.c **** 					break;
  97               		.loc 1 244 0
  98 0056 E0E0      		ldi r30,lo8(LanguageString)
  99 0058 F0E0      		ldi r31,hi8(LanguageString)
 100 005a 00C0      		rjmp .L15
 101               	.LVL12:
 102               	.L9:
 103               	.LBE3:
 104               	.LBB4:
 248:Descriptors.c **** 					break;
 105               		.loc 1 248 0
 106 005c E0E0      		ldi r30,lo8(ManufacturerString)
 107 005e F0E0      		ldi r31,hi8(ManufacturerString)
 108               	.LVL13:
 109               	.L15:
 110               	.LBE4:
 111               	.LBB5:
 252:Descriptors.c **** 					break;
 112               		.loc 1 252 0
 113               	/* #APP */
 114               	 ;  252 "Descriptors.c" 1
 115 0060 8491      		lpm r24, Z
 116               		
 117               	 ;  0 "" 2
 118               	.LVL14:
 119               	/* #NOAPP */
 120               	.LBE5:
 121 0062 90E0      		ldi r25,0
 122               	.LVL15:
 251:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 123               		.loc 1 251 0
 124 0064 9F01      		movw r18,r30
 253:Descriptors.c **** 			}
 125               		.loc 1 253 0
 126 0066 00C0      		rjmp .L2
 127               	.LVL16:
 128               	.L7:
 259:Descriptors.c **** 			break;
 129               		.loc 1 259 0
 130 0068 89E0      		ldi r24,lo8(9)
 131 006a 90E0      		ldi r25,0
 132               	.LVL17:
 258:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);
 133               		.loc 1 258 0
 134 006c 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
 135 006e 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
 136               	.LVL18:
 260:Descriptors.c **** 		case HID_DTYPE_Report:
 137               		.loc 1 260 0
 138 0070 00C0      		rjmp .L2
 139               	.LVL19:
 140               	.L14:
 227:Descriptors.c **** 
 141               		.loc 1 227 0
 142 0072 80E0      		ldi r24,0
 143 0074 90E0      		ldi r25,0
 226:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 144               		.loc 1 226 0
 145 0076 20E0      		ldi r18,0
 146 0078 30E0      		ldi r19,0
 147               	.LVL20:
 148               	.L2:
 265:Descriptors.c **** 	}
 266:Descriptors.c **** 
 267:Descriptors.c **** 	*DescriptorAddress = Address;
 149               		.loc 1 267 0
 150 007a FA01      		movw r30,r20
 151 007c 3183      		std Z+1,r19
 152 007e 2083      		st Z,r18
 268:Descriptors.c **** 	return Size;
 269:Descriptors.c **** }
 153               		.loc 1 269 0
 154 0080 0895      		ret
 155               		.cfi_endproc
 156               	.LFE97:
 158               	.global	ProductString
 159               		.section	.progmem.data,"a",@progbits
 162               	ProductString:
 163 0000 26        		.byte	38
 164 0001 03        		.byte	3
 165 0002 4C00      		.string	"L"
 166 0004 5500      		.string	"U"
 167 0006 4600      		.string	"F"
 168 0008 4100      		.string	"A"
 169 000a 2000      		.string	" "
 170 000c 4B00      		.string	"K"
 171 000e 6500      		.string	"e"
 172 0010 7900      		.string	"y"
 173 0012 6200      		.string	"b"
 174 0014 6F00      		.string	"o"
 175 0016 6100      		.string	"a"
 176 0018 7200      		.string	"r"
 177 001a 6400      		.string	"d"
 178 001c 2000      		.string	" "
 179 001e 4400      		.string	"D"
 180 0020 6500      		.string	"e"
 181 0022 6D00      		.string	"m"
 182 0024 6F00      		.string	"o"
 183 0026 00        		.string	""
 184 0027 00        		.string	""
 185               	.global	ManufacturerString
 188               	ManufacturerString:
 189 0028 18        		.byte	24
 190 0029 03        		.byte	3
 191 002a 4400      		.string	"D"
 192 002c 6500      		.string	"e"
 193 002e 6100      		.string	"a"
 194 0030 6E00      		.string	"n"
 195 0032 2000      		.string	" "
 196 0034 4300      		.string	"C"
 197 0036 6100      		.string	"a"
 198 0038 6D00      		.string	"m"
 199 003a 6500      		.string	"e"
 200 003c 7200      		.string	"r"
 201 003e 6100      		.string	"a"
 202 0040 00        		.string	""
 203 0041 00        		.string	""
 204               	.global	LanguageString
 207               	LanguageString:
 208 0042 04        		.byte	4
 209 0043 03        		.byte	3
 210 0044 0904      		.word	1033
 211               	.global	ConfigurationDescriptor
 214               	ConfigurationDescriptor:
 215 0046 09        		.byte	9
 216 0047 02        		.byte	2
 217 0048 2900      		.word	41
 218 004a 01        		.byte	1
 219 004b 01        		.byte	1
 220 004c 00        		.byte	0
 221 004d C0        		.byte	-64
 222 004e 32        		.byte	50
 223 004f 09        		.byte	9
 224 0050 04        		.byte	4
 225 0051 00        		.byte	0
 226 0052 00        		.byte	0
 227 0053 02        		.byte	2
 228 0054 03        		.byte	3
 229 0055 01        		.byte	1
 230 0056 01        		.byte	1
 231 0057 00        		.byte	0
 232 0058 09        		.byte	9
 233 0059 21        		.byte	33
 234 005a 1101      		.word	273
 235 005c 00        		.byte	0
 236 005d 01        		.byte	1
 237 005e 22        		.byte	34
 238 005f 3F00      		.word	63
 239 0061 07        		.byte	7
 240 0062 05        		.byte	5
 241 0063 81        		.byte	-127
 242 0064 03        		.byte	3
 243 0065 0800      		.word	8
 244 0067 01        		.byte	1
 245 0068 07        		.byte	7
 246 0069 05        		.byte	5
 247 006a 02        		.byte	2
 248 006b 03        		.byte	3
 249 006c 0800      		.word	8
 250 006e 01        		.byte	1
 251               	.global	DeviceDescriptor
 254               	DeviceDescriptor:
 255 006f 12        		.byte	18
 256 0070 01        		.byte	1
 257 0071 1001      		.word	272
 258 0073 00        		.byte	0
 259 0074 00        		.byte	0
 260 0075 00        		.byte	0
 261 0076 08        		.byte	8
 262 0077 EB03      		.word	1003
 263 0079 4220      		.word	8258
 264 007b 0100      		.word	1
 265 007d 01        		.byte	1
 266 007e 02        		.byte	2
 267 007f 00        		.byte	0
 268 0080 01        		.byte	1
 269               	.global	KeyboardReport
 272               	KeyboardReport:
 273 0081 05        		.byte	5
 274 0082 01        		.byte	1
 275 0083 09        		.byte	9
 276 0084 06        		.byte	6
 277 0085 A1        		.byte	-95
 278 0086 01        		.byte	1
 279 0087 05        		.byte	5
 280 0088 07        		.byte	7
 281 0089 19        		.byte	25
 282 008a E0        		.byte	-32
 283 008b 29        		.byte	41
 284 008c E7        		.byte	-25
 285 008d 15        		.byte	21
 286 008e 00        		.byte	0
 287 008f 25        		.byte	37
 288 0090 01        		.byte	1
 289 0091 75        		.byte	117
 290 0092 01        		.byte	1
 291 0093 95        		.byte	-107
 292 0094 08        		.byte	8
 293 0095 81        		.byte	-127
 294 0096 02        		.byte	2
 295 0097 95        		.byte	-107
 296 0098 01        		.byte	1
 297 0099 75        		.byte	117
 298 009a 08        		.byte	8
 299 009b 81        		.byte	-127
 300 009c 01        		.byte	1
 301 009d 05        		.byte	5
 302 009e 08        		.byte	8
 303 009f 19        		.byte	25
 304 00a0 01        		.byte	1
 305 00a1 29        		.byte	41
 306 00a2 05        		.byte	5
 307 00a3 95        		.byte	-107
 308 00a4 05        		.byte	5
 309 00a5 75        		.byte	117
 310 00a6 01        		.byte	1
 311 00a7 91        		.byte	-111
 312 00a8 02        		.byte	2
 313 00a9 95        		.byte	-107
 314 00aa 01        		.byte	1
 315 00ab 75        		.byte	117
 316 00ac 03        		.byte	3
 317 00ad 91        		.byte	-111
 318 00ae 01        		.byte	1
 319 00af 15        		.byte	21
 320 00b0 00        		.byte	0
 321 00b1 25        		.byte	37
 322 00b2 65        		.byte	101
 323 00b3 05        		.byte	5
 324 00b4 07        		.byte	7
 325 00b5 19        		.byte	25
 326 00b6 00        		.byte	0
 327 00b7 29        		.byte	41
 328 00b8 65        		.byte	101
 329 00b9 95        		.byte	-107
 330 00ba 06        		.byte	6
 331 00bb 75        		.byte	117
 332 00bc 08        		.byte	8
 333 00bd 81        		.byte	-127
 334 00be 00        		.byte	0
 335 00bf C0        		.byte	-64
 336               		.text
 337               	.Letext0:
 338               		.file 2 "/usr/lib/avr/include/stdint.h"
 339               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 340               		.file 4 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 341               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 342               		.file 6 "Descriptors.h"
 343               		.file 7 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccBttjTR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccBttjTR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccBttjTR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccBttjTR.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccBttjTR.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccBttjTR.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccBttjTR.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccBttjTR.s:214    .progmem.data:0000000000000046 ConfigurationDescriptor
     /tmp/ccBttjTR.s:272    .progmem.data:0000000000000081 KeyboardReport
     /tmp/ccBttjTR.s:254    .progmem.data:000000000000006f DeviceDescriptor
     /tmp/ccBttjTR.s:162    .progmem.data:0000000000000000 ProductString
     /tmp/ccBttjTR.s:207    .progmem.data:0000000000000042 LanguageString
     /tmp/ccBttjTR.s:188    .progmem.data:0000000000000028 ManufacturerString

NO UNDEFINED SYMBOLS
