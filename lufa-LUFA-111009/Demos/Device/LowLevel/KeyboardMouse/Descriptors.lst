   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB97:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c ****   Copyright 2010  Denver Gingerich (denver [at] ossguy [dot] com)
  12:Descriptors.c **** 
  13:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  14:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  15:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  16:Descriptors.c ****   all copies and that both that the copyright notice and this
  17:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  18:Descriptors.c ****   documentation, and that the name of the author not be used in
  19:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  20:Descriptors.c ****   software without specific, written prior permission.
  21:Descriptors.c **** 
  22:Descriptors.c ****   The author disclaim all warranties with regard to this
  23:Descriptors.c ****   software, including all implied warranties of merchantability
  24:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  25:Descriptors.c ****   special, indirect or consequential damages or any damages
  26:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  27:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  28:Descriptors.c ****   arising out of or in connection with the use or performance of
  29:Descriptors.c ****   this software.
  30:Descriptors.c **** */
  31:Descriptors.c **** 
  32:Descriptors.c **** /** \file
  33:Descriptors.c ****  *
  34:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  35:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  36:Descriptors.c ****  *  the device's capabilities and functions.
  37:Descriptors.c ****  */
  38:Descriptors.c **** 
  39:Descriptors.c **** #include "Descriptors.h"
  40:Descriptors.c **** 
  41:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  42:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  43:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  44:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  45:Descriptors.c ****  *  more details on HID report descriptors.
  46:Descriptors.c ****  *
  47:Descriptors.c ****  *  This descriptor describes the mouse HID interface's report structure.
  48:Descriptors.c ****  */
  49:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM MouseReport[] =
  50:Descriptors.c **** {
  51:Descriptors.c **** 	HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  52:Descriptors.c **** 	HID_RI_USAGE(8, 0x02), /* Mouse */
  53:Descriptors.c **** 	HID_RI_COLLECTION(8, 0x01), /* Application */
  54:Descriptors.c **** 	    HID_RI_USAGE(8, 0x01), /* Pointer */
  55:Descriptors.c **** 	    HID_RI_COLLECTION(8, 0x00), /* Physical */
  56:Descriptors.c **** 	        HID_RI_USAGE_PAGE(8, 0x09), /* Button */
  57:Descriptors.c **** 	        HID_RI_USAGE_MINIMUM(8, 0x01),
  58:Descriptors.c **** 	        HID_RI_USAGE_MAXIMUM(8, 0x03),
  59:Descriptors.c **** 	        HID_RI_LOGICAL_MINIMUM(8, 0x00),
  60:Descriptors.c **** 	        HID_RI_LOGICAL_MAXIMUM(8, 0x01),
  61:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x03),
  62:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x01),
  63:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE),
  64:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x01),
  65:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x05),
  66:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_CONSTANT),
  67:Descriptors.c **** 	        HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  68:Descriptors.c **** 	        HID_RI_USAGE(8, 0x30), /* Usage X */
  69:Descriptors.c **** 	        HID_RI_USAGE(8, 0x31), /* Usage Y */
  70:Descriptors.c **** 	        HID_RI_LOGICAL_MINIMUM(8, -1),
  71:Descriptors.c **** 	        HID_RI_LOGICAL_MAXIMUM(8, 1),
  72:Descriptors.c **** 	        HID_RI_PHYSICAL_MINIMUM(8, -1),
  73:Descriptors.c **** 	        HID_RI_PHYSICAL_MAXIMUM(8, 1),
  74:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x02),
  75:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x08),
  76:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_RELATIVE),
  77:Descriptors.c **** 	    HID_RI_END_COLLECTION(0),
  78:Descriptors.c **** 	HID_RI_END_COLLECTION(0),
  79:Descriptors.c **** };
  80:Descriptors.c **** 
  81:Descriptors.c **** /** Same as the MouseReport structure, but defines the keyboard HID interface's report structure. *
  82:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM KeyboardReport[] =
  83:Descriptors.c **** {
  84:Descriptors.c **** 	HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  85:Descriptors.c **** 	HID_RI_USAGE(8, 0x06), /* Keyboard */
  86:Descriptors.c **** 	HID_RI_COLLECTION(8, 0x01), /* Application */
  87:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x07), /* Key Codes */
  88:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0xE0), /* Keyboard Left Control */
  89:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0xE7), /* Keyboard Right GUI */
  90:Descriptors.c **** 	    HID_RI_LOGICAL_MINIMUM(8, 0x00),
  91:Descriptors.c **** 	    HID_RI_LOGICAL_MAXIMUM(8, 0x01),
  92:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x01),
  93:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x08),
  94:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE),
  95:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x01),
  96:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x08),
  97:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_CONSTANT),
  98:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x08), /* LEDs */
  99:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0x01), /* Num Lock */
 100:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0x05), /* Kana */
 101:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x05),
 102:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x01),
 103:Descriptors.c **** 	    HID_RI_OUTPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE | HID_IOF_NON_VOLATILE),
 104:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x01),
 105:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x03),
 106:Descriptors.c **** 	    HID_RI_OUTPUT(8, HID_IOF_CONSTANT),
 107:Descriptors.c **** 	    HID_RI_LOGICAL_MINIMUM(8, 0x00),
 108:Descriptors.c **** 	    HID_RI_LOGICAL_MAXIMUM(8, 0x65),
 109:Descriptors.c **** 	    HID_RI_USAGE_PAGE(8, 0x07), /* Keyboard */
 110:Descriptors.c **** 	    HID_RI_USAGE_MINIMUM(8, 0x00), /* Reserved (no event indicated) */
 111:Descriptors.c **** 	    HID_RI_USAGE_MAXIMUM(8, 0x65), /* Keyboard Application */
 112:Descriptors.c **** 	    HID_RI_REPORT_COUNT(8, 0x06),
 113:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x08),
 114:Descriptors.c **** 	    HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_ARRAY | HID_IOF_ABSOLUTE),
 115:Descriptors.c **** 	HID_RI_END_COLLECTION(0),
 116:Descriptors.c **** };
 117:Descriptors.c **** 
 118:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
 119:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
 120:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
 121:Descriptors.c ****  *  process begins.
 122:Descriptors.c ****  */
 123:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
 124:Descriptors.c **** {
 125:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
 126:Descriptors.c **** 
 127:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
 128:Descriptors.c **** 	.Class                  = USB_CSCP_NoDeviceClass,
 129:Descriptors.c **** 	.SubClass               = USB_CSCP_NoDeviceSubclass,
 130:Descriptors.c **** 	.Protocol               = USB_CSCP_NoDeviceProtocol,
 131:Descriptors.c **** 
 132:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
 133:Descriptors.c **** 
 134:Descriptors.c **** 	.VendorID               = 0x03EB,
 135:Descriptors.c **** 	.ProductID              = 0x204D,
 136:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
 137:Descriptors.c **** 
 138:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
 139:Descriptors.c **** 	.ProductStrIndex        = 0x02,
 140:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
 141:Descriptors.c **** 
 142:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
 143:Descriptors.c **** };
 144:Descriptors.c **** 
 145:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
 146:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
 147:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 148:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 149:Descriptors.c ****  */
 150:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
 151:Descriptors.c **** {
 152:Descriptors.c **** 	.Config =
 153:Descriptors.c **** 		{
 154:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 155:Descriptors.c **** 
 156:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 157:Descriptors.c **** 			.TotalInterfaces        = 2,
 158:Descriptors.c **** 
 159:Descriptors.c **** 			.ConfigurationNumber    = 1,
 160:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 161:Descriptors.c **** 
 162:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 163:Descriptors.c **** 
 164:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 165:Descriptors.c **** 		},
 166:Descriptors.c **** 
 167:Descriptors.c **** 	.HID1_KeyboardInterface =
 168:Descriptors.c **** 		{
 169:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 170:Descriptors.c **** 
 171:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 172:Descriptors.c **** 			.AlternateSetting       = 0x00,
 173:Descriptors.c **** 
 174:Descriptors.c **** 			.TotalEndpoints         = 2,
 175:Descriptors.c **** 
 176:Descriptors.c **** 			.Class                  = HID_CSCP_HIDClass,
 177:Descriptors.c **** 			.SubClass               = HID_CSCP_BootSubclass,
 178:Descriptors.c **** 			.Protocol               = HID_CSCP_KeyboardBootProtocol,
 179:Descriptors.c **** 
 180:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 181:Descriptors.c **** 		},
 182:Descriptors.c **** 
 183:Descriptors.c **** 	.HID1_KeyboardHID =
 184:Descriptors.c **** 		{
 185:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_HID_t), .Type = HID_DTYPE_HID},
 186:Descriptors.c **** 
 187:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 188:Descriptors.c **** 			.CountryCode            = 0x00,
 189:Descriptors.c **** 			.TotalReportDescriptors = 1,
 190:Descriptors.c **** 			.HIDReportType          = HID_DTYPE_Report,
 191:Descriptors.c **** 			.HIDReportLength        = sizeof(KeyboardReport)
 192:Descriptors.c **** 		},
 193:Descriptors.c **** 
 194:Descriptors.c **** 	.HID1_ReportINEndpoint =
 195:Descriptors.c **** 		{
 196:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 197:Descriptors.c **** 
 198:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | KEYBOARD_IN_EPNUM),
 199:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 200:Descriptors.c **** 			.EndpointSize           = HID_EPSIZE,
 201:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 202:Descriptors.c **** 		},
 203:Descriptors.c **** 
 204:Descriptors.c **** 	.HID1_ReportOUTEndpoint =
 205:Descriptors.c **** 		{
 206:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 207:Descriptors.c **** 
 208:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | KEYBOARD_OUT_EPNUM),
 209:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 210:Descriptors.c **** 			.EndpointSize           = HID_EPSIZE,
 211:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 212:Descriptors.c **** 		},
 213:Descriptors.c **** 
 214:Descriptors.c **** 	.HID2_MouseInterface =
 215:Descriptors.c **** 		{
 216:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 217:Descriptors.c **** 
 218:Descriptors.c **** 			.InterfaceNumber        = 0x01,
 219:Descriptors.c **** 			.AlternateSetting       = 0x00,
 220:Descriptors.c **** 
 221:Descriptors.c **** 			.TotalEndpoints         = 1,
 222:Descriptors.c **** 
 223:Descriptors.c **** 			.Class                  = HID_CSCP_HIDClass,
 224:Descriptors.c **** 			.SubClass               = HID_CSCP_BootSubclass,
 225:Descriptors.c **** 			.Protocol               = HID_CSCP_MouseBootProtocol,
 226:Descriptors.c **** 
 227:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 228:Descriptors.c **** 		},
 229:Descriptors.c **** 
 230:Descriptors.c **** 	.HID2_MouseHID =
 231:Descriptors.c **** 		{
 232:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_HID_t), .Type = HID_DTYPE_HID},
 233:Descriptors.c **** 
 234:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 235:Descriptors.c **** 			.CountryCode            = 0x00,
 236:Descriptors.c **** 			.TotalReportDescriptors = 1,
 237:Descriptors.c **** 			.HIDReportType          = HID_DTYPE_Report,
 238:Descriptors.c **** 			.HIDReportLength        = sizeof(MouseReport)
 239:Descriptors.c **** 		},
 240:Descriptors.c **** 
 241:Descriptors.c **** 	.HID2_ReportINEndpoint =
 242:Descriptors.c **** 		{
 243:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 244:Descriptors.c **** 
 245:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | MOUSE_IN_EPNUM),
 246:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 247:Descriptors.c **** 			.EndpointSize           = HID_EPSIZE,
 248:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 249:Descriptors.c **** 		}
 250:Descriptors.c **** };
 251:Descriptors.c **** 
 252:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 253:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 254:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 255:Descriptors.c ****  */
 256:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 257:Descriptors.c **** {
 258:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 259:Descriptors.c **** 
 260:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 261:Descriptors.c **** };
 262:Descriptors.c **** 
 263:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 264:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 265:Descriptors.c ****  *  Descriptor.
 266:Descriptors.c ****  */
 267:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 268:Descriptors.c **** {
 269:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(11), .Type = DTYPE_String},
 270:Descriptors.c **** 
 271:Descriptors.c **** 	.UnicodeString          = L"Dean Camera"
 272:Descriptors.c **** };
 273:Descriptors.c **** 
 274:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 275:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 276:Descriptors.c ****  *  Descriptor.
 277:Descriptors.c ****  */
 278:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 279:Descriptors.c **** {
 280:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(28), .Type = DTYPE_String},
 281:Descriptors.c **** 
 282:Descriptors.c **** 	.UnicodeString          = L"LUFA Mouse and Keyboard Demo"
 283:Descriptors.c **** };
 284:Descriptors.c **** 
 285:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 286:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 287:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 288:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 289:Descriptors.c ****  *  USB host.
 290:Descriptors.c ****  */
 291:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 292:Descriptors.c ****                                     const uint8_t wIndex,
 293:Descriptors.c ****                                     const void** const DescriptorAddress)
 294:Descriptors.c **** {
  17               		.loc 1 294 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 295:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 296:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 297:Descriptors.c **** 
 298:Descriptors.c **** 	const void* Address = NULL;
 299:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 300:Descriptors.c **** 
 301:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 301 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2330      		cpi r18,3
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 00F4      		brsh .L4
  31 000c 2130      		cpi r18,1
  32 000e 3105      		cpc r19,__zero_reg__
  33 0010 01F0      		breq .L5
  34 0012 2230      		cpi r18,2
  35 0014 3105      		cpc r19,__zero_reg__
  36 0016 01F4      		brne .L16
  37               	.LVL1:
 302:Descriptors.c **** 	{
 303:Descriptors.c **** 		case DTYPE_Device:
 304:Descriptors.c **** 			Address = &DeviceDescriptor;
 305:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 306:Descriptors.c **** 			break;
 307:Descriptors.c **** 		case DTYPE_Configuration:
 308:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 309:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  38               		.loc 1 309 0
  39 0018 89E4      		ldi r24,lo8(73)
  40 001a 90E0      		ldi r25,0
  41               	.LVL2:
 308:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  42               		.loc 1 308 0
  43 001c 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  44 001e 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 310:Descriptors.c **** 			break;
  45               		.loc 1 310 0
  46 0020 00C0      		rjmp .L2
  47               	.LVL3:
  48               	.L4:
 301:Descriptors.c **** 	{
  49               		.loc 1 301 0
  50 0022 2132      		cpi r18,33
  51 0024 3105      		cpc r19,__zero_reg__
  52 0026 01F0      		breq .L7
  53 0028 2232      		cpi r18,34
  54 002a 3105      		cpc r19,__zero_reg__
  55 002c 01F0      		breq .L8
  56 002e 00C0      		rjmp .L16
  57               	.L5:
 305:Descriptors.c **** 			break;
  58               		.loc 1 305 0
  59 0030 82E1      		ldi r24,lo8(18)
  60 0032 90E0      		ldi r25,0
  61               	.LVL4:
 304:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  62               		.loc 1 304 0
  63 0034 20E0      		ldi r18,lo8(DeviceDescriptor)
  64 0036 30E0      		ldi r19,hi8(DeviceDescriptor)
  65 0038 00C0      		rjmp .L2
  66               	.LVL5:
  67               	.L3:
 311:Descriptors.c **** 		case DTYPE_String:
 312:Descriptors.c **** 			switch (DescriptorNumber)
  68               		.loc 1 312 0
  69 003a 9927      		clr r25
  70               	.LVL6:
  71 003c 8130      		cpi r24,1
  72 003e 9105      		cpc r25,__zero_reg__
  73 0040 01F0      		breq .L9
  74 0042 00F0      		brlo .L10
  75 0044 0297      		sbiw r24,2
  76 0046 01F4      		brne .L16
  77               	.LVL7:
  78               	.LBB2:
 313:Descriptors.c **** 			{
 314:Descriptors.c **** 				case 0x00:
 315:Descriptors.c **** 					Address = &LanguageString;
 316:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 317:Descriptors.c **** 					break;
 318:Descriptors.c **** 				case 0x01:
 319:Descriptors.c **** 					Address = &ManufacturerString;
 320:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 321:Descriptors.c **** 					break;
 322:Descriptors.c **** 				case 0x02:
 323:Descriptors.c **** 					Address = &ProductString;
 324:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
  79               		.loc 1 324 0
  80 0048 E0E0      		ldi r30,lo8(ProductString)
  81 004a F0E0      		ldi r31,hi8(ProductString)
  82 004c 00C0      		rjmp .L17
  83               	.LVL8:
  84               	.L10:
  85               	.LBE2:
  86               	.LBB3:
 316:Descriptors.c **** 					break;
  87               		.loc 1 316 0
  88 004e E0E0      		ldi r30,lo8(LanguageString)
  89 0050 F0E0      		ldi r31,hi8(LanguageString)
  90 0052 00C0      		rjmp .L17
  91               	.LVL9:
  92               	.L9:
  93               	.LBE3:
  94               	.LBB4:
 320:Descriptors.c **** 					break;
  95               		.loc 1 320 0
  96 0054 E0E0      		ldi r30,lo8(ManufacturerString)
  97 0056 F0E0      		ldi r31,hi8(ManufacturerString)
  98               	.LVL10:
  99               	.L17:
 100               	.LBE4:
 101               	.LBB5:
 102               		.loc 1 324 0
 103               	/* #APP */
 104               	 ;  324 "Descriptors.c" 1
 105 0058 8491      		lpm r24, Z
 106               		
 107               	 ;  0 "" 2
 108               	.LVL11:
 109               	/* #NOAPP */
 110               	.LBE5:
 111 005a 90E0      		ldi r25,0
 112               	.LVL12:
 323:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 113               		.loc 1 323 0
 114 005c 9F01      		movw r18,r30
 325:Descriptors.c **** 					break;
 115               		.loc 1 325 0
 116 005e 00C0      		rjmp .L2
 117               	.LVL13:
 118               	.L7:
 326:Descriptors.c **** 			}
 327:Descriptors.c **** 
 328:Descriptors.c **** 			break;
 329:Descriptors.c **** 		case HID_DTYPE_HID:
 330:Descriptors.c **** 			if (!(wIndex))
 331:Descriptors.c **** 			{
 332:Descriptors.c **** 				Address = &ConfigurationDescriptor.HID1_KeyboardHID;
 333:Descriptors.c **** 				Size    = sizeof(USB_HID_Descriptor_HID_t);
 119               		.loc 1 333 0
 120 0060 89E0      		ldi r24,lo8(9)
 121 0062 90E0      		ldi r25,0
 122               	.LVL14:
 330:Descriptors.c **** 			{
 123               		.loc 1 330 0
 124 0064 6623      		tst r22
 125 0066 01F0      		breq .L14
 334:Descriptors.c **** 			}
 335:Descriptors.c **** 			else
 336:Descriptors.c **** 			{
 337:Descriptors.c **** 				Address = &ConfigurationDescriptor.HID2_MouseHID;
 126               		.loc 1 337 0
 127 0068 20E0      		ldi r18,lo8(ConfigurationDescriptor+50)
 128 006a 30E0      		ldi r19,hi8(ConfigurationDescriptor+50)
 129 006c 00C0      		rjmp .L2
 130               	.LVL15:
 131               	.L8:
 338:Descriptors.c **** 				Size    = sizeof(USB_HID_Descriptor_HID_t);
 339:Descriptors.c **** 			}
 340:Descriptors.c **** 			break;
 341:Descriptors.c **** 		case HID_DTYPE_Report:
 342:Descriptors.c **** 			if (!(wIndex))
 132               		.loc 1 342 0
 133 006e 6623      		tst r22
 134 0070 01F0      		breq .L15
 343:Descriptors.c **** 			{
 344:Descriptors.c **** 				Address = &KeyboardReport;
 345:Descriptors.c **** 				Size    = sizeof(KeyboardReport);
 346:Descriptors.c **** 			}
 347:Descriptors.c **** 			else
 348:Descriptors.c **** 			{
 349:Descriptors.c **** 				Address = &MouseReport;
 350:Descriptors.c **** 				Size    = sizeof(MouseReport);
 135               		.loc 1 350 0
 136 0072 86E3      		ldi r24,lo8(54)
 137 0074 90E0      		ldi r25,0
 138               	.LVL16:
 349:Descriptors.c **** 				Size    = sizeof(MouseReport);
 139               		.loc 1 349 0
 140 0076 20E0      		ldi r18,lo8(MouseReport)
 141 0078 30E0      		ldi r19,hi8(MouseReport)
 142 007a 00C0      		rjmp .L2
 143               	.L16:
 299:Descriptors.c **** 
 144               		.loc 1 299 0
 145 007c 80E0      		ldi r24,0
 146 007e 90E0      		ldi r25,0
 298:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 147               		.loc 1 298 0
 148 0080 20E0      		ldi r18,0
 149 0082 30E0      		ldi r19,0
 150 0084 00C0      		rjmp .L2
 151               	.L14:
 332:Descriptors.c **** 				Size    = sizeof(USB_HID_Descriptor_HID_t);
 152               		.loc 1 332 0
 153 0086 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
 154 0088 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
 155 008a 00C0      		rjmp .L2
 156               	.LVL17:
 157               	.L15:
 345:Descriptors.c **** 			}
 158               		.loc 1 345 0
 159 008c 8FE3      		ldi r24,lo8(63)
 160 008e 90E0      		ldi r25,0
 161               	.LVL18:
 344:Descriptors.c **** 				Size    = sizeof(KeyboardReport);
 162               		.loc 1 344 0
 163 0090 20E0      		ldi r18,lo8(KeyboardReport)
 164 0092 30E0      		ldi r19,hi8(KeyboardReport)
 165               	.LVL19:
 166               	.L2:
 351:Descriptors.c **** 			}
 352:Descriptors.c **** 
 353:Descriptors.c **** 			break;
 354:Descriptors.c **** 	}
 355:Descriptors.c **** 
 356:Descriptors.c **** 	*DescriptorAddress = Address;
 167               		.loc 1 356 0
 168 0094 FA01      		movw r30,r20
 169 0096 3183      		std Z+1,r19
 170 0098 2083      		st Z,r18
 357:Descriptors.c **** 	return Size;
 358:Descriptors.c **** }
 171               		.loc 1 358 0
 172 009a 0895      		ret
 173               		.cfi_endproc
 174               	.LFE97:
 176               	.global	ProductString
 177               		.section	.progmem.data,"a",@progbits
 180               	ProductString:
 181 0000 3A        		.byte	58
 182 0001 03        		.byte	3
 183 0002 4C00      		.string	"L"
 184 0004 5500      		.string	"U"
 185 0006 4600      		.string	"F"
 186 0008 4100      		.string	"A"
 187 000a 2000      		.string	" "
 188 000c 4D00      		.string	"M"
 189 000e 6F00      		.string	"o"
 190 0010 7500      		.string	"u"
 191 0012 7300      		.string	"s"
 192 0014 6500      		.string	"e"
 193 0016 2000      		.string	" "
 194 0018 6100      		.string	"a"
 195 001a 6E00      		.string	"n"
 196 001c 6400      		.string	"d"
 197 001e 2000      		.string	" "
 198 0020 4B00      		.string	"K"
 199 0022 6500      		.string	"e"
 200 0024 7900      		.string	"y"
 201 0026 6200      		.string	"b"
 202 0028 6F00      		.string	"o"
 203 002a 6100      		.string	"a"
 204 002c 7200      		.string	"r"
 205 002e 6400      		.string	"d"
 206 0030 2000      		.string	" "
 207 0032 4400      		.string	"D"
 208 0034 6500      		.string	"e"
 209 0036 6D00      		.string	"m"
 210 0038 6F00      		.string	"o"
 211 003a 00        		.string	""
 212 003b 00        		.string	""
 213               	.global	ManufacturerString
 216               	ManufacturerString:
 217 003c 18        		.byte	24
 218 003d 03        		.byte	3
 219 003e 4400      		.string	"D"
 220 0040 6500      		.string	"e"
 221 0042 6100      		.string	"a"
 222 0044 6E00      		.string	"n"
 223 0046 2000      		.string	" "
 224 0048 4300      		.string	"C"
 225 004a 6100      		.string	"a"
 226 004c 6D00      		.string	"m"
 227 004e 6500      		.string	"e"
 228 0050 7200      		.string	"r"
 229 0052 6100      		.string	"a"
 230 0054 00        		.string	""
 231 0055 00        		.string	""
 232               	.global	LanguageString
 235               	LanguageString:
 236 0056 04        		.byte	4
 237 0057 03        		.byte	3
 238 0058 0904      		.word	1033
 239               	.global	ConfigurationDescriptor
 242               	ConfigurationDescriptor:
 243 005a 09        		.byte	9
 244 005b 02        		.byte	2
 245 005c 4900      		.word	73
 246 005e 02        		.byte	2
 247 005f 01        		.byte	1
 248 0060 00        		.byte	0
 249 0061 C0        		.byte	-64
 250 0062 32        		.byte	50
 251 0063 09        		.byte	9
 252 0064 04        		.byte	4
 253 0065 00        		.byte	0
 254 0066 00        		.byte	0
 255 0067 02        		.byte	2
 256 0068 03        		.byte	3
 257 0069 01        		.byte	1
 258 006a 01        		.byte	1
 259 006b 00        		.byte	0
 260 006c 09        		.byte	9
 261 006d 21        		.byte	33
 262 006e 1101      		.word	273
 263 0070 00        		.byte	0
 264 0071 01        		.byte	1
 265 0072 22        		.byte	34
 266 0073 3F00      		.word	63
 267 0075 07        		.byte	7
 268 0076 05        		.byte	5
 269 0077 81        		.byte	-127
 270 0078 03        		.byte	3
 271 0079 0800      		.word	8
 272 007b 01        		.byte	1
 273 007c 07        		.byte	7
 274 007d 05        		.byte	5
 275 007e 02        		.byte	2
 276 007f 03        		.byte	3
 277 0080 0800      		.word	8
 278 0082 01        		.byte	1
 279 0083 09        		.byte	9
 280 0084 04        		.byte	4
 281 0085 01        		.byte	1
 282 0086 00        		.byte	0
 283 0087 01        		.byte	1
 284 0088 03        		.byte	3
 285 0089 01        		.byte	1
 286 008a 02        		.byte	2
 287 008b 00        		.byte	0
 288 008c 09        		.byte	9
 289 008d 21        		.byte	33
 290 008e 1101      		.word	273
 291 0090 00        		.byte	0
 292 0091 01        		.byte	1
 293 0092 22        		.byte	34
 294 0093 3600      		.word	54
 295 0095 07        		.byte	7
 296 0096 05        		.byte	5
 297 0097 83        		.byte	-125
 298 0098 03        		.byte	3
 299 0099 0800      		.word	8
 300 009b 01        		.byte	1
 301 009c 0000 0000 		.zero	7
 301      0000 00
 302               	.global	DeviceDescriptor
 305               	DeviceDescriptor:
 306 00a3 12        		.byte	18
 307 00a4 01        		.byte	1
 308 00a5 1001      		.word	272
 309 00a7 00        		.byte	0
 310 00a8 00        		.byte	0
 311 00a9 00        		.byte	0
 312 00aa 08        		.byte	8
 313 00ab EB03      		.word	1003
 314 00ad 4D20      		.word	8269
 315 00af 0100      		.word	1
 316 00b1 01        		.byte	1
 317 00b2 02        		.byte	2
 318 00b3 00        		.byte	0
 319 00b4 01        		.byte	1
 320               	.global	KeyboardReport
 323               	KeyboardReport:
 324 00b5 05        		.byte	5
 325 00b6 01        		.byte	1
 326 00b7 09        		.byte	9
 327 00b8 06        		.byte	6
 328 00b9 A1        		.byte	-95
 329 00ba 01        		.byte	1
 330 00bb 05        		.byte	5
 331 00bc 07        		.byte	7
 332 00bd 19        		.byte	25
 333 00be E0        		.byte	-32
 334 00bf 29        		.byte	41
 335 00c0 E7        		.byte	-25
 336 00c1 15        		.byte	21
 337 00c2 00        		.byte	0
 338 00c3 25        		.byte	37
 339 00c4 01        		.byte	1
 340 00c5 75        		.byte	117
 341 00c6 01        		.byte	1
 342 00c7 95        		.byte	-107
 343 00c8 08        		.byte	8
 344 00c9 81        		.byte	-127
 345 00ca 02        		.byte	2
 346 00cb 95        		.byte	-107
 347 00cc 01        		.byte	1
 348 00cd 75        		.byte	117
 349 00ce 08        		.byte	8
 350 00cf 81        		.byte	-127
 351 00d0 01        		.byte	1
 352 00d1 05        		.byte	5
 353 00d2 08        		.byte	8
 354 00d3 19        		.byte	25
 355 00d4 01        		.byte	1
 356 00d5 29        		.byte	41
 357 00d6 05        		.byte	5
 358 00d7 95        		.byte	-107
 359 00d8 05        		.byte	5
 360 00d9 75        		.byte	117
 361 00da 01        		.byte	1
 362 00db 91        		.byte	-111
 363 00dc 02        		.byte	2
 364 00dd 95        		.byte	-107
 365 00de 01        		.byte	1
 366 00df 75        		.byte	117
 367 00e0 03        		.byte	3
 368 00e1 91        		.byte	-111
 369 00e2 01        		.byte	1
 370 00e3 15        		.byte	21
 371 00e4 00        		.byte	0
 372 00e5 25        		.byte	37
 373 00e6 65        		.byte	101
 374 00e7 05        		.byte	5
 375 00e8 07        		.byte	7
 376 00e9 19        		.byte	25
 377 00ea 00        		.byte	0
 378 00eb 29        		.byte	41
 379 00ec 65        		.byte	101
 380 00ed 95        		.byte	-107
 381 00ee 06        		.byte	6
 382 00ef 75        		.byte	117
 383 00f0 08        		.byte	8
 384 00f1 81        		.byte	-127
 385 00f2 00        		.byte	0
 386 00f3 C0        		.byte	-64
 387               	.global	MouseReport
 390               	MouseReport:
 391 00f4 05        		.byte	5
 392 00f5 01        		.byte	1
 393 00f6 09        		.byte	9
 394 00f7 02        		.byte	2
 395 00f8 A1        		.byte	-95
 396 00f9 01        		.byte	1
 397 00fa 09        		.byte	9
 398 00fb 01        		.byte	1
 399 00fc A1        		.byte	-95
 400 00fd 00        		.byte	0
 401 00fe 05        		.byte	5
 402 00ff 09        		.byte	9
 403 0100 19        		.byte	25
 404 0101 01        		.byte	1
 405 0102 29        		.byte	41
 406 0103 03        		.byte	3
 407 0104 15        		.byte	21
 408 0105 00        		.byte	0
 409 0106 25        		.byte	37
 410 0107 01        		.byte	1
 411 0108 95        		.byte	-107
 412 0109 03        		.byte	3
 413 010a 75        		.byte	117
 414 010b 01        		.byte	1
 415 010c 81        		.byte	-127
 416 010d 02        		.byte	2
 417 010e 95        		.byte	-107
 418 010f 01        		.byte	1
 419 0110 75        		.byte	117
 420 0111 05        		.byte	5
 421 0112 81        		.byte	-127
 422 0113 01        		.byte	1
 423 0114 05        		.byte	5
 424 0115 01        		.byte	1
 425 0116 09        		.byte	9
 426 0117 30        		.byte	48
 427 0118 09        		.byte	9
 428 0119 31        		.byte	49
 429 011a 15        		.byte	21
 430 011b FF        		.byte	-1
 431 011c 25        		.byte	37
 432 011d 01        		.byte	1
 433 011e 35        		.byte	53
 434 011f FF        		.byte	-1
 435 0120 45        		.byte	69
 436 0121 01        		.byte	1
 437 0122 95        		.byte	-107
 438 0123 02        		.byte	2
 439 0124 75        		.byte	117
 440 0125 08        		.byte	8
 441 0126 81        		.byte	-127
 442 0127 06        		.byte	6
 443 0128 C0        		.byte	-64
 444 0129 C0        		.byte	-64
 445               		.text
 446               	.Letext0:
 447               		.file 2 "/usr/lib/avr/include/stdint.h"
 448               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 449               		.file 4 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 450               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 451               		.file 6 "Descriptors.h"
 452               		.file 7 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccYO3Li3.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccYO3Li3.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccYO3Li3.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccYO3Li3.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccYO3Li3.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccYO3Li3.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccYO3Li3.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccYO3Li3.s:242    .progmem.data:000000000000005a ConfigurationDescriptor
     /tmp/ccYO3Li3.s:305    .progmem.data:00000000000000a3 DeviceDescriptor
     /tmp/ccYO3Li3.s:180    .progmem.data:0000000000000000 ProductString
     /tmp/ccYO3Li3.s:235    .progmem.data:0000000000000056 LanguageString
     /tmp/ccYO3Li3.s:216    .progmem.data:000000000000003c ManufacturerString
     /tmp/ccYO3Li3.s:390    .progmem.data:00000000000000f4 MouseReport
     /tmp/ccYO3Li3.s:323    .progmem.data:00000000000000b5 KeyboardReport

NO UNDEFINED SYMBOLS
