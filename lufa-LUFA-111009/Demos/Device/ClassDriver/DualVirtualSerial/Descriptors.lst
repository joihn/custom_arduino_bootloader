   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB97:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /* On some devices, there is a factory set internal serial number which can be automatically sent t
  41:Descriptors.c ****  * the device's serial number when the Device Descriptor's .SerialNumStrIndex entry is set to USE_I
  42:Descriptors.c ****  * This allows the host to track a device across insertions on different ports, allowing them to re
  43:Descriptors.c ****  * resources like COM port numbers and drivers. On demos using this feature, give a warning on unsu
  44:Descriptors.c ****  * so that the user can supply their own serial number descriptor instead or remove the USE_INTERNA
  45:Descriptors.c ****  * from the Device Descriptor (forcing the host to generate a serial number for each device from th
  46:Descriptors.c ****  * port location).
  47:Descriptors.c ****  */
  48:Descriptors.c **** #if (USE_INTERNAL_SERIAL == NO_DESCRIPTOR)
  49:Descriptors.c **** 	#warning USE_INTERNAL_SERIAL is not available on this AVR - please manually construct a device ser
  50:Descriptors.c **** #endif
  51:Descriptors.c **** 
  52:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  53:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  54:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  55:Descriptors.c ****  *  process begins.
  56:Descriptors.c ****  */
  57:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  58:Descriptors.c **** {
  59:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  60:Descriptors.c **** 
  61:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  62:Descriptors.c **** 	.Class                  = USB_CSCP_IADDeviceClass,
  63:Descriptors.c **** 	.SubClass               = USB_CSCP_IADDeviceSubclass,
  64:Descriptors.c **** 	.Protocol               = USB_CSCP_IADDeviceProtocol,
  65:Descriptors.c **** 
  66:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  67:Descriptors.c **** 
  68:Descriptors.c **** 	.VendorID               = 0x03EB,
  69:Descriptors.c **** 	.ProductID              = 0x204E,
  70:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
  71:Descriptors.c **** 
  72:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
  73:Descriptors.c **** 	.ProductStrIndex        = 0x02,
  74:Descriptors.c **** 	.SerialNumStrIndex      = USE_INTERNAL_SERIAL,
  75:Descriptors.c **** 
  76:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  77:Descriptors.c **** };
  78:Descriptors.c **** 
  79:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
  80:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
  81:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
  82:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
  83:Descriptors.c ****  */
  84:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
  85:Descriptors.c **** {
  86:Descriptors.c **** 	.Config =
  87:Descriptors.c **** 		{
  88:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
  89:Descriptors.c **** 
  90:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
  91:Descriptors.c **** 			.TotalInterfaces        = 4,
  92:Descriptors.c **** 
  93:Descriptors.c **** 			.ConfigurationNumber    = 1,
  94:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
  95:Descriptors.c **** 
  96:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
  97:Descriptors.c **** 
  98:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
  99:Descriptors.c **** 		},
 100:Descriptors.c **** 
 101:Descriptors.c **** 	.CDC1_IAD =
 102:Descriptors.c **** 		{
 103:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_Association_t), .Type = DTYPE
 104:Descriptors.c **** 
 105:Descriptors.c **** 			.FirstInterfaceIndex    = 0,
 106:Descriptors.c **** 			.TotalInterfaces        = 2,
 107:Descriptors.c **** 
 108:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCClass,
 109:Descriptors.c **** 			.SubClass               = CDC_CSCP_ACMSubclass,
 110:Descriptors.c **** 			.Protocol               = CDC_CSCP_ATCommandProtocol,
 111:Descriptors.c **** 
 112:Descriptors.c **** 			.IADStrIndex            = NO_DESCRIPTOR
 113:Descriptors.c **** 		},
 114:Descriptors.c **** 
 115:Descriptors.c **** 	.CDC1_CCI_Interface =
 116:Descriptors.c **** 		{
 117:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 118:Descriptors.c **** 
 119:Descriptors.c **** 			.InterfaceNumber        = 0,
 120:Descriptors.c **** 			.AlternateSetting       = 0,
 121:Descriptors.c **** 
 122:Descriptors.c **** 			.TotalEndpoints         = 1,
 123:Descriptors.c **** 
 124:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCClass,
 125:Descriptors.c **** 			.SubClass               = CDC_CSCP_ACMSubclass,
 126:Descriptors.c **** 			.Protocol               = CDC_CSCP_ATCommandProtocol,
 127:Descriptors.c **** 
 128:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 129:Descriptors.c **** 		},
 130:Descriptors.c **** 
 131:Descriptors.c **** 	.CDC1_Functional_Header =
 132:Descriptors.c **** 		{
 133:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalHeader_t), .Type = DTYPE_
 134:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_Header,
 135:Descriptors.c **** 
 136:Descriptors.c **** 			.CDCSpecification       = VERSION_BCD(01.10),
 137:Descriptors.c **** 		},
 138:Descriptors.c **** 
 139:Descriptors.c **** 	.CDC1_Functional_ACM =
 140:Descriptors.c **** 		{
 141:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalACM_t), .Type = DTYPE_CSI
 142:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_ACM,
 143:Descriptors.c **** 
 144:Descriptors.c **** 			.Capabilities           = 0x06,
 145:Descriptors.c **** 		},
 146:Descriptors.c **** 
 147:Descriptors.c **** 	.CDC1_Functional_Union =
 148:Descriptors.c **** 		{
 149:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalUnion_t), .Type = DTYPE_C
 150:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_Union,
 151:Descriptors.c **** 
 152:Descriptors.c **** 			.MasterInterfaceNumber  = 0,
 153:Descriptors.c **** 			.SlaveInterfaceNumber   = 1,
 154:Descriptors.c **** 		},
 155:Descriptors.c **** 
 156:Descriptors.c **** 	.CDC1_ManagementEndpoint =
 157:Descriptors.c **** 		{
 158:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 159:Descriptors.c **** 
 160:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC1_NOTIFICATION_EPNUM),
 161:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 162:Descriptors.c **** 			.EndpointSize           = CDC_NOTIFICATION_EPSIZE,
 163:Descriptors.c **** 			.PollingIntervalMS      = 0xFF
 164:Descriptors.c **** 		},
 165:Descriptors.c **** 
 166:Descriptors.c **** 	.CDC1_DCI_Interface =
 167:Descriptors.c **** 		{
 168:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 169:Descriptors.c **** 
 170:Descriptors.c **** 			.InterfaceNumber        = 1,
 171:Descriptors.c **** 			.AlternateSetting       = 0,
 172:Descriptors.c **** 
 173:Descriptors.c **** 			.TotalEndpoints         = 2,
 174:Descriptors.c **** 
 175:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCDataClass,
 176:Descriptors.c **** 			.SubClass               = CDC_CSCP_NoDataSubclass,
 177:Descriptors.c **** 			.Protocol               = CDC_CSCP_NoDataProtocol,
 178:Descriptors.c **** 
 179:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 180:Descriptors.c **** 		},
 181:Descriptors.c **** 
 182:Descriptors.c **** 	.CDC1_DataOutEndpoint =
 183:Descriptors.c **** 		{
 184:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 185:Descriptors.c **** 
 186:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | CDC1_RX_EPNUM),
 187:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 188:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 189:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 190:Descriptors.c **** 		},
 191:Descriptors.c **** 
 192:Descriptors.c **** 	.CDC1_DataInEndpoint =
 193:Descriptors.c **** 		{
 194:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 195:Descriptors.c **** 
 196:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC1_TX_EPNUM),
 197:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 198:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 199:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 200:Descriptors.c **** 		},
 201:Descriptors.c **** 
 202:Descriptors.c **** 	.CDC2_IAD =
 203:Descriptors.c **** 		{
 204:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_Association_t), .Type = DTYPE
 205:Descriptors.c **** 
 206:Descriptors.c **** 			.FirstInterfaceIndex    = 2,
 207:Descriptors.c **** 			.TotalInterfaces        = 2,
 208:Descriptors.c **** 
 209:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCClass,
 210:Descriptors.c **** 			.SubClass               = CDC_CSCP_ACMSubclass,
 211:Descriptors.c **** 			.Protocol               = CDC_CSCP_ATCommandProtocol,
 212:Descriptors.c **** 
 213:Descriptors.c **** 			.IADStrIndex            = NO_DESCRIPTOR
 214:Descriptors.c **** 		},
 215:Descriptors.c **** 
 216:Descriptors.c **** 	.CDC2_CCI_Interface =
 217:Descriptors.c **** 		{
 218:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 219:Descriptors.c **** 
 220:Descriptors.c **** 			.InterfaceNumber        = 2,
 221:Descriptors.c **** 			.AlternateSetting       = 0,
 222:Descriptors.c **** 
 223:Descriptors.c **** 			.TotalEndpoints         = 1,
 224:Descriptors.c **** 
 225:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCClass,
 226:Descriptors.c **** 			.SubClass               = CDC_CSCP_ACMSubclass,
 227:Descriptors.c **** 			.Protocol               = CDC_CSCP_ATCommandProtocol,
 228:Descriptors.c **** 
 229:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 230:Descriptors.c **** 		},
 231:Descriptors.c **** 
 232:Descriptors.c **** 	.CDC2_Functional_Header =
 233:Descriptors.c **** 		{
 234:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalHeader_t), .Type = DTYPE_
 235:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_Header,
 236:Descriptors.c **** 
 237:Descriptors.c **** 			.CDCSpecification       = VERSION_BCD(01.10),
 238:Descriptors.c **** 		},
 239:Descriptors.c **** 
 240:Descriptors.c **** 	.CDC2_Functional_ACM =
 241:Descriptors.c **** 		{
 242:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalACM_t), .Type = DTYPE_CSI
 243:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_ACM,
 244:Descriptors.c **** 
 245:Descriptors.c **** 			.Capabilities           = 0x06,
 246:Descriptors.c **** 		},
 247:Descriptors.c **** 
 248:Descriptors.c **** 	.CDC2_Functional_Union =
 249:Descriptors.c **** 		{
 250:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalUnion_t), .Type = DTYPE_C
 251:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_Union,
 252:Descriptors.c **** 
 253:Descriptors.c **** 			.MasterInterfaceNumber  = 2,
 254:Descriptors.c **** 			.SlaveInterfaceNumber   = 3,
 255:Descriptors.c **** 		},
 256:Descriptors.c **** 
 257:Descriptors.c **** 	.CDC2_ManagementEndpoint =
 258:Descriptors.c **** 		{
 259:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 260:Descriptors.c **** 
 261:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC2_NOTIFICATION_EPNUM),
 262:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 263:Descriptors.c **** 			.EndpointSize           = CDC_NOTIFICATION_EPSIZE,
 264:Descriptors.c **** 			.PollingIntervalMS      = 0xFF
 265:Descriptors.c **** 		},
 266:Descriptors.c **** 
 267:Descriptors.c **** 	.CDC2_DCI_Interface =
 268:Descriptors.c **** 		{
 269:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 270:Descriptors.c **** 
 271:Descriptors.c **** 			.InterfaceNumber        = 3,
 272:Descriptors.c **** 			.AlternateSetting       = 0,
 273:Descriptors.c **** 
 274:Descriptors.c **** 			.TotalEndpoints         = 2,
 275:Descriptors.c **** 
 276:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCDataClass,
 277:Descriptors.c **** 			.SubClass               = CDC_CSCP_NoDataSubclass,
 278:Descriptors.c **** 			.Protocol               = CDC_CSCP_NoDataProtocol,
 279:Descriptors.c **** 
 280:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 281:Descriptors.c **** 		},
 282:Descriptors.c **** 
 283:Descriptors.c **** 	.CDC2_DataOutEndpoint =
 284:Descriptors.c **** 		{
 285:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 286:Descriptors.c **** 
 287:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | CDC2_RX_EPNUM),
 288:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 289:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 290:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 291:Descriptors.c **** 		},
 292:Descriptors.c **** 
 293:Descriptors.c **** 	.CDC2_DataInEndpoint =
 294:Descriptors.c **** 		{
 295:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 296:Descriptors.c **** 
 297:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC2_TX_EPNUM),
 298:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 299:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 300:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 301:Descriptors.c **** 		}
 302:Descriptors.c **** };
 303:Descriptors.c **** 
 304:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 305:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 306:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 307:Descriptors.c ****  */
 308:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 309:Descriptors.c **** {
 310:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 311:Descriptors.c **** 
 312:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 313:Descriptors.c **** };
 314:Descriptors.c **** 
 315:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 316:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 317:Descriptors.c ****  *  Descriptor.
 318:Descriptors.c ****  */
 319:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 320:Descriptors.c **** {
 321:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(11), .Type = DTYPE_String},
 322:Descriptors.c **** 
 323:Descriptors.c **** 	.UnicodeString          = L"Dean Camera"
 324:Descriptors.c **** };
 325:Descriptors.c **** 
 326:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 327:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 328:Descriptors.c ****  *  Descriptor.
 329:Descriptors.c ****  */
 330:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 331:Descriptors.c **** {
 332:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(13), .Type = DTYPE_String},
 333:Descriptors.c **** 
 334:Descriptors.c **** 	.UnicodeString          = L"LUFA Dual CDC Demo"
 335:Descriptors.c **** };
 336:Descriptors.c **** 
 337:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 338:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 339:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 340:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 341:Descriptors.c ****  *  USB host.
 342:Descriptors.c ****  */
 343:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 344:Descriptors.c ****                                     const uint8_t wIndex,
 345:Descriptors.c ****                                     const void** const DescriptorAddress)
 346:Descriptors.c **** {
  17               		.loc 1 346 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 347:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 348:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 349:Descriptors.c **** 
 350:Descriptors.c **** 	const void* Address = NULL;
 351:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 352:Descriptors.c **** 
 353:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 353 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2230      		cpi r18,2
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 2330      		cpi r18,3
  31 000c 3105      		cpc r19,__zero_reg__
  32 000e 01F0      		breq .L4
  33 0010 2130      		cpi r18,1
  34 0012 3105      		cpc r19,__zero_reg__
  35 0014 01F4      		brne .L12
 354:Descriptors.c **** 	{
 355:Descriptors.c **** 		case DTYPE_Device:
 356:Descriptors.c **** 			Address = &DeviceDescriptor;
 357:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  36               		.loc 1 357 0
  37 0016 82E1      		ldi r24,lo8(18)
  38 0018 90E0      		ldi r25,0
  39               	.LVL1:
 356:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  40               		.loc 1 356 0
  41 001a 20E0      		ldi r18,lo8(DeviceDescriptor)
  42 001c 30E0      		ldi r19,hi8(DeviceDescriptor)
  43 001e 00C0      		rjmp .L2
  44               	.LVL2:
  45               	.L3:
 358:Descriptors.c **** 			break;
 359:Descriptors.c **** 		case DTYPE_Configuration:
 360:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 361:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  46               		.loc 1 361 0
  47 0020 83E8      		ldi r24,lo8(-125)
  48 0022 90E0      		ldi r25,0
  49               	.LVL3:
 360:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  50               		.loc 1 360 0
  51 0024 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  52 0026 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 362:Descriptors.c **** 			break;
  53               		.loc 1 362 0
  54 0028 00C0      		rjmp .L2
  55               	.LVL4:
  56               	.L4:
 363:Descriptors.c **** 		case DTYPE_String:
 364:Descriptors.c **** 			switch (DescriptorNumber)
  57               		.loc 1 364 0
  58 002a 9927      		clr r25
  59               	.LVL5:
  60 002c 8130      		cpi r24,1
  61 002e 9105      		cpc r25,__zero_reg__
  62 0030 01F0      		breq .L6
  63 0032 00F0      		brlo .L7
  64 0034 0297      		sbiw r24,2
  65 0036 01F4      		brne .L12
  66               	.LVL6:
  67               	.LBB2:
 365:Descriptors.c **** 			{
 366:Descriptors.c **** 				case 0x00:
 367:Descriptors.c **** 					Address = &LanguageString;
 368:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 369:Descriptors.c **** 					break;
 370:Descriptors.c **** 				case 0x01:
 371:Descriptors.c **** 					Address = &ManufacturerString;
 372:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 373:Descriptors.c **** 					break;
 374:Descriptors.c **** 				case 0x02:
 375:Descriptors.c **** 					Address = &ProductString;
 376:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
  68               		.loc 1 376 0
  69 0038 E0E0      		ldi r30,lo8(ProductString)
  70 003a F0E0      		ldi r31,hi8(ProductString)
  71 003c 00C0      		rjmp .L13
  72               	.LVL7:
  73               	.L7:
  74               	.LBE2:
  75               	.LBB3:
 368:Descriptors.c **** 					break;
  76               		.loc 1 368 0
  77 003e E0E0      		ldi r30,lo8(LanguageString)
  78 0040 F0E0      		ldi r31,hi8(LanguageString)
  79 0042 00C0      		rjmp .L13
  80               	.LVL8:
  81               	.L6:
  82               	.LBE3:
  83               	.LBB4:
 372:Descriptors.c **** 					break;
  84               		.loc 1 372 0
  85 0044 E0E0      		ldi r30,lo8(ManufacturerString)
  86 0046 F0E0      		ldi r31,hi8(ManufacturerString)
  87               	.LVL9:
  88               	.L13:
  89               	.LBE4:
  90               	.LBB5:
  91               		.loc 1 376 0
  92               	/* #APP */
  93               	 ;  376 "Descriptors.c" 1
  94 0048 8491      		lpm r24, Z
  95               		
  96               	 ;  0 "" 2
  97               	.LVL10:
  98               	/* #NOAPP */
  99               	.LBE5:
 100 004a 90E0      		ldi r25,0
 101               	.LVL11:
 375:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 102               		.loc 1 375 0
 103 004c 9F01      		movw r18,r30
 377:Descriptors.c **** 					break;
 104               		.loc 1 377 0
 105 004e 00C0      		rjmp .L2
 106               	.LVL12:
 107               	.L12:
 351:Descriptors.c **** 
 108               		.loc 1 351 0
 109 0050 80E0      		ldi r24,0
 110 0052 90E0      		ldi r25,0
 350:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 111               		.loc 1 350 0
 112 0054 20E0      		ldi r18,0
 113 0056 30E0      		ldi r19,0
 114               	.LVL13:
 115               	.L2:
 378:Descriptors.c **** 			}
 379:Descriptors.c **** 
 380:Descriptors.c **** 			break;
 381:Descriptors.c **** 	}
 382:Descriptors.c **** 
 383:Descriptors.c **** 	*DescriptorAddress = Address;
 116               		.loc 1 383 0
 117 0058 FA01      		movw r30,r20
 118 005a 3183      		std Z+1,r19
 119 005c 2083      		st Z,r18
 384:Descriptors.c **** 	return Size;
 385:Descriptors.c **** }
 120               		.loc 1 385 0
 121 005e 0895      		ret
 122               		.cfi_endproc
 123               	.LFE97:
 125               	.global	ProductString
 126               		.section	.progmem.data,"a",@progbits
 129               	ProductString:
 130 0000 1C        		.byte	28
 131 0001 03        		.byte	3
 132 0002 4C00      		.string	"L"
 133 0004 5500      		.string	"U"
 134 0006 4600      		.string	"F"
 135 0008 4100      		.string	"A"
 136 000a 2000      		.string	" "
 137 000c 4400      		.string	"D"
 138 000e 7500      		.string	"u"
 139 0010 6100      		.string	"a"
 140 0012 6C00      		.string	"l"
 141 0014 2000      		.string	" "
 142 0016 4300      		.string	"C"
 143 0018 4400      		.string	"D"
 144 001a 4300      		.string	"C"
 145 001c 2000      		.string	" "
 146 001e 4400      		.string	"D"
 147 0020 6500      		.string	"e"
 148 0022 6D00      		.string	"m"
 149 0024 6F00      		.string	"o"
 150 0026 00        		.string	""
 151 0027 00        		.string	""
 152               	.global	ManufacturerString
 155               	ManufacturerString:
 156 0028 18        		.byte	24
 157 0029 03        		.byte	3
 158 002a 4400      		.string	"D"
 159 002c 6500      		.string	"e"
 160 002e 6100      		.string	"a"
 161 0030 6E00      		.string	"n"
 162 0032 2000      		.string	" "
 163 0034 4300      		.string	"C"
 164 0036 6100      		.string	"a"
 165 0038 6D00      		.string	"m"
 166 003a 6500      		.string	"e"
 167 003c 7200      		.string	"r"
 168 003e 6100      		.string	"a"
 169 0040 00        		.string	""
 170 0041 00        		.string	""
 171               	.global	LanguageString
 174               	LanguageString:
 175 0042 04        		.byte	4
 176 0043 03        		.byte	3
 177 0044 0904      		.word	1033
 178               	.global	ConfigurationDescriptor
 181               	ConfigurationDescriptor:
 182 0046 09        		.byte	9
 183 0047 02        		.byte	2
 184 0048 8300      		.word	131
 185 004a 04        		.byte	4
 186 004b 01        		.byte	1
 187 004c 00        		.byte	0
 188 004d C0        		.byte	-64
 189 004e 32        		.byte	50
 190 004f 08        		.byte	8
 191 0050 0B        		.byte	11
 192 0051 00        		.byte	0
 193 0052 02        		.byte	2
 194 0053 02        		.byte	2
 195 0054 02        		.byte	2
 196 0055 01        		.byte	1
 197 0056 00        		.byte	0
 198 0057 09        		.byte	9
 199 0058 04        		.byte	4
 200 0059 00        		.byte	0
 201 005a 00        		.byte	0
 202 005b 01        		.byte	1
 203 005c 02        		.byte	2
 204 005d 02        		.byte	2
 205 005e 01        		.byte	1
 206 005f 00        		.byte	0
 207 0060 05        		.byte	5
 208 0061 24        		.byte	36
 209 0062 00        		.byte	0
 210 0063 1001      		.word	272
 211 0065 04        		.byte	4
 212 0066 24        		.byte	36
 213 0067 02        		.byte	2
 214 0068 06        		.byte	6
 215 0069 05        		.byte	5
 216 006a 24        		.byte	36
 217 006b 06        		.byte	6
 218 006c 00        		.byte	0
 219 006d 01        		.byte	1
 220 006e 07        		.byte	7
 221 006f 05        		.byte	5
 222 0070 83        		.byte	-125
 223 0071 03        		.byte	3
 224 0072 0800      		.word	8
 225 0074 FF        		.byte	-1
 226 0075 09        		.byte	9
 227 0076 04        		.byte	4
 228 0077 01        		.byte	1
 229 0078 00        		.byte	0
 230 0079 02        		.byte	2
 231 007a 0A        		.byte	10
 232 007b 00        		.byte	0
 233 007c 00        		.byte	0
 234 007d 00        		.byte	0
 235 007e 07        		.byte	7
 236 007f 05        		.byte	5
 237 0080 02        		.byte	2
 238 0081 02        		.byte	2
 239 0082 1000      		.word	16
 240 0084 01        		.byte	1
 241 0085 07        		.byte	7
 242 0086 05        		.byte	5
 243 0087 81        		.byte	-127
 244 0088 02        		.byte	2
 245 0089 1000      		.word	16
 246 008b 01        		.byte	1
 247 008c 08        		.byte	8
 248 008d 0B        		.byte	11
 249 008e 02        		.byte	2
 250 008f 02        		.byte	2
 251 0090 02        		.byte	2
 252 0091 02        		.byte	2
 253 0092 01        		.byte	1
 254 0093 00        		.byte	0
 255 0094 09        		.byte	9
 256 0095 04        		.byte	4
 257 0096 02        		.byte	2
 258 0097 00        		.byte	0
 259 0098 01        		.byte	1
 260 0099 02        		.byte	2
 261 009a 02        		.byte	2
 262 009b 01        		.byte	1
 263 009c 00        		.byte	0
 264 009d 05        		.byte	5
 265 009e 24        		.byte	36
 266 009f 00        		.byte	0
 267 00a0 1001      		.word	272
 268 00a2 04        		.byte	4
 269 00a3 24        		.byte	36
 270 00a4 02        		.byte	2
 271 00a5 06        		.byte	6
 272 00a6 05        		.byte	5
 273 00a7 24        		.byte	36
 274 00a8 06        		.byte	6
 275 00a9 02        		.byte	2
 276 00aa 03        		.byte	3
 277 00ab 07        		.byte	7
 278 00ac 05        		.byte	5
 279 00ad 86        		.byte	-122
 280 00ae 03        		.byte	3
 281 00af 0800      		.word	8
 282 00b1 FF        		.byte	-1
 283 00b2 09        		.byte	9
 284 00b3 04        		.byte	4
 285 00b4 03        		.byte	3
 286 00b5 00        		.byte	0
 287 00b6 02        		.byte	2
 288 00b7 0A        		.byte	10
 289 00b8 00        		.byte	0
 290 00b9 00        		.byte	0
 291 00ba 00        		.byte	0
 292 00bb 07        		.byte	7
 293 00bc 05        		.byte	5
 294 00bd 05        		.byte	5
 295 00be 02        		.byte	2
 296 00bf 1000      		.word	16
 297 00c1 01        		.byte	1
 298 00c2 07        		.byte	7
 299 00c3 05        		.byte	5
 300 00c4 84        		.byte	-124
 301 00c5 02        		.byte	2
 302 00c6 1000      		.word	16
 303 00c8 01        		.byte	1
 304               	.global	DeviceDescriptor
 307               	DeviceDescriptor:
 308 00c9 12        		.byte	18
 309 00ca 01        		.byte	1
 310 00cb 1001      		.word	272
 311 00cd EF        		.byte	-17
 312 00ce 02        		.byte	2
 313 00cf 01        		.byte	1
 314 00d0 08        		.byte	8
 315 00d1 EB03      		.word	1003
 316 00d3 4E20      		.word	8270
 317 00d5 0100      		.word	1
 318 00d7 01        		.byte	1
 319 00d8 02        		.byte	2
 320 00d9 DC        		.byte	-36
 321 00da 01        		.byte	1
 322               		.text
 323               	.Letext0:
 324               		.file 2 "/usr/lib/avr/include/stdint.h"
 325               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 326               		.file 4 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 327               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/CDC.h"
 328               		.file 6 "Descriptors.h"
 329               		.file 7 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccUrS1Wb.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccUrS1Wb.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccUrS1Wb.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccUrS1Wb.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccUrS1Wb.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccUrS1Wb.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccUrS1Wb.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccUrS1Wb.s:307    .progmem.data:00000000000000c9 DeviceDescriptor
     /tmp/ccUrS1Wb.s:181    .progmem.data:0000000000000046 ConfigurationDescriptor
     /tmp/ccUrS1Wb.s:129    .progmem.data:0000000000000000 ProductString
     /tmp/ccUrS1Wb.s:174    .progmem.data:0000000000000042 LanguageString
     /tmp/ccUrS1Wb.s:155    .progmem.data:0000000000000028 ManufacturerString

NO UNDEFINED SYMBOLS
