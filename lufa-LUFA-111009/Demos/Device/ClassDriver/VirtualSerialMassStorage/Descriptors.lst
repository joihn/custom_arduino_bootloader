   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB97:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /* On some devices, there is a factory set internal serial number which can be automatically sent t
  41:Descriptors.c ****  * the device's serial number when the Device Descriptor's .SerialNumStrIndex entry is set to USE_I
  42:Descriptors.c ****  * This allows the host to track a device across insertions on different ports, allowing them to re
  43:Descriptors.c ****  * resources like COM port numbers and drivers. On demos using this feature, give a warning on unsu
  44:Descriptors.c ****  * so that the user can supply their own serial number descriptor instead or remove the USE_INTERNA
  45:Descriptors.c ****  * from the Device Descriptor (forcing the host to generate a serial number for each device from th
  46:Descriptors.c ****  * port location).
  47:Descriptors.c ****  */
  48:Descriptors.c **** #if (USE_INTERNAL_SERIAL == NO_DESCRIPTOR)
  49:Descriptors.c **** 	#warning USE_INTERNAL_SERIAL is not available on this AVR - please manually construct a device ser
  50:Descriptors.c **** #endif
  51:Descriptors.c **** 
  52:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  53:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  54:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  55:Descriptors.c ****  *  process begins.
  56:Descriptors.c ****  */
  57:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  58:Descriptors.c **** {
  59:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  60:Descriptors.c **** 
  61:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  62:Descriptors.c **** 	.Class                  = USB_CSCP_IADDeviceClass,
  63:Descriptors.c **** 	.SubClass               = USB_CSCP_IADDeviceSubclass,
  64:Descriptors.c **** 	.Protocol               = USB_CSCP_IADDeviceProtocol,
  65:Descriptors.c **** 
  66:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  67:Descriptors.c **** 
  68:Descriptors.c **** 	.VendorID               = 0x03EB,
  69:Descriptors.c **** 	.ProductID              = 0x2068,
  70:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
  71:Descriptors.c **** 
  72:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
  73:Descriptors.c **** 	.ProductStrIndex        = 0x02,
  74:Descriptors.c **** 	.SerialNumStrIndex      = USE_INTERNAL_SERIAL,
  75:Descriptors.c **** 
  76:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  77:Descriptors.c **** };
  78:Descriptors.c **** 
  79:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
  80:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
  81:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
  82:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
  83:Descriptors.c ****  */
  84:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
  85:Descriptors.c **** {
  86:Descriptors.c **** 	.Config =
  87:Descriptors.c **** 		{
  88:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
  89:Descriptors.c **** 
  90:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
  91:Descriptors.c **** 			.TotalInterfaces        = 3,
  92:Descriptors.c **** 
  93:Descriptors.c **** 			.ConfigurationNumber    = 1,
  94:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
  95:Descriptors.c **** 
  96:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
  97:Descriptors.c **** 
  98:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
  99:Descriptors.c **** 		},
 100:Descriptors.c **** 
 101:Descriptors.c **** 	.CDC_IAD =
 102:Descriptors.c **** 		{
 103:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_Association_t), .Type = DTYPE
 104:Descriptors.c **** 
 105:Descriptors.c **** 			.FirstInterfaceIndex    = 0,
 106:Descriptors.c **** 			.TotalInterfaces        = 2,
 107:Descriptors.c **** 
 108:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCClass,
 109:Descriptors.c **** 			.SubClass               = CDC_CSCP_ACMSubclass,
 110:Descriptors.c **** 			.Protocol               = CDC_CSCP_ATCommandProtocol,
 111:Descriptors.c **** 
 112:Descriptors.c **** 			.IADStrIndex            = NO_DESCRIPTOR
 113:Descriptors.c **** 		},
 114:Descriptors.c **** 
 115:Descriptors.c **** 	.CDC_CCI_Interface =
 116:Descriptors.c **** 		{
 117:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 118:Descriptors.c **** 
 119:Descriptors.c **** 			.InterfaceNumber        = 0,
 120:Descriptors.c **** 			.AlternateSetting       = 0,
 121:Descriptors.c **** 
 122:Descriptors.c **** 			.TotalEndpoints         = 1,
 123:Descriptors.c **** 
 124:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCClass,
 125:Descriptors.c **** 			.SubClass               = CDC_CSCP_ACMSubclass,
 126:Descriptors.c **** 			.Protocol               = CDC_CSCP_ATCommandProtocol,
 127:Descriptors.c **** 
 128:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 129:Descriptors.c **** 		},
 130:Descriptors.c **** 
 131:Descriptors.c **** 	.CDC_Functional_Header =
 132:Descriptors.c **** 		{
 133:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalHeader_t), .Type = DTYPE_
 134:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_Header,
 135:Descriptors.c **** 
 136:Descriptors.c **** 			.CDCSpecification       = VERSION_BCD(01.10),
 137:Descriptors.c **** 		},
 138:Descriptors.c **** 
 139:Descriptors.c **** 	.CDC_Functional_ACM =
 140:Descriptors.c **** 		{
 141:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalACM_t), .Type = DTYPE_CSI
 142:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_ACM,
 143:Descriptors.c **** 
 144:Descriptors.c **** 			.Capabilities           = 0x06,
 145:Descriptors.c **** 		},
 146:Descriptors.c **** 
 147:Descriptors.c **** 	.CDC_Functional_Union =
 148:Descriptors.c **** 		{
 149:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalUnion_t), .Type = DTYPE_C
 150:Descriptors.c **** 			.Subtype                = CDC_DSUBTYPE_CSInterface_Union,
 151:Descriptors.c **** 
 152:Descriptors.c **** 			.MasterInterfaceNumber  = 0,
 153:Descriptors.c **** 			.SlaveInterfaceNumber   = 1,
 154:Descriptors.c **** 		},
 155:Descriptors.c **** 
 156:Descriptors.c **** 	.CDC_NotificationEndpoint =
 157:Descriptors.c **** 		{
 158:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 159:Descriptors.c **** 
 160:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM),
 161:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 162:Descriptors.c **** 			.EndpointSize           = CDC_NOTIFICATION_EPSIZE,
 163:Descriptors.c **** 			.PollingIntervalMS      = 0xFF
 164:Descriptors.c **** 		},
 165:Descriptors.c **** 
 166:Descriptors.c **** 	.CDC_DCI_Interface =
 167:Descriptors.c **** 		{
 168:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 169:Descriptors.c **** 
 170:Descriptors.c **** 			.InterfaceNumber        = 1,
 171:Descriptors.c **** 			.AlternateSetting       = 0,
 172:Descriptors.c **** 
 173:Descriptors.c **** 			.TotalEndpoints         = 2,
 174:Descriptors.c **** 
 175:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCDataClass,
 176:Descriptors.c **** 			.SubClass               = CDC_CSCP_NoDataSubclass,
 177:Descriptors.c **** 			.Protocol               = CDC_CSCP_NoDataProtocol,
 178:Descriptors.c **** 
 179:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 180:Descriptors.c **** 		},
 181:Descriptors.c **** 
 182:Descriptors.c **** 	.CDC_DataOutEndpoint =
 183:Descriptors.c **** 		{
 184:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 185:Descriptors.c **** 
 186:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | CDC_RX_EPNUM),
 187:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 188:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 189:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 190:Descriptors.c **** 		},
 191:Descriptors.c **** 
 192:Descriptors.c **** 	.CDC_DataInEndpoint =
 193:Descriptors.c **** 		{
 194:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 195:Descriptors.c **** 
 196:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC_TX_EPNUM),
 197:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 198:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 199:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 200:Descriptors.c **** 		},
 201:Descriptors.c **** 
 202:Descriptors.c **** 	.MS_Interface =
 203:Descriptors.c **** 		{
 204:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 205:Descriptors.c **** 
 206:Descriptors.c **** 			.InterfaceNumber        = 2,
 207:Descriptors.c **** 			.AlternateSetting       = 0,
 208:Descriptors.c **** 
 209:Descriptors.c **** 			.TotalEndpoints         = 2,
 210:Descriptors.c **** 
 211:Descriptors.c **** 			.Class                  = MS_CSCP_MassStorageClass,
 212:Descriptors.c **** 			.SubClass               = MS_CSCP_SCSITransparentSubclass,
 213:Descriptors.c **** 			.Protocol               = MS_CSCP_BulkOnlyTransportProtocol,
 214:Descriptors.c **** 
 215:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 216:Descriptors.c **** 		},
 217:Descriptors.c **** 
 218:Descriptors.c **** 	.MS_DataInEndpoint =
 219:Descriptors.c **** 		{
 220:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 221:Descriptors.c **** 
 222:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | MASS_STORAGE_IN_EPNUM),
 223:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 224:Descriptors.c **** 			.EndpointSize           = MASS_STORAGE_IO_EPSIZE,
 225:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 226:Descriptors.c **** 		},
 227:Descriptors.c **** 
 228:Descriptors.c **** 	.MS_DataOutEndpoint =
 229:Descriptors.c **** 		{
 230:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 231:Descriptors.c **** 
 232:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | MASS_STORAGE_OUT_EPNUM),
 233:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 234:Descriptors.c **** 			.EndpointSize           = MASS_STORAGE_IO_EPSIZE,
 235:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 236:Descriptors.c **** 		}
 237:Descriptors.c **** };
 238:Descriptors.c **** 
 239:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 240:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 241:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 242:Descriptors.c ****  */
 243:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 244:Descriptors.c **** {
 245:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 246:Descriptors.c **** 
 247:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 248:Descriptors.c **** };
 249:Descriptors.c **** 
 250:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 251:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 252:Descriptors.c ****  *  Descriptor.
 253:Descriptors.c ****  */
 254:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 255:Descriptors.c **** {
 256:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(11), .Type = DTYPE_String},
 257:Descriptors.c **** 
 258:Descriptors.c **** 	.UnicodeString          = L"Dean Camera"
 259:Descriptors.c **** };
 260:Descriptors.c **** 
 261:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 262:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 263:Descriptors.c ****  *  Descriptor.
 264:Descriptors.c ****  */
 265:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 266:Descriptors.c **** {
 267:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(30), .Type = DTYPE_String},
 268:Descriptors.c **** 
 269:Descriptors.c **** 	.UnicodeString          = L"LUFA CDC and Mass Storage Demo"
 270:Descriptors.c **** };
 271:Descriptors.c **** 
 272:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 273:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 274:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 275:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 276:Descriptors.c ****  *  USB host.
 277:Descriptors.c ****  */
 278:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 279:Descriptors.c ****                                     const uint8_t wIndex,
 280:Descriptors.c ****                                     const void** const DescriptorAddress)
 281:Descriptors.c **** {
  17               		.loc 1 281 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 282:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 283:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 284:Descriptors.c **** 
 285:Descriptors.c **** 	const void* Address = NULL;
 286:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 287:Descriptors.c **** 
 288:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 288 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2230      		cpi r18,2
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 2330      		cpi r18,3
  31 000c 3105      		cpc r19,__zero_reg__
  32 000e 01F0      		breq .L4
  33 0010 2130      		cpi r18,1
  34 0012 3105      		cpc r19,__zero_reg__
  35 0014 01F4      		brne .L12
 289:Descriptors.c **** 	{
 290:Descriptors.c **** 		case DTYPE_Device:
 291:Descriptors.c **** 			Address = &DeviceDescriptor;
 292:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  36               		.loc 1 292 0
  37 0016 82E1      		ldi r24,lo8(18)
  38 0018 90E0      		ldi r25,0
  39               	.LVL1:
 291:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  40               		.loc 1 291 0
  41 001a 20E0      		ldi r18,lo8(DeviceDescriptor)
  42 001c 30E0      		ldi r19,hi8(DeviceDescriptor)
  43 001e 00C0      		rjmp .L2
  44               	.LVL2:
  45               	.L3:
 293:Descriptors.c **** 			break;
 294:Descriptors.c **** 		case DTYPE_Configuration:
 295:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 296:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  46               		.loc 1 296 0
  47 0020 8DE5      		ldi r24,lo8(93)
  48 0022 90E0      		ldi r25,0
  49               	.LVL3:
 295:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  50               		.loc 1 295 0
  51 0024 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  52 0026 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 297:Descriptors.c **** 			break;
  53               		.loc 1 297 0
  54 0028 00C0      		rjmp .L2
  55               	.LVL4:
  56               	.L4:
 298:Descriptors.c **** 		case DTYPE_String:
 299:Descriptors.c **** 			switch (DescriptorNumber)
  57               		.loc 1 299 0
  58 002a 9927      		clr r25
  59               	.LVL5:
  60 002c 8130      		cpi r24,1
  61 002e 9105      		cpc r25,__zero_reg__
  62 0030 01F0      		breq .L6
  63 0032 00F0      		brlo .L7
  64 0034 0297      		sbiw r24,2
  65 0036 01F4      		brne .L12
  66               	.LVL6:
  67               	.LBB2:
 300:Descriptors.c **** 			{
 301:Descriptors.c **** 				case 0x00:
 302:Descriptors.c **** 					Address = &LanguageString;
 303:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 304:Descriptors.c **** 					break;
 305:Descriptors.c **** 				case 0x01:
 306:Descriptors.c **** 					Address = &ManufacturerString;
 307:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 308:Descriptors.c **** 					break;
 309:Descriptors.c **** 				case 0x02:
 310:Descriptors.c **** 					Address = &ProductString;
 311:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
  68               		.loc 1 311 0
  69 0038 E0E0      		ldi r30,lo8(ProductString)
  70 003a F0E0      		ldi r31,hi8(ProductString)
  71 003c 00C0      		rjmp .L13
  72               	.LVL7:
  73               	.L7:
  74               	.LBE2:
  75               	.LBB3:
 303:Descriptors.c **** 					break;
  76               		.loc 1 303 0
  77 003e E0E0      		ldi r30,lo8(LanguageString)
  78 0040 F0E0      		ldi r31,hi8(LanguageString)
  79 0042 00C0      		rjmp .L13
  80               	.LVL8:
  81               	.L6:
  82               	.LBE3:
  83               	.LBB4:
 307:Descriptors.c **** 					break;
  84               		.loc 1 307 0
  85 0044 E0E0      		ldi r30,lo8(ManufacturerString)
  86 0046 F0E0      		ldi r31,hi8(ManufacturerString)
  87               	.LVL9:
  88               	.L13:
  89               	.LBE4:
  90               	.LBB5:
  91               		.loc 1 311 0
  92               	/* #APP */
  93               	 ;  311 "Descriptors.c" 1
  94 0048 8491      		lpm r24, Z
  95               		
  96               	 ;  0 "" 2
  97               	.LVL10:
  98               	/* #NOAPP */
  99               	.LBE5:
 100 004a 90E0      		ldi r25,0
 101               	.LVL11:
 310:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 102               		.loc 1 310 0
 103 004c 9F01      		movw r18,r30
 312:Descriptors.c **** 					break;
 104               		.loc 1 312 0
 105 004e 00C0      		rjmp .L2
 106               	.LVL12:
 107               	.L12:
 286:Descriptors.c **** 
 108               		.loc 1 286 0
 109 0050 80E0      		ldi r24,0
 110 0052 90E0      		ldi r25,0
 285:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 111               		.loc 1 285 0
 112 0054 20E0      		ldi r18,0
 113 0056 30E0      		ldi r19,0
 114               	.LVL13:
 115               	.L2:
 313:Descriptors.c **** 			}
 314:Descriptors.c **** 
 315:Descriptors.c **** 			break;
 316:Descriptors.c **** 	}
 317:Descriptors.c **** 
 318:Descriptors.c **** 	*DescriptorAddress = Address;
 116               		.loc 1 318 0
 117 0058 FA01      		movw r30,r20
 118 005a 3183      		std Z+1,r19
 119 005c 2083      		st Z,r18
 319:Descriptors.c **** 	return Size;
 320:Descriptors.c **** }
 120               		.loc 1 320 0
 121 005e 0895      		ret
 122               		.cfi_endproc
 123               	.LFE97:
 125               	.global	ProductString
 126               		.section	.progmem.data,"a",@progbits
 129               	ProductString:
 130 0000 3E        		.byte	62
 131 0001 03        		.byte	3
 132 0002 4C00      		.string	"L"
 133 0004 5500      		.string	"U"
 134 0006 4600      		.string	"F"
 135 0008 4100      		.string	"A"
 136 000a 2000      		.string	" "
 137 000c 4300      		.string	"C"
 138 000e 4400      		.string	"D"
 139 0010 4300      		.string	"C"
 140 0012 2000      		.string	" "
 141 0014 6100      		.string	"a"
 142 0016 6E00      		.string	"n"
 143 0018 6400      		.string	"d"
 144 001a 2000      		.string	" "
 145 001c 4D00      		.string	"M"
 146 001e 6100      		.string	"a"
 147 0020 7300      		.string	"s"
 148 0022 7300      		.string	"s"
 149 0024 2000      		.string	" "
 150 0026 5300      		.string	"S"
 151 0028 7400      		.string	"t"
 152 002a 6F00      		.string	"o"
 153 002c 7200      		.string	"r"
 154 002e 6100      		.string	"a"
 155 0030 6700      		.string	"g"
 156 0032 6500      		.string	"e"
 157 0034 2000      		.string	" "
 158 0036 4400      		.string	"D"
 159 0038 6500      		.string	"e"
 160 003a 6D00      		.string	"m"
 161 003c 6F00      		.string	"o"
 162 003e 00        		.string	""
 163 003f 00        		.string	""
 164               	.global	ManufacturerString
 167               	ManufacturerString:
 168 0040 18        		.byte	24
 169 0041 03        		.byte	3
 170 0042 4400      		.string	"D"
 171 0044 6500      		.string	"e"
 172 0046 6100      		.string	"a"
 173 0048 6E00      		.string	"n"
 174 004a 2000      		.string	" "
 175 004c 4300      		.string	"C"
 176 004e 6100      		.string	"a"
 177 0050 6D00      		.string	"m"
 178 0052 6500      		.string	"e"
 179 0054 7200      		.string	"r"
 180 0056 6100      		.string	"a"
 181 0058 00        		.string	""
 182 0059 00        		.string	""
 183               	.global	LanguageString
 186               	LanguageString:
 187 005a 04        		.byte	4
 188 005b 03        		.byte	3
 189 005c 0904      		.word	1033
 190               	.global	ConfigurationDescriptor
 193               	ConfigurationDescriptor:
 194 005e 09        		.byte	9
 195 005f 02        		.byte	2
 196 0060 5D00      		.word	93
 197 0062 03        		.byte	3
 198 0063 01        		.byte	1
 199 0064 00        		.byte	0
 200 0065 C0        		.byte	-64
 201 0066 32        		.byte	50
 202 0067 08        		.byte	8
 203 0068 0B        		.byte	11
 204 0069 00        		.byte	0
 205 006a 02        		.byte	2
 206 006b 02        		.byte	2
 207 006c 02        		.byte	2
 208 006d 01        		.byte	1
 209 006e 00        		.byte	0
 210 006f 09        		.byte	9
 211 0070 04        		.byte	4
 212 0071 00        		.byte	0
 213 0072 00        		.byte	0
 214 0073 01        		.byte	1
 215 0074 02        		.byte	2
 216 0075 02        		.byte	2
 217 0076 01        		.byte	1
 218 0077 00        		.byte	0
 219 0078 05        		.byte	5
 220 0079 24        		.byte	36
 221 007a 00        		.byte	0
 222 007b 1001      		.word	272
 223 007d 04        		.byte	4
 224 007e 24        		.byte	36
 225 007f 02        		.byte	2
 226 0080 06        		.byte	6
 227 0081 05        		.byte	5
 228 0082 24        		.byte	36
 229 0083 06        		.byte	6
 230 0084 00        		.byte	0
 231 0085 01        		.byte	1
 232 0086 07        		.byte	7
 233 0087 05        		.byte	5
 234 0088 81        		.byte	-127
 235 0089 03        		.byte	3
 236 008a 0800      		.word	8
 237 008c FF        		.byte	-1
 238 008d 09        		.byte	9
 239 008e 04        		.byte	4
 240 008f 01        		.byte	1
 241 0090 00        		.byte	0
 242 0091 02        		.byte	2
 243 0092 0A        		.byte	10
 244 0093 00        		.byte	0
 245 0094 00        		.byte	0
 246 0095 00        		.byte	0
 247 0096 07        		.byte	7
 248 0097 05        		.byte	5
 249 0098 03        		.byte	3
 250 0099 02        		.byte	2
 251 009a 1000      		.word	16
 252 009c 01        		.byte	1
 253 009d 07        		.byte	7
 254 009e 05        		.byte	5
 255 009f 82        		.byte	-126
 256 00a0 02        		.byte	2
 257 00a1 1000      		.word	16
 258 00a3 01        		.byte	1
 259 00a4 09        		.byte	9
 260 00a5 04        		.byte	4
 261 00a6 02        		.byte	2
 262 00a7 00        		.byte	0
 263 00a8 02        		.byte	2
 264 00a9 08        		.byte	8
 265 00aa 06        		.byte	6
 266 00ab 50        		.byte	80
 267 00ac 00        		.byte	0
 268 00ad 07        		.byte	7
 269 00ae 05        		.byte	5
 270 00af 84        		.byte	-124
 271 00b0 02        		.byte	2
 272 00b1 4000      		.word	64
 273 00b3 01        		.byte	1
 274 00b4 07        		.byte	7
 275 00b5 05        		.byte	5
 276 00b6 05        		.byte	5
 277 00b7 02        		.byte	2
 278 00b8 4000      		.word	64
 279 00ba 01        		.byte	1
 280               	.global	DeviceDescriptor
 283               	DeviceDescriptor:
 284 00bb 12        		.byte	18
 285 00bc 01        		.byte	1
 286 00bd 1001      		.word	272
 287 00bf EF        		.byte	-17
 288 00c0 02        		.byte	2
 289 00c1 01        		.byte	1
 290 00c2 08        		.byte	8
 291 00c3 EB03      		.word	1003
 292 00c5 6820      		.word	8296
 293 00c7 0100      		.word	1
 294 00c9 01        		.byte	1
 295 00ca 02        		.byte	2
 296 00cb DC        		.byte	-36
 297 00cc 01        		.byte	1
 298               		.text
 299               	.Letext0:
 300               		.file 2 "/usr/lib/avr/include/stdint.h"
 301               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 302               		.file 4 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 303               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/CDC.h"
 304               		.file 6 "../../../../LUFA/Drivers/USB/Class/Device/../Common/MassStorage.h"
 305               		.file 7 "Descriptors.h"
 306               		.file 8 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccK1GUlq.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccK1GUlq.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccK1GUlq.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccK1GUlq.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccK1GUlq.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccK1GUlq.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccK1GUlq.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccK1GUlq.s:283    .progmem.data:00000000000000bb DeviceDescriptor
     /tmp/ccK1GUlq.s:193    .progmem.data:000000000000005e ConfigurationDescriptor
     /tmp/ccK1GUlq.s:129    .progmem.data:0000000000000000 ProductString
     /tmp/ccK1GUlq.s:186    .progmem.data:000000000000005a LanguageString
     /tmp/ccK1GUlq.s:167    .progmem.data:0000000000000040 ManufacturerString

NO UNDEFINED SYMBOLS
