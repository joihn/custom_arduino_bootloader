
Webserver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000238  00800100  00007ade  00007b72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007ade  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a60  00800338  00800338  00007daa  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00007daa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007dbc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000008d8  00000000  00000000  00007dfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00015ea4  00000000  00000000  000086d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005418  00000000  00000000  0001e578  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000a3aa  00000000  00000000  00023990  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001e78  00000000  00000000  0002dd3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005dee  00000000  00000000  0002fbb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000c9c3  00000000  00000000  000359a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b90  00000000  00000000  00042365  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	23 c2       	rjmp	.+1094   	; 0x448 <__ctors_end>
       2:	00 00       	nop
       4:	3f c2       	rjmp	.+1150   	; 0x484 <__bad_interrupt>
       6:	00 00       	nop
       8:	3d c2       	rjmp	.+1146   	; 0x484 <__bad_interrupt>
       a:	00 00       	nop
       c:	3b c2       	rjmp	.+1142   	; 0x484 <__bad_interrupt>
       e:	00 00       	nop
      10:	39 c2       	rjmp	.+1138   	; 0x484 <__bad_interrupt>
      12:	00 00       	nop
      14:	37 c2       	rjmp	.+1134   	; 0x484 <__bad_interrupt>
      16:	00 00       	nop
      18:	35 c2       	rjmp	.+1130   	; 0x484 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	33 c2       	rjmp	.+1126   	; 0x484 <__bad_interrupt>
      1e:	00 00       	nop
      20:	31 c2       	rjmp	.+1122   	; 0x484 <__bad_interrupt>
      22:	00 00       	nop
      24:	2f c2       	rjmp	.+1118   	; 0x484 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 3e 28 	jmp	0x507c	; 0x507c <__vector_10>
      2c:	0c 94 9d 29 	jmp	0x533a	; 0x533a <__vector_11>
      30:	29 c2       	rjmp	.+1106   	; 0x484 <__bad_interrupt>
      32:	00 00       	nop
      34:	27 c2       	rjmp	.+1102   	; 0x484 <__bad_interrupt>
      36:	00 00       	nop
      38:	25 c2       	rjmp	.+1098   	; 0x484 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	23 c2       	rjmp	.+1094   	; 0x484 <__bad_interrupt>
      3e:	00 00       	nop
      40:	21 c2       	rjmp	.+1090   	; 0x484 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 fe 1a 	jmp	0x35fc	; 0x35fc <__vector_17>
      48:	1d c2       	rjmp	.+1082   	; 0x484 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1b c2       	rjmp	.+1078   	; 0x484 <__bad_interrupt>
      4e:	00 00       	nop
      50:	19 c2       	rjmp	.+1074   	; 0x484 <__bad_interrupt>
      52:	00 00       	nop
      54:	17 c2       	rjmp	.+1070   	; 0x484 <__bad_interrupt>
      56:	00 00       	nop
      58:	15 c2       	rjmp	.+1066   	; 0x484 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	13 c2       	rjmp	.+1062   	; 0x484 <__bad_interrupt>
      5e:	00 00       	nop
      60:	11 c2       	rjmp	.+1058   	; 0x484 <__bad_interrupt>
      62:	00 00       	nop
      64:	0f c2       	rjmp	.+1054   	; 0x484 <__bad_interrupt>
      66:	00 00       	nop
      68:	0d c2       	rjmp	.+1050   	; 0x484 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	0b c2       	rjmp	.+1046   	; 0x484 <__bad_interrupt>
      6e:	00 00       	nop
      70:	09 c2       	rjmp	.+1042   	; 0x484 <__bad_interrupt>
      72:	00 00       	nop
      74:	07 c2       	rjmp	.+1038   	; 0x484 <__bad_interrupt>
      76:	00 00       	nop
      78:	05 c2       	rjmp	.+1034   	; 0x484 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	03 c2       	rjmp	.+1030   	; 0x484 <__bad_interrupt>
      7e:	00 00       	nop
      80:	01 c2       	rjmp	.+1026   	; 0x484 <__bad_interrupt>
      82:	00 00       	nop
      84:	ff c1       	rjmp	.+1022   	; 0x484 <__bad_interrupt>
      86:	00 00       	nop
      88:	fd c1       	rjmp	.+1018   	; 0x484 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fb c1       	rjmp	.+1014   	; 0x484 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f9 c1       	rjmp	.+1010   	; 0x484 <__bad_interrupt>
      92:	00 00       	nop
      94:	f7 c1       	rjmp	.+1006   	; 0x484 <__bad_interrupt>
      96:	00 00       	nop
      98:	bf 15       	cp	r27, r15
      9a:	d6 15       	cp	r29, r6
      9c:	45 16       	cp	r4, r21
      9e:	34 17       	cp	r19, r20
      a0:	53 17       	cp	r21, r19
      a2:	71 17       	cp	r23, r17
      a4:	79 17       	cp	r23, r25
      a6:	29 17       	cp	r18, r25
      a8:	9b 25       	eor	r25, r11
      aa:	91 26       	eor	r9, r17
      ac:	b9 25       	eor	r27, r9
      ae:	c3 25       	eor	r28, r3
      b0:	ee 25       	eor	r30, r14
      b2:	16 26       	eor	r1, r22
      b4:	21 26       	eor	r2, r17
      b6:	32 26       	eor	r3, r18
      b8:	4f 26       	eor	r4, r31
      ba:	77 26       	eor	r7, r23
      bc:	9f 2d       	mov	r25, r15
      be:	c1 2d       	mov	r28, r1
      c0:	b6 2e       	mov	r11, r22
      c2:	c1 2d       	mov	r28, r1
      c4:	b6 2e       	mov	r11, r22
      c6:	0b 2e       	mov	r0, r27
      c8:	2e 2e       	mov	r2, r30
      ca:	b6 2e       	mov	r11, r22
      cc:	81 2e       	mov	r8, r17
      ce:	94 2e       	mov	r9, r20

000000d0 <ProductString>:
      d0:	1e 03 4c 00 55 00 46 00 41 00 20 00 57 00 65 00     ..L.U.F.A. .W.e.
      e0:	62 00 73 00 65 00 72 00 76 00 65 00 72 00 00 00     b.s.e.r.v.e.r...

000000f0 <ManufacturerString>:
      f0:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
     100:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

0000010a <LanguageString>:
     10a:	04 03 09 04                                         ....

0000010e <ConfigurationDescriptor>:
     10e:	09 02 5d 00 03 01 00 80 32 08 0b 00 02 02 02 ff     ..].....2.......
     11e:	00 09 04 00 00 01 02 02 ff 00 05 24 00 10 01 04     ...........$....
     12e:	24 02 00 05 24 06 00 01 07 05 85 03 08 00 ff 09     $...$...........
     13e:	04 01 00 02 0a 00 00 00 07 05 02 02 40 00 01 07     ............@...
     14e:	05 81 02 40 00 01 09 04 02 00 02 08 06 50 00 07     ...@.........P..
     15e:	05 83 02 40 00 01 07 05 04 02 40 00 01              ...@......@..

0000016b <DeviceDescriptor>:
     16b:	12 01 10 01 ef 02 01 08 eb 03 69 20 01 00 01 02     ..........i ....
     17b:	dc 01                                               ..

0000017d <__c.2296>:
     17d:	0d 0a 0d 0a 00                                      .....

00000182 <__c.2282>:
     182:	47 45 54 00                                         GET.

00000186 <DefaultMIMEType>:
     186:	74 65 78 74 2f 70 6c 61 69 6e 00                    text/plain.

00000191 <DefaultDirFileName>:
     191:	69 6e 64 65 78 2e 68 74 6d 00                       index.htm.

0000019b <HTTP404Header>:
     19b:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     1ab:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1bb:	4c 55 46 41 20 31 31 31 30 30 39 0d 0a 43 6f 6e     LUFA 111009..Con
     1cb:	6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a     nection: close..
     1db:	4d 49 4d 45 2d 76 65 72 73 69 6f 6e 3a 20 31 2e     MIME-version: 1.
     1eb:	30 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a     0..Content-Type:
     1fb:	20 74 65 78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 45      text/plain....E
     20b:	72 72 6f 72 20 34 30 34 3a 20 46 69 6c 65 20 4e     rror 404: File N
     21b:	6f 74 20 46 6f 75 6e 64 3a 20 2f 00                 ot Found: /.

00000227 <HTTP200Header>:
     227:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     237:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 31 31     .Server: LUFA 11
     247:	31 30 30 39 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e     1009..Connection
     257:	3a 20 63 6c 6f 73 65 0d 0a 4d 49 4d 45 2d 76 65     : close..MIME-ve
     267:	72 73 69 6f 6e 3a 20 31 2e 30 0d 0a 43 6f 6e 74     rsion: 1.0..Cont
     277:	65 6e 74 2d 54 79 70 65 3a 20 00                    ent-Type: .

00000282 <__c.2479>:
     282:	25 75 29 20 25 64 2e 25 64 2e 25 64 2e 25 64 20     %u) %d.%d.%d.%d 
     292:	28 4c 6f 63 61 6c 20 50 6f 72 74 20 25 75 20 3c     (Local Port %u <
     2a2:	3d 3e 20 52 65 6d 6f 74 65 20 50 6f 72 74 20 25     => Remote Port %
     2b2:	75 29 0d 0a 00                                      u)...

000002b7 <__c.2469>:
     2b7:	49 6e 76 61 6c 69 64 20 43 6f 6d 6d 61 6e 64 2e     Invalid Command.
     2c7:	0d 0a 00                                            ...

000002ca <CurrentConnectionsHeader>:
     2ca:	0d 0a 2a 20 43 75 72 72 65 6e 74 20 54 43 50 20     ..* Current TCP 
     2da:	43 6f 6e 6e 65 63 74 69 6f 6e 73 3a 20 2a 0d 0a     Connections: *..
     2ea:	00                                                  .

000002eb <TELNETMenu>:
     2eb:	0d 0a 20 20 3d 3d 20 41 76 61 69 6c 61 62 6c 65     ..  == Available
     2fb:	20 43 6f 6d 6d 61 6e 64 73 3a 20 3d 3d 0d 0a 20      Commands: ==.. 
     30b:	20 20 20 20 63 29 20 4c 69 73 74 20 41 63 74 69         c) List Acti
     31b:	76 65 20 54 43 50 20 43 6f 6e 6e 65 63 74 69 6f     ve TCP Connectio
     32b:	6e 73 0d 0a 20 20 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d     ns..  ==========
     33b:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 0d     ===============.
     34b:	0a 0d 0a 3e 00                                      ...>.

00000350 <WelcomeHeader>:
     350:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     360:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     370:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 2a 20     ************..* 
     380:	20 20 20 20 20 20 4c 55 46 41 20 75 49 50 20 57           LUFA uIP W
     390:	65 62 73 65 72 76 65 72 20 28 54 45 4c 4e 45 54     ebserver (TELNET
     3a0:	29 20 20 20 20 20 20 20 20 2a 0d 0a 2a 2a 2a 2a     )        *..****
     3b0:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     3c0:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     3d0:	2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 00                    ********...

000003db <AdapterSupportedOIDList>:
     3db:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3eb:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3fb:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     40b:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     41b:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     42b:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     43b:	01 01 02 01 02 01 02 01 03 01 02 01 00              .............

00000448 <__ctors_end>:
     448:	11 24       	eor	r1, r1
     44a:	1f be       	out	0x3f, r1	; 63
     44c:	cf ef       	ldi	r28, 0xFF	; 255
     44e:	d0 e2       	ldi	r29, 0x20	; 32
     450:	de bf       	out	0x3e, r29	; 62
     452:	cd bf       	out	0x3d, r28	; 61

00000454 <__do_copy_data>:
     454:	13 e0       	ldi	r17, 0x03	; 3
     456:	a0 e0       	ldi	r26, 0x00	; 0
     458:	b1 e0       	ldi	r27, 0x01	; 1
     45a:	ee ed       	ldi	r30, 0xDE	; 222
     45c:	fa e7       	ldi	r31, 0x7A	; 122
     45e:	00 e0       	ldi	r16, 0x00	; 0
     460:	0b bf       	out	0x3b, r16	; 59
     462:	02 c0       	rjmp	.+4      	; 0x468 <__do_copy_data+0x14>
     464:	07 90       	elpm	r0, Z+
     466:	0d 92       	st	X+, r0
     468:	a8 33       	cpi	r26, 0x38	; 56
     46a:	b1 07       	cpc	r27, r17
     46c:	d9 f7       	brne	.-10     	; 0x464 <__do_copy_data+0x10>

0000046e <__do_clear_bss>:
     46e:	2d e0       	ldi	r18, 0x0D	; 13
     470:	a8 e3       	ldi	r26, 0x38	; 56
     472:	b3 e0       	ldi	r27, 0x03	; 3
     474:	01 c0       	rjmp	.+2      	; 0x478 <.do_clear_bss_start>

00000476 <.do_clear_bss_loop>:
     476:	1d 92       	st	X+, r1

00000478 <.do_clear_bss_start>:
     478:	a8 39       	cpi	r26, 0x98	; 152
     47a:	b2 07       	cpc	r27, r18
     47c:	e1 f7       	brne	.-8      	; 0x476 <.do_clear_bss_loop>
     47e:	36 d0       	rcall	.+108    	; 0x4ec <main>
     480:	0c 94 6d 3d 	jmp	0x7ada	; 0x7ada <_exit>

00000484 <__bad_interrupt>:
     484:	bd cd       	rjmp	.-1158   	; 0x0 <__vectors>

00000486 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     486:	84 b7       	in	r24, 0x34	; 52
     488:	87 7f       	andi	r24, 0xF7	; 247
     48a:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     48c:	0f b6       	in	r0, 0x3f	; 63
     48e:	f8 94       	cli
     490:	a8 95       	wdr
     492:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     496:	88 61       	ori	r24, 0x18	; 24
     498:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     49c:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     4a0:	0f be       	out	0x3f, r0	; 63
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     4a2:	90 e0       	ldi	r25, 0x00	; 0
     4a4:	80 e8       	ldi	r24, 0x80	; 128
     4a6:	0f b6       	in	r0, 0x3f	; 63
     4a8:	f8 94       	cli
     4aa:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
     4ae:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
     4b2:	0f be       	out	0x3f, r0	; 63
			 *                         \c SPI_SCK_*, \c SPI_SAMPLE_*, \c SPI_ORDER_* and \c SPI_MODE_* masks.
			 */
			static inline void SPI_Init(const uint8_t SPIOptions)
			{
				/* Prevent high rise times on PB.0 (/SS) from forcing a change to SPI slave mode */
				DDRB  |= (1 << 0);
     4b4:	20 9a       	sbi	0x04, 0	; 4
				PORTB |= (1 << 0);
     4b6:	28 9a       	sbi	0x05, 0	; 5

				DDRB  |=  ((1 << 1) | (1 << 2));
     4b8:	84 b1       	in	r24, 0x04	; 4
     4ba:	86 60       	ori	r24, 0x06	; 6
     4bc:	84 b9       	out	0x04, r24	; 4
				DDRB  &= ~(1 << 3);
     4be:	23 98       	cbi	0x04, 3	; 4
				PORTB |=  (1 << 3);
     4c0:	2b 9a       	sbi	0x05, 3	; 5

				if (SPIOptions & SPI_USE_DOUBLESPEED)
				  SPSR |= (1 << SPI2X);
     4c2:	8d b5       	in	r24, 0x2d	; 45
     4c4:	81 60       	ori	r24, 0x01	; 1
     4c6:	8d bd       	out	0x2d, r24	; 45
				else
				  SPSR &= ~(1 << SPI2X);

				/* Switch /SS to input mode after configuration to allow for forced mode changes */
				DDRB &= ~(1 << 0);
     4c8:	20 98       	cbi	0x04, 0	; 4

				SPCR  = ((1 << SPE) | SPIOptions);
     4ca:	8c e5       	ldi	r24, 0x5C	; 92
     4cc:	8c bd       	out	0x2c, r24	; 44
			/** Initializes the dataflash driver so that commands and data may be sent to an attached dataflash IC.
			 *  The microcontroller's SPI driver MUST be initialized before any of the dataflash commands are used.
			 */
			static inline void Dataflash_Init(void)
			{
				DATAFLASH_CHIPCS_DDR  |= DATAFLASH_CHIPCS_MASK;
     4ce:	8d b1       	in	r24, 0x0d	; 13
     4d0:	83 60       	ori	r24, 0x03	; 3
     4d2:	8d b9       	out	0x0d, r24	; 13
				DATAFLASH_CHIPCS_PORT |= DATAFLASH_CHIPCS_MASK;
     4d4:	8e b1       	in	r24, 0x0e	; 14
     4d6:	83 60       	ori	r24, 0x03	; 3
     4d8:	8e b9       	out	0x0e, r24	; 14

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4da:	8a b1       	in	r24, 0x0a	; 10
     4dc:	80 6f       	ori	r24, 0xF0	; 240
     4de:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4e0:	8b b1       	in	r24, 0x0b	; 11
     4e2:	8f 70       	andi	r24, 0x0F	; 15
     4e4:	8b b9       	out	0x0b, r24	; 11

	/* Hardware Initialization */
	SPI_Init(SPI_SPEED_FCPU_DIV_2 | SPI_SCK_LEAD_FALLING | SPI_SAMPLE_TRAILING | SPI_MODE_MASTER);
	Dataflash_Init();
	LEDs_Init();
	USB_Init(USB_MODE_UID);
     4e6:	83 e0       	ldi	r24, 0x03	; 3
     4e8:	0c 94 05 28 	jmp	0x500a	; 0x500a <USB_Init>

000004ec <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     4ec:	cc df       	rcall	.-104    	; 0x486 <SetupHardware>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     4ee:	8b b1       	in	r24, 0x0b	; 11
     4f0:	8f 70       	andi	r24, 0x0F	; 15
     4f2:	80 61       	ori	r24, 0x10	; 16
     4f4:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     4f6:	78 94       	sei

	for (;;)
	{
		if (USB_CurrentMode == USB_MODE_Host)
     4f8:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
     4fc:	82 30       	cpi	r24, 0x02	; 2
		  USBHostMode_USBTask();
     4fe:	11 f4       	brne	.+4      	; 0x504 <main+0x18>
     500:	7b d0       	rcall	.+246    	; 0x5f8 <USBHostMode_USBTask>
		else
		  USBDeviceMode_USBTask();
     502:	01 c0       	rjmp	.+2      	; 0x506 <main+0x1a>
     504:	38 d0       	rcall	.+112    	; 0x576 <USBDeviceMode_USBTask>

		USB_USBTask();
     506:	0e 94 18 30 	call	0x6030	; 0x6030 <USB_USBTask>
	}
     50a:	f6 cf       	rjmp	.-20     	; 0x4f8 <main+0xc>

0000050c <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     50c:	29 2f       	mov	r18, r25
     50e:	33 27       	eor	r19, r19
     510:	22 30       	cpi	r18, 0x02	; 2
     512:	31 05       	cpc	r19, r1
     514:	59 f0       	breq	.+22     	; 0x52c <CALLBACK_USB_GetDescriptor+0x20>
     516:	23 30       	cpi	r18, 0x03	; 3
     518:	31 05       	cpc	r19, r1
     51a:	69 f0       	breq	.+26     	; 0x536 <CALLBACK_USB_GetDescriptor+0x2a>
     51c:	21 30       	cpi	r18, 0x01	; 1
     51e:	31 05       	cpc	r19, r1
     520:	e9 f4       	brne	.+58     	; 0x55c <CALLBACK_USB_GetDescriptor+0x50>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     522:	82 e1       	ldi	r24, 0x12	; 18
     524:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     526:	2b e6       	ldi	r18, 0x6B	; 107
     528:	31 e0       	ldi	r19, 0x01	; 1
     52a:	1c c0       	rjmp	.+56     	; 0x564 <CALLBACK_USB_GetDescriptor+0x58>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     52c:	8d e5       	ldi	r24, 0x5D	; 93
     52e:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     530:	2e e0       	ldi	r18, 0x0E	; 14
     532:	31 e0       	ldi	r19, 0x01	; 1
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     534:	17 c0       	rjmp	.+46     	; 0x564 <CALLBACK_USB_GetDescriptor+0x58>
		case DTYPE_String:
			switch (DescriptorNumber)
     536:	99 27       	eor	r25, r25
     538:	81 30       	cpi	r24, 0x01	; 1
     53a:	91 05       	cpc	r25, r1
     53c:	49 f0       	breq	.+18     	; 0x550 <CALLBACK_USB_GetDescriptor+0x44>
     53e:	28 f0       	brcs	.+10     	; 0x54a <CALLBACK_USB_GetDescriptor+0x3e>
     540:	02 97       	sbiw	r24, 0x02	; 2
     542:	61 f4       	brne	.+24     	; 0x55c <CALLBACK_USB_GetDescriptor+0x50>
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     544:	e0 ed       	ldi	r30, 0xD0	; 208
     546:	f0 e0       	ldi	r31, 0x00	; 0
     548:	05 c0       	rjmp	.+10     	; 0x554 <CALLBACK_USB_GetDescriptor+0x48>
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     54a:	ea e0       	ldi	r30, 0x0A	; 10
     54c:	f1 e0       	ldi	r31, 0x01	; 1
     54e:	02 c0       	rjmp	.+4      	; 0x554 <CALLBACK_USB_GetDescriptor+0x48>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     550:	e0 ef       	ldi	r30, 0xF0	; 240
     552:	f0 e0       	ldi	r31, 0x00	; 0
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     554:	84 91       	lpm	r24, Z
     556:	90 e0       	ldi	r25, 0x00	; 0
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case 0x02:
					Address = &ProductString;
     558:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     55a:	04 c0       	rjmp	.+8      	; 0x564 <CALLBACK_USB_GetDescriptor+0x58>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     55c:	80 e0       	ldi	r24, 0x00	; 0
     55e:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     560:	20 e0       	ldi	r18, 0x00	; 0
     562:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     564:	fa 01       	movw	r30, r20
     566:	31 83       	std	Z+1, r19	; 0x01
     568:	20 83       	st	Z, r18
	return Size;
}
     56a:	08 95       	ret

0000056c <LEDs_SetAllLEDs>:
     56c:	9b b1       	in	r25, 0x0b	; 11
     56e:	9f 70       	andi	r25, 0x0F	; 15
     570:	89 2b       	or	r24, r25
     572:	8b b9       	out	0x0b, r24	; 11
     574:	08 95       	ret

00000576 <USBDeviceMode_USBTask>:
/** USB device mode management task. This function manages the Mass Storage Device class driver when the device is
 *  initialized in USB device mode.
 */
void USBDeviceMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Device)
     576:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
     57a:	81 30       	cpi	r24, 0x01	; 1
     57c:	49 f4       	brne	.+18     	; 0x590 <USBDeviceMode_USBTask+0x1a>
	  return;

	uIPManagement_ManageNetwork();
     57e:	e4 d5       	rcall	.+3016   	; 0x1148 <uIPManagement_ManageNetwork>

	RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface_Device);
     580:	87 e3       	ldi	r24, 0x37	; 55
     582:	91 e0       	ldi	r25, 0x01	; 1
     584:	0e 94 83 34 	call	0x6906	; 0x6906 <RNDIS_Device_USBTask>
	MS_Device_USBTask(&Disk_MS_Interface);
     588:	80 e0       	ldi	r24, 0x00	; 0
     58a:	91 e0       	ldi	r25, 0x01	; 1
     58c:	0c 94 b8 30 	jmp	0x6170	; 0x6170 <MS_Device_USBTask>
     590:	08 95       	ret

00000592 <EVENT_USB_Device_Connect>:
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     592:	80 e3       	ldi	r24, 0x30	; 48
     594:	eb df       	rcall	.-42     	; 0x56c <LEDs_SetAllLEDs>

	uIPManagement_Init();
     596:	7d c5       	rjmp	.+2810   	; 0x1092 <uIPManagement_Init>

00000598 <EVENT_USB_Device_Disconnect>:
     598:	80 e1       	ldi	r24, 0x10	; 16
}

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     59a:	e8 cf       	rjmp	.-48     	; 0x56c <LEDs_SetAllLEDs>

0000059c <EVENT_USB_Device_ConfigurationChanged>:
}

/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     59c:	cf 93       	push	r28
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface_Device);
     59e:	87 e3       	ldi	r24, 0x37	; 55
     5a0:	91 e0       	ldi	r25, 0x01	; 1
     5a2:	0e 94 37 34 	call	0x686e	; 0x686e <RNDIS_Device_ConfigureEndpoints>
     5a6:	c8 2f       	mov	r28, r24
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
     5a8:	80 e0       	ldi	r24, 0x00	; 0
     5aa:	91 e0       	ldi	r25, 0x01	; 1
     5ac:	0e 94 7a 30 	call	0x60f4	; 0x60f4 <MS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     5b0:	cc 23       	and	r28, r28
     5b2:	11 f0       	breq	.+4      	; 0x5b8 <EVENT_USB_Device_ConfigurationChanged+0x1c>
     5b4:	81 11       	cpse	r24, r1
     5b6:	02 c0       	rjmp	.+4      	; 0x5bc <EVENT_USB_Device_ConfigurationChanged+0x20>
     5b8:	80 e9       	ldi	r24, 0x90	; 144
     5ba:	01 c0       	rjmp	.+2      	; 0x5be <EVENT_USB_Device_ConfigurationChanged+0x22>
     5bc:	80 e2       	ldi	r24, 0x20	; 32
}
     5be:	cf 91       	pop	r28
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface_Device);
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     5c0:	d5 cf       	rjmp	.-86     	; 0x56c <LEDs_SetAllLEDs>

000005c2 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface_Device);
     5c2:	87 e3       	ldi	r24, 0x37	; 55
     5c4:	91 e0       	ldi	r25, 0x01	; 1
     5c6:	0e 94 c5 31 	call	0x638a	; 0x638a <RNDIS_Device_ProcessControlRequest>
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
     5ca:	80 e0       	ldi	r24, 0x00	; 0
     5cc:	91 e0       	ldi	r25, 0x01	; 1
     5ce:	0c 94 3b 30 	jmp	0x6076	; 0x6076 <MS_Device_ProcessControlRequest>

000005d2 <CALLBACK_MS_Device_SCSICommandReceived>:
/** Mass Storage class driver callback function the reception of SCSI commands from the host, which must be processed.
 *
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface configuration structure being referenced
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     5d2:	cf 93       	push	r28
     5d4:	df 93       	push	r29
     5d6:	ec 01       	movw	r28, r24
	bool CommandSuccess;

	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     5d8:	80 ed       	ldi	r24, 0xD0	; 208
     5da:	c8 df       	rcall	.-112    	; 0x56c <LEDs_SetAllLEDs>
	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
     5dc:	ce 01       	movw	r24, r28
     5de:	df d0       	rcall	.+446    	; 0x79e <SCSI_DecodeSCSICommand>
     5e0:	c8 2f       	mov	r28, r24
	LEDs_SetAllLEDs(LEDMASK_USB_READY);
     5e2:	80 e2       	ldi	r24, 0x20	; 32
     5e4:	c3 df       	rcall	.-122    	; 0x56c <LEDs_SetAllLEDs>
     5e6:	8c 2f       	mov	r24, r28

	return CommandSuccess;
}
     5e8:	df 91       	pop	r29
     5ea:	cf 91       	pop	r28
     5ec:	08 95       	ret

000005ee <LEDs_SetAllLEDs>:
     5ee:	9b b1       	in	r25, 0x0b	; 11
     5f0:	9f 70       	andi	r25, 0x0F	; 15
     5f2:	89 2b       	or	r24, r25
     5f4:	8b b9       	out	0x0b, r24	; 11
     5f6:	08 95       	ret

000005f8 <USBHostMode_USBTask>:
/** USB host mode management task. This function manages the RNDIS Host class driver and uIP stack when the device is
 *  initialized in USB host mode.
 */
void USBHostMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Host)
     5f8:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
     5fc:	82 30       	cpi	r24, 0x02	; 2
     5fe:	09 f4       	brne	.+2      	; 0x602 <USBHostMode_USBTask+0xa>
	  return;

	uIPManagement_ManageNetwork();
     600:	a3 c5       	rjmp	.+2886   	; 0x1148 <uIPManagement_ManageNetwork>
     602:	08 95       	ret

00000604 <EVENT_USB_Host_DeviceAttached>:
/** Event handler for the USB_DeviceAttached event. This indicates that a device has been attached to the host, and
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Host_DeviceAttached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     604:	80 e3       	ldi	r24, 0x30	; 48
     606:	f3 cf       	rjmp	.-26     	; 0x5ee <LEDs_SetAllLEDs>

00000608 <EVENT_USB_Host_DeviceUnattached>:
/** Event handler for the USB_DeviceUnattached event. This indicates that a device has been removed from the host, and
 *  stops the library USB task management process.
 */
void EVENT_USB_Host_DeviceUnattached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     608:	80 e1       	ldi	r24, 0x10	; 16
     60a:	f1 cf       	rjmp	.-30     	; 0x5ee <LEDs_SetAllLEDs>

0000060c <EVENT_USB_Host_DeviceEnumerationComplete>:

/** Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully
 *  enumerated by the host and is now ready to be used by the application.
 */
void EVENT_USB_Host_DeviceEnumerationComplete(void)
{
     60c:	0f 93       	push	r16
     60e:	1f 93       	push	r17
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
     614:	cd b7       	in	r28, 0x3d	; 61
     616:	de b7       	in	r29, 0x3e	; 62
     618:	c6 50       	subi	r28, 0x06	; 6
     61a:	d2 40       	sbci	r29, 0x02	; 2
     61c:	0f b6       	in	r0, 0x3f	; 63
     61e:	f8 94       	cli
     620:	de bf       	out	0x3e, r29	; 62
     622:	0f be       	out	0x3f, r0	; 63
     624:	cd bf       	out	0x3d, r28	; 61
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     626:	80 e3       	ldi	r24, 0x30	; 48
     628:	e2 df       	rcall	.-60     	; 0x5ee <LEDs_SetAllLEDs>

	uint16_t ConfigDescriptorSize;
	uint8_t  ConfigDescriptorData[512];

	if (USB_Host_GetDeviceConfigDescriptor(1, &ConfigDescriptorSize, ConfigDescriptorData,
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	32 e0       	ldi	r19, 0x02	; 2
     62e:	ae 01       	movw	r20, r28
     630:	4f 5f       	subi	r20, 0xFF	; 255
     632:	5f 4f       	sbci	r21, 0xFF	; 255
     634:	be 01       	movw	r22, r28
     636:	6b 5f       	subi	r22, 0xFB	; 251
     638:	7d 4f       	sbci	r23, 0xFD	; 253
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <USB_Host_GetDeviceConfigDescriptor>
     640:	88 23       	and	r24, r24
     642:	11 f0       	breq	.+4      	; 0x648 <EVENT_USB_Host_DeviceEnumerationComplete+0x3c>
	                                       sizeof(ConfigDescriptorData)) != HOST_GETCONFIG_Successful)
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     644:	80 e9       	ldi	r24, 0x90	; 144
     646:	4b c0       	rjmp	.+150    	; 0x6de <EVENT_USB_Host_DeviceEnumerationComplete+0xd2>
		return;
	}

	if (RNDIS_Host_ConfigurePipes(&Ethernet_RNDIS_Interface_Host,
     648:	cb 5f       	subi	r28, 0xFB	; 251
     64a:	dd 4f       	sbci	r29, 0xFD	; 253
     64c:	68 81       	ld	r22, Y
     64e:	79 81       	ldd	r23, Y+1	; 0x01
     650:	c5 50       	subi	r28, 0x05	; 5
     652:	d2 40       	sbci	r29, 0x02	; 2
     654:	ae 01       	movw	r20, r28
     656:	4f 5f       	subi	r20, 0xFF	; 255
     658:	5f 4f       	sbci	r21, 0xFF	; 255
     65a:	82 ed       	ldi	r24, 0xD2	; 210
     65c:	91 e0       	ldi	r25, 0x01	; 1
     65e:	0e 94 fc 35 	call	0x6bf8	; 0x6bf8 <RNDIS_Host_ConfigurePipes>
     662:	81 11       	cpse	r24, r1
     664:	ef cf       	rjmp	.-34     	; 0x644 <EVENT_USB_Host_DeviceEnumerationComplete+0x38>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (USB_Host_SetDeviceConfiguration(1) != HOST_SENDCONTROL_Successful)
     666:	81 e0       	ldi	r24, 0x01	; 1
     668:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <USB_Host_SetDeviceConfiguration>
     66c:	81 11       	cpse	r24, r1
     66e:	ea cf       	rjmp	.-44     	; 0x644 <EVENT_USB_Host_DeviceEnumerationComplete+0x38>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (RNDIS_Host_InitializeDevice(&Ethernet_RNDIS_Interface_Host) != HOST_SENDCONTROL_Successful)
     670:	82 ed       	ldi	r24, 0xD2	; 210
     672:	91 e0       	ldi	r25, 0x01	; 1
     674:	0e 94 e9 36 	call	0x6dd2	; 0x6dd2 <RNDIS_Host_InitializeDevice>
     678:	88 23       	and	r24, r24
     67a:	31 f0       	breq	.+12     	; 0x688 <EVENT_USB_Host_DeviceEnumerationComplete+0x7c>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     67c:	80 e9       	ldi	r24, 0x90	; 144
     67e:	b7 df       	rcall	.-146    	; 0x5ee <LEDs_SetAllLEDs>
		USB_Host_SetDeviceConfiguration(0);
     680:	80 e0       	ldi	r24, 0x00	; 0
     682:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <USB_Host_SetDeviceConfiguration>
		return;
     686:	2c c0       	rjmp	.+88     	; 0x6e0 <EVENT_USB_Host_DeviceEnumerationComplete+0xd4>
	}

	uint32_t PacketFilter = (REMOTE_NDIS_PACKET_DIRECTED | REMOTE_NDIS_PACKET_BROADCAST);
     688:	89 e0       	ldi	r24, 0x09	; 9
     68a:	90 e0       	ldi	r25, 0x00	; 0
     68c:	a0 e0       	ldi	r26, 0x00	; 0
     68e:	b0 e0       	ldi	r27, 0x00	; 0
     690:	cf 5f       	subi	r28, 0xFF	; 255
     692:	dd 4f       	sbci	r29, 0xFD	; 253
     694:	88 83       	st	Y, r24
     696:	99 83       	std	Y+1, r25	; 0x01
     698:	aa 83       	std	Y+2, r26	; 0x02
     69a:	bb 83       	std	Y+3, r27	; 0x03
     69c:	c1 50       	subi	r28, 0x01	; 1
     69e:	d2 40       	sbci	r29, 0x02	; 2
	if (RNDIS_Host_SetRNDISProperty(&Ethernet_RNDIS_Interface_Host, OID_GEN_CURRENT_PACKET_FILTER,
     6a0:	04 e0       	ldi	r16, 0x04	; 4
     6a2:	10 e0       	ldi	r17, 0x00	; 0
     6a4:	9e 01       	movw	r18, r28
     6a6:	2f 5f       	subi	r18, 0xFF	; 255
     6a8:	3d 4f       	sbci	r19, 0xFD	; 253
     6aa:	4e e0       	ldi	r20, 0x0E	; 14
     6ac:	51 e0       	ldi	r21, 0x01	; 1
     6ae:	61 e0       	ldi	r22, 0x01	; 1
     6b0:	70 e0       	ldi	r23, 0x00	; 0
     6b2:	82 ed       	ldi	r24, 0xD2	; 210
     6b4:	91 e0       	ldi	r25, 0x01	; 1
     6b6:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <RNDIS_Host_SetRNDISProperty>
     6ba:	81 11       	cpse	r24, r1
     6bc:	df cf       	rjmp	.-66     	; 0x67c <EVENT_USB_Host_DeviceEnumerationComplete+0x70>
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		USB_Host_SetDeviceConfiguration(0);
		return;
	}

	if (RNDIS_Host_QueryRNDISProperty(&Ethernet_RNDIS_Interface_Host, OID_802_3_CURRENT_ADDRESS,
     6be:	06 e0       	ldi	r16, 0x06	; 6
     6c0:	10 e0       	ldi	r17, 0x00	; 0
     6c2:	2d eb       	ldi	r18, 0xBD	; 189
     6c4:	33 e0       	ldi	r19, 0x03	; 3
     6c6:	42 e0       	ldi	r20, 0x02	; 2
     6c8:	51 e0       	ldi	r21, 0x01	; 1
     6ca:	61 e0       	ldi	r22, 0x01	; 1
     6cc:	71 e0       	ldi	r23, 0x01	; 1
     6ce:	82 ed       	ldi	r24, 0xD2	; 210
     6d0:	91 e0       	ldi	r25, 0x01	; 1
     6d2:	0e 94 0d 38 	call	0x701a	; 0x701a <RNDIS_Host_QueryRNDISProperty>
     6d6:	81 11       	cpse	r24, r1
		USB_Host_SetDeviceConfiguration(0);
		return;
	}

	/* Initialize uIP stack */
	uIPManagement_Init();
     6d8:	d1 cf       	rjmp	.-94     	; 0x67c <EVENT_USB_Host_DeviceEnumerationComplete+0x70>

	LEDs_SetAllLEDs(LEDMASK_USB_READY);
     6da:	db d4       	rcall	.+2486   	; 0x1092 <uIPManagement_Init>
     6dc:	80 e2       	ldi	r24, 0x20	; 32
     6de:	87 df       	rcall	.-242    	; 0x5ee <LEDs_SetAllLEDs>
}
     6e0:	ca 5f       	subi	r28, 0xFA	; 250
     6e2:	dd 4f       	sbci	r29, 0xFD	; 253
     6e4:	0f b6       	in	r0, 0x3f	; 63
     6e6:	f8 94       	cli
     6e8:	de bf       	out	0x3e, r29	; 62
     6ea:	0f be       	out	0x3f, r0	; 63
     6ec:	cd bf       	out	0x3d, r28	; 61
     6ee:	df 91       	pop	r29
     6f0:	cf 91       	pop	r28
     6f2:	1f 91       	pop	r17
     6f4:	0f 91       	pop	r16
     6f6:	08 95       	ret

000006f8 <EVENT_USB_Host_HostError>:

/** Event handler for the USB_HostError event. This indicates that a hardware error occurred while in host mode. */
void EVENT_USB_Host_HostError(const uint8_t ErrorCode)
{
	USB_Disable();
     6f8:	0e 94 5d 27 	call	0x4eba	; 0x4eba <USB_Disable>

	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     6fc:	80 e9       	ldi	r24, 0x90	; 144
     6fe:	77 df       	rcall	.-274    	; 0x5ee <LEDs_SetAllLEDs>
     700:	ff cf       	rjmp	.-2      	; 0x700 <EVENT_USB_Host_HostError+0x8>

00000702 <EVENT_USB_Host_DeviceEnumerationFailed>:
/** Event handler for the USB_DeviceEnumerationFailed event. This indicates that a problem occurred while
 *  enumerating an attached USB device.
 */
void EVENT_USB_Host_DeviceEnumerationFailed(const uint8_t ErrorCode, const uint8_t SubErrorCode)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     702:	80 e9       	ldi	r24, 0x90	; 144
     704:	74 cf       	rjmp	.-280    	; 0x5ee <LEDs_SetAllLEDs>

00000706 <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
     706:	0f 93       	push	r16
     708:	1f 93       	push	r17
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	ec 01       	movw	r28, r24
     710:	96 2f       	mov	r25, r22
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
     712:	4b 8d       	ldd	r20, Y+27	; 0x1b
     714:	5c 8d       	ldd	r21, Y+28	; 0x1c
     716:	6d 8d       	ldd	r22, Y+29	; 0x1d
     718:	7e 8d       	ldd	r23, Y+30	; 0x1e

				Temp = Data.Bytes[0];
     71a:	84 2f       	mov	r24, r20
				Data.Bytes[0] = Data.Bytes[3];
     71c:	47 2f       	mov	r20, r23
				Data.Bytes[3] = Temp;
     71e:	78 2f       	mov	r23, r24

				Temp = Data.Bytes[1];
     720:	85 2f       	mov	r24, r21
				Data.Bytes[1] = Data.Bytes[2];
     722:	56 2f       	mov	r21, r22
				Data.Bytes[2] = Temp;
     724:	68 2f       	mov	r22, r24
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     726:	08 a1       	ldd	r16, Y+32	; 0x20
     728:	19 a1       	ldd	r17, Y+33	; 0x21

				Temp = Data.Bytes[0];
     72a:	80 2f       	mov	r24, r16
				Data.Bytes[0] = Data.Bytes[1];
     72c:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
     72e:	18 2f       	mov	r17, r24

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= VIRTUAL_MEMORY_BLOCKS)
     730:	41 15       	cp	r20, r1
     732:	80 e8       	ldi	r24, 0x80	; 128
     734:	58 07       	cpc	r21, r24
     736:	61 05       	cpc	r22, r1
     738:	71 05       	cpc	r23, r1
     73a:	68 f0       	brcs	.+26     	; 0x756 <SCSI_Command_ReadWrite_10+0x50>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     73c:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <SenseData+0x2>
     740:	80 7f       	andi	r24, 0xF0	; 240
     742:	85 60       	ori	r24, 0x05	; 5
     744:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <SenseData+0x2>
     748:	81 e2       	ldi	r24, 0x21	; 33
     74a:	80 93 f8 01 	sts	0x01F8, r24	; 0x8001f8 <SenseData+0xc>
     74e:	10 92 f9 01 	sts	0x01F9, r1	; 0x8001f9 <SenseData+0xd>
		               SCSI_ASENSE_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
     752:	80 e0       	ldi	r24, 0x00	; 0
     754:	1f c0       	rjmp	.+62     	; 0x794 <SCSI_Command_ReadWrite_10+0x8e>
	}
	
	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
	  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     756:	98 01       	movw	r18, r16

		return false;
	}
	
	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
     758:	99 23       	and	r25, r25
     75a:	19 f0       	breq	.+6      	; 0x762 <SCSI_Command_ReadWrite_10+0x5c>
	  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     75c:	ce 01       	movw	r24, r28
     75e:	c5 d2       	rcall	.+1418   	; 0xcea <DataflashManager_ReadBlocks>
     760:	02 c0       	rjmp	.+4      	; 0x766 <SCSI_Command_ReadWrite_10+0x60>
	else
	  DataflashManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     762:	ce 01       	movw	r24, r28
     764:	83 d1       	rcall	.+774    	; 0xa6c <DataflashManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
     766:	a8 01       	movw	r20, r16
     768:	60 e0       	ldi	r22, 0x00	; 0
     76a:	70 e0       	ldi	r23, 0x00	; 0
     76c:	89 e0       	ldi	r24, 0x09	; 9
     76e:	44 0f       	add	r20, r20
     770:	55 1f       	adc	r21, r21
     772:	66 1f       	adc	r22, r22
     774:	77 1f       	adc	r23, r23
     776:	8a 95       	dec	r24
     778:	d1 f7       	brne	.-12     	; 0x76e <SCSI_Command_ReadWrite_10+0x68>
     77a:	8a 89       	ldd	r24, Y+18	; 0x12
     77c:	9b 89       	ldd	r25, Y+19	; 0x13
     77e:	ac 89       	ldd	r26, Y+20	; 0x14
     780:	bd 89       	ldd	r27, Y+21	; 0x15
     782:	84 1b       	sub	r24, r20
     784:	95 0b       	sbc	r25, r21
     786:	a6 0b       	sbc	r26, r22
     788:	b7 0b       	sbc	r27, r23
     78a:	8a 8b       	std	Y+18, r24	; 0x12
     78c:	9b 8b       	std	Y+19, r25	; 0x13
     78e:	ac 8b       	std	Y+20, r26	; 0x14
     790:	bd 8b       	std	Y+21, r27	; 0x15

	return true;
     792:	81 e0       	ldi	r24, 0x01	; 1
}
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	1f 91       	pop	r17
     79a:	0f 91       	pop	r16
     79c:	08 95       	ret

0000079e <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean true if the command completed successfully, false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     79e:	cf 92       	push	r12
     7a0:	df 92       	push	r13
     7a2:	ef 92       	push	r14
     7a4:	ff 92       	push	r15
     7a6:	0f 93       	push	r16
     7a8:	1f 93       	push	r17
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
     7ae:	cd b7       	in	r28, 0x3d	; 61
     7b0:	de b7       	in	r29, 0x3e	; 62
     7b2:	28 97       	sbiw	r28, 0x08	; 8
     7b4:	0f b6       	in	r0, 0x3f	; 63
     7b6:	f8 94       	cli
     7b8:	de bf       	out	0x3e, r29	; 62
     7ba:	0f be       	out	0x3f, r0	; 63
     7bc:	cd bf       	out	0x3d, r28	; 61
     7be:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     7c0:	fc 01       	movw	r30, r24
     7c2:	81 8d       	ldd	r24, Z+25	; 0x19
     7c4:	8d 31       	cpi	r24, 0x1D	; 29
     7c6:	09 f4       	brne	.+2      	; 0x7ca <SCSI_DecodeSCSICommand+0x2c>
     7c8:	c5 c0       	rjmp	.+394    	; 0x954 <SCSI_DecodeSCSICommand+0x1b6>
     7ca:	20 f5       	brcc	.+72     	; 0x814 <SCSI_DecodeSCSICommand+0x76>
     7cc:	83 30       	cpi	r24, 0x03	; 3
     7ce:	09 f4       	brne	.+2      	; 0x7d2 <SCSI_DecodeSCSICommand+0x34>
     7d0:	99 c0       	rjmp	.+306    	; 0x904 <SCSI_DecodeSCSICommand+0x166>
     7d2:	20 f4       	brcc	.+8      	; 0x7dc <SCSI_DecodeSCSICommand+0x3e>
     7d4:	88 23       	and	r24, r24
     7d6:	09 f4       	brne	.+2      	; 0x7da <SCSI_DecodeSCSICommand+0x3c>
     7d8:	dc c0       	rjmp	.+440    	; 0x992 <SCSI_DecodeSCSICommand+0x1f4>
     7da:	e1 c0       	rjmp	.+450    	; 0x99e <SCSI_DecodeSCSICommand+0x200>
     7dc:	82 31       	cpi	r24, 0x12	; 18
     7de:	09 f4       	brne	.+2      	; 0x7e2 <SCSI_DecodeSCSICommand+0x44>
     7e0:	58 c0       	rjmp	.+176    	; 0x892 <SCSI_DecodeSCSICommand+0xf4>
     7e2:	8a 31       	cpi	r24, 0x1A	; 26
     7e4:	09 f0       	breq	.+2      	; 0x7e8 <SCSI_DecodeSCSICommand+0x4a>
     7e6:	db c0       	rjmp	.+438    	; 0x99e <SCSI_DecodeSCSICommand+0x200>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     7e8:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     7ec:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     7f0:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     7f4:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     7f8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     7fc:	8e 77       	andi	r24, 0x7E	; 126
     7fe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
     802:	f8 01       	movw	r30, r16
     804:	82 89       	ldd	r24, Z+18	; 0x12
     806:	93 89       	ldd	r25, Z+19	; 0x13
     808:	a4 89       	ldd	r26, Z+20	; 0x14
     80a:	b5 89       	ldd	r27, Z+21	; 0x15
     80c:	04 97       	sbiw	r24, 0x04	; 4
     80e:	a1 09       	sbc	r26, r1
     810:	b1 09       	sbc	r27, r1
     812:	ba c0       	rjmp	.+372    	; 0x988 <SCSI_DecodeSCSICommand+0x1ea>
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     814:	88 32       	cpi	r24, 0x28	; 40
     816:	09 f4       	brne	.+2      	; 0x81a <SCSI_DecodeSCSICommand+0x7c>
     818:	b1 c0       	rjmp	.+354    	; 0x97c <SCSI_DecodeSCSICommand+0x1de>
     81a:	a0 f5       	brcc	.+104    	; 0x884 <SCSI_DecodeSCSICommand+0xe6>
     81c:	8e 31       	cpi	r24, 0x1E	; 30
     81e:	09 f4       	brne	.+2      	; 0x822 <SCSI_DecodeSCSICommand+0x84>
     820:	b8 c0       	rjmp	.+368    	; 0x992 <SCSI_DecodeSCSICommand+0x1f4>
     822:	85 32       	cpi	r24, 0x25	; 37
     824:	09 f0       	breq	.+2      	; 0x828 <SCSI_DecodeSCSICommand+0x8a>
     826:	bb c0       	rjmp	.+374    	; 0x99e <SCSI_DecodeSCSICommand+0x200>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN = (VIRTUAL_MEMORY_BLOCKS - 1);
     828:	8f ef       	ldi	r24, 0xFF	; 255
     82a:	9f e7       	ldi	r25, 0x7F	; 127
     82c:	a0 e0       	ldi	r26, 0x00	; 0
     82e:	b0 e0       	ldi	r27, 0x00	; 0
     830:	8d 83       	std	Y+5, r24	; 0x05
     832:	9e 83       	std	Y+6, r25	; 0x06
     834:	af 83       	std	Y+7, r26	; 0x07
     836:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	92 e0       	ldi	r25, 0x02	; 2
     83c:	a0 e0       	ldi	r26, 0x00	; 0
     83e:	b0 e0       	ldi	r27, 0x00	; 0
     840:	89 83       	std	Y+1, r24	; 0x01
     842:	9a 83       	std	Y+2, r25	; 0x02
     844:	ab 83       	std	Y+3, r26	; 0x03
     846:	bc 83       	std	Y+4, r27	; 0x04

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
     848:	40 e0       	ldi	r20, 0x00	; 0
     84a:	50 e0       	ldi	r21, 0x00	; 0
     84c:	64 e0       	ldi	r22, 0x04	; 4
     84e:	70 e0       	ldi	r23, 0x00	; 0
     850:	ce 01       	movw	r24, r28
     852:	05 96       	adiw	r24, 0x05	; 5
     854:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
     858:	40 e0       	ldi	r20, 0x00	; 0
     85a:	50 e0       	ldi	r21, 0x00	; 0
     85c:	64 e0       	ldi	r22, 0x04	; 4
     85e:	70 e0       	ldi	r23, 0x00	; 0
     860:	ce 01       	movw	r24, r28
     862:	01 96       	adiw	r24, 0x01	; 1
     864:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <Endpoint_Write_Stream_BE>
     868:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     86c:	8e 77       	andi	r24, 0x7E	; 126
     86e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
     872:	f8 01       	movw	r30, r16
     874:	82 89       	ldd	r24, Z+18	; 0x12
     876:	93 89       	ldd	r25, Z+19	; 0x13
     878:	a4 89       	ldd	r26, Z+20	; 0x14
     87a:	b5 89       	ldd	r27, Z+21	; 0x15
     87c:	08 97       	sbiw	r24, 0x08	; 8
     87e:	a1 09       	sbc	r26, r1
     880:	b1 09       	sbc	r27, r1
     882:	82 c0       	rjmp	.+260    	; 0x988 <SCSI_DecodeSCSICommand+0x1ea>
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     884:	8a 32       	cpi	r24, 0x2A	; 42
     886:	09 f4       	brne	.+2      	; 0x88a <SCSI_DecodeSCSICommand+0xec>
     888:	77 c0       	rjmp	.+238    	; 0x978 <SCSI_DecodeSCSICommand+0x1da>
     88a:	8f 32       	cpi	r24, 0x2F	; 47
     88c:	09 f4       	brne	.+2      	; 0x890 <SCSI_DecodeSCSICommand+0xf2>
     88e:	81 c0       	rjmp	.+258    	; 0x992 <SCSI_DecodeSCSICommand+0x1f4>
     890:	86 c0       	rjmp	.+268    	; 0x99e <SCSI_DecodeSCSICommand+0x200>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     892:	f8 01       	movw	r30, r16
     894:	e4 8c       	ldd	r14, Z+28	; 0x1c
     896:	f5 8c       	ldd	r15, Z+29	; 0x1d

				Temp = Data.Bytes[0];
     898:	8e 2d       	mov	r24, r14
				Data.Bytes[0] = Data.Bytes[1];
     89a:	ef 2c       	mov	r14, r15
				Data.Bytes[1] = Temp;
     89c:	f8 2e       	mov	r15, r24
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
     89e:	82 8d       	ldd	r24, Z+26	; 0x1a
     8a0:	83 70       	andi	r24, 0x03	; 3
     8a2:	19 f4       	brne	.+6      	; 0x8aa <SCSI_DecodeSCSICommand+0x10c>
     8a4:	83 8d       	ldd	r24, Z+27	; 0x1b
     8a6:	88 23       	and	r24, r24
     8a8:	41 f0       	breq	.+16     	; 0x8ba <SCSI_DecodeSCSICommand+0x11c>
	     MSInterfaceInfo->State.CommandBlock.SCSICommandData[2])
	{
		/* Optional but unsupported bits set - update the SENSE key and fail the request */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     8aa:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <SenseData+0x2>
     8ae:	80 7f       	andi	r24, 0xF0	; 240
     8b0:	85 60       	ori	r24, 0x05	; 5
     8b2:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <SenseData+0x2>
     8b6:	84 e2       	ldi	r24, 0x24	; 36
     8b8:	79 c0       	rjmp	.+242    	; 0x9ac <SCSI_DecodeSCSICommand+0x20e>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
     8ba:	67 01       	movw	r12, r14
     8bc:	f5 e2       	ldi	r31, 0x25	; 37
     8be:	ef 16       	cp	r14, r31
     8c0:	f1 04       	cpc	r15, r1
     8c2:	18 f0       	brcs	.+6      	; 0x8ca <SCSI_DecodeSCSICommand+0x12c>
     8c4:	94 e2       	ldi	r25, 0x24	; 36
     8c6:	c9 2e       	mov	r12, r25
     8c8:	d1 2c       	mov	r13, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
     8ca:	40 e0       	ldi	r20, 0x00	; 0
     8cc:	50 e0       	ldi	r21, 0x00	; 0
     8ce:	b6 01       	movw	r22, r12
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	91 e0       	ldi	r25, 0x01	; 1
     8d4:	0e 94 20 2a 	call	0x5440	; 0x5440 <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     8d8:	60 e0       	ldi	r22, 0x00	; 0
     8da:	70 e0       	ldi	r23, 0x00	; 0
     8dc:	c7 01       	movw	r24, r14
     8de:	8c 19       	sub	r24, r12
     8e0:	9d 09       	sbc	r25, r13
     8e2:	0e 94 e1 29 	call	0x53c2	; 0x53c2 <Endpoint_Null_Stream>
     8e6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     8ea:	8e 77       	andi	r24, 0x7E	; 126
     8ec:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     8f0:	f8 01       	movw	r30, r16
     8f2:	82 89       	ldd	r24, Z+18	; 0x12
     8f4:	93 89       	ldd	r25, Z+19	; 0x13
     8f6:	a4 89       	ldd	r26, Z+20	; 0x14
     8f8:	b5 89       	ldd	r27, Z+21	; 0x15
     8fa:	8c 19       	sub	r24, r12
     8fc:	9d 09       	sbc	r25, r13
     8fe:	a1 09       	sbc	r26, r1
     900:	b1 09       	sbc	r27, r1
     902:	42 c0       	rjmp	.+132    	; 0x988 <SCSI_DecodeSCSICommand+0x1ea>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
     904:	f8 01       	movw	r30, r16
     906:	f5 8c       	ldd	r15, Z+29	; 0x1d
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
     908:	ef 2c       	mov	r14, r15
     90a:	f2 e1       	ldi	r31, 0x12	; 18
     90c:	ff 15       	cp	r31, r15
     90e:	10 f4       	brcc	.+4      	; 0x914 <SCSI_DecodeSCSICommand+0x176>
     910:	82 e1       	ldi	r24, 0x12	; 18
     912:	e8 2e       	mov	r14, r24

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
     914:	ce 2c       	mov	r12, r14
     916:	d1 2c       	mov	r13, r1
     918:	40 e0       	ldi	r20, 0x00	; 0
     91a:	50 e0       	ldi	r21, 0x00	; 0
     91c:	b6 01       	movw	r22, r12
     91e:	8c ee       	ldi	r24, 0xEC	; 236
     920:	91 e0       	ldi	r25, 0x01	; 1
     922:	0e 94 20 2a 	call	0x5440	; 0x5440 <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     926:	8f 2d       	mov	r24, r15
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	60 e0       	ldi	r22, 0x00	; 0
     92c:	70 e0       	ldi	r23, 0x00	; 0
     92e:	8c 19       	sub	r24, r12
     930:	9d 09       	sbc	r25, r13
     932:	0e 94 e1 29 	call	0x53c2	; 0x53c2 <Endpoint_Null_Stream>
     936:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     93a:	8e 77       	andi	r24, 0x7E	; 126
     93c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     940:	f8 01       	movw	r30, r16
     942:	82 89       	ldd	r24, Z+18	; 0x12
     944:	93 89       	ldd	r25, Z+19	; 0x13
     946:	a4 89       	ldd	r26, Z+20	; 0x14
     948:	b5 89       	ldd	r27, Z+21	; 0x15
     94a:	8e 19       	sub	r24, r14
     94c:	91 09       	sbc	r25, r1
     94e:	a1 09       	sbc	r26, r1
     950:	b1 09       	sbc	r27, r1
     952:	1a c0       	rjmp	.+52     	; 0x988 <SCSI_DecodeSCSICommand+0x1ea>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
     954:	f8 01       	movw	r30, r16
     956:	82 8d       	ldd	r24, Z+26	; 0x1a
     958:	82 ff       	sbrs	r24, 2
     95a:	a7 cf       	rjmp	.-178    	; 0x8aa <SCSI_DecodeSCSICommand+0x10c>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(DataflashManager_CheckDataflashOperation()))
     95c:	6c d3       	rcall	.+1752   	; 0x1036 <DataflashManager_CheckDataflashOperation>
     95e:	81 11       	cpse	r24, r1
     960:	18 c0       	rjmp	.+48     	; 0x992 <SCSI_DecodeSCSICommand+0x1f4>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
     962:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <SenseData+0x2>
     966:	80 7f       	andi	r24, 0xF0	; 240
     968:	84 60       	ori	r24, 0x04	; 4
     96a:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <SenseData+0x2>
     96e:	10 92 f8 01 	sts	0x01F8, r1	; 0x8001f8 <SenseData+0xc>
     972:	10 92 f9 01 	sts	0x01F9, r1	; 0x8001f9 <SenseData+0xd>
     976:	28 c0       	rjmp	.+80     	; 0x9c8 <SCSI_DecodeSCSICommand+0x22a>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
     978:	60 e0       	ldi	r22, 0x00	; 0
     97a:	01 c0       	rjmp	.+2      	; 0x97e <SCSI_DecodeSCSICommand+0x1e0>
			break;
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
     97c:	61 e0       	ldi	r22, 0x01	; 1
     97e:	c8 01       	movw	r24, r16
     980:	c2 de       	rcall	.-636    	; 0x706 <SCSI_Command_ReadWrite_10>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
     982:	81 11       	cpse	r24, r1
     984:	16 c0       	rjmp	.+44     	; 0x9b2 <SCSI_DecodeSCSICommand+0x214>
     986:	20 c0       	rjmp	.+64     	; 0x9c8 <SCSI_DecodeSCSICommand+0x22a>
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
     988:	82 8b       	std	Z+18, r24	; 0x12
     98a:	93 8b       	std	Z+19, r25	; 0x13
     98c:	a4 8b       	std	Z+20, r26	; 0x14
     98e:	b5 8b       	std	Z+21, r27	; 0x15
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
     990:	10 c0       	rjmp	.+32     	; 0x9b2 <SCSI_DecodeSCSICommand+0x214>
		case SCSI_CMD_TEST_UNIT_READY:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
     992:	f8 01       	movw	r30, r16
     994:	12 8a       	std	Z+18, r1	; 0x12
     996:	13 8a       	std	Z+19, r1	; 0x13
     998:	14 8a       	std	Z+20, r1	; 0x14
     99a:	15 8a       	std	Z+21, r1	; 0x15
			break;
     99c:	0a c0       	rjmp	.+20     	; 0x9b2 <SCSI_DecodeSCSICommand+0x214>
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     99e:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <SenseData+0x2>
     9a2:	80 7f       	andi	r24, 0xF0	; 240
     9a4:	85 60       	ori	r24, 0x05	; 5
     9a6:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <SenseData+0x2>
     9aa:	80 e2       	ldi	r24, 0x20	; 32
     9ac:	80 93 f8 01 	sts	0x01F8, r24	; 0x8001f8 <SenseData+0xc>
     9b0:	e0 cf       	rjmp	.-64     	; 0x972 <SCSI_DecodeSCSICommand+0x1d4>
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
     9b2:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <SenseData+0x2>
     9b6:	80 7f       	andi	r24, 0xF0	; 240
     9b8:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <SenseData+0x2>
     9bc:	10 92 f8 01 	sts	0x01F8, r1	; 0x8001f8 <SenseData+0xc>
     9c0:	10 92 f9 01 	sts	0x01F9, r1	; 0x8001f9 <SenseData+0xd>
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
     9c4:	81 e0       	ldi	r24, 0x01	; 1
     9c6:	01 c0       	rjmp	.+2      	; 0x9ca <SCSI_DecodeSCSICommand+0x22c>
	}

	return false;
     9c8:	80 e0       	ldi	r24, 0x00	; 0
}
     9ca:	28 96       	adiw	r28, 0x08	; 8
     9cc:	0f b6       	in	r0, 0x3f	; 63
     9ce:	f8 94       	cli
     9d0:	de bf       	out	0x3e, r29	; 62
     9d2:	0f be       	out	0x3f, r0	; 63
     9d4:	cd bf       	out	0x3d, r28	; 61
     9d6:	df 91       	pop	r29
     9d8:	cf 91       	pop	r28
     9da:	1f 91       	pop	r17
     9dc:	0f 91       	pop	r16
     9de:	ff 90       	pop	r15
     9e0:	ef 90       	pop	r14
     9e2:	df 90       	pop	r13
     9e4:	cf 90       	pop	r12
     9e6:	08 95       	ret

000009e8 <Dataflash_ToggleSelectedChipCS>:
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
				while (!(SPSR & (1 << SPIF)));
     9e8:	8e b1       	in	r24, 0x0e	; 14
     9ea:	9e b1       	in	r25, 0x0e	; 14
     9ec:	93 60       	ori	r25, 0x03	; 3
     9ee:	9e b9       	out	0x0e, r25	; 14
     9f0:	9e b1       	in	r25, 0x0e	; 14
     9f2:	9c 7f       	andi	r25, 0xFC	; 252
     9f4:	83 70       	andi	r24, 0x03	; 3
     9f6:	89 2b       	or	r24, r25
     9f8:	8e b9       	out	0x0e, r24	; 14
     9fa:	08 95       	ret

000009fc <Dataflash_WaitWhileBusy>:
     9fc:	f5 df       	rcall	.-22     	; 0x9e8 <Dataflash_ToggleSelectedChipCS>
     9fe:	87 ed       	ldi	r24, 0xD7	; 215
     a00:	8e bd       	out	0x2e, r24	; 46
     a02:	0d b4       	in	r0, 0x2d	; 45
     a04:	07 fe       	sbrs	r0, 7
     a06:	fd cf       	rjmp	.-6      	; 0xa02 <Dataflash_WaitWhileBusy+0x6>
     a08:	1e bc       	out	0x2e, r1	; 46
     a0a:	0d b4       	in	r0, 0x2d	; 45
     a0c:	07 fe       	sbrs	r0, 7
     a0e:	fd cf       	rjmp	.-6      	; 0xa0a <Dataflash_WaitWhileBusy+0xe>
     a10:	0e b4       	in	r0, 0x2e	; 46
     a12:	07 fe       	sbrs	r0, 7
     a14:	f9 cf       	rjmp	.-14     	; 0xa08 <Dataflash_WaitWhileBusy+0xc>
     a16:	e8 cf       	rjmp	.-48     	; 0x9e8 <Dataflash_ToggleSelectedChipCS>

00000a18 <Dataflash_SendAddressBytes>:
     a18:	9c 01       	movw	r18, r24
     a1a:	36 95       	lsr	r19
     a1c:	27 95       	ror	r18
     a1e:	56 e0       	ldi	r21, 0x06	; 6
     a20:	96 95       	lsr	r25
     a22:	87 95       	ror	r24
     a24:	5a 95       	dec	r21
     a26:	e1 f7       	brne	.-8      	; 0xa20 <Dataflash_SendAddressBytes+0x8>
     a28:	8e bd       	out	0x2e, r24	; 46
     a2a:	0d b4       	in	r0, 0x2d	; 45
     a2c:	07 fe       	sbrs	r0, 7
     a2e:	fd cf       	rjmp	.-6      	; 0xa2a <Dataflash_SendAddressBytes+0x12>
     a30:	22 0f       	add	r18, r18
     a32:	22 0f       	add	r18, r18
     a34:	22 0f       	add	r18, r18
     a36:	27 2b       	or	r18, r23
     a38:	2e bd       	out	0x2e, r18	; 46
     a3a:	0d b4       	in	r0, 0x2d	; 45
     a3c:	07 fe       	sbrs	r0, 7
     a3e:	fd cf       	rjmp	.-6      	; 0xa3a <Dataflash_SendAddressBytes+0x22>
     a40:	6e bd       	out	0x2e, r22	; 46
     a42:	0d b4       	in	r0, 0x2d	; 45
     a44:	07 fe       	sbrs	r0, 7
     a46:	fd cf       	rjmp	.-6      	; 0xa42 <Dataflash_SendAddressBytes+0x2a>
     a48:	08 95       	ret

00000a4a <Dataflash_SelectChipFromPage>:
     a4a:	9c 01       	movw	r18, r24
     a4c:	9e b1       	in	r25, 0x0e	; 14
     a4e:	93 60       	ori	r25, 0x03	; 3
     a50:	9e b9       	out	0x0e, r25	; 14
     a52:	21 15       	cp	r18, r1
     a54:	80 e4       	ldi	r24, 0x40	; 64
     a56:	38 07       	cpc	r19, r24
     a58:	40 f4       	brcc	.+16     	; 0xa6a <Dataflash_SelectChipFromPage+0x20>
     a5a:	8e b1       	in	r24, 0x0e	; 14
     a5c:	8c 7f       	andi	r24, 0xFC	; 252
     a5e:	20 ff       	sbrs	r18, 0
     a60:	02 c0       	rjmp	.+4      	; 0xa66 <Dataflash_SelectChipFromPage+0x1c>
     a62:	81 60       	ori	r24, 0x01	; 1
     a64:	01 c0       	rjmp	.+2      	; 0xa68 <Dataflash_SelectChipFromPage+0x1e>
     a66:	82 60       	ori	r24, 0x02	; 2
     a68:	8e b9       	out	0x0e, r24	; 14
     a6a:	08 95       	ret

00000a6c <DataflashManager_WriteBlocks>:
     a6c:	4f 92       	push	r4
     a6e:	5f 92       	push	r5
     a70:	6f 92       	push	r6
     a72:	7f 92       	push	r7
     a74:	8f 92       	push	r8
     a76:	9f 92       	push	r9
     a78:	af 92       	push	r10
     a7a:	bf 92       	push	r11
     a7c:	cf 92       	push	r12
     a7e:	df 92       	push	r13
     a80:	ef 92       	push	r14
     a82:	ff 92       	push	r15
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	4c 01       	movw	r8, r24
     a8e:	89 01       	movw	r16, r18
     a90:	2a 01       	movw	r4, r20
     a92:	3b 01       	movw	r6, r22
     a94:	39 e0       	ldi	r19, 0x09	; 9
     a96:	44 0c       	add	r4, r4
     a98:	55 1c       	adc	r5, r5
     a9a:	66 1c       	adc	r6, r6
     a9c:	77 1c       	adc	r7, r7
     a9e:	3a 95       	dec	r19
     aa0:	d1 f7       	brne	.-12     	; 0xa96 <DataflashManager_WriteBlocks+0x2a>
     aa2:	6a e0       	ldi	r22, 0x0A	; 10
     aa4:	76 94       	lsr	r7
     aa6:	67 94       	ror	r6
     aa8:	57 94       	ror	r5
     aaa:	47 94       	ror	r4
     aac:	6a 95       	dec	r22
     aae:	d1 f7       	brne	.-12     	; 0xaa4 <DataflashManager_WriteBlocks+0x38>
     ab0:	e2 01       	movw	r28, r4
     ab2:	54 2f       	mov	r21, r20
     ab4:	44 27       	eor	r20, r20
     ab6:	55 0f       	add	r21, r21
     ab8:	7a 01       	movw	r14, r20
     aba:	ee 24       	eor	r14, r14
     abc:	82 e0       	ldi	r24, 0x02	; 2
     abe:	f8 22       	and	r15, r24
     ac0:	c2 01       	movw	r24, r4
     ac2:	c3 df       	rcall	.-122    	; 0xa4a <Dataflash_SelectChipFromPage>
     ac4:	83 e5       	ldi	r24, 0x53	; 83
     ac6:	8e bd       	out	0x2e, r24	; 46
     ac8:	0d b4       	in	r0, 0x2d	; 45
     aca:	07 fe       	sbrs	r0, 7
     acc:	fd cf       	rjmp	.-6      	; 0xac8 <DataflashManager_WriteBlocks+0x5c>
     ace:	60 e0       	ldi	r22, 0x00	; 0
     ad0:	70 e0       	ldi	r23, 0x00	; 0
     ad2:	c2 01       	movw	r24, r4
     ad4:	a1 df       	rcall	.-190    	; 0xa18 <Dataflash_SendAddressBytes>
     ad6:	92 df       	rcall	.-220    	; 0x9fc <Dataflash_WaitWhileBusy>
     ad8:	84 e8       	ldi	r24, 0x84	; 132
     ada:	8e bd       	out	0x2e, r24	; 46
     adc:	0d b4       	in	r0, 0x2d	; 45
     ade:	07 fe       	sbrs	r0, 7
     ae0:	fd cf       	rjmp	.-6      	; 0xadc <DataflashManager_WriteBlocks+0x70>
     ae2:	b7 01       	movw	r22, r14
     ae4:	80 e0       	ldi	r24, 0x00	; 0
     ae6:	90 e0       	ldi	r25, 0x00	; 0
     ae8:	97 df       	rcall	.-210    	; 0xa18 <Dataflash_SendAddressBytes>
     aea:	0e 94 ad 24 	call	0x495a	; 0x495a <Endpoint_WaitUntilReady>
     aee:	81 11       	cpse	r24, r1
     af0:	eb c0       	rjmp	.+470    	; 0xcc8 <DataflashManager_WriteBlocks+0x25c>
     af2:	94 e0       	ldi	r25, 0x04	; 4
     af4:	f6 94       	lsr	r15
     af6:	e7 94       	ror	r14
     af8:	9a 95       	dec	r25
     afa:	e1 f7       	brne	.-8      	; 0xaf4 <DataflashManager_WriteBlocks+0x88>
     afc:	7e 2c       	mov	r7, r14
     afe:	58 01       	movw	r10, r16
     b00:	25 e0       	ldi	r18, 0x05	; 5
     b02:	aa 0c       	add	r10, r10
     b04:	bb 1c       	adc	r11, r11
     b06:	2a 95       	dec	r18
     b08:	e1 f7       	brne	.-8      	; 0xb02 <DataflashManager_WriteBlocks+0x96>
     b0a:	e1 2c       	mov	r14, r1
     b0c:	f1 2c       	mov	r15, r1
     b0e:	61 2c       	mov	r6, r1
     b10:	01 15       	cp	r16, r1
     b12:	11 05       	cpc	r17, r1
     b14:	09 f4       	brne	.+2      	; 0xb18 <DataflashManager_WriteBlocks+0xac>
     b16:	bd c0       	rjmp	.+378    	; 0xc92 <DataflashManager_WriteBlocks+0x226>
     b18:	65 01       	movw	r12, r10
     b1a:	ce 0c       	add	r12, r14
     b1c:	df 1c       	adc	r13, r15
     b1e:	80 e2       	ldi	r24, 0x20	; 32
     b20:	58 2e       	mov	r5, r24
     b22:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     b26:	85 ff       	sbrs	r24, 5
     b28:	04 c0       	rjmp	.+8      	; 0xb32 <DataflashManager_WriteBlocks+0xc6>
     b2a:	e0 e4       	ldi	r30, 0x40	; 64
     b2c:	7e 12       	cpse	r7, r30
     b2e:	43 c0       	rjmp	.+134    	; 0xbb6 <DataflashManager_WriteBlocks+0x14a>
     b30:	0a c0       	rjmp	.+20     	; 0xb46 <DataflashManager_WriteBlocks+0xda>
     b32:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     b36:	8b 77       	andi	r24, 0x7B	; 123
     b38:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     b3c:	0e 94 ad 24 	call	0x495a	; 0x495a <Endpoint_WaitUntilReady>
     b40:	88 23       	and	r24, r24
     b42:	99 f3       	breq	.-26     	; 0xb2a <DataflashManager_WriteBlocks+0xbe>
     b44:	c1 c0       	rjmp	.+386    	; 0xcc8 <DataflashManager_WriteBlocks+0x25c>
     b46:	5a df       	rcall	.-332    	; 0x9fc <Dataflash_WaitWhileBusy>
     b48:	61 10       	cpse	r6, r1
     b4a:	02 c0       	rjmp	.+4      	; 0xb50 <DataflashManager_WriteBlocks+0xe4>
     b4c:	83 e8       	ldi	r24, 0x83	; 131
     b4e:	01 c0       	rjmp	.+2      	; 0xb52 <DataflashManager_WriteBlocks+0xe6>
     b50:	86 e8       	ldi	r24, 0x86	; 134
     b52:	8e bd       	out	0x2e, r24	; 46
     b54:	0d b4       	in	r0, 0x2d	; 45
     b56:	07 fe       	sbrs	r0, 7
     b58:	fd cf       	rjmp	.-6      	; 0xb54 <DataflashManager_WriteBlocks+0xe8>
     b5a:	60 e0       	ldi	r22, 0x00	; 0
     b5c:	70 e0       	ldi	r23, 0x00	; 0
     b5e:	ce 01       	movw	r24, r28
     b60:	5b df       	rcall	.-330    	; 0xa18 <Dataflash_SendAddressBytes>
     b62:	21 96       	adiw	r28, 0x01	; 1
     b64:	8e b1       	in	r24, 0x0e	; 14
     b66:	83 70       	andi	r24, 0x03	; 3
     b68:	81 30       	cpi	r24, 0x01	; 1
     b6a:	09 f4       	brne	.+2      	; 0xb6e <DataflashManager_WriteBlocks+0x102>
     b6c:	68 26       	eor	r6, r24
     b6e:	ce 01       	movw	r24, r28
     b70:	6c df       	rcall	.-296    	; 0xa4a <Dataflash_SelectChipFromPage>
     b72:	f0 e4       	ldi	r31, 0x40	; 64
     b74:	cf 16       	cp	r12, r31
     b76:	d1 04       	cpc	r13, r1
     b78:	78 f4       	brcc	.+30     	; 0xb98 <DataflashManager_WriteBlocks+0x12c>
     b7a:	40 df       	rcall	.-384    	; 0x9fc <Dataflash_WaitWhileBusy>
     b7c:	61 10       	cpse	r6, r1
     b7e:	02 c0       	rjmp	.+4      	; 0xb84 <DataflashManager_WriteBlocks+0x118>
     b80:	83 e5       	ldi	r24, 0x53	; 83
     b82:	01 c0       	rjmp	.+2      	; 0xb86 <DataflashManager_WriteBlocks+0x11a>
     b84:	85 e5       	ldi	r24, 0x55	; 85
     b86:	8e bd       	out	0x2e, r24	; 46
     b88:	0d b4       	in	r0, 0x2d	; 45
     b8a:	07 fe       	sbrs	r0, 7
     b8c:	fd cf       	rjmp	.-6      	; 0xb88 <DataflashManager_WriteBlocks+0x11c>
     b8e:	60 e0       	ldi	r22, 0x00	; 0
     b90:	70 e0       	ldi	r23, 0x00	; 0
     b92:	ce 01       	movw	r24, r28
     b94:	41 df       	rcall	.-382    	; 0xa18 <Dataflash_SendAddressBytes>
     b96:	32 df       	rcall	.-412    	; 0x9fc <Dataflash_WaitWhileBusy>
     b98:	61 10       	cpse	r6, r1
     b9a:	02 c0       	rjmp	.+4      	; 0xba0 <DataflashManager_WriteBlocks+0x134>
     b9c:	84 e8       	ldi	r24, 0x84	; 132
     b9e:	01 c0       	rjmp	.+2      	; 0xba2 <DataflashManager_WriteBlocks+0x136>
     ba0:	87 e8       	ldi	r24, 0x87	; 135
     ba2:	8e bd       	out	0x2e, r24	; 46
     ba4:	0d b4       	in	r0, 0x2d	; 45
     ba6:	07 fe       	sbrs	r0, 7
     ba8:	fd cf       	rjmp	.-6      	; 0xba4 <DataflashManager_WriteBlocks+0x138>
     baa:	60 e0       	ldi	r22, 0x00	; 0
     bac:	70 e0       	ldi	r23, 0x00	; 0
     bae:	80 e0       	ldi	r24, 0x00	; 0
     bb0:	90 e0       	ldi	r25, 0x00	; 0
     bb2:	32 df       	rcall	.-412    	; 0xa18 <Dataflash_SendAddressBytes>
     bb4:	71 2c       	mov	r7, r1
     bb6:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     bba:	8e bd       	out	0x2e, r24	; 46
     bbc:	0d b4       	in	r0, 0x2d	; 45
     bbe:	07 fe       	sbrs	r0, 7
     bc0:	fd cf       	rjmp	.-6      	; 0xbbc <DataflashManager_WriteBlocks+0x150>
     bc2:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     bc6:	8e bd       	out	0x2e, r24	; 46
     bc8:	0d b4       	in	r0, 0x2d	; 45
     bca:	07 fe       	sbrs	r0, 7
     bcc:	fd cf       	rjmp	.-6      	; 0xbc8 <DataflashManager_WriteBlocks+0x15c>
     bce:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     bd2:	8e bd       	out	0x2e, r24	; 46
     bd4:	0d b4       	in	r0, 0x2d	; 45
     bd6:	07 fe       	sbrs	r0, 7
     bd8:	fd cf       	rjmp	.-6      	; 0xbd4 <DataflashManager_WriteBlocks+0x168>
     bda:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     bde:	8e bd       	out	0x2e, r24	; 46
     be0:	0d b4       	in	r0, 0x2d	; 45
     be2:	07 fe       	sbrs	r0, 7
     be4:	fd cf       	rjmp	.-6      	; 0xbe0 <DataflashManager_WriteBlocks+0x174>
     be6:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     bea:	8e bd       	out	0x2e, r24	; 46
     bec:	0d b4       	in	r0, 0x2d	; 45
     bee:	07 fe       	sbrs	r0, 7
     bf0:	fd cf       	rjmp	.-6      	; 0xbec <DataflashManager_WriteBlocks+0x180>
     bf2:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     bf6:	8e bd       	out	0x2e, r24	; 46
     bf8:	0d b4       	in	r0, 0x2d	; 45
     bfa:	07 fe       	sbrs	r0, 7
     bfc:	fd cf       	rjmp	.-6      	; 0xbf8 <DataflashManager_WriteBlocks+0x18c>
     bfe:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c02:	8e bd       	out	0x2e, r24	; 46
     c04:	0d b4       	in	r0, 0x2d	; 45
     c06:	07 fe       	sbrs	r0, 7
     c08:	fd cf       	rjmp	.-6      	; 0xc04 <DataflashManager_WriteBlocks+0x198>
     c0a:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c0e:	8e bd       	out	0x2e, r24	; 46
     c10:	0d b4       	in	r0, 0x2d	; 45
     c12:	07 fe       	sbrs	r0, 7
     c14:	fd cf       	rjmp	.-6      	; 0xc10 <DataflashManager_WriteBlocks+0x1a4>
     c16:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c1a:	8e bd       	out	0x2e, r24	; 46
     c1c:	0d b4       	in	r0, 0x2d	; 45
     c1e:	07 fe       	sbrs	r0, 7
     c20:	fd cf       	rjmp	.-6      	; 0xc1c <DataflashManager_WriteBlocks+0x1b0>
     c22:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c26:	8e bd       	out	0x2e, r24	; 46
     c28:	0d b4       	in	r0, 0x2d	; 45
     c2a:	07 fe       	sbrs	r0, 7
     c2c:	fd cf       	rjmp	.-6      	; 0xc28 <DataflashManager_WriteBlocks+0x1bc>
     c2e:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c32:	8e bd       	out	0x2e, r24	; 46
     c34:	0d b4       	in	r0, 0x2d	; 45
     c36:	07 fe       	sbrs	r0, 7
     c38:	fd cf       	rjmp	.-6      	; 0xc34 <DataflashManager_WriteBlocks+0x1c8>
     c3a:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c3e:	8e bd       	out	0x2e, r24	; 46
     c40:	0d b4       	in	r0, 0x2d	; 45
     c42:	07 fe       	sbrs	r0, 7
     c44:	fd cf       	rjmp	.-6      	; 0xc40 <DataflashManager_WriteBlocks+0x1d4>
     c46:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c4a:	8e bd       	out	0x2e, r24	; 46
     c4c:	0d b4       	in	r0, 0x2d	; 45
     c4e:	07 fe       	sbrs	r0, 7
     c50:	fd cf       	rjmp	.-6      	; 0xc4c <DataflashManager_WriteBlocks+0x1e0>
     c52:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c56:	8e bd       	out	0x2e, r24	; 46
     c58:	0d b4       	in	r0, 0x2d	; 45
     c5a:	07 fe       	sbrs	r0, 7
     c5c:	fd cf       	rjmp	.-6      	; 0xc58 <DataflashManager_WriteBlocks+0x1ec>
     c5e:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c62:	8e bd       	out	0x2e, r24	; 46
     c64:	0d b4       	in	r0, 0x2d	; 45
     c66:	07 fe       	sbrs	r0, 7
     c68:	fd cf       	rjmp	.-6      	; 0xc64 <DataflashManager_WriteBlocks+0x1f8>
     c6a:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     c6e:	8e bd       	out	0x2e, r24	; 46
     c70:	0d b4       	in	r0, 0x2d	; 45
     c72:	07 fe       	sbrs	r0, 7
     c74:	fd cf       	rjmp	.-6      	; 0xc70 <DataflashManager_WriteBlocks+0x204>
     c76:	73 94       	inc	r7
     c78:	f4 01       	movw	r30, r8
     c7a:	86 a9       	ldd	r24, Z+54	; 0x36
     c7c:	81 11       	cpse	r24, r1
     c7e:	24 c0       	rjmp	.+72     	; 0xcc8 <DataflashManager_WriteBlocks+0x25c>
     c80:	5a 94       	dec	r5
     c82:	51 10       	cpse	r5, r1
     c84:	4e cf       	rjmp	.-356    	; 0xb22 <DataflashManager_WriteBlocks+0xb6>
     c86:	01 50       	subi	r16, 0x01	; 1
     c88:	11 09       	sbc	r17, r1
     c8a:	f0 e2       	ldi	r31, 0x20	; 32
     c8c:	ef 1a       	sub	r14, r31
     c8e:	f1 08       	sbc	r15, r1
     c90:	3f cf       	rjmp	.-386    	; 0xb10 <DataflashManager_WriteBlocks+0xa4>
     c92:	b4 de       	rcall	.-664    	; 0x9fc <Dataflash_WaitWhileBusy>
     c94:	61 10       	cpse	r6, r1
     c96:	02 c0       	rjmp	.+4      	; 0xc9c <DataflashManager_WriteBlocks+0x230>
     c98:	83 e8       	ldi	r24, 0x83	; 131
     c9a:	01 c0       	rjmp	.+2      	; 0xc9e <DataflashManager_WriteBlocks+0x232>
     c9c:	86 e8       	ldi	r24, 0x86	; 134
     c9e:	8e bd       	out	0x2e, r24	; 46
     ca0:	0d b4       	in	r0, 0x2d	; 45
     ca2:	07 fe       	sbrs	r0, 7
     ca4:	fd cf       	rjmp	.-6      	; 0xca0 <DataflashManager_WriteBlocks+0x234>
     ca6:	60 e0       	ldi	r22, 0x00	; 0
     ca8:	70 e0       	ldi	r23, 0x00	; 0
     caa:	ce 01       	movw	r24, r28
     cac:	b5 de       	rcall	.-662    	; 0xa18 <Dataflash_SendAddressBytes>
     cae:	a6 de       	rcall	.-692    	; 0x9fc <Dataflash_WaitWhileBusy>
     cb0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     cb4:	85 fd       	sbrc	r24, 5
     cb6:	05 c0       	rjmp	.+10     	; 0xcc2 <DataflashManager_WriteBlocks+0x256>
     cb8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     cbc:	8b 77       	andi	r24, 0x7B	; 123
     cbe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     cc2:	8e b1       	in	r24, 0x0e	; 14
     cc4:	83 60       	ori	r24, 0x03	; 3
     cc6:	8e b9       	out	0x0e, r24	; 14
     cc8:	df 91       	pop	r29
     cca:	cf 91       	pop	r28
     ccc:	1f 91       	pop	r17
     cce:	0f 91       	pop	r16
     cd0:	ff 90       	pop	r15
     cd2:	ef 90       	pop	r14
     cd4:	df 90       	pop	r13
     cd6:	cf 90       	pop	r12
     cd8:	bf 90       	pop	r11
     cda:	af 90       	pop	r10
     cdc:	9f 90       	pop	r9
     cde:	8f 90       	pop	r8
     ce0:	7f 90       	pop	r7
     ce2:	6f 90       	pop	r6
     ce4:	5f 90       	pop	r5
     ce6:	4f 90       	pop	r4
     ce8:	08 95       	ret

00000cea <DataflashManager_ReadBlocks>:
     cea:	8f 92       	push	r8
     cec:	9f 92       	push	r9
     cee:	af 92       	push	r10
     cf0:	bf 92       	push	r11
     cf2:	cf 92       	push	r12
     cf4:	df 92       	push	r13
     cf6:	ef 92       	push	r14
     cf8:	ff 92       	push	r15
     cfa:	0f 93       	push	r16
     cfc:	1f 93       	push	r17
     cfe:	cf 93       	push	r28
     d00:	df 93       	push	r29
     d02:	6c 01       	movw	r12, r24
     d04:	79 01       	movw	r14, r18
     d06:	4a 01       	movw	r8, r20
     d08:	5b 01       	movw	r10, r22
     d0a:	29 e0       	ldi	r18, 0x09	; 9
     d0c:	88 0c       	add	r8, r8
     d0e:	99 1c       	adc	r9, r9
     d10:	aa 1c       	adc	r10, r10
     d12:	bb 1c       	adc	r11, r11
     d14:	2a 95       	dec	r18
     d16:	d1 f7       	brne	.-12     	; 0xd0c <DataflashManager_ReadBlocks+0x22>
     d18:	3a e0       	ldi	r19, 0x0A	; 10
     d1a:	b6 94       	lsr	r11
     d1c:	a7 94       	ror	r10
     d1e:	97 94       	ror	r9
     d20:	87 94       	ror	r8
     d22:	3a 95       	dec	r19
     d24:	d1 f7       	brne	.-12     	; 0xd1a <DataflashManager_ReadBlocks+0x30>
     d26:	84 01       	movw	r16, r8
     d28:	ea 01       	movw	r28, r20
     d2a:	dc 2f       	mov	r29, r28
     d2c:	cc 27       	eor	r28, r28
     d2e:	dd 0f       	add	r29, r29
     d30:	cc 27       	eor	r28, r28
     d32:	d2 70       	andi	r29, 0x02	; 2
     d34:	c4 01       	movw	r24, r8
     d36:	89 de       	rcall	.-750    	; 0xa4a <Dataflash_SelectChipFromPage>
     d38:	82 ed       	ldi	r24, 0xD2	; 210
     d3a:	8e bd       	out	0x2e, r24	; 46
     d3c:	0d b4       	in	r0, 0x2d	; 45
     d3e:	07 fe       	sbrs	r0, 7
     d40:	fd cf       	rjmp	.-6      	; 0xd3c <DataflashManager_ReadBlocks+0x52>
     d42:	be 01       	movw	r22, r28
     d44:	c4 01       	movw	r24, r8
     d46:	68 de       	rcall	.-816    	; 0xa18 <Dataflash_SendAddressBytes>
     d48:	1e bc       	out	0x2e, r1	; 46
     d4a:	0d b4       	in	r0, 0x2d	; 45
     d4c:	07 fe       	sbrs	r0, 7
     d4e:	fd cf       	rjmp	.-6      	; 0xd4a <DataflashManager_ReadBlocks+0x60>
     d50:	1e bc       	out	0x2e, r1	; 46
     d52:	0d b4       	in	r0, 0x2d	; 45
     d54:	07 fe       	sbrs	r0, 7
     d56:	fd cf       	rjmp	.-6      	; 0xd52 <DataflashManager_ReadBlocks+0x68>
     d58:	1e bc       	out	0x2e, r1	; 46
     d5a:	0d b4       	in	r0, 0x2d	; 45
     d5c:	07 fe       	sbrs	r0, 7
     d5e:	fd cf       	rjmp	.-6      	; 0xd5a <DataflashManager_ReadBlocks+0x70>
     d60:	1e bc       	out	0x2e, r1	; 46
     d62:	0d b4       	in	r0, 0x2d	; 45
     d64:	07 fe       	sbrs	r0, 7
     d66:	fd cf       	rjmp	.-6      	; 0xd62 <DataflashManager_ReadBlocks+0x78>
     d68:	0e 94 ad 24 	call	0x495a	; 0x495a <Endpoint_WaitUntilReady>
     d6c:	81 11       	cpse	r24, r1
     d6e:	c2 c0       	rjmp	.+388    	; 0xef4 <DataflashManager_ReadBlocks+0x20a>
     d70:	84 e0       	ldi	r24, 0x04	; 4
     d72:	d6 95       	lsr	r29
     d74:	c7 95       	ror	r28
     d76:	8a 95       	dec	r24
     d78:	e1 f7       	brne	.-8      	; 0xd72 <DataflashManager_ReadBlocks+0x88>
     d7a:	92 ed       	ldi	r25, 0xD2	; 210
     d7c:	b9 2e       	mov	r11, r25
     d7e:	e1 14       	cp	r14, r1
     d80:	f1 04       	cpc	r15, r1
     d82:	09 f4       	brne	.+2      	; 0xd86 <DataflashManager_ReadBlocks+0x9c>
     d84:	ab c0       	rjmp	.+342    	; 0xedc <DataflashManager_ReadBlocks+0x1f2>
     d86:	d0 e2       	ldi	r29, 0x20	; 32
     d88:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     d8c:	85 ff       	sbrs	r24, 5
     d8e:	08 c0       	rjmp	.+16     	; 0xda0 <DataflashManager_ReadBlocks+0xb6>
     d90:	c0 34       	cpi	r28, 0x40	; 64
     d92:	41 f5       	brne	.+80     	; 0xde4 <DataflashManager_ReadBlocks+0xfa>
     d94:	0f 5f       	subi	r16, 0xFF	; 255
     d96:	1f 4f       	sbci	r17, 0xFF	; 255
     d98:	c8 01       	movw	r24, r16
     d9a:	57 de       	rcall	.-850    	; 0xa4a <Dataflash_SelectChipFromPage>
     d9c:	be bc       	out	0x2e, r11	; 46
     d9e:	0a c0       	rjmp	.+20     	; 0xdb4 <DataflashManager_ReadBlocks+0xca>
     da0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     da4:	8e 77       	andi	r24, 0x7E	; 126
     da6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     daa:	0e 94 ad 24 	call	0x495a	; 0x495a <Endpoint_WaitUntilReady>
     dae:	88 23       	and	r24, r24
     db0:	79 f3       	breq	.-34     	; 0xd90 <DataflashManager_ReadBlocks+0xa6>
     db2:	a0 c0       	rjmp	.+320    	; 0xef4 <DataflashManager_ReadBlocks+0x20a>
     db4:	0d b4       	in	r0, 0x2d	; 45
     db6:	07 fe       	sbrs	r0, 7
     db8:	fd cf       	rjmp	.-6      	; 0xdb4 <DataflashManager_ReadBlocks+0xca>
     dba:	60 e0       	ldi	r22, 0x00	; 0
     dbc:	70 e0       	ldi	r23, 0x00	; 0
     dbe:	c8 01       	movw	r24, r16
     dc0:	2b de       	rcall	.-938    	; 0xa18 <Dataflash_SendAddressBytes>
     dc2:	1e bc       	out	0x2e, r1	; 46
     dc4:	0d b4       	in	r0, 0x2d	; 45
     dc6:	07 fe       	sbrs	r0, 7
     dc8:	fd cf       	rjmp	.-6      	; 0xdc4 <DataflashManager_ReadBlocks+0xda>
     dca:	1e bc       	out	0x2e, r1	; 46
     dcc:	0d b4       	in	r0, 0x2d	; 45
     dce:	07 fe       	sbrs	r0, 7
     dd0:	fd cf       	rjmp	.-6      	; 0xdcc <DataflashManager_ReadBlocks+0xe2>
     dd2:	1e bc       	out	0x2e, r1	; 46
     dd4:	0d b4       	in	r0, 0x2d	; 45
     dd6:	07 fe       	sbrs	r0, 7
     dd8:	fd cf       	rjmp	.-6      	; 0xdd4 <DataflashManager_ReadBlocks+0xea>
     dda:	1e bc       	out	0x2e, r1	; 46
     ddc:	0d b4       	in	r0, 0x2d	; 45
     dde:	07 fe       	sbrs	r0, 7
     de0:	fd cf       	rjmp	.-6      	; 0xddc <DataflashManager_ReadBlocks+0xf2>
     de2:	c0 e0       	ldi	r28, 0x00	; 0
     de4:	1e bc       	out	0x2e, r1	; 46
     de6:	0d b4       	in	r0, 0x2d	; 45
     de8:	07 fe       	sbrs	r0, 7
     dea:	fd cf       	rjmp	.-6      	; 0xde6 <DataflashManager_ReadBlocks+0xfc>
     dec:	8e b5       	in	r24, 0x2e	; 46
     dee:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     df2:	1e bc       	out	0x2e, r1	; 46
     df4:	0d b4       	in	r0, 0x2d	; 45
     df6:	07 fe       	sbrs	r0, 7
     df8:	fd cf       	rjmp	.-6      	; 0xdf4 <DataflashManager_ReadBlocks+0x10a>
     dfa:	8e b5       	in	r24, 0x2e	; 46
     dfc:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e00:	1e bc       	out	0x2e, r1	; 46
     e02:	0d b4       	in	r0, 0x2d	; 45
     e04:	07 fe       	sbrs	r0, 7
     e06:	fd cf       	rjmp	.-6      	; 0xe02 <DataflashManager_ReadBlocks+0x118>
     e08:	8e b5       	in	r24, 0x2e	; 46
     e0a:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e0e:	1e bc       	out	0x2e, r1	; 46
     e10:	0d b4       	in	r0, 0x2d	; 45
     e12:	07 fe       	sbrs	r0, 7
     e14:	fd cf       	rjmp	.-6      	; 0xe10 <DataflashManager_ReadBlocks+0x126>
     e16:	8e b5       	in	r24, 0x2e	; 46
     e18:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e1c:	1e bc       	out	0x2e, r1	; 46
     e1e:	0d b4       	in	r0, 0x2d	; 45
     e20:	07 fe       	sbrs	r0, 7
     e22:	fd cf       	rjmp	.-6      	; 0xe1e <DataflashManager_ReadBlocks+0x134>
     e24:	8e b5       	in	r24, 0x2e	; 46
     e26:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e2a:	1e bc       	out	0x2e, r1	; 46
     e2c:	0d b4       	in	r0, 0x2d	; 45
     e2e:	07 fe       	sbrs	r0, 7
     e30:	fd cf       	rjmp	.-6      	; 0xe2c <DataflashManager_ReadBlocks+0x142>
     e32:	8e b5       	in	r24, 0x2e	; 46
     e34:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e38:	1e bc       	out	0x2e, r1	; 46
     e3a:	0d b4       	in	r0, 0x2d	; 45
     e3c:	07 fe       	sbrs	r0, 7
     e3e:	fd cf       	rjmp	.-6      	; 0xe3a <DataflashManager_ReadBlocks+0x150>
     e40:	8e b5       	in	r24, 0x2e	; 46
     e42:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e46:	1e bc       	out	0x2e, r1	; 46
     e48:	0d b4       	in	r0, 0x2d	; 45
     e4a:	07 fe       	sbrs	r0, 7
     e4c:	fd cf       	rjmp	.-6      	; 0xe48 <DataflashManager_ReadBlocks+0x15e>
     e4e:	8e b5       	in	r24, 0x2e	; 46
     e50:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e54:	1e bc       	out	0x2e, r1	; 46
     e56:	0d b4       	in	r0, 0x2d	; 45
     e58:	07 fe       	sbrs	r0, 7
     e5a:	fd cf       	rjmp	.-6      	; 0xe56 <DataflashManager_ReadBlocks+0x16c>
     e5c:	8e b5       	in	r24, 0x2e	; 46
     e5e:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e62:	1e bc       	out	0x2e, r1	; 46
     e64:	0d b4       	in	r0, 0x2d	; 45
     e66:	07 fe       	sbrs	r0, 7
     e68:	fd cf       	rjmp	.-6      	; 0xe64 <DataflashManager_ReadBlocks+0x17a>
     e6a:	8e b5       	in	r24, 0x2e	; 46
     e6c:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e70:	1e bc       	out	0x2e, r1	; 46
     e72:	0d b4       	in	r0, 0x2d	; 45
     e74:	07 fe       	sbrs	r0, 7
     e76:	fd cf       	rjmp	.-6      	; 0xe72 <DataflashManager_ReadBlocks+0x188>
     e78:	8e b5       	in	r24, 0x2e	; 46
     e7a:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e7e:	1e bc       	out	0x2e, r1	; 46
     e80:	0d b4       	in	r0, 0x2d	; 45
     e82:	07 fe       	sbrs	r0, 7
     e84:	fd cf       	rjmp	.-6      	; 0xe80 <DataflashManager_ReadBlocks+0x196>
     e86:	8e b5       	in	r24, 0x2e	; 46
     e88:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e8c:	1e bc       	out	0x2e, r1	; 46
     e8e:	0d b4       	in	r0, 0x2d	; 45
     e90:	07 fe       	sbrs	r0, 7
     e92:	fd cf       	rjmp	.-6      	; 0xe8e <DataflashManager_ReadBlocks+0x1a4>
     e94:	8e b5       	in	r24, 0x2e	; 46
     e96:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     e9a:	1e bc       	out	0x2e, r1	; 46
     e9c:	0d b4       	in	r0, 0x2d	; 45
     e9e:	07 fe       	sbrs	r0, 7
     ea0:	fd cf       	rjmp	.-6      	; 0xe9c <DataflashManager_ReadBlocks+0x1b2>
     ea2:	8e b5       	in	r24, 0x2e	; 46
     ea4:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     ea8:	1e bc       	out	0x2e, r1	; 46
     eaa:	0d b4       	in	r0, 0x2d	; 45
     eac:	07 fe       	sbrs	r0, 7
     eae:	fd cf       	rjmp	.-6      	; 0xeaa <DataflashManager_ReadBlocks+0x1c0>
     eb0:	8e b5       	in	r24, 0x2e	; 46
     eb2:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     eb6:	1e bc       	out	0x2e, r1	; 46
     eb8:	0d b4       	in	r0, 0x2d	; 45
     eba:	07 fe       	sbrs	r0, 7
     ebc:	fd cf       	rjmp	.-6      	; 0xeb8 <DataflashManager_ReadBlocks+0x1ce>
     ebe:	8e b5       	in	r24, 0x2e	; 46
     ec0:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
     ec4:	cf 5f       	subi	r28, 0xFF	; 255
     ec6:	f6 01       	movw	r30, r12
     ec8:	86 a9       	ldd	r24, Z+54	; 0x36
     eca:	81 11       	cpse	r24, r1
     ecc:	13 c0       	rjmp	.+38     	; 0xef4 <DataflashManager_ReadBlocks+0x20a>
     ece:	d1 50       	subi	r29, 0x01	; 1
     ed0:	09 f0       	breq	.+2      	; 0xed4 <DataflashManager_ReadBlocks+0x1ea>
     ed2:	5a cf       	rjmp	.-332    	; 0xd88 <DataflashManager_ReadBlocks+0x9e>
     ed4:	f1 e0       	ldi	r31, 0x01	; 1
     ed6:	ef 1a       	sub	r14, r31
     ed8:	f1 08       	sbc	r15, r1
     eda:	51 cf       	rjmp	.-350    	; 0xd7e <DataflashManager_ReadBlocks+0x94>
     edc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     ee0:	85 fd       	sbrc	r24, 5
     ee2:	05 c0       	rjmp	.+10     	; 0xeee <DataflashManager_ReadBlocks+0x204>
     ee4:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     ee8:	8e 77       	andi	r24, 0x7E	; 126
     eea:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     eee:	8e b1       	in	r24, 0x0e	; 14
     ef0:	83 60       	ori	r24, 0x03	; 3
     ef2:	8e b9       	out	0x0e, r24	; 14
     ef4:	df 91       	pop	r29
     ef6:	cf 91       	pop	r28
     ef8:	1f 91       	pop	r17
     efa:	0f 91       	pop	r16
     efc:	ff 90       	pop	r15
     efe:	ef 90       	pop	r14
     f00:	df 90       	pop	r13
     f02:	cf 90       	pop	r12
     f04:	bf 90       	pop	r11
     f06:	af 90       	pop	r10
     f08:	9f 90       	pop	r9
     f0a:	8f 90       	pop	r8
     f0c:	08 95       	ret

00000f0e <DataflashManager_ReadBlocks_RAM>:
     f0e:	4f 92       	push	r4
     f10:	5f 92       	push	r5
     f12:	6f 92       	push	r6
     f14:	7f 92       	push	r7
     f16:	af 92       	push	r10
     f18:	bf 92       	push	r11
     f1a:	cf 92       	push	r12
     f1c:	df 92       	push	r13
     f1e:	ff 92       	push	r15
     f20:	0f 93       	push	r16
     f22:	1f 93       	push	r17
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
     f28:	5a 01       	movw	r10, r20
     f2a:	89 01       	movw	r16, r18
     f2c:	2b 01       	movw	r4, r22
     f2e:	3c 01       	movw	r6, r24
     f30:	99 e0       	ldi	r25, 0x09	; 9
     f32:	44 0c       	add	r4, r4
     f34:	55 1c       	adc	r5, r5
     f36:	66 1c       	adc	r6, r6
     f38:	77 1c       	adc	r7, r7
     f3a:	9a 95       	dec	r25
     f3c:	d1 f7       	brne	.-12     	; 0xf32 <DataflashManager_ReadBlocks_RAM+0x24>
     f3e:	2a e0       	ldi	r18, 0x0A	; 10
     f40:	76 94       	lsr	r7
     f42:	67 94       	ror	r6
     f44:	57 94       	ror	r5
     f46:	47 94       	ror	r4
     f48:	2a 95       	dec	r18
     f4a:	d1 f7       	brne	.-12     	; 0xf40 <DataflashManager_ReadBlocks_RAM+0x32>
     f4c:	62 01       	movw	r12, r4
     f4e:	eb 01       	movw	r28, r22
     f50:	dc 2f       	mov	r29, r28
     f52:	cc 27       	eor	r28, r28
     f54:	dd 0f       	add	r29, r29
     f56:	cc 27       	eor	r28, r28
     f58:	d2 70       	andi	r29, 0x02	; 2
     f5a:	ce 01       	movw	r24, r28
     f5c:	44 e0       	ldi	r20, 0x04	; 4
     f5e:	96 95       	lsr	r25
     f60:	87 95       	ror	r24
     f62:	4a 95       	dec	r20
     f64:	e1 f7       	brne	.-8      	; 0xf5e <DataflashManager_ReadBlocks_RAM+0x50>
     f66:	f8 2e       	mov	r15, r24
     f68:	c2 01       	movw	r24, r4
     f6a:	6f dd       	rcall	.-1314   	; 0xa4a <Dataflash_SelectChipFromPage>
     f6c:	82 ed       	ldi	r24, 0xD2	; 210
     f6e:	8e bd       	out	0x2e, r24	; 46
     f70:	0d b4       	in	r0, 0x2d	; 45
     f72:	07 fe       	sbrs	r0, 7
     f74:	fd cf       	rjmp	.-6      	; 0xf70 <DataflashManager_ReadBlocks_RAM+0x62>
     f76:	be 01       	movw	r22, r28
     f78:	c2 01       	movw	r24, r4
     f7a:	4e dd       	rcall	.-1380   	; 0xa18 <Dataflash_SendAddressBytes>
     f7c:	1e bc       	out	0x2e, r1	; 46
     f7e:	0d b4       	in	r0, 0x2d	; 45
     f80:	07 fe       	sbrs	r0, 7
     f82:	fd cf       	rjmp	.-6      	; 0xf7e <DataflashManager_ReadBlocks_RAM+0x70>
     f84:	1e bc       	out	0x2e, r1	; 46
     f86:	0d b4       	in	r0, 0x2d	; 45
     f88:	07 fe       	sbrs	r0, 7
     f8a:	fd cf       	rjmp	.-6      	; 0xf86 <DataflashManager_ReadBlocks_RAM+0x78>
     f8c:	1e bc       	out	0x2e, r1	; 46
     f8e:	0d b4       	in	r0, 0x2d	; 45
     f90:	07 fe       	sbrs	r0, 7
     f92:	fd cf       	rjmp	.-6      	; 0xf8e <DataflashManager_ReadBlocks_RAM+0x80>
     f94:	1e bc       	out	0x2e, r1	; 46
     f96:	0d b4       	in	r0, 0x2d	; 45
     f98:	07 fe       	sbrs	r0, 7
     f9a:	fd cf       	rjmp	.-6      	; 0xf96 <DataflashManager_ReadBlocks_RAM+0x88>
     f9c:	82 ed       	ldi	r24, 0xD2	; 210
     f9e:	78 2e       	mov	r7, r24
     fa0:	a1 14       	cp	r10, r1
     fa2:	b1 04       	cpc	r11, r1
     fa4:	b9 f1       	breq	.+110    	; 0x1014 <__EEPROM_REGION_LENGTH__+0x14>
     fa6:	e8 01       	movw	r28, r16
     fa8:	de 5f       	subi	r29, 0xFE	; 254
     faa:	80 e4       	ldi	r24, 0x40	; 64
     fac:	f8 12       	cpse	r15, r24
     fae:	1e c0       	rjmp	.+60     	; 0xfec <DataflashManager_ReadBlocks_RAM+0xde>
     fb0:	8f ef       	ldi	r24, 0xFF	; 255
     fb2:	c8 1a       	sub	r12, r24
     fb4:	d8 0a       	sbc	r13, r24
     fb6:	c6 01       	movw	r24, r12
     fb8:	48 dd       	rcall	.-1392   	; 0xa4a <Dataflash_SelectChipFromPage>
     fba:	7e bc       	out	0x2e, r7	; 46
     fbc:	0d b4       	in	r0, 0x2d	; 45
     fbe:	07 fe       	sbrs	r0, 7
     fc0:	fd cf       	rjmp	.-6      	; 0xfbc <DataflashManager_ReadBlocks_RAM+0xae>
     fc2:	60 e0       	ldi	r22, 0x00	; 0
     fc4:	70 e0       	ldi	r23, 0x00	; 0
     fc6:	c6 01       	movw	r24, r12
     fc8:	27 dd       	rcall	.-1458   	; 0xa18 <Dataflash_SendAddressBytes>
     fca:	1e bc       	out	0x2e, r1	; 46
     fcc:	0d b4       	in	r0, 0x2d	; 45
     fce:	07 fe       	sbrs	r0, 7
     fd0:	fd cf       	rjmp	.-6      	; 0xfcc <DataflashManager_ReadBlocks_RAM+0xbe>
     fd2:	1e bc       	out	0x2e, r1	; 46
     fd4:	0d b4       	in	r0, 0x2d	; 45
     fd6:	07 fe       	sbrs	r0, 7
     fd8:	fd cf       	rjmp	.-6      	; 0xfd4 <DataflashManager_ReadBlocks_RAM+0xc6>
     fda:	1e bc       	out	0x2e, r1	; 46
     fdc:	0d b4       	in	r0, 0x2d	; 45
     fde:	07 fe       	sbrs	r0, 7
     fe0:	fd cf       	rjmp	.-6      	; 0xfdc <DataflashManager_ReadBlocks_RAM+0xce>
     fe2:	1e bc       	out	0x2e, r1	; 46
     fe4:	0d b4       	in	r0, 0x2d	; 45
     fe6:	07 fe       	sbrs	r0, 7
     fe8:	fd cf       	rjmp	.-6      	; 0xfe4 <DataflashManager_ReadBlocks_RAM+0xd6>
     fea:	f1 2c       	mov	r15, r1
     fec:	f8 01       	movw	r30, r16
     fee:	00 5f       	subi	r16, 0xF0	; 240
     ff0:	1f 4f       	sbci	r17, 0xFF	; 255
     ff2:	1e bc       	out	0x2e, r1	; 46
     ff4:	0d b4       	in	r0, 0x2d	; 45
     ff6:	07 fe       	sbrs	r0, 7
     ff8:	fd cf       	rjmp	.-6      	; 0xff4 <DataflashManager_ReadBlocks_RAM+0xe6>
     ffa:	8e b5       	in	r24, 0x2e	; 46
     ffc:	81 93       	st	Z+, r24
     ffe:	e0 17       	cp	r30, r16
    1000:	f1 07       	cpc	r31, r17
    1002:	b9 f7       	brne	.-18     	; 0xff2 <DataflashManager_ReadBlocks_RAM+0xe4>
    1004:	f3 94       	inc	r15
    1006:	c0 17       	cp	r28, r16
    1008:	d1 07       	cpc	r29, r17
    100a:	79 f6       	brne	.-98     	; 0xfaa <DataflashManager_ReadBlocks_RAM+0x9c>
    100c:	81 e0       	ldi	r24, 0x01	; 1
    100e:	a8 1a       	sub	r10, r24
    1010:	b1 08       	sbc	r11, r1
    1012:	c6 cf       	rjmp	.-116    	; 0xfa0 <DataflashManager_ReadBlocks_RAM+0x92>
    1014:	8e b1       	in	r24, 0x0e	; 14
    1016:	83 60       	ori	r24, 0x03	; 3
    1018:	8e b9       	out	0x0e, r24	; 14
    101a:	df 91       	pop	r29
    101c:	cf 91       	pop	r28
    101e:	1f 91       	pop	r17
    1020:	0f 91       	pop	r16
    1022:	ff 90       	pop	r15
    1024:	df 90       	pop	r13
    1026:	cf 90       	pop	r12
    1028:	bf 90       	pop	r11
    102a:	af 90       	pop	r10
    102c:	7f 90       	pop	r7
    102e:	6f 90       	pop	r6
    1030:	5f 90       	pop	r5
    1032:	4f 90       	pop	r4
    1034:	08 95       	ret

00001036 <DataflashManager_CheckDataflashOperation>:
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
    1036:	8e b1       	in	r24, 0x0e	; 14
    1038:	8c 7f       	andi	r24, 0xFC	; 252
    103a:	82 60       	ori	r24, 0x02	; 2
    103c:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
    103e:	8f e9       	ldi	r24, 0x9F	; 159
    1040:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    1042:	0d b4       	in	r0, 0x2d	; 45
    1044:	07 fe       	sbrs	r0, 7
    1046:	fd cf       	rjmp	.-6      	; 0x1042 <DataflashManager_CheckDataflashOperation+0xc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
    1048:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
    104a:	0d b4       	in	r0, 0x2d	; 45
    104c:	07 fe       	sbrs	r0, 7
    104e:	fd cf       	rjmp	.-6      	; 0x104a <DataflashManager_CheckDataflashOperation+0x14>
				return SPDR;
    1050:	9e b5       	in	r25, 0x2e	; 46
    1052:	8e b1       	in	r24, 0x0e	; 14
    1054:	83 60       	ori	r24, 0x03	; 3
    1056:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
    1058:	9f 31       	cpi	r25, 0x1F	; 31
    105a:	a1 f4       	brne	.+40     	; 0x1084 <DataflashManager_CheckDataflashOperation+0x4e>
    105c:	8e b1       	in	r24, 0x0e	; 14
    105e:	8c 7f       	andi	r24, 0xFC	; 252
    1060:	81 60       	ori	r24, 0x01	; 1
    1062:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
    1064:	8f e9       	ldi	r24, 0x9F	; 159
    1066:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    1068:	0d b4       	in	r0, 0x2d	; 45
    106a:	07 fe       	sbrs	r0, 7
    106c:	fd cf       	rjmp	.-6      	; 0x1068 <DataflashManager_CheckDataflashOperation+0x32>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
    106e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
    1070:	0d b4       	in	r0, 0x2d	; 45
    1072:	07 fe       	sbrs	r0, 7
    1074:	fd cf       	rjmp	.-6      	; 0x1070 <DataflashManager_CheckDataflashOperation+0x3a>
				return SPDR;
    1076:	9e b5       	in	r25, 0x2e	; 46
    1078:	8e b1       	in	r24, 0x0e	; 14
    107a:	83 60       	ori	r24, 0x03	; 3
    107c:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	9f 31       	cpi	r25, 0x1F	; 31
    1082:	09 f0       	breq	.+2      	; 0x1086 <DataflashManager_CheckDataflashOperation+0x50>
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
    1084:	80 e0       	ldi	r24, 0x00	; 0
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
	#endif

	return true;
}
    1086:	08 95       	ret

00001088 <LEDs_SetAllLEDs>:
    1088:	9b b1       	in	r25, 0x0b	; 11
    108a:	9f 70       	andi	r25, 0x0F	; 15
    108c:	89 2b       	or	r24, r25
    108e:	8b b9       	out	0x0b, r24	; 11
    1090:	08 95       	ret

00001092 <uIPManagement_Init>:
struct uip_eth_addr MACAddress;


/** Configures the uIP stack ready for network traffic processing. */
void uIPManagement_Init(void)
{
    1092:	cf 93       	push	r28
	/* uIP Timing Initialization */
	clock_init();
    1094:	0e 94 15 1b 	call	0x362a	; 0x362a <clock_init>
	timer_set(&ConnectionTimer, CLOCK_SECOND / 2);
    1098:	62 e3       	ldi	r22, 0x32	; 50
    109a:	70 e0       	ldi	r23, 0x00	; 0
    109c:	8c e3       	ldi	r24, 0x3C	; 60
    109e:	93 e0       	ldi	r25, 0x03	; 3
    10a0:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <timer_set>
	timer_set(&ARPTimer, CLOCK_SECOND * 10);
    10a4:	68 ee       	ldi	r22, 0xE8	; 232
    10a6:	73 e0       	ldi	r23, 0x03	; 3
    10a8:	88 e3       	ldi	r24, 0x38	; 56
    10aa:	93 e0       	ldi	r25, 0x03	; 3
    10ac:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <timer_set>

	/* uIP Stack Initialization */
	uip_init();
    10b0:	ee d7       	rcall	.+4060   	; 0x208e <uip_init>
	uip_arp_init();
    10b2:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <uip_arp_init>

	/* DHCP/Server IP Settings Initialization */
	if (USB_CurrentMode == USB_MODE_Device)
    10b6:	c0 91 ba 03 	lds	r28, 0x03BA	; 0x8003ba <USB_CurrentMode>
    10ba:	c1 30       	cpi	r28, 0x01	; 1
    10bc:	49 f5       	brne	.+82     	; 0x1110 <uIPManagement_Init+0x7e>
	{
		MACAddress.addr[0] = SERVER_MAC_ADDRESS[0];
    10be:	c0 93 bd 03 	sts	0x03BD, r28	; 0x8003bd <MACAddress>
		MACAddress.addr[1] = SERVER_MAC_ADDRESS[1];
    10c2:	10 92 be 03 	sts	0x03BE, r1	; 0x8003be <MACAddress+0x1>
		MACAddress.addr[2] = SERVER_MAC_ADDRESS[2];
    10c6:	c0 93 bf 03 	sts	0x03BF, r28	; 0x8003bf <MACAddress+0x2>
		MACAddress.addr[3] = SERVER_MAC_ADDRESS[3];
    10ca:	10 92 c0 03 	sts	0x03C0, r1	; 0x8003c0 <MACAddress+0x3>
		MACAddress.addr[4] = SERVER_MAC_ADDRESS[4];
    10ce:	c0 93 c1 03 	sts	0x03C1, r28	; 0x8003c1 <MACAddress+0x4>
		MACAddress.addr[5] = SERVER_MAC_ADDRESS[5];
    10d2:	10 92 c2 03 	sts	0x03C2, r1	; 0x8003c2 <MACAddress+0x5>

		#if defined(ENABLE_DHCP_SERVER)
		DHCPServerApp_Init();	
    10d6:	84 d3       	rcall	.+1800   	; 0x17e0 <DHCPServerApp_Init>

		uip_ipaddr_t IPAddress, Netmask, GatewayIPAddress;
		uip_ipaddr(&IPAddress,        DEVICE_IP_ADDRESS[0], DEVICE_IP_ADDRESS[1], DEVICE_IP_ADDRESS[2], DEVICE_IP_ADDRESS[3]);
		uip_ipaddr(&Netmask,          DEVICE_NETMASK[0],    DEVICE_NETMASK[1],    DEVICE_NETMASK[2],    DEVICE_NETMASK[3]);
		uip_ipaddr(&GatewayIPAddress, DEVICE_GATEWAY[0],    DEVICE_GATEWAY[1],    DEVICE_GATEWAY[2],    DEVICE_GATEWAY[3]);
		uip_sethostaddr(&IPAddress);
    10d8:	9a e0       	ldi	r25, 0x0A	; 10
    10da:	90 93 7a 07 	sts	0x077A, r25	; 0x80077a <uip_hostaddr>
    10de:	10 92 7b 07 	sts	0x077B, r1	; 0x80077b <uip_hostaddr+0x1>
    10e2:	10 92 7c 07 	sts	0x077C, r1	; 0x80077c <uip_hostaddr+0x2>
    10e6:	82 e0       	ldi	r24, 0x02	; 2
    10e8:	80 93 7d 07 	sts	0x077D, r24	; 0x80077d <uip_hostaddr+0x3>
		uip_setnetmask(&Netmask);
    10ec:	8f ef       	ldi	r24, 0xFF	; 255
    10ee:	80 93 76 07 	sts	0x0776, r24	; 0x800776 <uip_netmask>
    10f2:	80 93 77 07 	sts	0x0777, r24	; 0x800777 <uip_netmask+0x1>
    10f6:	80 93 78 07 	sts	0x0778, r24	; 0x800778 <uip_netmask+0x2>
    10fa:	10 92 79 07 	sts	0x0779, r1	; 0x800779 <uip_netmask+0x3>
		uip_setdraddr(&GatewayIPAddress);
    10fe:	90 93 72 07 	sts	0x0772, r25	; 0x800772 <uip_draddr>
    1102:	10 92 73 07 	sts	0x0773, r1	; 0x800773 <uip_draddr+0x1>
    1106:	10 92 74 07 	sts	0x0774, r1	; 0x800774 <uip_draddr+0x2>
    110a:	c0 93 75 07 	sts	0x0775, r28	; 0x800775 <uip_draddr+0x3>
	}
	else
	{
		#if defined(ENABLE_DHCP_CLIENT)
		DHCPClientApp_Init();	
    110e:	01 c0       	rjmp	.+2      	; 0x1112 <uIPManagement_Init+0x80>
    1110:	ac d1       	rcall	.+856    	; 0x146a <DHCPClientApp_Init>
		uip_setdraddr(&GatewayIPAddress);
		#endif
	}

	/* Virtual Webserver Ethernet Address Configuration */
	uip_setethaddr(MACAddress);
    1112:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <MACAddress>
    1116:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <uip_ethaddr>
    111a:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <MACAddress+0x1>
    111e:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <uip_ethaddr+0x1>
    1122:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <MACAddress+0x2>
    1126:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <uip_ethaddr+0x2>
    112a:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <MACAddress+0x3>
    112e:	80 93 43 03 	sts	0x0343, r24	; 0x800343 <uip_ethaddr+0x3>
    1132:	80 91 c1 03 	lds	r24, 0x03C1	; 0x8003c1 <MACAddress+0x4>
    1136:	80 93 44 03 	sts	0x0344, r24	; 0x800344 <uip_ethaddr+0x4>
    113a:	80 91 c2 03 	lds	r24, 0x03C2	; 0x8003c2 <MACAddress+0x5>
    113e:	80 93 45 03 	sts	0x0345, r24	; 0x800345 <uip_ethaddr+0x5>

	/* TELNET Server Initialization */
	#if defined(ENABLE_TELNET_SERVER)
	TELNETServerApp_Init();
	#endif
}
    1142:	a0 d4       	rcall	.+2368   	; 0x1a84 <HTTPServerApp_Init>
	/* HTTP Webserver Initialization */
	HTTPServerApp_Init();

	/* TELNET Server Initialization */
	#if defined(ENABLE_TELNET_SERVER)
	TELNETServerApp_Init();
    1144:	cf 91       	pop	r28
    1146:	28 c6       	rjmp	.+3152   	; 0x1d98 <TELNETServerApp_Init>

00001148 <uIPManagement_ManageNetwork>:

/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
    1148:	ef 92       	push	r14
    114a:	ff 92       	push	r15
    114c:	0f 93       	push	r16
    114e:	1f 93       	push	r17
    1150:	cf 93       	push	r28
    1152:	df 93       	push	r29
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    1154:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
    1158:	82 30       	cpi	r24, 0x02	; 2
    115a:	21 f4       	brne	.+8      	; 0x1164 <uIPManagement_ManageNetwork+0x1c>
    115c:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <USB_HostState>
    1160:	8b 30       	cpi	r24, 0x0B	; 11
    1162:	49 f0       	breq	.+18     	; 0x1176 <uIPManagement_ManageNetwork+0x2e>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
    1164:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    1168:	81 30       	cpi	r24, 0x01	; 1
    116a:	09 f0       	breq	.+2      	; 0x116e <uIPManagement_ManageNetwork+0x26>
    116c:	b5 c0       	rjmp	.+362    	; 0x12d8 <uIPManagement_ManageNetwork+0x190>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
    116e:	8e b3       	in	r24, 0x1e	; 30
    1170:	84 30       	cpi	r24, 0x04	; 4
    1172:	09 f0       	breq	.+2      	; 0x1176 <uIPManagement_ManageNetwork+0x2e>
    1174:	b1 c0       	rjmp	.+354    	; 0x12d8 <uIPManagement_ManageNetwork+0x190>

/** Processes Incoming packets to the server from the connected RNDIS device, creating responses as needed. */
static void uIPManagement_ProcessIncomingPacket(void)
{
	/* Determine which USB mode the system is currently initialized in */
	if (USB_CurrentMode == USB_MODE_Device)
    1176:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
    117a:	81 30       	cpi	r24, 0x01	; 1
    117c:	91 f4       	brne	.+36     	; 0x11a2 <uIPManagement_ManageNetwork+0x5a>
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface_Device)))
    117e:	87 e3       	ldi	r24, 0x37	; 55
    1180:	91 e0       	ldi	r25, 0x01	; 1
    1182:	0e 94 c4 34 	call	0x6988	; 0x6988 <RNDIS_Device_IsPacketReceived>
    1186:	88 23       	and	r24, r24
    1188:	09 f4       	brne	.+2      	; 0x118c <uIPManagement_ManageNetwork+0x44>
    118a:	43 c0       	rjmp	.+134    	; 0x1212 <uIPManagement_ManageNetwork+0xca>
		  return;
	
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    118c:	80 ed       	ldi	r24, 0xD0	; 208
    118e:	7c df       	rcall	.-264    	; 0x1088 <LEDs_SetAllLEDs>

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, &uip_len);
    1190:	46 e0       	ldi	r20, 0x06	; 6
    1192:	56 e0       	ldi	r21, 0x06	; 6
    1194:	6e e7       	ldi	r22, 0x7E	; 126
    1196:	77 e0       	ldi	r23, 0x07	; 7
    1198:	87 e3       	ldi	r24, 0x37	; 55
    119a:	91 e0       	ldi	r25, 0x01	; 1
    119c:	0e 94 d9 34 	call	0x69b2	; 0x69b2 <RNDIS_Device_ReadPacket>
    11a0:	10 c0       	rjmp	.+32     	; 0x11c2 <uIPManagement_ManageNetwork+0x7a>
	}
	else
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Host_IsPacketReceived(&Ethernet_RNDIS_Interface_Host)))
    11a2:	82 ed       	ldi	r24, 0xD2	; 210
    11a4:	91 e0       	ldi	r25, 0x01	; 1
    11a6:	0e 94 b0 38 	call	0x7160	; 0x7160 <RNDIS_Host_IsPacketReceived>
    11aa:	88 23       	and	r24, r24
    11ac:	91 f1       	breq	.+100    	; 0x1212 <uIPManagement_ManageNetwork+0xca>
		  return;
	
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    11ae:	80 ed       	ldi	r24, 0xD0	; 208
    11b0:	6b df       	rcall	.-298    	; 0x1088 <LEDs_SetAllLEDs>

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Host_ReadPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, &uip_len);
    11b2:	46 e0       	ldi	r20, 0x06	; 6
    11b4:	56 e0       	ldi	r21, 0x06	; 6
    11b6:	6e e7       	ldi	r22, 0x7E	; 126
    11b8:	77 e0       	ldi	r23, 0x07	; 7
    11ba:	82 ed       	ldi	r24, 0xD2	; 210
    11bc:	91 e0       	ldi	r25, 0x01	; 1
    11be:	0e 94 cb 38 	call	0x7196	; 0x7196 <RNDIS_Host_ReadPacket>
	}
	
	/* If the packet contains an Ethernet frame, process it */
	if (uip_len > 0)
    11c2:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    11c6:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    11ca:	89 2b       	or	r24, r25
    11cc:	01 f1       	breq	.+64     	; 0x120e <uIPManagement_ManageNetwork+0xc6>
	{
		switch (((struct uip_eth_hdr*)uip_buf)->type)
    11ce:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <uip_buf+0xc>
    11d2:	90 91 8b 07 	lds	r25, 0x078B	; 0x80078b <uip_buf+0xd>
    11d6:	88 30       	cpi	r24, 0x08	; 8
    11d8:	91 05       	cpc	r25, r1
    11da:	21 f0       	breq	.+8      	; 0x11e4 <uIPManagement_ManageNetwork+0x9c>
    11dc:	88 30       	cpi	r24, 0x08	; 8
    11de:	96 40       	sbci	r25, 0x06	; 6
    11e0:	61 f0       	breq	.+24     	; 0x11fa <uIPManagement_ManageNetwork+0xb2>
			case HTONS(UIP_ETHTYPE_IP):
				/* Filter packet by MAC destination */
				uip_arp_ipin();

				/* Process Incoming packet */
				uip_input();
    11e2:	15 c0       	rjmp	.+42     	; 0x120e <uIPManagement_ManageNetwork+0xc6>
    11e4:	81 e0       	ldi	r24, 0x01	; 1
    11e6:	da d7       	rcall	.+4020   	; 0x219c <uip_process>

				/* If a response was generated, send it */
				if (uip_len > 0)
    11e8:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    11ec:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    11f0:	89 2b       	or	r24, r25
    11f2:	69 f0       	breq	.+26     	; 0x120e <uIPManagement_ManageNetwork+0xc6>
				{
					/* Add destination MAC to outgoing packet */
					uip_arp_out();
    11f4:	0e 94 d3 19 	call	0x33a6	; 0x33a6 <uip_arp_out>
    11f8:	08 c0       	rjmp	.+16     	; 0x120a <uIPManagement_ManageNetwork+0xc2>
				}

				break;
			case HTONS(UIP_ETHTYPE_ARP):
				/* Process ARP packet */
				uip_arp_arpin();
    11fa:	0e 94 33 19 	call	0x3266	; 0x3266 <uip_arp_arpin>

				/* If a response was generated, send it */
				if (uip_len > 0)
    11fe:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    1202:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    1206:	89 2b       	or	r24, r25
    1208:	11 f0       	breq	.+4      	; 0x120e <uIPManagement_ManageNetwork+0xc6>
				  uip_split_output();
    120a:	0e 94 29 1b 	call	0x3652	; 0x3652 <uip_split_output>

				break;
		}
	}

	LEDs_SetAllLEDs(LEDMASK_USB_READY);
    120e:	80 e2       	ldi	r24, 0x20	; 32
    1210:	3b df       	rcall	.-394    	; 0x1088 <LEDs_SetAllLEDs>
    1212:	c5 e1       	ldi	r28, 0x15	; 21
    1214:	d6 e0       	ldi	r29, 0x06	; 6
    1216:	88 e6       	ldi	r24, 0x68	; 104
    1218:	e8 2e       	mov	r14, r24
    121a:	87 e0       	ldi	r24, 0x07	; 7
    121c:	f8 2e       	mov	r15, r24

/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
    121e:	8e 01       	movw	r16, r28
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		uip_poll_conn(&uip_conns[i]);
    1220:	10 93 14 06 	sts	0x0614, r17	; 0x800614 <uip_conn+0x1>
    1224:	00 93 13 06 	sts	0x0613, r16	; 0x800613 <uip_conn>
    1228:	83 e0       	ldi	r24, 0x03	; 3
    122a:	b8 d7       	rcall	.+3952   	; 0x219c <uip_process>

		/* If a response was generated, send it */
		if (uip_len > 0)
    122c:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    1230:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    1234:	89 2b       	or	r24, r25
    1236:	21 f0       	breq	.+8      	; 0x1240 <uIPManagement_ManageNetwork+0xf8>
		{
			/* Add destination MAC to outgoing packet */
			uip_arp_out();
    1238:	0e 94 d3 19 	call	0x33a6	; 0x33a6 <uip_arp_out>

			/* Split and send the outgoing packet */
			uip_split_output();
    123c:	0e 94 29 1b 	call	0x3652	; 0x3652 <uip_split_output>
    1240:	0f 58       	subi	r16, 0x8F	; 143
    1242:	1f 4f       	sbci	r17, 0xFF	; 255

/** Manages the currently open network connections, including TCP and (if enabled) UDP. */
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    1244:	e0 16       	cp	r14, r16
    1246:	f1 06       	cpc	r15, r17
    1248:	59 f7       	brne	.-42     	; 0x1220 <uIPManagement_ManageNetwork+0xd8>
			uip_split_output();
		}
	}

	/* Manage open connections for timeouts */
	if (timer_expired(&ConnectionTimer))
    124a:	8c e3       	ldi	r24, 0x3C	; 60
    124c:	93 e0       	ldi	r25, 0x03	; 3
    124e:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <timer_expired>
    1252:	89 2b       	or	r24, r25
    1254:	79 f1       	breq	.+94     	; 0x12b4 <uIPManagement_ManageNetwork+0x16c>
	{
		timer_reset(&ConnectionTimer);
    1256:	8c e3       	ldi	r24, 0x3C	; 60
    1258:	93 e0       	ldi	r25, 0x03	; 3
    125a:	0e 94 df 1a 	call	0x35be	; 0x35be <timer_reset>

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    125e:	80 ed       	ldi	r24, 0xD0	; 208
    1260:	13 df       	rcall	.-474    	; 0x1088 <LEDs_SetAllLEDs>

		for (uint8_t i = 0; i < UIP_CONNS; i++)
		{
			/* Run periodic connection management for each TCP connection */
			uip_periodic(i);
    1262:	d0 93 14 06 	sts	0x0614, r29	; 0x800614 <uip_conn+0x1>
    1266:	c0 93 13 06 	sts	0x0613, r28	; 0x800613 <uip_conn>
    126a:	82 e0       	ldi	r24, 0x02	; 2
    126c:	97 d7       	rcall	.+3886   	; 0x219c <uip_process>

			/* If a response was generated, send it */
			if (uip_len > 0)
    126e:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    1272:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    1276:	89 2b       	or	r24, r25
    1278:	21 f0       	breq	.+8      	; 0x1282 <uIPManagement_ManageNetwork+0x13a>
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    127a:	0e 94 d3 19 	call	0x33a6	; 0x33a6 <uip_arp_out>

				/* Split and send the outgoing packet */
				uip_split_output();
    127e:	0e 94 29 1b 	call	0x3652	; 0x3652 <uip_split_output>
    1282:	cf 58       	subi	r28, 0x8F	; 143
    1284:	df 4f       	sbci	r29, 0xFF	; 255
	{
		timer_reset(&ConnectionTimer);

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		for (uint8_t i = 0; i < UIP_CONNS; i++)
    1286:	ec 16       	cp	r14, r28
    1288:	fd 06       	cpc	r15, r29
    128a:	59 f7       	brne	.-42     	; 0x1262 <uIPManagement_ManageNetwork+0x11a>

		#if defined(ENABLE_DHCP_CLIENT)
		for (uint8_t i = 0; i < UIP_UDP_CONNS; i++)
		{
			/* Run periodic connection management for each UDP connection */
			uip_udp_periodic(i);
    128c:	8c e6       	ldi	r24, 0x6C	; 108
    128e:	9d e0       	ldi	r25, 0x0D	; 13
    1290:	90 93 10 06 	sts	0x0610, r25	; 0x800610 <uip_udp_conn+0x1>
    1294:	80 93 0f 06 	sts	0x060F, r24	; 0x80060f <uip_udp_conn>
    1298:	85 e0       	ldi	r24, 0x05	; 5
    129a:	80 d7       	rcall	.+3840   	; 0x219c <uip_process>

			/* If a response was generated, send it */
			if (uip_len > 0)
    129c:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    12a0:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    12a4:	89 2b       	or	r24, r25
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    12a6:	21 f0       	breq	.+8      	; 0x12b0 <uIPManagement_ManageNetwork+0x168>
    12a8:	0e 94 d3 19 	call	0x33a6	; 0x33a6 <uip_arp_out>

				/* Split and send the outgoing packet */
				uip_split_output();
    12ac:	0e 94 29 1b 	call	0x3652	; 0x3652 <uip_split_output>
			}
		}
		#endif

		LEDs_SetAllLEDs(LEDMASK_USB_READY);
    12b0:	80 e2       	ldi	r24, 0x20	; 32
    12b2:	ea de       	rcall	.-556    	; 0x1088 <LEDs_SetAllLEDs>
	}

	/* Manage ARP cache refreshing */
	if (timer_expired(&ARPTimer))
    12b4:	88 e3       	ldi	r24, 0x38	; 56
    12b6:	93 e0       	ldi	r25, 0x03	; 3
    12b8:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <timer_expired>
    12bc:	89 2b       	or	r24, r25
    12be:	61 f0       	breq	.+24     	; 0x12d8 <uIPManagement_ManageNetwork+0x190>
	{
		timer_reset(&ARPTimer);
    12c0:	88 e3       	ldi	r24, 0x38	; 56
    12c2:	93 e0       	ldi	r25, 0x03	; 3
    12c4:	0e 94 df 1a 	call	0x35be	; 0x35be <timer_reset>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
	{
		uIPManagement_ProcessIncomingPacket();
		uIPManagement_ManageConnections();
	}
}
    12c8:	df 91       	pop	r29
    12ca:	cf 91       	pop	r28
    12cc:	1f 91       	pop	r17
    12ce:	0f 91       	pop	r16
    12d0:	ff 90       	pop	r15
    12d2:	ef 90       	pop	r14

	/* Manage ARP cache refreshing */
	if (timer_expired(&ARPTimer))
	{
		timer_reset(&ARPTimer);
		uip_arp_timer();
    12d4:	0c 94 f9 18 	jmp	0x31f2	; 0x31f2 <uip_arp_timer>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
	{
		uIPManagement_ProcessIncomingPacket();
		uIPManagement_ManageConnections();
	}
}
    12d8:	df 91       	pop	r29
    12da:	cf 91       	pop	r28
    12dc:	1f 91       	pop	r17
    12de:	0f 91       	pop	r16
    12e0:	ff 90       	pop	r15
    12e2:	ef 90       	pop	r14
    12e4:	08 95       	ret

000012e6 <uIPManagement_TCPCallback>:
 *  to the appropriate TCP protocol application based on the connection's listen port number.
 */
void uIPManagement_TCPCallback(void)
{
	/* Call the correct TCP application based on the port number the connection is listening on */
	switch (uip_conn->lport)
    12e6:	e0 91 13 06 	lds	r30, 0x0613	; 0x800613 <uip_conn>
    12ea:	f0 91 14 06 	lds	r31, 0x0614	; 0x800614 <uip_conn+0x1>
    12ee:	84 81       	ldd	r24, Z+4	; 0x04
    12f0:	95 81       	ldd	r25, Z+5	; 0x05
    12f2:	81 15       	cp	r24, r1
    12f4:	27 e1       	ldi	r18, 0x17	; 23
    12f6:	92 07       	cpc	r25, r18
    12f8:	21 f0       	breq	.+8      	; 0x1302 <uIPManagement_TCPCallback+0x1c>
    12fa:	81 15       	cp	r24, r1
    12fc:	90 45       	sbci	r25, 0x50	; 80
    12fe:	11 f4       	brne	.+4      	; 0x1304 <uIPManagement_TCPCallback+0x1e>
	{
		case HTONS(HTTP_SERVER_PORT):
			HTTPServerApp_Callback();
    1300:	c9 c3       	rjmp	.+1938   	; 0x1a94 <HTTPServerApp_Callback>
			break;
		#if defined(ENABLE_TELNET_SERVER)
		case HTONS(TELNET_SERVER_PORT):
			TELNETServerApp_Callback();
    1302:	4d c5       	rjmp	.+2714   	; 0x1d9e <TELNETServerApp_Callback>
    1304:	08 95       	ret

00001306 <uIPManagement_UDPCallback>:
    1306:	e0 91 0f 06 	lds	r30, 0x060F	; 0x80060f <uip_udp_conn>
 *  to the appropriate UDP protocol application based on the connection's listen port number.
 */
void uIPManagement_UDPCallback(void)
{
	/* Call the correct UDP application based on the port number the connection is listening on */
	switch (uip_udp_conn->lport)
    130a:	f0 91 10 06 	lds	r31, 0x0610	; 0x800610 <uip_udp_conn+0x1>
    130e:	84 81       	ldd	r24, Z+4	; 0x04
    1310:	95 81       	ldd	r25, Z+5	; 0x05
    1312:	81 15       	cp	r24, r1
    1314:	23 e4       	ldi	r18, 0x43	; 67
    1316:	92 07       	cpc	r25, r18
    1318:	21 f0       	breq	.+8      	; 0x1322 <uIPManagement_UDPCallback+0x1c>
    131a:	81 15       	cp	r24, r1
    131c:	94 44       	sbci	r25, 0x44	; 68
    131e:	11 f4       	brne	.+4      	; 0x1324 <uIPManagement_UDPCallback+0x1e>
	{
		#if defined(ENABLE_DHCP_CLIENT)
		case HTONS(DHCP_CLIENT_PORT):
			DHCPClientApp_Callback();
    1320:	b7 c0       	rjmp	.+366    	; 0x1490 <DHCPClientApp_Callback>
			break;
		#endif
		#if defined(ENABLE_DHCP_SERVER)
		case HTONS(DHCP_SERVER_PORT):
			DHCPServerApp_Callback();
    1322:	77 c2       	rjmp	.+1262   	; 0x1812 <DHCPServerApp_Callback>
    1324:	08 95       	ret

00001326 <DHCPCommon_SetOption>:
    1326:	ef 92       	push	r14
 */
uint8_t DHCPCommon_SetOption(uint8_t* DHCPOptionList,
                             const uint8_t Option,
                             const uint8_t DataLen,
                             void* const OptionData)
{
    1328:	ff 92       	push	r15
    132a:	0f 93       	push	r16
    132c:	1f 93       	push	r17
    132e:	cf 93       	push	r28
    1330:	df 93       	push	r29
    1332:	ec 01       	movw	r28, r24
    1334:	f4 2e       	mov	r15, r20
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1336:	e8 80       	ld	r14, Y
    1338:	8f ef       	ldi	r24, 0xFF	; 255
    133a:	e8 16       	cp	r14, r24
    133c:	31 f0       	breq	.+12     	; 0x134a <DHCPCommon_SetOption+0x24>
	  DHCPOptionList += (DHCPOptionList[1] + 2);
    133e:	89 81       	ldd	r24, Y+1	; 0x01
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	02 96       	adiw	r24, 0x02	; 2
    1344:	c8 0f       	add	r28, r24
    1346:	d9 1f       	adc	r29, r25
    1348:	f6 cf       	rjmp	.-20     	; 0x1336 <DHCPCommon_SetOption+0x10>

	/* Overwrite the existing terminator with the new option, add a new terminator at the end of the list */
	DHCPOptionList[0] = Option;
    134a:	68 83       	st	Y, r22
	DHCPOptionList[1] = DataLen;
    134c:	f9 82       	std	Y+1, r15	; 0x01
	memcpy(&DHCPOptionList[2], OptionData, DataLen);
    134e:	0f 2d       	mov	r16, r15
    1350:	10 e0       	ldi	r17, 0x00	; 0
    1352:	a8 01       	movw	r20, r16
    1354:	b9 01       	movw	r22, r18
    1356:	ce 01       	movw	r24, r28
    1358:	02 96       	adiw	r24, 0x02	; 2
    135a:	0e 94 2c 3a 	call	0x7458	; 0x7458 <memcpy>
	DHCPOptionList[2 + DataLen] = DHCP_OPTION_END;
    135e:	c0 0f       	add	r28, r16
    1360:	d1 1f       	adc	r29, r17
    1362:	ea 82       	std	Y+2, r14	; 0x02

	/* Calculate the total number of bytes added to the outgoing packet */
	return (2 + DataLen);
}
    1364:	82 e0       	ldi	r24, 0x02	; 2
    1366:	8f 0d       	add	r24, r15
    1368:	df 91       	pop	r29
    136a:	cf 91       	pop	r28
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	ff 90       	pop	r15
    1372:	ef 90       	pop	r14
    1374:	08 95       	ret

00001376 <DHCPCommon_GetOption>:
 *  \return Boolean true if the option was found in the DHCP packet's options list, false otherwise
 */
bool DHCPCommon_GetOption(const uint8_t* DHCPOptionList,
                          const uint8_t Option,
                          void* const Destination)
{
    1376:	fc 01       	movw	r30, r24
    1378:	9a 01       	movw	r18, r20
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
    137a:	90 81       	ld	r25, Z
    137c:	9f 3f       	cpi	r25, 0xFF	; 255
    137e:	89 f0       	breq	.+34     	; 0x13a2 <DHCPCommon_GetOption+0x2c>
    1380:	41 81       	ldd	r20, Z+1	; 0x01
	{
		/* Check if the current DHCP option in the packet is the one requested */
		if (DHCPOptionList[0] == Option)
		{
			/* Copy request option's data to the destination buffer */
			memcpy(Destination, &DHCPOptionList[2], DHCPOptionList[1]);
    1382:	50 e0       	ldi	r21, 0x00	; 0
{
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
	{
		/* Check if the current DHCP option in the packet is the one requested */
		if (DHCPOptionList[0] == Option)
    1384:	96 13       	cpse	r25, r22
    1386:	08 c0       	rjmp	.+16     	; 0x1398 <DHCPCommon_GetOption+0x22>
		{
			/* Copy request option's data to the destination buffer */
			memcpy(Destination, &DHCPOptionList[2], DHCPOptionList[1]);
    1388:	bf 01       	movw	r22, r30
    138a:	6e 5f       	subi	r22, 0xFE	; 254
    138c:	7f 4f       	sbci	r23, 0xFF	; 255
    138e:	c9 01       	movw	r24, r18
    1390:	0e 94 2c 3a 	call	0x7458	; 0x7458 <memcpy>

			/* Indicate that the requested option data was successfully retrieved */
			return true;
    1394:	81 e0       	ldi	r24, 0x01	; 1
    1396:	08 95       	ret
		}

		/* Skip to next DHCP option in the options list */
		DHCPOptionList += (DHCPOptionList[1] + 2);
    1398:	4e 5f       	subi	r20, 0xFE	; 254
    139a:	5f 4f       	sbci	r21, 0xFF	; 255
    139c:	e4 0f       	add	r30, r20
    139e:	f5 1f       	adc	r31, r21
    13a0:	ec cf       	rjmp	.-40     	; 0x137a <DHCPCommon_GetOption+0x4>
	}

	/* Requested option not found in the incoming packet's DHCP options list */
	return false;
    13a2:	80 e0       	ldi	r24, 0x00	; 0
}
    13a4:	08 95       	ret

000013a6 <DHCPClientApp_FillDHCPHeader>:
 *  \return Size in bytes of the created DHCP packet
 */
static uint16_t DHCPClientApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             uip_udp_appstate_t* const AppState)
{
    13a6:	0f 93       	push	r16
    13a8:	1f 93       	push	r17
    13aa:	cf 93       	push	r28
    13ac:	df 93       	push	r29
    13ae:	ec 01       	movw	r28, r24
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    13b0:	80 ef       	ldi	r24, 0xF0	; 240
    13b2:	fe 01       	movw	r30, r28
    13b4:	11 92       	st	Z+, r1
    13b6:	8a 95       	dec	r24
    13b8:	e9 f7       	brne	.-6      	; 0x13b4 <DHCPClientApp_FillDHCPHeader+0xe>

	/* Fill out the DHCP packet header */
	DHCPHeader->Operation             = DHCP_OP_BOOTREQUEST;
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	88 83       	st	Y, r24
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    13be:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    13c0:	96 e0       	ldi	r25, 0x06	; 6
    13c2:	9a 83       	std	Y+2, r25	; 0x02
	DHCPHeader->Hops                  = 0;
    13c4:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeader->TransactionID         = DHCP_TRANSACTION_ID;
    13c6:	06 e6       	ldi	r16, 0x66	; 102
    13c8:	14 e5       	ldi	r17, 0x54	; 84
    13ca:	24 e2       	ldi	r18, 0x24	; 36
    13cc:	33 e1       	ldi	r19, 0x13	; 19
    13ce:	0c 83       	std	Y+4, r16	; 0x04
    13d0:	1d 83       	std	Y+5, r17	; 0x05
    13d2:	2e 83       	std	Y+6, r18	; 0x06
    13d4:	3f 83       	std	Y+7, r19	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    13d6:	19 86       	std	Y+9, r1	; 0x09
    13d8:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeader->Flags                 = HTONS(BOOTP_BROADCAST);
    13da:	20 e8       	ldi	r18, 0x80	; 128
    13dc:	30 e0       	ldi	r19, 0x00	; 0
    13de:	3b 87       	std	Y+11, r19	; 0x0b
    13e0:	2a 87       	std	Y+10, r18	; 0x0a
	memcpy(&DHCPHeader->ClientIP,     &uip_hostaddr,        sizeof(uip_ipaddr_t));
    13e2:	00 91 7a 07 	lds	r16, 0x077A	; 0x80077a <uip_hostaddr>
    13e6:	10 91 7b 07 	lds	r17, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    13ea:	20 91 7c 07 	lds	r18, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    13ee:	30 91 7d 07 	lds	r19, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    13f2:	0c 87       	std	Y+12, r16	; 0x0c
    13f4:	1d 87       	std	Y+13, r17	; 0x0d
    13f6:	2e 87       	std	Y+14, r18	; 0x0e
    13f8:	3f 87       	std	Y+15, r19	; 0x0f
	memcpy(&DHCPHeader->YourIP,       &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, sizeof(uip_ipaddr_t));
    13fa:	de 01       	movw	r26, r28
    13fc:	50 96       	adiw	r26, 0x10	; 16
    13fe:	fa 01       	movw	r30, r20
    1400:	35 96       	adiw	r30, 0x05	; 5
    1402:	94 e0       	ldi	r25, 0x04	; 4
    1404:	01 90       	ld	r0, Z+
    1406:	0d 92       	st	X+, r0
    1408:	9a 95       	dec	r25
    140a:	e1 f7       	brne	.-8      	; 0x1404 <DHCPClientApp_FillDHCPHeader+0x5e>
	memcpy(&DHCPHeader->NextServerIP, &AppState->DHCPClient.DHCPOffer_Data.ServerIP,    sizeof(uip_ipaddr_t));
    140c:	de 01       	movw	r26, r28
    140e:	54 96       	adiw	r26, 0x14	; 20
    1410:	fa 01       	movw	r30, r20
    1412:	71 96       	adiw	r30, 0x11	; 17
    1414:	94 e0       	ldi	r25, 0x04	; 4
    1416:	01 90       	ld	r0, Z+
    1418:	0d 92       	st	X+, r0
    141a:	9a 95       	dec	r25
    141c:	e1 f7       	brne	.-8      	; 0x1416 <DHCPClientApp_FillDHCPHeader+0x70>
	memcpy(&DHCPHeader->ClientHardwareAddress, &MACAddress, sizeof(struct uip_eth_addr));
    141e:	96 e0       	ldi	r25, 0x06	; 6
    1420:	ed eb       	ldi	r30, 0xBD	; 189
    1422:	f3 e0       	ldi	r31, 0x03	; 3
    1424:	de 01       	movw	r26, r28
    1426:	5c 96       	adiw	r26, 0x1c	; 28
    1428:	01 90       	ld	r0, Z+
    142a:	0d 92       	st	X+, r0
    142c:	9a 95       	dec	r25
    142e:	e1 f7       	brne	.-8      	; 0x1428 <DHCPClientApp_FillDHCPHeader+0x82>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    1430:	fe 01       	movw	r30, r28
    1432:	e4 51       	subi	r30, 0x14	; 20
    1434:	ff 4f       	sbci	r31, 0xFF	; 255
    1436:	03 e6       	ldi	r16, 0x63	; 99
    1438:	12 e8       	ldi	r17, 0x82	; 130
    143a:	23 e5       	ldi	r18, 0x53	; 83
    143c:	33 e6       	ldi	r19, 0x63	; 99
    143e:	00 83       	st	Z, r16
    1440:	11 83       	std	Z+1, r17	; 0x01
    1442:	22 83       	std	Z+2, r18	; 0x02
    1444:	33 83       	std	Z+3, r19	; 0x03

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    1446:	34 96       	adiw	r30, 0x04	; 4
    1448:	95 e3       	ldi	r25, 0x35	; 53
    144a:	90 83       	st	Z, r25
	DHCPHeader->Options[1]            = 1;
    144c:	31 96       	adiw	r30, 0x01	; 1
    144e:	80 83       	st	Z, r24
	DHCPHeader->Options[2]            = DHCPMessageType;
    1450:	31 96       	adiw	r30, 0x01	; 1
    1452:	60 83       	st	Z, r22
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    1454:	cd 50       	subi	r28, 0x0D	; 13
    1456:	df 4f       	sbci	r29, 0xFF	; 255
    1458:	8f ef       	ldi	r24, 0xFF	; 255
    145a:	88 83       	st	Y, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    145c:	84 ef       	ldi	r24, 0xF4	; 244
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	df 91       	pop	r29
    1462:	cf 91       	pop	r28
    1464:	1f 91       	pop	r17
    1466:	0f 91       	pop	r16
    1468:	08 95       	ret

0000146a <DHCPClientApp_Init>:

/** Initialization function for the DHCP client. */
void DHCPClientApp_Init(void)
{
	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* Connection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_SERVER_PORT));
    146a:	60 e0       	ldi	r22, 0x00	; 0
    146c:	73 e4       	ldi	r23, 0x43	; 67
    146e:	82 e5       	ldi	r24, 0x52	; 82
    1470:	92 e0       	ldi	r25, 0x02	; 2
    1472:	32 d6       	rcall	.+3172   	; 0x20d8 <uip_udp_new>

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (Connection != NULL)
    1474:	00 97       	sbiw	r24, 0x00	; 0
    1476:	59 f0       	breq	.+22     	; 0x148e <DHCPClientApp_Init+0x24>
	{
		uip_udp_appstate_t* const AppState = &Connection->appstate;
		uip_udp_bind(Connection, HTONS(DHCP_CLIENT_PORT));
    1478:	20 e0       	ldi	r18, 0x00	; 0
    147a:	34 e4       	ldi	r19, 0x44	; 68
    147c:	fc 01       	movw	r30, r24
    147e:	35 83       	std	Z+5, r19	; 0x05
    1480:	24 83       	std	Z+4, r18	; 0x04

		/* Set the initial client state */
		AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1482:	11 86       	std	Z+9, r1	; 0x09

		/* Set timeout period to half a second for a DHCP server to respond */
		timer_set(&AppState->DHCPClient.Timeout, CLOCK_SECOND / 2);
    1484:	62 e3       	ldi	r22, 0x32	; 50
    1486:	70 e0       	ldi	r23, 0x00	; 0
    1488:	0a 96       	adiw	r24, 0x0a	; 10
    148a:	0c 94 d4 1a 	jmp	0x35a8	; 0x35a8 <timer_set>
    148e:	08 95       	ret

00001490 <DHCPClientApp_Callback>:

/** uIP stack application callback for the DHCP client. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPClientApp_Callback(void)
{
    1490:	bf 92       	push	r11
    1492:	cf 92       	push	r12
    1494:	df 92       	push	r13
    1496:	ef 92       	push	r14
    1498:	ff 92       	push	r15
    149a:	0f 93       	push	r16
    149c:	1f 93       	push	r17
    149e:	cf 93       	push	r28
    14a0:	df 93       	push	r29
    14a2:	00 d0       	rcall	.+0      	; 0x14a4 <DHCPClientApp_Callback+0x14>
    14a4:	1f 92       	push	r1
    14a6:	cd b7       	in	r28, 0x3d	; 61
    14a8:	de b7       	in	r29, 0x3e	; 62
	uip_udp_appstate_t* const AppState    = &uip_udp_conn->appstate;
    14aa:	00 91 0f 06 	lds	r16, 0x060F	; 0x80060f <uip_udp_conn>
    14ae:	10 91 10 06 	lds	r17, 0x0610	; 0x800610 <uip_udp_conn+0x1>
    14b2:	a8 01       	movw	r20, r16
    14b4:	47 5f       	subi	r20, 0xF7	; 247
    14b6:	5f 4f       	sbci	r21, 0xFF	; 255
	DHCP_Header_t*      const AppData     = (DHCP_Header_t*)uip_appdata;
    14b8:	e0 90 11 06 	lds	r14, 0x0611	; 0x800611 <uip_appdata>
    14bc:	f0 90 12 06 	lds	r15, 0x0612	; 0x800612 <uip_appdata+0x1>
	uint16_t                  AppDataSize = 0;

	switch (AppState->DHCPClient.CurrentState)
    14c0:	d8 01       	movw	r26, r16
    14c2:	19 96       	adiw	r26, 0x09	; 9
    14c4:	8c 91       	ld	r24, X
    14c6:	81 30       	cpi	r24, 0x01	; 1
    14c8:	09 f4       	brne	.+2      	; 0x14cc <DHCPClientApp_Callback+0x3c>
    14ca:	44 c0       	rjmp	.+136    	; 0x1554 <DHCPClientApp_Callback+0xc4>
    14cc:	38 f0       	brcs	.+14     	; 0x14dc <DHCPClientApp_Callback+0x4c>
    14ce:	82 30       	cpi	r24, 0x02	; 2
    14d0:	09 f4       	brne	.+2      	; 0x14d4 <DHCPClientApp_Callback+0x44>
    14d2:	8d c0       	rjmp	.+282    	; 0x15ee <DHCPClientApp_Callback+0x15e>
    14d4:	83 30       	cpi	r24, 0x03	; 3
    14d6:	09 f4       	brne	.+2      	; 0x14da <DHCPClientApp_Callback+0x4a>
    14d8:	b3 c0       	rjmp	.+358    	; 0x1640 <DHCPClientApp_Callback+0x1b0>
    14da:	ff c0       	rjmp	.+510    	; 0x16da <DHCPClientApp_Callback+0x24a>
	{
		case DHCP_STATE_SendDiscover:
			/* Clear all DHCP settings, reset client IP address */
			memset(&AppState->DHCPClient.DHCPOffer_Data, 0x00, sizeof(AppState->DHCPClient.DHCPOffer_Data));
    14dc:	f8 01       	movw	r30, r16
    14de:	3e 96       	adiw	r30, 0x0e	; 14
    14e0:	80 e1       	ldi	r24, 0x10	; 16
    14e2:	df 01       	movw	r26, r30
    14e4:	1d 92       	st	X+, r1
    14e6:	8a 95       	dec	r24
    14e8:	e9 f7       	brne	.-6      	; 0x14e4 <DHCPClientApp_Callback+0x54>
			uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    14ea:	f8 01       	movw	r30, r16
    14ec:	86 85       	ldd	r24, Z+14	; 0x0e
    14ee:	97 85       	ldd	r25, Z+15	; 0x0f
    14f0:	a0 89       	ldd	r26, Z+16	; 0x10
    14f2:	b1 89       	ldd	r27, Z+17	; 0x11
    14f4:	80 93 7a 07 	sts	0x077A, r24	; 0x80077a <uip_hostaddr>
    14f8:	90 93 7b 07 	sts	0x077B, r25	; 0x80077b <uip_hostaddr+0x1>
    14fc:	a0 93 7c 07 	sts	0x077C, r26	; 0x80077c <uip_hostaddr+0x2>
    1500:	b0 93 7d 07 	sts	0x077D, r27	; 0x80077d <uip_hostaddr+0x3>

			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_DISCOVER, AppState);
    1504:	61 e0       	ldi	r22, 0x01	; 1
    1506:	c7 01       	movw	r24, r14
    1508:	4e df       	rcall	.-356    	; 0x13a6 <DHCPClientApp_FillDHCPHeader>
    150a:	6c 01       	movw	r12, r24

			/* Add the required DHCP options list to the packet */
			uint8_t RequiredOptionList[] = {DHCP_OPTION_SUBNET_MASK, DHCP_OPTION_ROUTER, DHCP_OPTION_DNS_SERVER};
    150c:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <InquiryData+0x24>
    1510:	90 91 24 02 	lds	r25, 0x0224	; 0x800224 <InquiryData+0x25>
    1514:	a0 91 25 02 	lds	r26, 0x0225	; 0x800225 <InquiryData+0x26>
    1518:	89 83       	std	Y+1, r24	; 0x01
    151a:	9a 83       	std	Y+2, r25	; 0x02
    151c:	ab 83       	std	Y+3, r26	; 0x03
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_LIST, sizeof(RequiredOptionList),
    151e:	9e 01       	movw	r18, r28
    1520:	2f 5f       	subi	r18, 0xFF	; 255
    1522:	3f 4f       	sbci	r19, 0xFF	; 255
    1524:	43 e0       	ldi	r20, 0x03	; 3
    1526:	67 e3       	ldi	r22, 0x37	; 55
    1528:	c7 01       	movw	r24, r14
    152a:	80 51       	subi	r24, 0x10	; 16
    152c:	9f 4f       	sbci	r25, 0xFF	; 255
    152e:	fb de       	rcall	.-522    	; 0x1326 <DHCPCommon_SetOption>
			                                    RequiredOptionList);

			/* Send the DHCP DISCOVER packet */
			uip_udp_send(AppDataSize);
    1530:	b6 01       	movw	r22, r12
    1532:	68 0f       	add	r22, r24
    1534:	71 1d       	adc	r23, r1
    1536:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <uip_appdata>
    153a:	90 91 12 06 	lds	r25, 0x0612	; 0x800612 <uip_appdata+0x1>
    153e:	0e 94 23 18 	call	0x3046	; 0x3046 <uip_send>

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    1542:	c8 01       	movw	r24, r16
    1544:	0a 96       	adiw	r24, 0x0a	; 10
    1546:	0e 94 df 1a 	call	0x35be	; 0x35be <timer_reset>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForOffer;
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	d8 01       	movw	r26, r16
    154e:	19 96       	adiw	r26, 0x09	; 9
    1550:	8c 93       	st	X, r24

			break;
    1552:	c3 c0       	rjmp	.+390    	; 0x16da <DHCPClientApp_Callback+0x24a>
		case DHCP_STATE_WaitForOffer:
			if (!(uip_newdata()))
    1554:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    1558:	81 fd       	sbrc	r24, 1
    155a:	0a c0       	rjmp	.+20     	; 0x1570 <DHCPClientApp_Callback+0xe0>
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    155c:	c8 01       	movw	r24, r16
    155e:	0a 96       	adiw	r24, 0x0a	; 10
    1560:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <timer_expired>
    1564:	89 2b       	or	r24, r25
    1566:	09 f4       	brne	.+2      	; 0x156a <DHCPClientApp_Callback+0xda>
    1568:	b8 c0       	rjmp	.+368    	; 0x16da <DHCPClientApp_Callback+0x24a>
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    156a:	f8 01       	movw	r30, r16
    156c:	11 86       	std	Z+9, r1	; 0x09
    156e:	b5 c0       	rjmp	.+362    	; 0x16da <DHCPClientApp_Callback+0x24a>

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1570:	f7 01       	movw	r30, r14
    1572:	84 81       	ldd	r24, Z+4	; 0x04
    1574:	95 81       	ldd	r25, Z+5	; 0x05
    1576:	a6 81       	ldd	r26, Z+6	; 0x06
    1578:	b7 81       	ldd	r27, Z+7	; 0x07
    157a:	86 36       	cpi	r24, 0x66	; 102
    157c:	94 45       	sbci	r25, 0x54	; 84
    157e:	a4 42       	sbci	r26, 0x24	; 36
    1580:	b3 41       	sbci	r27, 0x13	; 19
    1582:	09 f0       	breq	.+2      	; 0x1586 <DHCPClientApp_Callback+0xf6>
    1584:	aa c0       	rjmp	.+340    	; 0x16da <DHCPClientApp_Callback+0x24a>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
    1586:	67 01       	movw	r12, r14
    1588:	20 ef       	ldi	r18, 0xF0	; 240
    158a:	c2 0e       	add	r12, r18
    158c:	d1 1c       	adc	r13, r1
    158e:	ae 01       	movw	r20, r28
    1590:	4f 5f       	subi	r20, 0xFF	; 255
    1592:	5f 4f       	sbci	r21, 0xFF	; 255
    1594:	65 e3       	ldi	r22, 0x35	; 53
    1596:	c6 01       	movw	r24, r12
    1598:	ee de       	rcall	.-548    	; 0x1376 <DHCPCommon_GetOption>

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    159a:	88 23       	and	r24, r24
    159c:	09 f4       	brne	.+2      	; 0x15a0 <DHCPClientApp_Callback+0x110>
    159e:	9d c0       	rjmp	.+314    	; 0x16da <DHCPClientApp_Callback+0x24a>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
    15a0:	b9 80       	ldd	r11, Y+1	; 0x01
    15a2:	82 e0       	ldi	r24, 0x02	; 2
    15a4:	b8 12       	cpse	r11, r24
    15a6:	99 c0       	rjmp	.+306    	; 0x16da <DHCPClientApp_Callback+0x24a>
			    (OfferResponse_MessageType == DHCP_OFFER))
			{
				/* Received a DHCP offer for an IP address, copy over values for later request */
				memcpy(&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, &AppData->YourIP, sizeof(uip_ipaddr_t));
    15a8:	d8 01       	movw	r26, r16
    15aa:	1e 96       	adiw	r26, 0x0e	; 14
    15ac:	f7 01       	movw	r30, r14
    15ae:	70 96       	adiw	r30, 0x10	; 16
    15b0:	84 e0       	ldi	r24, 0x04	; 4
    15b2:	01 90       	ld	r0, Z+
    15b4:	0d 92       	st	X+, r0
    15b6:	8a 95       	dec	r24
    15b8:	e1 f7       	brne	.-8      	; 0x15b2 <DHCPClientApp_Callback+0x122>
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK, &AppState->DHCPClient.DHCPOffer_Data.Netmask);
    15ba:	a8 01       	movw	r20, r16
    15bc:	4e 5e       	subi	r20, 0xEE	; 238
    15be:	5f 4f       	sbci	r21, 0xFF	; 255
    15c0:	61 e0       	ldi	r22, 0x01	; 1
    15c2:	c6 01       	movw	r24, r12
    15c4:	d8 de       	rcall	.-592    	; 0x1376 <DHCPCommon_GetOption>
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_ROUTER,      &AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    15c6:	a8 01       	movw	r20, r16
    15c8:	4a 5e       	subi	r20, 0xEA	; 234
    15ca:	5f 4f       	sbci	r21, 0xFF	; 255
    15cc:	63 e0       	ldi	r22, 0x03	; 3
    15ce:	c6 01       	movw	r24, r12
    15d0:	d2 de       	rcall	.-604    	; 0x1376 <DHCPCommon_GetOption>
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SERVER_ID,   &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    15d2:	a8 01       	movw	r20, r16
    15d4:	46 5e       	subi	r20, 0xE6	; 230
    15d6:	5f 4f       	sbci	r21, 0xFF	; 255
    15d8:	66 e3       	ldi	r22, 0x36	; 54
    15da:	c6 01       	movw	r24, r12
    15dc:	cc de       	rcall	.-616    	; 0x1376 <DHCPCommon_GetOption>

				timer_reset(&AppState->DHCPClient.Timeout);
    15de:	c8 01       	movw	r24, r16
    15e0:	0a 96       	adiw	r24, 0x0a	; 10
    15e2:	0e 94 df 1a 	call	0x35be	; 0x35be <timer_reset>
				AppState->DHCPClient.CurrentState = DHCP_STATE_SendRequest;
    15e6:	d8 01       	movw	r26, r16
    15e8:	19 96       	adiw	r26, 0x09	; 9
    15ea:	bc 92       	st	X, r11
			}

			break;
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);
    15ec:	76 c0       	rjmp	.+236    	; 0x16da <DHCPClientApp_Callback+0x24a>
    15ee:	63 e0       	ldi	r22, 0x03	; 3
    15f0:	c7 01       	movw	r24, r14
    15f2:	d9 de       	rcall	.-590    	; 0x13a6 <DHCPClientApp_FillDHCPHeader>
    15f4:	6c 01       	movw	r12, r24

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    15f6:	b0 ef       	ldi	r27, 0xF0	; 240
    15f8:	eb 0e       	add	r14, r27
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    15fa:	f1 1c       	adc	r15, r1
    15fc:	98 01       	movw	r18, r16
    15fe:	22 5f       	subi	r18, 0xF2	; 242
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    1600:	3f 4f       	sbci	r19, 0xFF	; 255
    1602:	44 e0       	ldi	r20, 0x04	; 4
    1604:	62 e3       	ldi	r22, 0x32	; 50
    1606:	c7 01       	movw	r24, r14
    1608:	8e de       	rcall	.-740    	; 0x1326 <DHCPCommon_SetOption>
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    160a:	b8 2e       	mov	r11, r24
    160c:	98 01       	movw	r18, r16
    160e:	26 5e       	subi	r18, 0xE6	; 230
			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    1610:	3f 4f       	sbci	r19, 0xFF	; 255
    1612:	44 e0       	ldi	r20, 0x04	; 4
    1614:	66 e3       	ldi	r22, 0x36	; 54
    1616:	c7 01       	movw	r24, r14
    1618:	86 de       	rcall	.-756    	; 0x1326 <DHCPCommon_SetOption>
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);

			/* Send the DHCP REQUEST packet */
			uip_udp_send(AppDataSize);
    161a:	68 2f       	mov	r22, r24
    161c:	70 e0       	ldi	r23, 0x00	; 0
    161e:	6b 0d       	add	r22, r11
    1620:	71 1d       	adc	r23, r1
    1622:	6c 0d       	add	r22, r12
    1624:	7d 1d       	adc	r23, r13
    1626:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <uip_appdata>
    162a:	90 91 12 06 	lds	r25, 0x0612	; 0x800612 <uip_appdata+0x1>
    162e:	0e 94 23 18 	call	0x3046	; 0x3046 <uip_send>

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    1632:	c8 01       	movw	r24, r16
    1634:	0a 96       	adiw	r24, 0x0a	; 10
    1636:	0e 94 df 1a 	call	0x35be	; 0x35be <timer_reset>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForACK;
    163a:	83 e0       	ldi	r24, 0x03	; 3
    163c:	f8 01       	movw	r30, r16
    163e:	4c c0       	rjmp	.+152    	; 0x16d8 <DHCPClientApp_Callback+0x248>

			break;
		case DHCP_STATE_WaitForACK:
			if (!(uip_newdata()))
    1640:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    1644:	81 fd       	sbrc	r24, 1
    1646:	0b c0       	rjmp	.+22     	; 0x165e <DHCPClientApp_Callback+0x1ce>
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    1648:	c8 01       	movw	r24, r16
    164a:	0a 96       	adiw	r24, 0x0a	; 10
    164c:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <timer_expired>
    1650:	89 2b       	or	r24, r25
    1652:	09 f4       	brne	.+2      	; 0x1656 <DHCPClientApp_Callback+0x1c6>
    1654:	42 c0       	rjmp	.+132    	; 0x16da <DHCPClientApp_Callback+0x24a>
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1656:	d8 01       	movw	r26, r16
    1658:	19 96       	adiw	r26, 0x09	; 9
    165a:	1c 92       	st	X, r1
    165c:	3e c0       	rjmp	.+124    	; 0x16da <DHCPClientApp_Callback+0x24a>

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    165e:	f7 01       	movw	r30, r14
    1660:	84 81       	ldd	r24, Z+4	; 0x04
    1662:	95 81       	ldd	r25, Z+5	; 0x05
    1664:	a6 81       	ldd	r26, Z+6	; 0x06
    1666:	b7 81       	ldd	r27, Z+7	; 0x07
    1668:	86 36       	cpi	r24, 0x66	; 102
    166a:	94 45       	sbci	r25, 0x54	; 84
    166c:	a4 42       	sbci	r26, 0x24	; 36
    166e:	b3 41       	sbci	r27, 0x13	; 19
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
    1670:	a1 f5       	brne	.+104    	; 0x16da <DHCPClientApp_Callback+0x24a>
    1672:	ae 01       	movw	r20, r28
    1674:	4f 5f       	subi	r20, 0xFF	; 255
    1676:	5f 4f       	sbci	r21, 0xFF	; 255
    1678:	65 e3       	ldi	r22, 0x35	; 53
    167a:	c7 01       	movw	r24, r14
    167c:	80 51       	subi	r24, 0x10	; 16
    167e:	9f 4f       	sbci	r25, 0xFF	; 255
    1680:	7a de       	rcall	.-780    	; 0x1376 <DHCPCommon_GetOption>

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1682:	88 23       	and	r24, r24
    1684:	51 f1       	breq	.+84     	; 0x16da <DHCPClientApp_Callback+0x24a>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
    1686:	89 81       	ldd	r24, Y+1	; 0x01
    1688:	85 30       	cpi	r24, 0x05	; 5
    168a:	39 f5       	brne	.+78     	; 0x16da <DHCPClientApp_Callback+0x24a>
			    (RequestResponse_MessageType == DHCP_ACK))
			{
				/* Set the new network parameters from the DHCP server */
				uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    168c:	f8 01       	movw	r30, r16
    168e:	86 85       	ldd	r24, Z+14	; 0x0e
    1690:	97 85       	ldd	r25, Z+15	; 0x0f
    1692:	a0 89       	ldd	r26, Z+16	; 0x10
    1694:	b1 89       	ldd	r27, Z+17	; 0x11
    1696:	80 93 7a 07 	sts	0x077A, r24	; 0x80077a <uip_hostaddr>
    169a:	90 93 7b 07 	sts	0x077B, r25	; 0x80077b <uip_hostaddr+0x1>
    169e:	a0 93 7c 07 	sts	0x077C, r26	; 0x80077c <uip_hostaddr+0x2>
    16a2:	b0 93 7d 07 	sts	0x077D, r27	; 0x80077d <uip_hostaddr+0x3>
				uip_setnetmask((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.Netmask);
    16a6:	82 89       	ldd	r24, Z+18	; 0x12
    16a8:	93 89       	ldd	r25, Z+19	; 0x13
    16aa:	a4 89       	ldd	r26, Z+20	; 0x14
    16ac:	b5 89       	ldd	r27, Z+21	; 0x15
    16ae:	80 93 76 07 	sts	0x0776, r24	; 0x800776 <uip_netmask>
    16b2:	90 93 77 07 	sts	0x0777, r25	; 0x800777 <uip_netmask+0x1>
    16b6:	a0 93 78 07 	sts	0x0778, r26	; 0x800778 <uip_netmask+0x2>
    16ba:	b0 93 79 07 	sts	0x0779, r27	; 0x800779 <uip_netmask+0x3>
				uip_setdraddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    16be:	86 89       	ldd	r24, Z+22	; 0x16
    16c0:	97 89       	ldd	r25, Z+23	; 0x17
    16c2:	a0 8d       	ldd	r26, Z+24	; 0x18
    16c4:	b1 8d       	ldd	r27, Z+25	; 0x19
    16c6:	80 93 72 07 	sts	0x0772, r24	; 0x800772 <uip_draddr>
    16ca:	90 93 73 07 	sts	0x0773, r25	; 0x800773 <uip_draddr+0x1>
    16ce:	a0 93 74 07 	sts	0x0774, r26	; 0x800774 <uip_draddr+0x2>
    16d2:	b0 93 75 07 	sts	0x0775, r27	; 0x800775 <uip_draddr+0x3>

				AppState->DHCPClient.CurrentState = DHCP_STATE_AddressLeased;
    16d6:	84 e0       	ldi	r24, 0x04	; 4
    16d8:	81 87       	std	Z+9, r24	; 0x09
			}

			break;
	}
}
    16da:	0f 90       	pop	r0
    16dc:	0f 90       	pop	r0
    16de:	0f 90       	pop	r0
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	1f 91       	pop	r17
    16e6:	0f 91       	pop	r16
    16e8:	ff 90       	pop	r15
    16ea:	ef 90       	pop	r14
    16ec:	df 90       	pop	r13
    16ee:	cf 90       	pop	r12
    16f0:	bf 90       	pop	r11
    16f2:	08 95       	ret

000016f4 <DHCPServerApp_FillDHCPHeader>:
static uint16_t DHCPServerApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             const struct uip_eth_addr* const ClientHardwareAddress,
											 const uip_ipaddr_t* const PreferredClientIP,
                                             const uint32_t TransactionID)
{
    16f4:	cf 92       	push	r12
    16f6:	df 92       	push	r13
    16f8:	ef 92       	push	r14
    16fa:	ff 92       	push	r15
    16fc:	0f 93       	push	r16
    16fe:	1f 93       	push	r17
    1700:	cf 93       	push	r28
    1702:	df 93       	push	r29
    1704:	ec 01       	movw	r28, r24
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    1706:	80 ef       	ldi	r24, 0xF0	; 240
    1708:	fe 01       	movw	r30, r28
    170a:	11 92       	st	Z+, r1
    170c:	8a 95       	dec	r24
    170e:	e9 f7       	brne	.-6      	; 0x170a <DHCPServerApp_FillDHCPHeader+0x16>

	DHCPHeader->Operation             = DHCPMessageType;
    1710:	68 83       	st	Y, r22
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    1712:	81 e0       	ldi	r24, 0x01	; 1
    1714:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    1716:	96 e0       	ldi	r25, 0x06	; 6
    1718:	9a 83       	std	Y+2, r25	; 0x02
	DHCPHeader->Hops                  = 0;
    171a:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeader->TransactionID         = TransactionID;
    171c:	ec 82       	std	Y+4, r14	; 0x04
    171e:	fd 82       	std	Y+5, r15	; 0x05
    1720:	0e 83       	std	Y+6, r16	; 0x06
    1722:	1f 83       	std	Y+7, r17	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    1724:	19 86       	std	Y+9, r1	; 0x09
    1726:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeader->Flags                 = 0;
    1728:	1b 86       	std	Y+11, r1	; 0x0b
    172a:	1a 86       	std	Y+10, r1	; 0x0a
	memcpy(&DHCPHeader->NextServerIP, &uip_hostaddr, sizeof(uip_ipaddr_t));
    172c:	c0 90 7a 07 	lds	r12, 0x077A	; 0x80077a <uip_hostaddr>
    1730:	d0 90 7b 07 	lds	r13, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    1734:	e0 90 7c 07 	lds	r14, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    1738:	f0 90 7d 07 	lds	r15, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    173c:	cc 8a       	std	Y+20, r12	; 0x14
    173e:	dd 8a       	std	Y+21, r13	; 0x15
    1740:	ee 8a       	std	Y+22, r14	; 0x16
    1742:	ff 8a       	std	Y+23, r15	; 0x17
	memcpy(&DHCPHeader->YourIP, PreferredClientIP, sizeof(uip_ipaddr_t));
    1744:	de 01       	movw	r26, r28
    1746:	50 96       	adiw	r26, 0x10	; 16
    1748:	94 e0       	ldi	r25, 0x04	; 4
    174a:	f9 01       	movw	r30, r18
    174c:	01 90       	ld	r0, Z+
    174e:	0d 92       	st	X+, r0
    1750:	9a 95       	dec	r25
    1752:	e1 f7       	brne	.-8      	; 0x174c <DHCPServerApp_FillDHCPHeader+0x58>
	memcpy(&DHCPHeader->ClientHardwareAddress, ClientHardwareAddress, sizeof(struct uip_eth_addr));
    1754:	de 01       	movw	r26, r28
    1756:	5c 96       	adiw	r26, 0x1c	; 28
    1758:	96 e0       	ldi	r25, 0x06	; 6
    175a:	fa 01       	movw	r30, r20
    175c:	01 90       	ld	r0, Z+
    175e:	0d 92       	st	X+, r0
    1760:	9a 95       	dec	r25
    1762:	e1 f7       	brne	.-8      	; 0x175c <DHCPServerApp_FillDHCPHeader+0x68>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    1764:	fe 01       	movw	r30, r28
    1766:	e4 51       	subi	r30, 0x14	; 20
    1768:	ff 4f       	sbci	r31, 0xFF	; 255
    176a:	03 e6       	ldi	r16, 0x63	; 99
    176c:	12 e8       	ldi	r17, 0x82	; 130
    176e:	23 e5       	ldi	r18, 0x53	; 83
    1770:	33 e6       	ldi	r19, 0x63	; 99
    1772:	00 83       	st	Z, r16
    1774:	11 83       	std	Z+1, r17	; 0x01
    1776:	22 83       	std	Z+2, r18	; 0x02
    1778:	33 83       	std	Z+3, r19	; 0x03
	  
	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    177a:	34 96       	adiw	r30, 0x04	; 4
    177c:	95 e3       	ldi	r25, 0x35	; 53
    177e:	90 83       	st	Z, r25
	DHCPHeader->Options[1]            = 1;
    1780:	31 96       	adiw	r30, 0x01	; 1
    1782:	80 83       	st	Z, r24
	DHCPHeader->Options[2]            = DHCPMessageType;
    1784:	31 96       	adiw	r30, 0x01	; 1
    1786:	60 83       	st	Z, r22
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    1788:	cd 50       	subi	r28, 0x0D	; 13
    178a:	df 4f       	sbci	r29, 0xFF	; 255
    178c:	8f ef       	ldi	r24, 0xFF	; 255
    178e:	88 83       	st	Y, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    1790:	84 ef       	ldi	r24, 0xF4	; 244
    1792:	90 e0       	ldi	r25, 0x00	; 0
    1794:	df 91       	pop	r29
    1796:	cf 91       	pop	r28
    1798:	1f 91       	pop	r17
    179a:	0f 91       	pop	r16
    179c:	ff 90       	pop	r15
    179e:	ef 90       	pop	r14
    17a0:	df 90       	pop	r13
    17a2:	cf 90       	pop	r12
    17a4:	08 95       	ret

000017a6 <DHCPServerApp_CheckIfIPLeased.isra.0>:
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
	
	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
    17a6:	88 23       	and	r24, r24
    17a8:	c9 f0       	breq	.+50     	; 0x17dc <DHCPServerApp_CheckIfIPLeased.isra.0+0x36>
    17aa:	90 91 7d 07 	lds	r25, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    17ae:	98 17       	cp	r25, r24
    17b0:	a9 f0       	breq	.+42     	; 0x17dc <DHCPServerApp_CheckIfIPLeased.isra.0+0x36>
    17b2:	98 2f       	mov	r25, r24
    17b4:	97 70       	andi	r25, 0x07	; 7
    17b6:	21 e0       	ldi	r18, 0x01	; 1
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	01 c0       	rjmp	.+2      	; 0x17be <DHCPServerApp_CheckIfIPLeased.isra.0+0x18>
    17bc:	22 0f       	add	r18, r18
    17be:	9a 95       	dec	r25
    17c0:	ea f7       	brpl	.-6      	; 0x17bc <DHCPServerApp_CheckIfIPLeased.isra.0+0x16>
    17c2:	86 95       	lsr	r24
    17c4:	86 95       	lsr	r24
    17c6:	86 95       	lsr	r24
    17c8:	e8 2f       	mov	r30, r24
    17ca:	f0 e0       	ldi	r31, 0x00	; 0
    17cc:	ed 53       	subi	r30, 0x3D	; 61
    17ce:	fc 4f       	sbci	r31, 0xFC	; 252
    17d0:	80 81       	ld	r24, Z
    17d2:	28 23       	and	r18, r24
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	19 f4       	brne	.+6      	; 0x17de <DHCPServerApp_CheckIfIPLeased.isra.0+0x38>
    17d8:	80 e0       	ldi	r24, 0x00	; 0
    17da:	08 95       	ret
	  return false;
	else
	  return true;
    17dc:	81 e0       	ldi	r24, 0x01	; 1
}
    17de:	08 95       	ret

000017e0 <DHCPServerApp_Init>:
	
/** Initialization function for the DHCP server. */
void DHCPServerApp_Init(void)
{
	/* Listen on port 67 for DHCP server connections from hosts */
	uip_listen(HTONS(DHCP_SERVER_PORT));
    17e0:	80 e0       	ldi	r24, 0x00	; 0
    17e2:	93 e4       	ldi	r25, 0x43	; 67
    17e4:	c1 d4       	rcall	.+2434   	; 0x2168 <uip_listen>
	
	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* BroadcastConnection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_CLIENT_PORT));
    17e6:	60 e0       	ldi	r22, 0x00	; 0
    17e8:	74 e4       	ldi	r23, 0x44	; 68
    17ea:	82 e5       	ldi	r24, 0x52	; 82
    17ec:	92 e0       	ldi	r25, 0x02	; 2
    17ee:	74 d4       	rcall	.+2280   	; 0x20d8 <uip_udp_new>

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (BroadcastConnection != NULL)
    17f0:	00 97       	sbiw	r24, 0x00	; 0
    17f2:	39 f0       	breq	.+14     	; 0x1802 <DHCPServerApp_Init+0x22>
	  uip_udp_bind(BroadcastConnection, HTONS(DHCP_SERVER_PORT));
    17f4:	20 e0       	ldi	r18, 0x00	; 0
    17f6:	33 e4       	ldi	r19, 0x43	; 67
    17f8:	dc 01       	movw	r26, r24
    17fa:	15 96       	adiw	r26, 0x05	; 5
    17fc:	3c 93       	st	X, r19
    17fe:	2e 93       	st	-X, r18
    1800:	14 97       	sbiw	r26, 0x04	; 4
	  
	/* Set all IP addresses as unleased */
	memset(LeasedIPs, 0x00, sizeof(LeasedIPs));
    1802:	8f e1       	ldi	r24, 0x1F	; 31
    1804:	e3 ec       	ldi	r30, 0xC3	; 195
    1806:	f3 e0       	ldi	r31, 0x03	; 3
    1808:	df 01       	movw	r26, r30
    180a:	1d 92       	st	X+, r1
    180c:	8a 95       	dec	r24
    180e:	e9 f7       	brne	.-6      	; 0x180a <DHCPServerApp_Init+0x2a>
    1810:	08 95       	ret

00001812 <DHCPServerApp_Callback>:

/** uIP stack application callback for the DHCP server. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPServerApp_Callback(void)
{
    1812:	4f 92       	push	r4
    1814:	5f 92       	push	r5
    1816:	6f 92       	push	r6
    1818:	7f 92       	push	r7
    181a:	af 92       	push	r10
    181c:	bf 92       	push	r11
    181e:	cf 92       	push	r12
    1820:	df 92       	push	r13
    1822:	ef 92       	push	r14
    1824:	ff 92       	push	r15
    1826:	0f 93       	push	r16
    1828:	1f 93       	push	r17
    182a:	cf 93       	push	r28
    182c:	df 93       	push	r29
    182e:	cd b7       	in	r28, 0x3d	; 61
    1830:	de b7       	in	r29, 0x3e	; 62
    1832:	63 97       	sbiw	r28, 0x13	; 19
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	de bf       	out	0x3e, r29	; 62
    183a:	0f be       	out	0x3f, r0	; 63
    183c:	cd bf       	out	0x3d, r28	; 61
	DHCP_Header_t* const AppData     = (DHCP_Header_t*)uip_appdata;
	uint16_t             AppDataSize = 0;

	/* Only process when new data arrives - don't retransmit lost packets */
	if (uip_newdata())
    183e:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    1842:	81 ff       	sbrs	r24, 1
    1844:	0a c1       	rjmp	.+532    	; 0x1a5a <DHCPServerApp_Callback+0x248>
/** uIP stack application callback for the DHCP server. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPServerApp_Callback(void)
{
	DHCP_Header_t* const AppData     = (DHCP_Header_t*)uip_appdata;
    1846:	c0 90 11 06 	lds	r12, 0x0611	; 0x800611 <uip_appdata>
    184a:	d0 90 12 06 	lds	r13, 0x0612	; 0x800612 <uip_appdata+0x1>
	/* Only process when new data arrives - don't retransmit lost packets */
	if (uip_newdata())
	{
		/* Get the DHCP message type (if present), otherwise early-abort */
		uint8_t DHCPMessageType;
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &DHCPMessageType)))
    184e:	56 01       	movw	r10, r12
    1850:	80 ef       	ldi	r24, 0xF0	; 240
    1852:	a8 0e       	add	r10, r24
    1854:	b1 1c       	adc	r11, r1
    1856:	ae 01       	movw	r20, r28
    1858:	4d 5e       	subi	r20, 0xED	; 237
    185a:	5f 4f       	sbci	r21, 0xFF	; 255
    185c:	65 e3       	ldi	r22, 0x35	; 53
    185e:	c5 01       	movw	r24, r10
    1860:	8a dd       	rcall	.-1260   	; 0x1376 <DHCPCommon_GetOption>
    1862:	88 23       	and	r24, r24
    1864:	09 f4       	brne	.+2      	; 0x1868 <DHCPServerApp_Callback+0x56>
    1866:	f9 c0       	rjmp	.+498    	; 0x1a5a <DHCPServerApp_Callback+0x248>
		uip_ipaddr_t        Netmask, GatewayIPAddress, PreferredClientIP;
		struct uip_eth_addr RemoteMACAddress;
		uint32_t            TransactionID;

		/* Get configured network mask, gateway IP and extract out DHCP transaction ID and remote IP */
		uip_getnetmask(&Netmask);
    1868:	80 91 76 07 	lds	r24, 0x0776	; 0x800776 <uip_netmask>
    186c:	90 91 77 07 	lds	r25, 0x0777	; 0x800777 <uip_netmask+0x1>
    1870:	a0 91 78 07 	lds	r26, 0x0778	; 0x800778 <uip_netmask+0x2>
    1874:	b0 91 79 07 	lds	r27, 0x0779	; 0x800779 <uip_netmask+0x3>
    1878:	8f 87       	std	Y+15, r24	; 0x0f
    187a:	98 8b       	std	Y+16, r25	; 0x10
    187c:	a9 8b       	std	Y+17, r26	; 0x11
    187e:	ba 8b       	std	Y+18, r27	; 0x12
		uip_getdraddr(&GatewayIPAddress);
    1880:	80 91 72 07 	lds	r24, 0x0772	; 0x800772 <uip_draddr>
    1884:	90 91 73 07 	lds	r25, 0x0773	; 0x800773 <uip_draddr+0x1>
    1888:	a0 91 74 07 	lds	r26, 0x0774	; 0x800774 <uip_draddr+0x2>
    188c:	b0 91 75 07 	lds	r27, 0x0775	; 0x800775 <uip_draddr+0x3>
    1890:	8b 87       	std	Y+11, r24	; 0x0b
    1892:	9c 87       	std	Y+12, r25	; 0x0c
    1894:	ad 87       	std	Y+13, r26	; 0x0d
    1896:	be 87       	std	Y+14, r27	; 0x0e
		memcpy(&RemoteMACAddress, &AppData->ClientHardwareAddress, sizeof(struct uip_eth_addr));
    1898:	86 e0       	ldi	r24, 0x06	; 6
    189a:	f6 01       	movw	r30, r12
    189c:	7c 96       	adiw	r30, 0x1c	; 28
    189e:	de 01       	movw	r26, r28
    18a0:	11 96       	adiw	r26, 0x01	; 1
    18a2:	01 90       	ld	r0, Z+
    18a4:	0d 92       	st	X+, r0
    18a6:	8a 95       	dec	r24
    18a8:	e1 f7       	brne	.-8      	; 0x18a2 <DHCPServerApp_Callback+0x90>
		TransactionID = AppData->TransactionID;
    18aa:	f6 01       	movw	r30, r12
    18ac:	44 80       	ldd	r4, Z+4	; 0x04
    18ae:	55 80       	ldd	r5, Z+5	; 0x05
    18b0:	66 80       	ldd	r6, Z+6	; 0x06
    18b2:	77 80       	ldd	r7, Z+7	; 0x07

		/* Try to extract out the client's preferred IP address if it is indicated in the packet */
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, &PreferredClientIP)))
    18b4:	ae 01       	movw	r20, r28
    18b6:	49 5f       	subi	r20, 0xF9	; 249
    18b8:	5f 4f       	sbci	r21, 0xFF	; 255
    18ba:	62 e3       	ldi	r22, 0x32	; 50
    18bc:	c5 01       	movw	r24, r10
    18be:	5b dd       	rcall	.-1354   	; 0x1376 <DHCPCommon_GetOption>
    18c0:	81 11       	cpse	r24, r1
    18c2:	0c c0       	rjmp	.+24     	; 0x18dc <DHCPServerApp_Callback+0xca>
		  memcpy(&PreferredClientIP, &uip_all_zeroes_addr, sizeof(uip_ipaddr_t));	
    18c4:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <uip_all_zeroes_addr>
    18c8:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <uip_all_zeroes_addr+0x1>
    18cc:	a0 91 50 02 	lds	r26, 0x0250	; 0x800250 <uip_all_zeroes_addr+0x2>
    18d0:	b0 91 51 02 	lds	r27, 0x0251	; 0x800251 <uip_all_zeroes_addr+0x3>
    18d4:	8f 83       	std	Y+7, r24	; 0x07
    18d6:	98 87       	std	Y+8, r25	; 0x08
    18d8:	a9 87       	std	Y+9, r26	; 0x09
    18da:	ba 87       	std	Y+10, r27	; 0x0a
		
		switch (DHCPMessageType)
    18dc:	8b 89       	ldd	r24, Y+19	; 0x13
    18de:	83 30       	cpi	r24, 0x03	; 3
    18e0:	09 f4       	brne	.+2      	; 0x18e4 <DHCPServerApp_Callback+0xd2>
    18e2:	41 c0       	rjmp	.+130    	; 0x1966 <DHCPServerApp_Callback+0x154>
    18e4:	87 30       	cpi	r24, 0x07	; 7
    18e6:	09 f4       	brne	.+2      	; 0x18ea <DHCPServerApp_Callback+0xd8>
    18e8:	a0 c0       	rjmp	.+320    	; 0x1a2a <DHCPServerApp_Callback+0x218>
    18ea:	81 30       	cpi	r24, 0x01	; 1
    18ec:	09 f0       	breq	.+2      	; 0x18f0 <DHCPServerApp_Callback+0xde>
		{
			case DHCP_DISCOVER:
				/* If no preference was made or the preferred IP is already taken, find a new address */
				if (DHCPServerApp_CheckIfIPLeased(&PreferredClientIP))
    18ee:	b5 c0       	rjmp	.+362    	; 0x1a5a <DHCPServerApp_Callback+0x248>
    18f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    18f2:	59 df       	rcall	.-334    	; 0x17a6 <DHCPServerApp_CheckIfIPLeased.isra.0>
    18f4:	81 11       	cpse	r24, r1
    18f6:	21 c0       	rjmp	.+66     	; 0x193a <DHCPServerApp_Callback+0x128>
				  DHCPServerApp_GetUnleasedIP(&PreferredClientIP);

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    18f8:	83 01       	movw	r16, r6
    18fa:	72 01       	movw	r14, r4
    18fc:	9e 01       	movw	r18, r28
    18fe:	29 5f       	subi	r18, 0xF9	; 249
    1900:	3f 4f       	sbci	r19, 0xFF	; 255
    1902:	ae 01       	movw	r20, r28
    1904:	4f 5f       	subi	r20, 0xFF	; 255
    1906:	5f 4f       	sbci	r21, 0xFF	; 255
    1908:	62 e0       	ldi	r22, 0x02	; 2
    190a:	c6 01       	movw	r24, r12
    190c:	f3 de       	rcall	.-538    	; 0x16f4 <DHCPServerApp_FillDHCPHeader>
    190e:	6c 01       	movw	r12, r24

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    1910:	9e 01       	movw	r18, r28
    1912:	21 5f       	subi	r18, 0xF1	; 241
    1914:	3f 4f       	sbci	r19, 0xFF	; 255
    1916:	44 e0       	ldi	r20, 0x04	; 4
    1918:	61 e0       	ldi	r22, 0x01	; 1
    191a:	c5 01       	movw	r24, r10
    191c:	04 dd       	rcall	.-1528   	; 0x1326 <DHCPCommon_SetOption>
    191e:	18 2f       	mov	r17, r24
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    1920:	9e 01       	movw	r18, r28
    1922:	25 5f       	subi	r18, 0xF5	; 245
    1924:	3f 4f       	sbci	r19, 0xFF	; 255
    1926:	44 e0       	ldi	r20, 0x04	; 4
    1928:	63 e0       	ldi	r22, 0x03	; 3
    192a:	c5 01       	movw	r24, r10
    192c:	fc dc       	rcall	.-1544   	; 0x1326 <DHCPCommon_SetOption>
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	81 0f       	add	r24, r17
    1932:	91 1d       	adc	r25, r1
    1934:	c8 0e       	add	r12, r24
    1936:	d9 1e       	adc	r13, r25
    1938:	56 c0       	rjmp	.+172    	; 0x19e6 <DHCPServerApp_Callback+0x1d4>
 *
 *  \param[out] NewIPAddress  Location where the generated IP Address should be stored
 */
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);
    193a:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    193e:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    1942:	a0 91 7c 07 	lds	r26, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    1946:	b0 91 7d 07 	lds	r27, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    194a:	8f 83       	std	Y+7, r24	; 0x07
    194c:	98 87       	std	Y+8, r25	; 0x08
    194e:	a9 87       	std	Y+9, r26	; 0x09
	
	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    1950:	ba 87       	std	Y+10, r27	; 0x0a
	{
		/* Update new IP address to lease with the current IP address to test */
		NewIPAddress->u8[3] = IP;
    1952:	11 e0       	ldi	r17, 0x01	; 1
		
		/* If we've found an unleased IP, abort with the updated IP stored for the called */
		if (!(DHCPServerApp_CheckIfIPLeased(NewIPAddress)))
    1954:	1a 87       	std	Y+10, r17	; 0x0a
    1956:	81 2f       	mov	r24, r17
    1958:	26 df       	rcall	.-436    	; 0x17a6 <DHCPServerApp_CheckIfIPLeased.isra.0>
    195a:	88 23       	and	r24, r24
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);
	
	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    195c:	69 f2       	breq	.-102    	; 0x18f8 <DHCPServerApp_Callback+0xe6>
    195e:	1f 5f       	subi	r17, 0xFF	; 255
    1960:	1e 3f       	cpi	r17, 0xFE	; 254
    1962:	c1 f7       	brne	.-16     	; 0x1954 <DHCPServerApp_Callback+0x142>
				uip_udp_send(AppDataSize);

				break;
			case DHCP_REQUEST:
				/* Check to see if the requested IP address has already been leased to a client */
				if (!(DHCPServerApp_CheckIfIPLeased(&PreferredClientIP)))
    1964:	c9 cf       	rjmp	.-110    	; 0x18f8 <DHCPServerApp_Callback+0xe6>
    1966:	8a 85       	ldd	r24, Y+10	; 0x0a
    1968:	1e df       	rcall	.-452    	; 0x17a6 <DHCPServerApp_CheckIfIPLeased.isra.0>
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */					
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    196a:	83 01       	movw	r16, r6
    196c:	72 01       	movw	r14, r4
				uip_udp_send(AppDataSize);

				break;
			case DHCP_REQUEST:
				/* Check to see if the requested IP address has already been leased to a client */
				if (!(DHCPServerApp_CheckIfIPLeased(&PreferredClientIP)))
    196e:	81 11       	cpse	r24, r1
    1970:	31 c0       	rjmp	.+98     	; 0x19d4 <DHCPServerApp_Callback+0x1c2>
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */					
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    1972:	9e 01       	movw	r18, r28
    1974:	29 5f       	subi	r18, 0xF9	; 249
    1976:	3f 4f       	sbci	r19, 0xFF	; 255
    1978:	ae 01       	movw	r20, r28
    197a:	4f 5f       	subi	r20, 0xFF	; 255
    197c:	5f 4f       	sbci	r21, 0xFF	; 255
    197e:	65 e0       	ldi	r22, 0x05	; 5
    1980:	c6 01       	movw	r24, r12
    1982:	b8 de       	rcall	.-656    	; 0x16f4 <DHCPServerApp_FillDHCPHeader>

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    1984:	6c 01       	movw	r12, r24
    1986:	9e 01       	movw	r18, r28
    1988:	21 5f       	subi	r18, 0xF1	; 241
    198a:	3f 4f       	sbci	r19, 0xFF	; 255
    198c:	44 e0       	ldi	r20, 0x04	; 4
    198e:	61 e0       	ldi	r22, 0x01	; 1
    1990:	c5 01       	movw	r24, r10
    1992:	c9 dc       	rcall	.-1646   	; 0x1326 <DHCPCommon_SetOption>
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    1994:	18 2f       	mov	r17, r24
    1996:	9e 01       	movw	r18, r28
    1998:	25 5f       	subi	r18, 0xF5	; 245
    199a:	3f 4f       	sbci	r19, 0xFF	; 255
    199c:	44 e0       	ldi	r20, 0x04	; 4
    199e:	63 e0       	ldi	r22, 0x03	; 3
    19a0:	c5 01       	movw	r24, r10
    19a2:	c1 dc       	rcall	.-1662   	; 0x1326 <DHCPCommon_SetOption>
    19a4:	90 e0       	ldi	r25, 0x00	; 0
    19a6:	81 0f       	add	r24, r17
    19a8:	91 1d       	adc	r25, r1
    19aa:	c8 0e       	add	r12, r24
    19ac:	d9 1e       	adc	r13, r25
    19ae:	8a 85       	ldd	r24, Y+10	; 0x0a
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
	
	/* Mark the IP address as leased in the allocation table */
	LeasedIPs[Byte] |= Mask;
    19b0:	e8 2f       	mov	r30, r24
    19b2:	e6 95       	lsr	r30
    19b4:	e6 95       	lsr	r30
    19b6:	e6 95       	lsr	r30
    19b8:	f0 e0       	ldi	r31, 0x00	; 0
    19ba:	ed 53       	subi	r30, 0x3D	; 61
    19bc:	fc 4f       	sbci	r31, 0xFC	; 252
    19be:	87 70       	andi	r24, 0x07	; 7
    19c0:	21 e0       	ldi	r18, 0x01	; 1
    19c2:	30 e0       	ldi	r19, 0x00	; 0
    19c4:	01 c0       	rjmp	.+2      	; 0x19c8 <DHCPServerApp_Callback+0x1b6>
    19c6:	22 0f       	add	r18, r18
    19c8:	8a 95       	dec	r24
    19ca:	ea f7       	brpl	.-6      	; 0x19c6 <DHCPServerApp_Callback+0x1b4>
    19cc:	80 81       	ld	r24, Z
    19ce:	28 2b       	or	r18, r24
    19d0:	20 83       	st	Z, r18
					DHCPServerApp_LeaseIP(&PreferredClientIP);
				}
				else
				{
					/* Create a new DHCP NAK packet to reject the requested allocation */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_NAK, &RemoteMACAddress, &uip_all_zeroes_addr, TransactionID);
    19d2:	09 c0       	rjmp	.+18     	; 0x19e6 <DHCPServerApp_Callback+0x1d4>
    19d4:	2e e4       	ldi	r18, 0x4E	; 78
    19d6:	32 e0       	ldi	r19, 0x02	; 2
    19d8:	ae 01       	movw	r20, r28
    19da:	4f 5f       	subi	r20, 0xFF	; 255
    19dc:	5f 4f       	sbci	r21, 0xFF	; 255
    19de:	66 e0       	ldi	r22, 0x06	; 6
    19e0:	c6 01       	movw	r24, r12
    19e2:	88 de       	rcall	.-752    	; 0x16f4 <DHCPServerApp_FillDHCPHeader>
				}
				
				/* Send the DHCP ACK or NAK packet */
				uip_poll_conn(BroadcastConnection);
    19e4:	6c 01       	movw	r12, r24
    19e6:	80 91 e2 03 	lds	r24, 0x03E2	; 0x8003e2 <BroadcastConnection>
    19ea:	90 91 e3 03 	lds	r25, 0x03E3	; 0x8003e3 <BroadcastConnection+0x1>
    19ee:	90 93 14 06 	sts	0x0614, r25	; 0x800614 <uip_conn+0x1>
    19f2:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <uip_conn>
    19f6:	83 e0       	ldi	r24, 0x03	; 3
    19f8:	d1 d3       	rcall	.+1954   	; 0x219c <uip_process>
				memcpy(&uip_udp_conn->ripaddr, &uip_broadcast_addr, sizeof(uip_ipaddr_t));
    19fa:	e0 91 0f 06 	lds	r30, 0x060F	; 0x80060f <uip_udp_conn>
    19fe:	f0 91 10 06 	lds	r31, 0x0610	; 0x800610 <uip_udp_conn+0x1>
    1a02:	80 91 52 02 	lds	r24, 0x0252	; 0x800252 <uip_broadcast_addr>
    1a06:	90 91 53 02 	lds	r25, 0x0253	; 0x800253 <uip_broadcast_addr+0x1>
    1a0a:	a0 91 54 02 	lds	r26, 0x0254	; 0x800254 <uip_broadcast_addr+0x2>
    1a0e:	b0 91 55 02 	lds	r27, 0x0255	; 0x800255 <uip_broadcast_addr+0x3>
    1a12:	80 83       	st	Z, r24
    1a14:	91 83       	std	Z+1, r25	; 0x01
    1a16:	a2 83       	std	Z+2, r26	; 0x02
    1a18:	b3 83       	std	Z+3, r27	; 0x03
				uip_udp_send(AppDataSize);
    1a1a:	b6 01       	movw	r22, r12
    1a1c:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <uip_appdata>
    1a20:	90 91 12 06 	lds	r25, 0x0612	; 0x800612 <uip_appdata+0x1>
    1a24:	0e 94 23 18 	call	0x3046	; 0x3046 <uip_send>
			
				break;
    1a28:	18 c0       	rjmp	.+48     	; 0x1a5a <DHCPServerApp_Callback+0x248>
    1a2a:	e0 91 0f 06 	lds	r30, 0x060F	; 0x80060f <uip_udp_conn>
    1a2e:	f0 91 10 06 	lds	r31, 0x0610	; 0x800610 <uip_udp_conn+0x1>
    1a32:	83 81       	ldd	r24, Z+3	; 0x03
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
	
	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
    1a34:	e8 2f       	mov	r30, r24
    1a36:	e6 95       	lsr	r30
    1a38:	e6 95       	lsr	r30
    1a3a:	e6 95       	lsr	r30
    1a3c:	f0 e0       	ldi	r31, 0x00	; 0
    1a3e:	ed 53       	subi	r30, 0x3D	; 61
    1a40:	fc 4f       	sbci	r31, 0xFC	; 252
    1a42:	28 2f       	mov	r18, r24
    1a44:	27 70       	andi	r18, 0x07	; 7
    1a46:	81 e0       	ldi	r24, 0x01	; 1
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	01 c0       	rjmp	.+2      	; 0x1a4e <DHCPServerApp_Callback+0x23c>
    1a4c:	88 0f       	add	r24, r24
    1a4e:	2a 95       	dec	r18
    1a50:	ea f7       	brpl	.-6      	; 0x1a4c <DHCPServerApp_Callback+0x23a>
    1a52:	80 95       	com	r24
    1a54:	90 81       	ld	r25, Z
    1a56:	89 23       	and	r24, r25
    1a58:	80 83       	st	Z, r24
				/* Mark the IP address as released in the allocation table */
				DHCPServerApp_UnleaseIP(&uip_udp_conn->ripaddr);
				break;
		}
	}
}
    1a5a:	63 96       	adiw	r28, 0x13	; 19
    1a5c:	0f b6       	in	r0, 0x3f	; 63
    1a5e:	f8 94       	cli
    1a60:	de bf       	out	0x3e, r29	; 62
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	cd bf       	out	0x3d, r28	; 61
    1a66:	df 91       	pop	r29
    1a68:	cf 91       	pop	r28
    1a6a:	1f 91       	pop	r17
    1a6c:	0f 91       	pop	r16
    1a6e:	ff 90       	pop	r15
    1a70:	ef 90       	pop	r14
    1a72:	df 90       	pop	r13
    1a74:	cf 90       	pop	r12
    1a76:	bf 90       	pop	r11
    1a78:	af 90       	pop	r10
    1a7a:	7f 90       	pop	r7
    1a7c:	6f 90       	pop	r6
    1a7e:	5f 90       	pop	r5
    1a80:	4f 90       	pop	r4
    1a82:	08 95       	ret

00001a84 <HTTPServerApp_Init>:

/** Initialization function for the simple HTTP webserver. */
void HTTPServerApp_Init(void)
{
	/* Listen on port 80 for HTTP connections from hosts */
	uip_listen(HTONS(HTTP_SERVER_PORT));
    1a84:	80 e0       	ldi	r24, 0x00	; 0
    1a86:	90 e5       	ldi	r25, 0x50	; 80
    1a88:	6f d3       	rcall	.+1758   	; 0x2168 <uip_listen>

	/* Mount the Dataflash disk via FatFS */
	f_mount(0, &DiskFATState);
    1a8a:	64 ee       	ldi	r22, 0xE4	; 228
    1a8c:	73 e0       	ldi	r23, 0x03	; 3
    1a8e:	80 e0       	ldi	r24, 0x00	; 0
    1a90:	0c 94 c3 1d 	jmp	0x3b86	; 0x3b86 <f_mount>

00001a94 <HTTPServerApp_Callback>:

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
{
    1a94:	af 92       	push	r10
    1a96:	bf 92       	push	r11
    1a98:	cf 92       	push	r12
    1a9a:	df 92       	push	r13
    1a9c:	ef 92       	push	r14
    1a9e:	ff 92       	push	r15
    1aa0:	0f 93       	push	r16
    1aa2:	1f 93       	push	r17
    1aa4:	cf 93       	push	r28
    1aa6:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState = &uip_conn->appstate;
    1aa8:	c0 91 13 06 	lds	r28, 0x0613	; 0x800613 <uip_conn>
    1aac:	d0 91 14 06 	lds	r29, 0x0614	; 0x800614 <uip_conn+0x1>

	if (uip_aborted() || uip_timedout() || uip_closed())
    1ab0:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    1ab4:	85 fd       	sbrc	r24, 5
    1ab6:	04 c0       	rjmp	.+8      	; 0x1ac0 <HTTPServerApp_Callback+0x2c>
    1ab8:	87 fd       	sbrc	r24, 7
    1aba:	02 c0       	rjmp	.+4      	; 0x1ac0 <HTTPServerApp_Callback+0x2c>
    1abc:	84 ff       	sbrs	r24, 4
    1abe:	03 c0       	rjmp	.+6      	; 0x1ac6 <HTTPServerApp_Callback+0x32>
	{
		/* Lock to the closed state so that no further processing will occur on the connection */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_Closing;
    1ac0:	93 e0       	ldi	r25, 0x03	; 3
    1ac2:	9c 8f       	std	Y+28, r25	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_Closing;
    1ac4:	9d 8f       	std	Y+29, r25	; 0x1d
	}

	if (uip_connected())
    1ac6:	86 ff       	sbrs	r24, 6
    1ac8:	0e c0       	rjmp	.+28     	; 0x1ae6 <HTTPServerApp_Callback+0x52>
	{
		/* New connection - initialize connection state values */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_OpenRequestedFile;
    1aca:	1c 8e       	std	Y+28, r1	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_OpenRequestedFile;
    1acc:	1d 8e       	std	Y+29, r1	; 0x1d
		AppState->HTTPServer.FileOpen      = false;
    1ace:	fe 01       	movw	r30, r28
    1ad0:	e6 59       	subi	r30, 0x96	; 150
    1ad2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ad4:	10 82       	st	Z, r1
		AppState->HTTPServer.ACKedFilePos  = 0;
    1ad6:	31 96       	adiw	r30, 0x01	; 1
    1ad8:	10 82       	st	Z, r1
    1ada:	11 82       	std	Z+1, r1	; 0x01
    1adc:	12 82       	std	Z+2, r1	; 0x02
    1ade:	13 82       	std	Z+3, r1	; 0x03
		AppState->HTTPServer.SentChunkSize = 0;
    1ae0:	34 96       	adiw	r30, 0x04	; 4
    1ae2:	11 82       	std	Z+1, r1	; 0x01
    1ae4:	10 82       	st	Z, r1
	}

	if (uip_acked())
    1ae6:	80 ff       	sbrs	r24, 0
    1ae8:	16 c0       	rjmp	.+44     	; 0x1b16 <HTTPServerApp_Callback+0x82>
	{
		/* Add the amount of ACKed file data to the total sent file bytes counter */
		AppState->HTTPServer.ACKedFilePos += AppState->HTTPServer.SentChunkSize;
    1aea:	fe 01       	movw	r30, r28
    1aec:	e5 59       	subi	r30, 0x95	; 149
    1aee:	ff 4f       	sbci	r31, 0xFF	; 255
    1af0:	de 01       	movw	r26, r28
    1af2:	a1 59       	subi	r26, 0x91	; 145
    1af4:	bf 4f       	sbci	r27, 0xFF	; 255
    1af6:	2d 91       	ld	r18, X+
    1af8:	3c 91       	ld	r19, X
    1afa:	40 81       	ld	r20, Z
    1afc:	51 81       	ldd	r21, Z+1	; 0x01
    1afe:	62 81       	ldd	r22, Z+2	; 0x02
    1b00:	73 81       	ldd	r23, Z+3	; 0x03
    1b02:	42 0f       	add	r20, r18
    1b04:	53 1f       	adc	r21, r19
    1b06:	61 1d       	adc	r22, r1
    1b08:	71 1d       	adc	r23, r1
    1b0a:	40 83       	st	Z, r20
    1b0c:	51 83       	std	Z+1, r21	; 0x01
    1b0e:	62 83       	std	Z+2, r22	; 0x02
    1b10:	73 83       	std	Z+3, r23	; 0x03

		/* Progress to the next state once the current state's data has been ACKed */
		AppState->HTTPServer.CurrentState = AppState->HTTPServer.NextState;
    1b12:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1b14:	9c 8f       	std	Y+28, r25	; 0x1c
	}

	if (uip_rexmit())
    1b16:	82 ff       	sbrs	r24, 2
    1b18:	0c c0       	rjmp	.+24     	; 0x1b32 <HTTPServerApp_Callback+0x9e>
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
    1b1a:	fe 01       	movw	r30, r28
    1b1c:	e5 59       	subi	r30, 0x95	; 149
    1b1e:	ff 4f       	sbci	r31, 0xFF	; 255
    1b20:	40 81       	ld	r20, Z
    1b22:	51 81       	ldd	r21, Z+1	; 0x01
    1b24:	62 81       	ldd	r22, Z+2	; 0x02
    1b26:	73 81       	ldd	r23, Z+3	; 0x03
    1b28:	ce 01       	movw	r24, r28
    1b2a:	80 5b       	subi	r24, 0xB0	; 176
    1b2c:	9f 4f       	sbci	r25, 0xFF	; 255
    1b2e:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <f_lseek>
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1b32:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <uip_flags>
    1b36:	89 2f       	mov	r24, r25
    1b38:	8f 74       	andi	r24, 0x4F	; 79
    1b3a:	09 f4       	brne	.+2      	; 0x1b3e <HTTPServerApp_Callback+0xaa>
    1b3c:	22 c1       	rjmp	.+580    	; 0x1d82 <HTTPServerApp_Callback+0x2ee>
	{
		switch (AppState->HTTPServer.CurrentState)
    1b3e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1b40:	81 30       	cpi	r24, 0x01	; 1
    1b42:	09 f4       	brne	.+2      	; 0x1b46 <HTTPServerApp_Callback+0xb2>
    1b44:	71 c0       	rjmp	.+226    	; 0x1c28 <HTTPServerApp_Callback+0x194>
    1b46:	a0 f0       	brcs	.+40     	; 0x1b70 <HTTPServerApp_Callback+0xdc>
    1b48:	82 30       	cpi	r24, 0x02	; 2
    1b4a:	09 f4       	brne	.+2      	; 0x1b4e <HTTPServerApp_Callback+0xba>
    1b4c:	f4 c0       	rjmp	.+488    	; 0x1d36 <HTTPServerApp_Callback+0x2a2>
    1b4e:	83 30       	cpi	r24, 0x03	; 3
    1b50:	09 f0       	breq	.+2      	; 0x1b54 <HTTPServerApp_Callback+0xc0>
    1b52:	17 c1       	rjmp	.+558    	; 0x1d82 <HTTPServerApp_Callback+0x2ee>
			case WEBSERVER_STATE_SendData:
				HTTPServerApp_SendData();
				break;
			case WEBSERVER_STATE_Closing:
				/* Connection is being terminated for some reason - close file handle */
				f_close(&AppState->HTTPServer.FileHandle);
    1b54:	ce 01       	movw	r24, r28
    1b56:	80 5b       	subi	r24, 0xB0	; 176
    1b58:	9f 4f       	sbci	r25, 0xFF	; 255
    1b5a:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <f_close>
				AppState->HTTPServer.FileOpen = false;
    1b5e:	fe 01       	movw	r30, r28
    1b60:	e6 59       	subi	r30, 0x96	; 150
    1b62:	ff 4f       	sbci	r31, 0xFF	; 255
    1b64:	10 82       	st	Z, r1

				/* If connection is not already closed, close it */
				uip_close();
    1b66:	80 e1       	ldi	r24, 0x10	; 16
    1b68:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>

				AppState->HTTPServer.CurrentState = WEBSERVER_STATE_Closed;
    1b6c:	84 e0       	ldi	r24, 0x04	; 4
    1b6e:	07 c1       	rjmp	.+526    	; 0x1d7e <HTTPServerApp_Callback+0x2ea>
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
	char*               const AppData     = (char*)uip_appdata;

	/* No HTTP header received from the client, abort processing */
	if (!(uip_newdata()))
    1b70:	91 ff       	sbrs	r25, 1
    1b72:	07 c1       	rjmp	.+526    	; 0x1d82 <HTTPServerApp_Callback+0x2ee>
/** HTTP Server State handler for the Request Process state. This state manages the processing of incoming HTTP
 *  GET requests to the server from the receiving HTTP client.
 */
static void HTTPServerApp_OpenRequestedFile(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1b74:	c0 91 13 06 	lds	r28, 0x0613	; 0x800613 <uip_conn>
    1b78:	d0 91 14 06 	lds	r29, 0x0614	; 0x800614 <uip_conn+0x1>

	/* No HTTP header received from the client, abort processing */
	if (!(uip_newdata()))
	  return;

	char* RequestToken      = strtok(AppData, " ");
    1b7c:	67 e8       	ldi	r22, 0x87	; 135
    1b7e:	72 e0       	ldi	r23, 0x02	; 2
    1b80:	80 91 11 06 	lds	r24, 0x0611	; 0x800611 <uip_appdata>
    1b84:	90 91 12 06 	lds	r25, 0x0612	; 0x800612 <uip_appdata+0x1>
    1b88:	0e 94 29 3a 	call	0x7452	; 0x7452 <strtok>
    1b8c:	8c 01       	movw	r16, r24
	char* RequestedFileName = strtok(NULL, " ");
    1b8e:	67 e8       	ldi	r22, 0x87	; 135
    1b90:	72 e0       	ldi	r23, 0x02	; 2
    1b92:	80 e0       	ldi	r24, 0x00	; 0
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	0e 94 29 3a 	call	0x7452	; 0x7452 <strtok>
    1b9a:	7c 01       	movw	r14, r24

	/* Must be a GET request, abort otherwise */
	if (strcmp_P(RequestToken, PSTR("GET")) != 0)
    1b9c:	62 e8       	ldi	r22, 0x82	; 130
    1b9e:	71 e0       	ldi	r23, 0x01	; 1
    1ba0:	c8 01       	movw	r24, r16
    1ba2:	0e 94 05 3a 	call	0x740a	; 0x740a <strcmp_P>
    1ba6:	89 2b       	or	r24, r25
    1ba8:	21 f0       	breq	.+8      	; 0x1bb2 <HTTPServerApp_Callback+0x11e>
	{
		uip_abort();
    1baa:	80 e2       	ldi	r24, 0x20	; 32
    1bac:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    1bb0:	e8 c0       	rjmp	.+464    	; 0x1d82 <HTTPServerApp_Callback+0x2ee>
		return;
	}

	/* Copy over the requested filename */
	strlcpy(AppState->HTTPServer.FileName, &RequestedFileName[1], sizeof(AppState->HTTPServer.FileName));
    1bb2:	8e 01       	movw	r16, r28
    1bb4:	02 5e       	subi	r16, 0xE2	; 226
    1bb6:	1f 4f       	sbci	r17, 0xFF	; 255
    1bb8:	b7 01       	movw	r22, r14
    1bba:	6f 5f       	subi	r22, 0xFF	; 255
    1bbc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bbe:	42 e3       	ldi	r20, 0x32	; 50
    1bc0:	50 e0       	ldi	r21, 0x00	; 0
    1bc2:	c8 01       	movw	r24, r16
    1bc4:	0e 94 57 3a 	call	0x74ae	; 0x74ae <strlcpy>

	/* Determine the length of the URI so that it can be checked to see if it is a directory */
	uint8_t FileNameLen = strlen(AppState->HTTPServer.FileName);
    1bc8:	f8 01       	movw	r30, r16
    1bca:	01 90       	ld	r0, Z+
    1bcc:	00 20       	and	r0, r0
    1bce:	e9 f7       	brne	.-6      	; 0x1bca <HTTPServerApp_Callback+0x136>
    1bd0:	31 97       	sbiw	r30, 0x01	; 1
    1bd2:	cf 01       	movw	r24, r30
    1bd4:	80 1b       	sub	r24, r16
    1bd6:	91 0b       	sbc	r25, r17
    1bd8:	28 2f       	mov	r18, r24
    1bda:	99 27       	eor	r25, r25

	/* If the URI is a directory, append the default filename */
	if ((AppState->HTTPServer.FileName[FileNameLen - 1] == '/') || !(FileNameLen))
    1bdc:	fe 01       	movw	r30, r28
    1bde:	e8 0f       	add	r30, r24
    1be0:	f9 1f       	adc	r31, r25
    1be2:	35 8d       	ldd	r19, Z+29	; 0x1d
    1be4:	ae 01       	movw	r20, r28
    1be6:	44 5e       	subi	r20, 0xE4	; 228
    1be8:	5f 4f       	sbci	r21, 0xFF	; 255
    1bea:	7a 01       	movw	r14, r20
    1bec:	3f 32       	cpi	r19, 0x2F	; 47
    1bee:	11 f0       	breq	.+4      	; 0x1bf4 <HTTPServerApp_Callback+0x160>
    1bf0:	21 11       	cpse	r18, r1
    1bf2:	0b c0       	rjmp	.+22     	; 0x1c0a <HTTPServerApp_Callback+0x176>
	{
		strlcpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
    1bf4:	42 e3       	ldi	r20, 0x32	; 50
    1bf6:	50 e0       	ldi	r21, 0x00	; 0
    1bf8:	48 1b       	sub	r20, r24
    1bfa:	59 0b       	sbc	r21, r25
    1bfc:	02 96       	adiw	r24, 0x02	; 2
    1bfe:	61 e9       	ldi	r22, 0x91	; 145
    1c00:	71 e0       	ldi	r23, 0x01	; 1
    1c02:	8e 0d       	add	r24, r14
    1c04:	9f 1d       	adc	r25, r15
    1c06:	0e 94 15 3a 	call	0x742a	; 0x742a <strlcpy_P>
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    1c0a:	41 e0       	ldi	r20, 0x01	; 1
    1c0c:	b8 01       	movw	r22, r16
    1c0e:	c7 01       	movw	r24, r14
    1c10:	c4 96       	adiw	r24, 0x34	; 52
    1c12:	0e 94 d9 1d 	call	0x3bb2	; 0x3bb2 <f_open>
    1c16:	fe 01       	movw	r30, r28
    1c18:	e6 59       	subi	r30, 0x96	; 150
    1c1a:	ff 4f       	sbci	r31, 0xFF	; 255
    1c1c:	91 e0       	ldi	r25, 0x01	; 1
    1c1e:	81 11       	cpse	r24, r1
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	90 83       	st	Z, r25
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);

	/* Lock to the SendResponseHeader state until connection terminated */
	AppState->HTTPServer.CurrentState = WEBSERVER_STATE_SendResponseHeader;
    1c24:	81 e0       	ldi	r24, 0x01	; 1
    1c26:	ab c0       	rjmp	.+342    	; 0x1d7e <HTTPServerApp_Callback+0x2ea>
/** HTTP Server State handler for the HTTP Response Header Send state. This state manages the transmission of
 *  the HTTP response header to the receiving HTTP client.
 */
static void HTTPServerApp_SendResponseHeader(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1c28:	e0 90 13 06 	lds	r14, 0x0613	; 0x800613 <uip_conn>
    1c2c:	f0 90 14 06 	lds	r15, 0x0614	; 0x800614 <uip_conn+0x1>
	char*               const AppData     = (char*)uip_appdata;
    1c30:	c0 91 11 06 	lds	r28, 0x0611	; 0x800611 <uip_appdata>
    1c34:	d0 91 12 06 	lds	r29, 0x0612	; 0x800612 <uip_appdata+0x1>

	char* Extension     = strpbrk(AppState->HTTPServer.FileName, ".");
    1c38:	87 01       	movw	r16, r14
    1c3a:	02 5e       	subi	r16, 0xE2	; 226
    1c3c:	1f 4f       	sbci	r17, 0xFF	; 255
    1c3e:	6e e2       	ldi	r22, 0x2E	; 46
    1c40:	70 e0       	ldi	r23, 0x00	; 0
    1c42:	c8 01       	movw	r24, r16
    1c44:	0e 94 3c 3a 	call	0x7478	; 0x7478 <strchr>
    1c48:	6c 01       	movw	r12, r24
	bool  FoundMIMEType = false;

	/* If the file isn't already open, it wasn't found - send back a 404 error response and abort */
	if (!(AppState->HTTPServer.FileOpen))
    1c4a:	f7 01       	movw	r30, r14
    1c4c:	e6 59       	subi	r30, 0x96	; 150
    1c4e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c50:	80 81       	ld	r24, Z
    1c52:	81 11       	cpse	r24, r1
    1c54:	1b c0       	rjmp	.+54     	; 0x1c8c <HTTPServerApp_Callback+0x1f8>
	{
		/* Copy over the HTTP 404 response header and send it to the receiving client */
		strcpy_P(AppData, HTTP404Header);
    1c56:	6b e9       	ldi	r22, 0x9B	; 155
    1c58:	71 e0       	ldi	r23, 0x01	; 1
    1c5a:	ce 01       	movw	r24, r28
    1c5c:	0e 94 0e 3a 	call	0x741c	; 0x741c <strcpy_P>
		strcpy(&AppData[strlen(AppData)], AppState->HTTPServer.FileName);
    1c60:	fe 01       	movw	r30, r28
    1c62:	01 90       	ld	r0, Z+
    1c64:	00 20       	and	r0, r0
    1c66:	e9 f7       	brne	.-6      	; 0x1c62 <HTTPServerApp_Callback+0x1ce>
    1c68:	cf 01       	movw	r24, r30
    1c6a:	b8 01       	movw	r22, r16
    1c6c:	01 97       	sbiw	r24, 0x01	; 1
    1c6e:	0e 94 50 3a 	call	0x74a0	; 0x74a0 <strcpy>
		uip_send(AppData, strlen(AppData));
    1c72:	fe 01       	movw	r30, r28
    1c74:	01 90       	ld	r0, Z+
    1c76:	00 20       	and	r0, r0
    1c78:	e9 f7       	brne	.-6      	; 0x1c74 <HTTPServerApp_Callback+0x1e0>
    1c7a:	31 97       	sbiw	r30, 0x01	; 1
    1c7c:	bf 01       	movw	r22, r30
    1c7e:	6c 1b       	sub	r22, r28
    1c80:	7d 0b       	sbc	r23, r29
    1c82:	ce 01       	movw	r24, r28
    1c84:	0e 94 23 18 	call	0x3046	; 0x3046 <uip_send>

		AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1c88:	83 e0       	ldi	r24, 0x03	; 3
    1c8a:	53 c0       	rjmp	.+166    	; 0x1d32 <HTTPServerApp_Callback+0x29e>
		return;
	}

	/* Copy over the HTTP 200 response header and send it to the receiving client */
	strcpy_P(AppData, HTTP200Header);
    1c8c:	67 e2       	ldi	r22, 0x27	; 39
    1c8e:	72 e0       	ldi	r23, 0x02	; 2
    1c90:	ce 01       	movw	r24, r28
    1c92:	0e 94 0e 3a 	call	0x741c	; 0x741c <strcpy_P>

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
    1c96:	c1 14       	cp	r12, r1
    1c98:	d1 04       	cpc	r13, r1
    1c9a:	59 f1       	breq	.+86     	; 0x1cf2 <HTTPServerApp_Callback+0x25e>
    1c9c:	36 e2       	ldi	r19, 0x26	; 38
    1c9e:	a3 2e       	mov	r10, r19
    1ca0:	32 e0       	ldi	r19, 0x02	; 2
    1ca2:	b3 2e       	mov	r11, r19
    1ca4:	00 e0       	ldi	r16, 0x00	; 0
    1ca6:	10 e0       	ldi	r17, 0x00	; 0
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
		{
			if (strcmp(&Extension[1], MIMETypes[i].Extension) == 0)
    1ca8:	ff ef       	ldi	r31, 0xFF	; 255
    1caa:	cf 1a       	sub	r12, r31
    1cac:	df 0a       	sbc	r13, r31
    1cae:	f5 01       	movw	r30, r10
    1cb0:	60 81       	ld	r22, Z
    1cb2:	71 81       	ldd	r23, Z+1	; 0x01
    1cb4:	c6 01       	movw	r24, r12
    1cb6:	0e 94 47 3a 	call	0x748e	; 0x748e <strcmp>
    1cba:	89 2b       	or	r24, r25
    1cbc:	91 f4       	brne	.+36     	; 0x1ce2 <HTTPServerApp_Callback+0x24e>
			{
				strcpy(&AppData[strlen(AppData)], MIMETypes[i].MIMEType);
    1cbe:	fe 01       	movw	r30, r28
    1cc0:	01 90       	ld	r0, Z+
    1cc2:	00 20       	and	r0, r0
    1cc4:	e9 f7       	brne	.-6      	; 0x1cc0 <HTTPServerApp_Callback+0x22c>
    1cc6:	cf 01       	movw	r24, r30
    1cc8:	00 0f       	add	r16, r16
    1cca:	11 1f       	adc	r17, r17
    1ccc:	00 0f       	add	r16, r16
    1cce:	11 1f       	adc	r17, r17
    1cd0:	f8 01       	movw	r30, r16
    1cd2:	ea 5d       	subi	r30, 0xDA	; 218
    1cd4:	fd 4f       	sbci	r31, 0xFD	; 253
    1cd6:	62 81       	ldd	r22, Z+2	; 0x02
    1cd8:	73 81       	ldd	r23, Z+3	; 0x03
    1cda:	01 97       	sbiw	r24, 0x01	; 1
    1cdc:	0e 94 50 3a 	call	0x74a0	; 0x74a0 <strcpy>
    1ce0:	12 c0       	rjmp	.+36     	; 0x1d06 <HTTPServerApp_Callback+0x272>
    1ce2:	0f 5f       	subi	r16, 0xFF	; 255
    1ce4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ce6:	f4 e0       	ldi	r31, 0x04	; 4
    1ce8:	af 0e       	add	r10, r31
    1cea:	b1 1c       	adc	r11, r1

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
    1cec:	0a 30       	cpi	r16, 0x0A	; 10
    1cee:	11 05       	cpc	r17, r1
    1cf0:	f1 f6       	brne	.-68     	; 0x1cae <HTTPServerApp_Callback+0x21a>

	/* Check if a MIME type was found and copied to the output buffer */
	if (!(FoundMIMEType))
	{
		/* MIME type not found - copy over the default MIME type */
		strcpy_P(&AppData[strlen(AppData)], DefaultMIMEType);
    1cf2:	fe 01       	movw	r30, r28
    1cf4:	01 90       	ld	r0, Z+
    1cf6:	00 20       	and	r0, r0
    1cf8:	e9 f7       	brne	.-6      	; 0x1cf4 <HTTPServerApp_Callback+0x260>
    1cfa:	cf 01       	movw	r24, r30
    1cfc:	66 e8       	ldi	r22, 0x86	; 134
    1cfe:	71 e0       	ldi	r23, 0x01	; 1
    1d00:	01 97       	sbiw	r24, 0x01	; 1
    1d02:	0e 94 0e 3a 	call	0x741c	; 0x741c <strcpy_P>
	}

	/* Add the end-of-line terminator and end-of-headers terminator after the MIME type */
	strcpy_P(&AppData[strlen(AppData)], PSTR("\r\n\r\n"));
    1d06:	fe 01       	movw	r30, r28
    1d08:	01 90       	ld	r0, Z+
    1d0a:	00 20       	and	r0, r0
    1d0c:	e9 f7       	brne	.-6      	; 0x1d08 <HTTPServerApp_Callback+0x274>
    1d0e:	cf 01       	movw	r24, r30
    1d10:	6d e7       	ldi	r22, 0x7D	; 125
    1d12:	71 e0       	ldi	r23, 0x01	; 1
    1d14:	01 97       	sbiw	r24, 0x01	; 1
    1d16:	0e 94 0e 3a 	call	0x741c	; 0x741c <strcpy_P>

	/* Send the MIME header to the receiving client */
	uip_send(AppData, strlen(AppData));
    1d1a:	fe 01       	movw	r30, r28
    1d1c:	01 90       	ld	r0, Z+
    1d1e:	00 20       	and	r0, r0
    1d20:	e9 f7       	brne	.-6      	; 0x1d1c <HTTPServerApp_Callback+0x288>
    1d22:	31 97       	sbiw	r30, 0x01	; 1
    1d24:	bf 01       	movw	r22, r30
    1d26:	6c 1b       	sub	r22, r28
    1d28:	7d 0b       	sbc	r23, r29
    1d2a:	ce 01       	movw	r24, r28
    1d2c:	0e 94 23 18 	call	0x3046	; 0x3046 <uip_send>

	/* When the MIME header is ACKed, progress to the data send stage */
	AppState->HTTPServer.NextState = WEBSERVER_STATE_SendData;
    1d30:	82 e0       	ldi	r24, 0x02	; 2
    1d32:	f7 01       	movw	r30, r14
    1d34:	22 c0       	rjmp	.+68     	; 0x1d7a <HTTPServerApp_Callback+0x2e6>
/** HTTP Server State handler for the Data Send state. This state manages the transmission of file chunks
 *  to the receiving HTTP client.
 */
static void HTTPServerApp_SendData(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1d36:	00 91 13 06 	lds	r16, 0x0613	; 0x800613 <uip_conn>
    1d3a:	10 91 14 06 	lds	r17, 0x0614	; 0x800614 <uip_conn+0x1>
	char*               const AppData     = (char*)uip_appdata;
    1d3e:	c0 90 11 06 	lds	r12, 0x0611	; 0x800611 <uip_appdata>
    1d42:	d0 90 12 06 	lds	r13, 0x0612	; 0x800612 <uip_appdata+0x1>

	/* Get the maximum segment size for the current packet */
	uint16_t MaxChunkSize = uip_mss();
    1d46:	f8 01       	movw	r30, r16
    1d48:	e2 88       	ldd	r14, Z+18	; 0x12
    1d4a:	f3 88       	ldd	r15, Z+19	; 0x13

	/* Read the next chunk of data from the open file */
	f_read(&AppState->HTTPServer.FileHandle, AppData, MaxChunkSize, &AppState->HTTPServer.SentChunkSize);
    1d4c:	e8 01       	movw	r28, r16
    1d4e:	c1 59       	subi	r28, 0x91	; 145
    1d50:	df 4f       	sbci	r29, 0xFF	; 255
    1d52:	9e 01       	movw	r18, r28
    1d54:	a7 01       	movw	r20, r14
    1d56:	b6 01       	movw	r22, r12
    1d58:	c8 01       	movw	r24, r16
    1d5a:	80 5b       	subi	r24, 0xB0	; 176
    1d5c:	9f 4f       	sbci	r25, 0xFF	; 255
    1d5e:	0e 94 c5 21 	call	0x438a	; 0x438a <f_read>

	/* Send the next file chunk to the receiving client */
	uip_send(AppData, AppState->HTTPServer.SentChunkSize);
    1d62:	68 81       	ld	r22, Y
    1d64:	79 81       	ldd	r23, Y+1	; 0x01
    1d66:	c6 01       	movw	r24, r12
    1d68:	0e 94 23 18 	call	0x3046	; 0x3046 <uip_send>

	/* Check if we are at the last chunk of the file, if so next ACK should close the connection */
	if (MaxChunkSize != AppState->HTTPServer.SentChunkSize)
    1d6c:	88 81       	ld	r24, Y
    1d6e:	99 81       	ldd	r25, Y+1	; 0x01
    1d70:	e8 16       	cp	r14, r24
    1d72:	f9 06       	cpc	r15, r25
    1d74:	31 f0       	breq	.+12     	; 0x1d82 <HTTPServerApp_Callback+0x2ee>
	  AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1d76:	83 e0       	ldi	r24, 0x03	; 3
    1d78:	f8 01       	movw	r30, r16
    1d7a:	85 8f       	std	Z+29, r24	; 0x1d
    1d7c:	02 c0       	rjmp	.+4      	; 0x1d82 <HTTPServerApp_Callback+0x2ee>
				AppState->HTTPServer.FileOpen = false;

				/* If connection is not already closed, close it */
				uip_close();

				AppState->HTTPServer.CurrentState = WEBSERVER_STATE_Closed;
    1d7e:	8c 8f       	std	Y+28, r24	; 0x1c
				AppState->HTTPServer.NextState    = WEBSERVER_STATE_Closed;
    1d80:	8d 8f       	std	Y+29, r24	; 0x1d
				break;
		}
	}
}
    1d82:	df 91       	pop	r29
    1d84:	cf 91       	pop	r28
    1d86:	1f 91       	pop	r17
    1d88:	0f 91       	pop	r16
    1d8a:	ff 90       	pop	r15
    1d8c:	ef 90       	pop	r14
    1d8e:	df 90       	pop	r13
    1d90:	cf 90       	pop	r12
    1d92:	bf 90       	pop	r11
    1d94:	af 90       	pop	r10
    1d96:	08 95       	ret

00001d98 <TELNETServerApp_Init>:

/** Initialization function for the simple TELNET webserver. */
void TELNETServerApp_Init(void)
{
	/* Listen on port 23 for TELNET connections from hosts */
	uip_listen(HTONS(TELNET_SERVER_PORT));
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	97 e1       	ldi	r25, 0x17	; 23
    1d9c:	e5 c1       	rjmp	.+970    	; 0x2168 <uip_listen>

00001d9e <TELNETServerApp_Callback>:

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
{
    1d9e:	9f 92       	push	r9
    1da0:	af 92       	push	r10
    1da2:	bf 92       	push	r11
    1da4:	cf 92       	push	r12
    1da6:	df 92       	push	r13
    1da8:	ef 92       	push	r14
    1daa:	ff 92       	push	r15
    1dac:	0f 93       	push	r16
    1dae:	1f 93       	push	r17
    1db0:	cf 93       	push	r28
    1db2:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState   = &uip_conn->appstate;
    1db4:	00 91 13 06 	lds	r16, 0x0613	; 0x800613 <uip_conn>
    1db8:	10 91 14 06 	lds	r17, 0x0614	; 0x800614 <uip_conn+0x1>
	char*               const AppData    = (char*)uip_appdata;
    1dbc:	c0 91 11 06 	lds	r28, 0x0611	; 0x800611 <uip_appdata>
    1dc0:	d0 91 12 06 	lds	r29, 0x0612	; 0x800612 <uip_appdata+0x1>

	if (uip_connected())
    1dc4:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    1dc8:	86 ff       	sbrs	r24, 6
    1dca:	02 c0       	rjmp	.+4      	; 0x1dd0 <TELNETServerApp_Callback+0x32>
	{
		/* New connection - initialize connection state values */
		AppState->TELNETServer.CurrentState = TELNET_STATE_SendHeader;
    1dcc:	f8 01       	movw	r30, r16
    1dce:	14 8e       	std	Z+28, r1	; 0x1c
	}

	if (uip_acked())
    1dd0:	80 ff       	sbrs	r24, 0
    1dd2:	03 c0       	rjmp	.+6      	; 0x1dda <TELNETServerApp_Callback+0x3c>
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
    1dd4:	f8 01       	movw	r30, r16
    1dd6:	95 8d       	ldd	r25, Z+29	; 0x1d
    1dd8:	94 8f       	std	Z+28, r25	; 0x1c
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1dda:	8f 74       	andi	r24, 0x4F	; 79
    1ddc:	09 f4       	brne	.+2      	; 0x1de0 <TELNETServerApp_Callback+0x42>
    1dde:	98 c0       	rjmp	.+304    	; 0x1f10 <TELNETServerApp_Callback+0x172>
	{
		switch (AppState->TELNETServer.CurrentState)
    1de0:	f8 01       	movw	r30, r16
    1de2:	84 8d       	ldd	r24, Z+28	; 0x1c
    1de4:	81 30       	cpi	r24, 0x01	; 1
    1de6:	49 f0       	breq	.+18     	; 0x1dfa <TELNETServerApp_Callback+0x5c>
    1de8:	28 f0       	brcs	.+10     	; 0x1df4 <TELNETServerApp_Callback+0x56>
    1dea:	82 30       	cpi	r24, 0x02	; 2
    1dec:	c1 f0       	breq	.+48     	; 0x1e1e <TELNETServerApp_Callback+0x80>
    1dee:	83 30       	cpi	r24, 0x03	; 3
    1df0:	19 f1       	breq	.+70     	; 0x1e38 <TELNETServerApp_Callback+0x9a>
    1df2:	8e c0       	rjmp	.+284    	; 0x1f10 <TELNETServerApp_Callback+0x172>
		{
			case TELNET_STATE_SendHeader:
				/* Copy over and send the TELNET welcome message upon first connection */
				strcpy_P(AppData, WelcomeHeader);
    1df4:	60 e5       	ldi	r22, 0x50	; 80
    1df6:	73 e0       	ldi	r23, 0x03	; 3
    1df8:	7a c0       	rjmp	.+244    	; 0x1eee <TELNETServerApp_Callback+0x150>

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
				break;
			case TELNET_STATE_SendMenu:
				/* Copy over and send the TELNET menu to the client */
				strcpy_P(AppData, TELNETMenu);
    1dfa:	6b ee       	ldi	r22, 0xEB	; 235
    1dfc:	72 e0       	ldi	r23, 0x02	; 2
    1dfe:	ce 01       	movw	r24, r28
    1e00:	0e 94 0e 3a 	call	0x741c	; 0x741c <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1e04:	fe 01       	movw	r30, r28
    1e06:	01 90       	ld	r0, Z+
    1e08:	00 20       	and	r0, r0
    1e0a:	e9 f7       	brne	.-6      	; 0x1e06 <TELNETServerApp_Callback+0x68>
    1e0c:	31 97       	sbiw	r30, 0x01	; 1
    1e0e:	bf 01       	movw	r22, r30
    1e10:	6c 1b       	sub	r22, r28
    1e12:	7d 0b       	sbc	r23, r29
    1e14:	ce 01       	movw	r24, r28
    1e16:	0e 94 23 18 	call	0x3046	; 0x3046 <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_GetCommand;
    1e1a:	82 e0       	ldi	r24, 0x02	; 2
    1e1c:	77 c0       	rjmp	.+238    	; 0x1f0c <TELNETServerApp_Callback+0x16e>
				break;
			case TELNET_STATE_GetCommand:
				if (!(uip_datalen()))
    1e1e:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    1e22:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    1e26:	89 2b       	or	r24, r25
    1e28:	09 f4       	brne	.+2      	; 0x1e2c <TELNETServerApp_Callback+0x8e>
    1e2a:	72 c0       	rjmp	.+228    	; 0x1f10 <TELNETServerApp_Callback+0x172>
				  break;

				/* Save the issued command for later processing */
				AppState->TELNETServer.IssuedCommand = AppData[0];
    1e2c:	88 81       	ld	r24, Y
    1e2e:	f8 01       	movw	r30, r16
    1e30:	86 8f       	std	Z+30, r24	; 0x1e

				AppState->TELNETServer.CurrentState  = TELNET_STATE_SendResponse;
    1e32:	83 e0       	ldi	r24, 0x03	; 3
    1e34:	84 8f       	std	Z+28, r24	; 0x1c
				break;
    1e36:	6c c0       	rjmp	.+216    	; 0x1f10 <TELNETServerApp_Callback+0x172>
			case TELNET_STATE_SendResponse:
				/* Determine which command was issued, perform command processing */
				switch (AppState->TELNETServer.IssuedCommand)
    1e38:	f8 01       	movw	r30, r16
    1e3a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e3c:	83 36       	cpi	r24, 0x63	; 99
    1e3e:	09 f0       	breq	.+2      	; 0x1e42 <TELNETServerApp_Callback+0xa4>
    1e40:	54 c0       	rjmp	.+168    	; 0x1eea <TELNETServerApp_Callback+0x14c>
/** Sends a list of active TCP connections to the TELNET client. */
static void TELNETServerApp_DisplayTCPConnections(void)
{
	char* const AppData    = (char*)uip_appdata;

	strcpy_P(AppData, CurrentConnectionsHeader);
    1e42:	6a ec       	ldi	r22, 0xCA	; 202
    1e44:	72 e0       	ldi	r23, 0x02	; 2
    1e46:	ce 01       	movw	r24, r28
    1e48:	0e 94 0e 3a 	call	0x741c	; 0x741c <strcpy_P>

	uint16_t ResponseLen     = strlen(AppData);
    1e4c:	fe 01       	movw	r30, r28
    1e4e:	01 90       	ld	r0, Z+
    1e50:	00 20       	and	r0, r0
    1e52:	e9 f7       	brne	.-6      	; 0x1e4e <TELNETServerApp_Callback+0xb0>
    1e54:	31 97       	sbiw	r30, 0x01	; 1
    1e56:	6f 01       	movw	r12, r30
    1e58:	cc 1a       	sub	r12, r28
    1e5a:	dd 0a       	sbc	r13, r29
    1e5c:	85 e1       	ldi	r24, 0x15	; 21
    1e5e:	e8 2e       	mov	r14, r24
    1e60:	86 e0       	ldi	r24, 0x06	; 6
    1e62:	f8 2e       	mov	r15, r24
	uint8_t  ActiveConnCount = 0;
    1e64:	91 2c       	mov	r9, r1

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1e66:	92 e8       	ldi	r25, 0x82	; 130
    1e68:	a9 2e       	mov	r10, r25
    1e6a:	92 e0       	ldi	r25, 0x02	; 2
    1e6c:	b9 2e       	mov	r11, r25
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		struct uip_conn* CurrConnection = &uip_conns[i];

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
    1e6e:	f7 01       	movw	r30, r14
    1e70:	81 8d       	ldd	r24, Z+25	; 0x19
    1e72:	88 23       	and	r24, r24
    1e74:	81 f1       	breq	.+96     	; 0x1ed6 <TELNETServerApp_Callback+0x138>
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1e76:	93 94       	inc	r9
    1e78:	86 81       	ldd	r24, Z+6	; 0x06
    1e7a:	97 81       	ldd	r25, Z+7	; 0x07
    1e7c:	98 27       	eor	r25, r24
    1e7e:	89 27       	eor	r24, r25
    1e80:	98 27       	eor	r25, r24
    1e82:	9f 93       	push	r25
    1e84:	8f 93       	push	r24
    1e86:	84 81       	ldd	r24, Z+4	; 0x04
    1e88:	95 81       	ldd	r25, Z+5	; 0x05
    1e8a:	98 27       	eor	r25, r24
    1e8c:	89 27       	eor	r24, r25
    1e8e:	98 27       	eor	r25, r24
    1e90:	9f 93       	push	r25
    1e92:	8f 93       	push	r24
    1e94:	83 81       	ldd	r24, Z+3	; 0x03
    1e96:	1f 92       	push	r1
    1e98:	8f 93       	push	r24
    1e9a:	82 81       	ldd	r24, Z+2	; 0x02
    1e9c:	1f 92       	push	r1
    1e9e:	8f 93       	push	r24
    1ea0:	81 81       	ldd	r24, Z+1	; 0x01
    1ea2:	1f 92       	push	r1
    1ea4:	8f 93       	push	r24
    1ea6:	80 81       	ld	r24, Z
    1ea8:	1f 92       	push	r1
    1eaa:	8f 93       	push	r24
    1eac:	1f 92       	push	r1
    1eae:	9f 92       	push	r9
    1eb0:	bf 92       	push	r11
    1eb2:	af 92       	push	r10
    1eb4:	ce 01       	movw	r24, r28
    1eb6:	8c 0d       	add	r24, r12
    1eb8:	9d 1d       	adc	r25, r13
    1eba:	9f 93       	push	r25
    1ebc:	8f 93       	push	r24
    1ebe:	0e 94 92 3a 	call	0x7524	; 0x7524 <sprintf_P>
    1ec2:	c8 0e       	add	r12, r24
    1ec4:	d9 1e       	adc	r13, r25
    1ec6:	8d b7       	in	r24, 0x3d	; 61
    1ec8:	9e b7       	in	r25, 0x3e	; 62
    1eca:	42 96       	adiw	r24, 0x12	; 18
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	9e bf       	out	0x3e, r25	; 62
    1ed2:	0f be       	out	0x3f, r0	; 63
    1ed4:	8d bf       	out	0x3d, r24	; 61
    1ed6:	91 e7       	ldi	r25, 0x71	; 113
    1ed8:	e9 0e       	add	r14, r25
    1eda:	f1 1c       	adc	r15, r1

	uint16_t ResponseLen     = strlen(AppData);
	uint8_t  ActiveConnCount = 0;

	/* Loop through the complete uIP TCP connections list, looking for active connections */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    1edc:	e8 e6       	ldi	r30, 0x68	; 104
    1ede:	ee 16       	cp	r14, r30
    1ee0:	e7 e0       	ldi	r30, 0x07	; 7
    1ee2:	fe 06       	cpc	r15, r30
    1ee4:	21 f6       	brne	.-120    	; 0x1e6e <TELNETServerApp_Callback+0xd0>
			                         CurrConnection->ripaddr.u8[3],
			                         HTONS(CurrConnection->lport), HTONS(CurrConnection->rport));
		}
	}

	uip_send(AppData, ResponseLen);
    1ee6:	b6 01       	movw	r22, r12
    1ee8:	0d c0       	rjmp	.+26     	; 0x1f04 <TELNETServerApp_Callback+0x166>
				{
					case 'c':
						TELNETServerApp_DisplayTCPConnections();
						break;
					default:
						strcpy_P(AppData, PSTR("Invalid Command.\r\n"));
    1eea:	67 eb       	ldi	r22, 0xB7	; 183
    1eec:	72 e0       	ldi	r23, 0x02	; 2
    1eee:	ce 01       	movw	r24, r28
    1ef0:	0e 94 0e 3a 	call	0x741c	; 0x741c <strcpy_P>
						uip_send(AppData, strlen(AppData));
    1ef4:	fe 01       	movw	r30, r28
    1ef6:	01 90       	ld	r0, Z+
    1ef8:	00 20       	and	r0, r0
    1efa:	e9 f7       	brne	.-6      	; 0x1ef6 <TELNETServerApp_Callback+0x158>
    1efc:	31 97       	sbiw	r30, 0x01	; 1
    1efe:	bf 01       	movw	r22, r30
    1f00:	6c 1b       	sub	r22, r28
    1f02:	7d 0b       	sbc	r23, r29
    1f04:	ce 01       	movw	r24, r28
    1f06:	0e 94 23 18 	call	0x3046	; 0x3046 <uip_send>
						break;
				}

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1f0a:	81 e0       	ldi	r24, 0x01	; 1
    1f0c:	f8 01       	movw	r30, r16
    1f0e:	85 8f       	std	Z+29, r24	; 0x1d
				break;
		}
	}
}
    1f10:	df 91       	pop	r29
    1f12:	cf 91       	pop	r28
    1f14:	1f 91       	pop	r17
    1f16:	0f 91       	pop	r16
    1f18:	ff 90       	pop	r15
    1f1a:	ef 90       	pop	r14
    1f1c:	df 90       	pop	r13
    1f1e:	cf 90       	pop	r12
    1f20:	bf 90       	pop	r11
    1f22:	af 90       	pop	r10
    1f24:	9f 90       	pop	r9
    1f26:	08 95       	ret

00001f28 <chksum>:

u32_t
htonl(u32_t val)
{
  return HTONL(val);
}
    1f28:	fb 01       	movw	r30, r22
    1f2a:	41 50       	subi	r20, 0x01	; 1
    1f2c:	51 09       	sbc	r21, r1
    1f2e:	46 0f       	add	r20, r22
    1f30:	57 1f       	adc	r21, r23
    1f32:	e4 17       	cp	r30, r20
    1f34:	f5 07       	cpc	r31, r21
    1f36:	78 f4       	brcc	.+30     	; 0x1f56 <chksum+0x2e>
    1f38:	20 81       	ld	r18, Z
    1f3a:	30 e0       	ldi	r19, 0x00	; 0
    1f3c:	32 2f       	mov	r19, r18
    1f3e:	22 27       	eor	r18, r18
    1f40:	61 81       	ldd	r22, Z+1	; 0x01
    1f42:	26 0f       	add	r18, r22
    1f44:	31 1d       	adc	r19, r1
    1f46:	82 0f       	add	r24, r18
    1f48:	93 1f       	adc	r25, r19
    1f4a:	82 17       	cp	r24, r18
    1f4c:	93 07       	cpc	r25, r19
    1f4e:	08 f4       	brcc	.+2      	; 0x1f52 <chksum+0x2a>
    1f50:	01 96       	adiw	r24, 0x01	; 1
    1f52:	32 96       	adiw	r30, 0x02	; 2
    1f54:	ee cf       	rjmp	.-36     	; 0x1f32 <chksum+0xa>
    1f56:	e4 17       	cp	r30, r20
    1f58:	f5 07       	cpc	r31, r21
    1f5a:	51 f4       	brne	.+20     	; 0x1f70 <chksum+0x48>
    1f5c:	20 81       	ld	r18, Z
    1f5e:	30 e0       	ldi	r19, 0x00	; 0
    1f60:	32 2f       	mov	r19, r18
    1f62:	22 27       	eor	r18, r18
    1f64:	82 0f       	add	r24, r18
    1f66:	93 1f       	adc	r25, r19
    1f68:	82 17       	cp	r24, r18
    1f6a:	93 07       	cpc	r25, r19
    1f6c:	08 f4       	brcc	.+2      	; 0x1f70 <chksum+0x48>
    1f6e:	01 96       	adiw	r24, 0x01	; 1
    1f70:	08 95       	ret

00001f72 <uip_add32>:
    1f72:	fc 01       	movw	r30, r24
    1f74:	23 81       	ldd	r18, Z+3	; 0x03
    1f76:	26 0f       	add	r18, r22
    1f78:	20 93 0d 06 	sts	0x060D, r18	; 0x80060d <uip_acc32+0x3>
    1f7c:	a7 2f       	mov	r26, r23
    1f7e:	bb 27       	eor	r27, r27
    1f80:	92 81       	ldd	r25, Z+2	; 0x02
    1f82:	9a 0f       	add	r25, r26
    1f84:	90 93 0c 06 	sts	0x060C, r25	; 0x80060c <uip_acc32+0x2>
    1f88:	31 81       	ldd	r19, Z+1	; 0x01
    1f8a:	30 93 0b 06 	sts	0x060B, r19	; 0x80060b <uip_acc32+0x1>
    1f8e:	40 81       	ld	r20, Z
    1f90:	40 93 0a 06 	sts	0x060A, r20	; 0x80060a <uip_acc32>
    1f94:	e9 2f       	mov	r30, r25
    1f96:	f0 e0       	ldi	r31, 0x00	; 0
    1f98:	ea 17       	cp	r30, r26
    1f9a:	fb 07       	cpc	r31, r27
    1f9c:	48 f4       	brcc	.+18     	; 0x1fb0 <uip_add32+0x3e>
    1f9e:	81 e0       	ldi	r24, 0x01	; 1
    1fa0:	83 0f       	add	r24, r19
    1fa2:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <uip_acc32+0x1>
    1fa6:	81 11       	cpse	r24, r1
    1fa8:	03 c0       	rjmp	.+6      	; 0x1fb0 <uip_add32+0x3e>
    1faa:	4f 5f       	subi	r20, 0xFF	; 255
    1fac:	40 93 0a 06 	sts	0x060A, r20	; 0x80060a <uip_acc32>
    1fb0:	30 e0       	ldi	r19, 0x00	; 0
    1fb2:	77 27       	eor	r23, r23
    1fb4:	26 17       	cp	r18, r22
    1fb6:	37 07       	cpc	r19, r23
    1fb8:	88 f4       	brcc	.+34     	; 0x1fdc <uip_add32+0x6a>
    1fba:	9f 5f       	subi	r25, 0xFF	; 255
    1fbc:	90 93 0c 06 	sts	0x060C, r25	; 0x80060c <uip_acc32+0x2>
    1fc0:	91 11       	cpse	r25, r1
    1fc2:	0c c0       	rjmp	.+24     	; 0x1fdc <uip_add32+0x6a>
    1fc4:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <uip_acc32+0x1>
    1fc8:	8f 5f       	subi	r24, 0xFF	; 255
    1fca:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <uip_acc32+0x1>
    1fce:	81 11       	cpse	r24, r1
    1fd0:	05 c0       	rjmp	.+10     	; 0x1fdc <uip_add32+0x6a>
    1fd2:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uip_acc32>
    1fd6:	8f 5f       	subi	r24, 0xFF	; 255
    1fd8:	80 93 0a 06 	sts	0x060A, r24	; 0x80060a <uip_acc32>
    1fdc:	08 95       	ret

00001fde <uip_add_rcv_nxt>:
    1fde:	20 91 13 06 	lds	r18, 0x0613	; 0x800613 <uip_conn>
    1fe2:	30 91 14 06 	lds	r19, 0x0614	; 0x800614 <uip_conn+0x1>
    1fe6:	bc 01       	movw	r22, r24
    1fe8:	c9 01       	movw	r24, r18
    1fea:	08 96       	adiw	r24, 0x08	; 8
    1fec:	c2 df       	rcall	.-124    	; 0x1f72 <uip_add32>
    1fee:	e0 91 13 06 	lds	r30, 0x0613	; 0x800613 <uip_conn>
    1ff2:	f0 91 14 06 	lds	r31, 0x0614	; 0x800614 <uip_conn+0x1>
    1ff6:	aa e0       	ldi	r26, 0x0A	; 10
    1ff8:	b6 e0       	ldi	r27, 0x06	; 6
    1ffa:	8c 91       	ld	r24, X
    1ffc:	80 87       	std	Z+8, r24	; 0x08
    1ffe:	11 96       	adiw	r26, 0x01	; 1
    2000:	8c 91       	ld	r24, X
    2002:	11 97       	sbiw	r26, 0x01	; 1
    2004:	81 87       	std	Z+9, r24	; 0x09
    2006:	12 96       	adiw	r26, 0x02	; 2
    2008:	8c 91       	ld	r24, X
    200a:	12 97       	sbiw	r26, 0x02	; 2
    200c:	82 87       	std	Z+10, r24	; 0x0a
    200e:	13 96       	adiw	r26, 0x03	; 3
    2010:	8c 91       	ld	r24, X
    2012:	83 87       	std	Z+11, r24	; 0x0b
    2014:	08 95       	ret

00002016 <uip_chksum>:
    2016:	ab 01       	movw	r20, r22
    2018:	bc 01       	movw	r22, r24
    201a:	80 e0       	ldi	r24, 0x00	; 0
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	84 df       	rcall	.-248    	; 0x1f28 <chksum>
    2020:	98 27       	eor	r25, r24
    2022:	89 27       	eor	r24, r25
    2024:	98 27       	eor	r25, r24
    2026:	08 95       	ret

00002028 <uip_ipchksum>:
    2028:	44 e1       	ldi	r20, 0x14	; 20
    202a:	50 e0       	ldi	r21, 0x00	; 0
    202c:	6c e8       	ldi	r22, 0x8C	; 140
    202e:	77 e0       	ldi	r23, 0x07	; 7
    2030:	80 e0       	ldi	r24, 0x00	; 0
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	79 df       	rcall	.-270    	; 0x1f28 <chksum>
    2036:	00 97       	sbiw	r24, 0x00	; 0
    2038:	21 f0       	breq	.+8      	; 0x2042 <uip_ipchksum+0x1a>
    203a:	98 27       	eor	r25, r24
    203c:	89 27       	eor	r24, r25
    203e:	98 27       	eor	r25, r24
    2040:	08 95       	ret
    2042:	8f ef       	ldi	r24, 0xFF	; 255
    2044:	9f ef       	ldi	r25, 0xFF	; 255
    2046:	08 95       	ret

00002048 <uip_tcpchksum>:
    2048:	cf 93       	push	r28
    204a:	df 93       	push	r29
    204c:	c0 91 8e 07 	lds	r28, 0x078E	; 0x80078e <uip_buf+0x10>
    2050:	d0 e0       	ldi	r29, 0x00	; 0
    2052:	dc 2f       	mov	r29, r28
    2054:	cc 27       	eor	r28, r28
    2056:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uip_buf+0x11>
    205a:	c8 0f       	add	r28, r24
    205c:	d1 1d       	adc	r29, r1
    205e:	48 e0       	ldi	r20, 0x08	; 8
    2060:	50 e0       	ldi	r21, 0x00	; 0
    2062:	68 e9       	ldi	r22, 0x98	; 152
    2064:	77 e0       	ldi	r23, 0x07	; 7
    2066:	ce 01       	movw	r24, r28
    2068:	0e 97       	sbiw	r24, 0x0e	; 14
    206a:	5e df       	rcall	.-324    	; 0x1f28 <chksum>
    206c:	ae 01       	movw	r20, r28
    206e:	44 51       	subi	r20, 0x14	; 20
    2070:	51 09       	sbc	r21, r1
    2072:	60 ea       	ldi	r22, 0xA0	; 160
    2074:	77 e0       	ldi	r23, 0x07	; 7
    2076:	58 df       	rcall	.-336    	; 0x1f28 <chksum>
    2078:	00 97       	sbiw	r24, 0x00	; 0
    207a:	21 f0       	breq	.+8      	; 0x2084 <uip_tcpchksum+0x3c>
    207c:	98 27       	eor	r25, r24
    207e:	89 27       	eor	r24, r25
    2080:	98 27       	eor	r25, r24
    2082:	02 c0       	rjmp	.+4      	; 0x2088 <uip_tcpchksum+0x40>
    2084:	8f ef       	ldi	r24, 0xFF	; 255
    2086:	9f ef       	ldi	r25, 0xFF	; 255
    2088:	df 91       	pop	r29
    208a:	cf 91       	pop	r28
    208c:	08 95       	ret

0000208e <uip_init>:
    208e:	80 e0       	ldi	r24, 0x00	; 0
    2090:	e8 2f       	mov	r30, r24
    2092:	f0 e0       	ldi	r31, 0x00	; 0
    2094:	ee 0f       	add	r30, r30
    2096:	ff 1f       	adc	r31, r31
    2098:	e8 59       	subi	r30, 0x98	; 152
    209a:	f8 4f       	sbci	r31, 0xF8	; 248
    209c:	11 82       	std	Z+1, r1	; 0x01
    209e:	10 82       	st	Z, r1
    20a0:	8f 5f       	subi	r24, 0xFF	; 255
    20a2:	85 30       	cpi	r24, 0x05	; 5
    20a4:	a9 f7       	brne	.-22     	; 0x2090 <uip_init+0x2>
    20a6:	80 e0       	ldi	r24, 0x00	; 0
    20a8:	91 e7       	ldi	r25, 0x71	; 113
    20aa:	98 9f       	mul	r25, r24
    20ac:	f0 01       	movw	r30, r0
    20ae:	11 24       	eor	r1, r1
    20b0:	eb 5e       	subi	r30, 0xEB	; 235
    20b2:	f9 4f       	sbci	r31, 0xF9	; 249
    20b4:	11 8e       	std	Z+25, r1	; 0x19
    20b6:	8f 5f       	subi	r24, 0xFF	; 255
    20b8:	83 30       	cpi	r24, 0x03	; 3
    20ba:	b9 f7       	brne	.-18     	; 0x20aa <uip_init+0x1c>
    20bc:	80 e0       	ldi	r24, 0x00	; 0
    20be:	94 e0       	ldi	r25, 0x04	; 4
    20c0:	90 93 4a 03 	sts	0x034A, r25	; 0x80034a <lastport+0x1>
    20c4:	80 93 49 03 	sts	0x0349, r24	; 0x800349 <lastport>
    20c8:	10 92 71 0d 	sts	0x0D71, r1	; 0x800d71 <uip_udp_conns+0x5>
    20cc:	10 92 70 0d 	sts	0x0D70, r1	; 0x800d70 <uip_udp_conns+0x4>
    20d0:	81 e0       	ldi	r24, 0x01	; 1
    20d2:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <c>
    20d6:	08 95       	ret

000020d8 <uip_udp_new>:
    20d8:	20 91 49 03 	lds	r18, 0x0349	; 0x800349 <lastport>
    20dc:	30 91 4a 03 	lds	r19, 0x034A	; 0x80034a <lastport+0x1>
    20e0:	e0 91 70 0d 	lds	r30, 0x0D70	; 0x800d70 <uip_udp_conns+0x4>
    20e4:	f0 91 71 0d 	lds	r31, 0x0D71	; 0x800d71 <uip_udp_conns+0x5>
    20e8:	2f 5f       	subi	r18, 0xFF	; 255
    20ea:	3f 4f       	sbci	r19, 0xFF	; 255
    20ec:	21 15       	cp	r18, r1
    20ee:	4d e7       	ldi	r20, 0x7D	; 125
    20f0:	34 07       	cpc	r19, r20
    20f2:	10 f0       	brcs	.+4      	; 0x20f8 <uip_udp_new+0x20>
    20f4:	20 e0       	ldi	r18, 0x00	; 0
    20f6:	30 e1       	ldi	r19, 0x10	; 16
    20f8:	52 2f       	mov	r21, r18
    20fa:	43 2f       	mov	r20, r19
    20fc:	e4 17       	cp	r30, r20
    20fe:	f5 07       	cpc	r31, r21
    2100:	99 f3       	breq	.-26     	; 0x20e8 <uip_udp_new+0x10>
    2102:	30 93 4a 03 	sts	0x034A, r19	; 0x80034a <lastport+0x1>
    2106:	20 93 49 03 	sts	0x0349, r18	; 0x800349 <lastport>
    210a:	ef 2b       	or	r30, r31
    210c:	31 f0       	breq	.+12     	; 0x211a <__stack+0x1b>
    210e:	81 e0       	ldi	r24, 0x01	; 1
    2110:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <c>
    2114:	80 e0       	ldi	r24, 0x00	; 0
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	08 95       	ret
    211a:	10 92 48 03 	sts	0x0348, r1	; 0x800348 <c>
    211e:	50 93 71 0d 	sts	0x0D71, r21	; 0x800d71 <uip_udp_conns+0x5>
    2122:	40 93 70 0d 	sts	0x0D70, r20	; 0x800d70 <uip_udp_conns+0x4>
    2126:	70 93 73 0d 	sts	0x0D73, r23	; 0x800d73 <uip_udp_conns+0x7>
    212a:	60 93 72 0d 	sts	0x0D72, r22	; 0x800d72 <uip_udp_conns+0x6>
    212e:	00 97       	sbiw	r24, 0x00	; 0
    2130:	41 f4       	brne	.+16     	; 0x2142 <__stack+0x43>
    2132:	ec e6       	ldi	r30, 0x6C	; 108
    2134:	fd e0       	ldi	r31, 0x0D	; 13
    2136:	84 e0       	ldi	r24, 0x04	; 4
    2138:	df 01       	movw	r26, r30
    213a:	1d 92       	st	X+, r1
    213c:	8a 95       	dec	r24
    213e:	e9 f7       	brne	.-6      	; 0x213a <__stack+0x3b>
    2140:	0d c0       	rjmp	.+26     	; 0x215c <__stack+0x5d>
    2142:	fc 01       	movw	r30, r24
    2144:	80 81       	ld	r24, Z
    2146:	91 81       	ldd	r25, Z+1	; 0x01
    2148:	a2 81       	ldd	r26, Z+2	; 0x02
    214a:	b3 81       	ldd	r27, Z+3	; 0x03
    214c:	80 93 6c 0d 	sts	0x0D6C, r24	; 0x800d6c <uip_udp_conns>
    2150:	90 93 6d 0d 	sts	0x0D6D, r25	; 0x800d6d <uip_udp_conns+0x1>
    2154:	a0 93 6e 0d 	sts	0x0D6E, r26	; 0x800d6e <uip_udp_conns+0x2>
    2158:	b0 93 6f 0d 	sts	0x0D6F, r27	; 0x800d6f <uip_udp_conns+0x3>
    215c:	80 e4       	ldi	r24, 0x40	; 64
    215e:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uip_udp_conns+0x8>
    2162:	8c e6       	ldi	r24, 0x6C	; 108
    2164:	9d e0       	ldi	r25, 0x0D	; 13
    2166:	08 95       	ret

00002168 <uip_listen>:
    2168:	9c 01       	movw	r18, r24
    216a:	90 e0       	ldi	r25, 0x00	; 0
    216c:	95 30       	cpi	r25, 0x05	; 5
    216e:	99 f0       	breq	.+38     	; 0x2196 <uip_listen+0x2e>
    2170:	e9 2f       	mov	r30, r25
    2172:	f0 e0       	ldi	r31, 0x00	; 0
    2174:	81 e0       	ldi	r24, 0x01	; 1
    2176:	89 0f       	add	r24, r25
    2178:	ee 0f       	add	r30, r30
    217a:	ff 1f       	adc	r31, r31
    217c:	e8 59       	subi	r30, 0x98	; 152
    217e:	f8 4f       	sbci	r31, 0xF8	; 248
    2180:	40 81       	ld	r20, Z
    2182:	51 81       	ldd	r21, Z+1	; 0x01
    2184:	45 2b       	or	r20, r21
    2186:	29 f4       	brne	.+10     	; 0x2192 <uip_listen+0x2a>
    2188:	90 93 48 03 	sts	0x0348, r25	; 0x800348 <c>
    218c:	31 83       	std	Z+1, r19	; 0x01
    218e:	20 83       	st	Z, r18
    2190:	08 95       	ret
    2192:	98 2f       	mov	r25, r24
    2194:	eb cf       	rjmp	.-42     	; 0x216c <uip_listen+0x4>
    2196:	90 93 48 03 	sts	0x0348, r25	; 0x800348 <c>
    219a:	08 95       	ret

0000219c <uip_process>:
    219c:	af 92       	push	r10
    219e:	bf 92       	push	r11
    21a0:	cf 92       	push	r12
    21a2:	df 92       	push	r13
    21a4:	ef 92       	push	r14
    21a6:	ff 92       	push	r15
    21a8:	0f 93       	push	r16
    21aa:	1f 93       	push	r17
    21ac:	cf 93       	push	r28
    21ae:	df 93       	push	r29
    21b0:	84 30       	cpi	r24, 0x04	; 4
    21b2:	09 f4       	brne	.+2      	; 0x21b6 <uip_process+0x1a>
    21b4:	61 c2       	rjmp	.+1218   	; 0x2678 <uip_process+0x4dc>
    21b6:	c0 91 13 06 	lds	r28, 0x0613	; 0x800613 <uip_conn>
    21ba:	d0 91 14 06 	lds	r29, 0x0614	; 0x800614 <uip_conn+0x1>
    21be:	24 eb       	ldi	r18, 0xB4	; 180
    21c0:	37 e0       	ldi	r19, 0x07	; 7
    21c2:	30 93 12 06 	sts	0x0612, r19	; 0x800612 <uip_appdata+0x1>
    21c6:	20 93 11 06 	sts	0x0611, r18	; 0x800611 <uip_appdata>
    21ca:	30 93 09 06 	sts	0x0609, r19	; 0x800609 <uip_sappdata+0x1>
    21ce:	20 93 08 06 	sts	0x0608, r18	; 0x800608 <uip_sappdata>
    21d2:	83 30       	cpi	r24, 0x03	; 3
    21d4:	99 f4       	brne	.+38     	; 0x21fc <uip_process+0x60>
    21d6:	89 8d       	ldd	r24, Y+25	; 0x19
    21d8:	8f 70       	andi	r24, 0x0F	; 15
    21da:	83 30       	cpi	r24, 0x03	; 3
    21dc:	09 f0       	breq	.+2      	; 0x21e0 <uip_process+0x44>
    21de:	22 c7       	rjmp	.+3652   	; 0x3024 <uip_process+0xe88>
    21e0:	88 89       	ldd	r24, Y+16	; 0x10
    21e2:	99 89       	ldd	r25, Y+17	; 0x11
    21e4:	89 2b       	or	r24, r25
    21e6:	09 f0       	breq	.+2      	; 0x21ea <uip_process+0x4e>
    21e8:	1d c7       	rjmp	.+3642   	; 0x3024 <uip_process+0xe88>
    21ea:	10 92 6b 0d 	sts	0x0D6B, r1	; 0x800d6b <uip_slen+0x1>
    21ee:	10 92 6a 0d 	sts	0x0D6A, r1	; 0x800d6a <uip_slen>
    21f2:	10 92 07 06 	sts	0x0607, r1	; 0x800607 <uip_len+0x1>
    21f6:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <uip_len>
    21fa:	7e c0       	rjmp	.+252    	; 0x22f8 <uip_process+0x15c>
    21fc:	82 30       	cpi	r24, 0x02	; 2
    21fe:	09 f0       	breq	.+2      	; 0x2202 <uip_process+0x66>
    2200:	7f c0       	rjmp	.+254    	; 0x2300 <uip_process+0x164>
    2202:	80 91 4e 03 	lds	r24, 0x034E	; 0x80034e <iss+0x3>
    2206:	8f 5f       	subi	r24, 0xFF	; 255
    2208:	80 93 4e 03 	sts	0x034E, r24	; 0x80034e <iss+0x3>
    220c:	81 11       	cpse	r24, r1
    220e:	13 c0       	rjmp	.+38     	; 0x2236 <uip_process+0x9a>
    2210:	80 91 4d 03 	lds	r24, 0x034D	; 0x80034d <iss+0x2>
    2214:	8f 5f       	subi	r24, 0xFF	; 255
    2216:	80 93 4d 03 	sts	0x034D, r24	; 0x80034d <iss+0x2>
    221a:	81 11       	cpse	r24, r1
    221c:	0c c0       	rjmp	.+24     	; 0x2236 <uip_process+0x9a>
    221e:	80 91 4c 03 	lds	r24, 0x034C	; 0x80034c <iss+0x1>
    2222:	8f 5f       	subi	r24, 0xFF	; 255
    2224:	80 93 4c 03 	sts	0x034C, r24	; 0x80034c <iss+0x1>
    2228:	81 11       	cpse	r24, r1
    222a:	05 c0       	rjmp	.+10     	; 0x2236 <uip_process+0x9a>
    222c:	80 91 4b 03 	lds	r24, 0x034B	; 0x80034b <iss>
    2230:	8f 5f       	subi	r24, 0xFF	; 255
    2232:	80 93 4b 03 	sts	0x034B, r24	; 0x80034b <iss>
    2236:	10 92 07 06 	sts	0x0607, r1	; 0x800607 <uip_len+0x1>
    223a:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <uip_len>
    223e:	10 92 6b 0d 	sts	0x0D6B, r1	; 0x800d6b <uip_slen+0x1>
    2242:	10 92 6a 0d 	sts	0x0D6A, r1	; 0x800d6a <uip_slen>
    2246:	89 8d       	ldd	r24, Y+25	; 0x19
    2248:	98 2f       	mov	r25, r24
    224a:	9d 7f       	andi	r25, 0xFD	; 253
    224c:	95 30       	cpi	r25, 0x05	; 5
    224e:	41 f4       	brne	.+16     	; 0x2260 <uip_process+0xc4>
    2250:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2252:	8f 5f       	subi	r24, 0xFF	; 255
    2254:	8a 8f       	std	Y+26, r24	; 0x1a
    2256:	88 37       	cpi	r24, 0x78	; 120
    2258:	09 f0       	breq	.+2      	; 0x225c <uip_process+0xc0>
    225a:	e4 c6       	rjmp	.+3528   	; 0x3024 <uip_process+0xe88>
    225c:	19 8e       	std	Y+25, r1	; 0x19
    225e:	e2 c6       	rjmp	.+3524   	; 0x3024 <uip_process+0xe88>
    2260:	88 23       	and	r24, r24
    2262:	09 f4       	brne	.+2      	; 0x2266 <uip_process+0xca>
    2264:	df c6       	rjmp	.+3518   	; 0x3024 <uip_process+0xe88>
    2266:	28 89       	ldd	r18, Y+16	; 0x10
    2268:	39 89       	ldd	r19, Y+17	; 0x11
    226a:	23 2b       	or	r18, r19
    226c:	09 f4       	brne	.+2      	; 0x2270 <uip_process+0xd4>
    226e:	40 c0       	rjmp	.+128    	; 0x22f0 <uip_process+0x154>
    2270:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2272:	2f ef       	ldi	r18, 0xFF	; 255
    2274:	29 0f       	add	r18, r25
    2276:	2a 8f       	std	Y+26, r18	; 0x1a
    2278:	91 11       	cpse	r25, r1
    227a:	d4 c6       	rjmp	.+3496   	; 0x3024 <uip_process+0xe88>
    227c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    227e:	98 30       	cpi	r25, 0x08	; 8
    2280:	31 f0       	breq	.+12     	; 0x228e <uip_process+0xf2>
    2282:	2f ef       	ldi	r18, 0xFF	; 255
    2284:	28 0f       	add	r18, r24
    2286:	22 30       	cpi	r18, 0x02	; 2
    2288:	40 f4       	brcc	.+16     	; 0x229a <uip_process+0xfe>
    228a:	95 30       	cpi	r25, 0x05	; 5
    228c:	31 f4       	brne	.+12     	; 0x229a <uip_process+0xfe>
    228e:	19 8e       	std	Y+25, r1	; 0x19
    2290:	80 e8       	ldi	r24, 0x80	; 128
    2292:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2296:	27 d8       	rcall	.-4018   	; 0x12e6 <uIPManagement_TCPCallback>
    2298:	83 c5       	rjmp	.+2822   	; 0x2da0 <uip_process+0xc04>
    229a:	95 30       	cpi	r25, 0x05	; 5
    229c:	40 f4       	brcc	.+16     	; 0x22ae <uip_process+0x112>
    229e:	23 e0       	ldi	r18, 0x03	; 3
    22a0:	30 e0       	ldi	r19, 0x00	; 0
    22a2:	09 2e       	mov	r0, r25
    22a4:	01 c0       	rjmp	.+2      	; 0x22a8 <uip_process+0x10c>
    22a6:	22 0f       	add	r18, r18
    22a8:	0a 94       	dec	r0
    22aa:	ea f7       	brpl	.-6      	; 0x22a6 <uip_process+0x10a>
    22ac:	01 c0       	rjmp	.+2      	; 0x22b0 <uip_process+0x114>
    22ae:	20 e3       	ldi	r18, 0x30	; 48
    22b0:	2a 8f       	std	Y+26, r18	; 0x1a
    22b2:	9f 5f       	subi	r25, 0xFF	; 255
    22b4:	9b 8f       	std	Y+27, r25	; 0x1b
    22b6:	8f 70       	andi	r24, 0x0F	; 15
    22b8:	83 30       	cpi	r24, 0x03	; 3
    22ba:	a1 f0       	breq	.+40     	; 0x22e4 <uip_process+0x148>
    22bc:	48 f4       	brcc	.+18     	; 0x22d0 <uip_process+0x134>
    22be:	81 30       	cpi	r24, 0x01	; 1
    22c0:	09 f4       	brne	.+2      	; 0x22c4 <uip_process+0x128>
    22c2:	a8 c3       	rjmp	.+1872   	; 0x2a14 <uip_process+0x878>
    22c4:	82 30       	cpi	r24, 0x02	; 2
    22c6:	09 f0       	breq	.+2      	; 0x22ca <uip_process+0x12e>
    22c8:	ad c6       	rjmp	.+3418   	; 0x3024 <uip_process+0xe88>
    22ca:	10 92 ad 07 	sts	0x07AD, r1	; 0x8007ad <uip_buf+0x2f>
    22ce:	a5 c3       	rjmp	.+1866   	; 0x2a1a <uip_process+0x87e>
    22d0:	86 30       	cpi	r24, 0x06	; 6
    22d2:	09 f4       	brne	.+2      	; 0x22d6 <uip_process+0x13a>
    22d4:	03 c5       	rjmp	.+2566   	; 0x2cdc <uip_process+0xb40>
    22d6:	88 30       	cpi	r24, 0x08	; 8
    22d8:	09 f4       	brne	.+2      	; 0x22dc <uip_process+0x140>
    22da:	00 c5       	rjmp	.+2560   	; 0x2cdc <uip_process+0xb40>
    22dc:	84 30       	cpi	r24, 0x04	; 4
    22de:	09 f0       	breq	.+2      	; 0x22e2 <uip_process+0x146>
    22e0:	a1 c6       	rjmp	.+3394   	; 0x3024 <uip_process+0xe88>
    22e2:	fc c4       	rjmp	.+2552   	; 0x2cdc <uip_process+0xb40>
    22e4:	84 e0       	ldi	r24, 0x04	; 4
    22e6:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    22ea:	0e 94 73 09 	call	0x12e6	; 0x12e6 <uIPManagement_TCPCallback>
    22ee:	8a c5       	rjmp	.+2836   	; 0x2e04 <uip_process+0xc68>
    22f0:	8f 70       	andi	r24, 0x0F	; 15
    22f2:	83 30       	cpi	r24, 0x03	; 3
    22f4:	09 f0       	breq	.+2      	; 0x22f8 <uip_process+0x15c>
    22f6:	96 c6       	rjmp	.+3372   	; 0x3024 <uip_process+0xe88>
    22f8:	88 e0       	ldi	r24, 0x08	; 8
    22fa:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    22fe:	45 c5       	rjmp	.+2698   	; 0x2d8a <uip_process+0xbee>
    2300:	85 30       	cpi	r24, 0x05	; 5
    2302:	19 f5       	brne	.+70     	; 0x234a <uip_process+0x1ae>
    2304:	e0 91 0f 06 	lds	r30, 0x060F	; 0x80060f <uip_udp_conn>
    2308:	f0 91 10 06 	lds	r31, 0x0610	; 0x800610 <uip_udp_conn+0x1>
    230c:	84 81       	ldd	r24, Z+4	; 0x04
    230e:	95 81       	ldd	r25, Z+5	; 0x05
    2310:	89 2b       	or	r24, r25
    2312:	09 f4       	brne	.+2      	; 0x2316 <uip_process+0x17a>
    2314:	87 c6       	rjmp	.+3342   	; 0x3024 <uip_process+0xe88>
    2316:	10 92 14 06 	sts	0x0614, r1	; 0x800614 <uip_conn+0x1>
    231a:	10 92 13 06 	sts	0x0613, r1	; 0x800613 <uip_conn>
    231e:	88 ea       	ldi	r24, 0xA8	; 168
    2320:	97 e0       	ldi	r25, 0x07	; 7
    2322:	90 93 12 06 	sts	0x0612, r25	; 0x800612 <uip_appdata+0x1>
    2326:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <uip_appdata>
    232a:	90 93 09 06 	sts	0x0609, r25	; 0x800609 <uip_sappdata+0x1>
    232e:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <uip_sappdata>
    2332:	10 92 6b 0d 	sts	0x0D6B, r1	; 0x800d6b <uip_slen+0x1>
    2336:	10 92 6a 0d 	sts	0x0D6A, r1	; 0x800d6a <uip_slen>
    233a:	10 92 07 06 	sts	0x0607, r1	; 0x800607 <uip_len+0x1>
    233e:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <uip_len>
    2342:	88 e0       	ldi	r24, 0x08	; 8
    2344:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2348:	95 c1       	rjmp	.+810    	; 0x2674 <uip_process+0x4d8>
    234a:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <uip_buf+0xe>
    234e:	85 34       	cpi	r24, 0x45	; 69
    2350:	09 f0       	breq	.+2      	; 0x2354 <uip_process+0x1b8>
    2352:	68 c6       	rjmp	.+3280   	; 0x3024 <uip_process+0xe88>
    2354:	00 91 8e 07 	lds	r16, 0x078E	; 0x80078e <uip_buf+0x10>
    2358:	10 e0       	ldi	r17, 0x00	; 0
    235a:	10 2f       	mov	r17, r16
    235c:	00 27       	eor	r16, r16
    235e:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uip_buf+0x11>
    2362:	08 0f       	add	r16, r24
    2364:	11 1d       	adc	r17, r1
    2366:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    236a:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    236e:	80 17       	cp	r24, r16
    2370:	91 07       	cpc	r25, r17
    2372:	08 f4       	brcc	.+2      	; 0x2376 <uip_process+0x1da>
    2374:	57 c6       	rjmp	.+3246   	; 0x3024 <uip_process+0xe88>
    2376:	10 93 07 06 	sts	0x0607, r17	; 0x800607 <uip_len+0x1>
    237a:	00 93 06 06 	sts	0x0606, r16	; 0x800606 <uip_len>
    237e:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <uip_buf+0x14>
    2382:	8f 73       	andi	r24, 0x3F	; 63
    2384:	09 f0       	breq	.+2      	; 0x2388 <uip_process+0x1ec>
    2386:	4e c6       	rjmp	.+3228   	; 0x3024 <uip_process+0xe88>
    2388:	f0 90 93 07 	lds	r15, 0x0793	; 0x800793 <uip_buf+0x15>
    238c:	f1 10       	cpse	r15, r1
    238e:	4a c6       	rjmp	.+3220   	; 0x3024 <uip_process+0xe88>
    2390:	20 91 7a 07 	lds	r18, 0x077A	; 0x80077a <uip_hostaddr>
    2394:	30 91 7b 07 	lds	r19, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    2398:	c0 91 4e 02 	lds	r28, 0x024E	; 0x80024e <uip_all_zeroes_addr>
    239c:	d0 91 4f 02 	lds	r29, 0x024F	; 0x80024f <uip_all_zeroes_addr+0x1>
    23a0:	2c 17       	cp	r18, r28
    23a2:	3d 07       	cpc	r19, r29
    23a4:	61 f4       	brne	.+24     	; 0x23be <uip_process+0x222>
    23a6:	40 91 7c 07 	lds	r20, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    23aa:	50 91 7d 07 	lds	r21, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    23ae:	80 91 50 02 	lds	r24, 0x0250	; 0x800250 <uip_all_zeroes_addr+0x2>
    23b2:	90 91 51 02 	lds	r25, 0x0251	; 0x800251 <uip_all_zeroes_addr+0x3>
    23b6:	48 17       	cp	r20, r24
    23b8:	59 07       	cpc	r21, r25
    23ba:	09 f4       	brne	.+2      	; 0x23be <uip_process+0x222>
    23bc:	4f c0       	rjmp	.+158    	; 0x245c <uip_process+0x2c0>
    23be:	40 91 95 07 	lds	r20, 0x0795	; 0x800795 <uip_buf+0x17>
    23c2:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uip_buf+0x1e>
    23c6:	90 91 9d 07 	lds	r25, 0x079D	; 0x80079d <uip_buf+0x1f>
    23ca:	41 31       	cpi	r20, 0x11	; 17
    23cc:	b9 f5       	brne	.+110    	; 0x243c <uip_process+0x2a0>
    23ce:	40 91 52 02 	lds	r20, 0x0252	; 0x800252 <uip_broadcast_addr>
    23d2:	50 91 53 02 	lds	r21, 0x0253	; 0x800253 <uip_broadcast_addr+0x1>
    23d6:	84 17       	cp	r24, r20
    23d8:	95 07       	cpc	r25, r21
    23da:	81 f5       	brne	.+96     	; 0x243c <uip_process+0x2a0>
    23dc:	60 91 9e 07 	lds	r22, 0x079E	; 0x80079e <uip_buf+0x20>
    23e0:	70 91 9f 07 	lds	r23, 0x079F	; 0x80079f <uip_buf+0x21>
    23e4:	40 91 54 02 	lds	r20, 0x0254	; 0x800254 <uip_broadcast_addr+0x2>
    23e8:	50 91 55 02 	lds	r21, 0x0255	; 0x800255 <uip_broadcast_addr+0x3>
    23ec:	64 17       	cp	r22, r20
    23ee:	75 07       	cpc	r23, r21
    23f0:	29 f5       	brne	.+74     	; 0x243c <uip_process+0x2a0>
    23f2:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uip_buf+0x1a>
    23f6:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uip_buf+0x1b>
    23fa:	c8 17       	cp	r28, r24
    23fc:	d9 07       	cpc	r29, r25
    23fe:	09 f0       	breq	.+2      	; 0x2402 <uip_process+0x266>
    2400:	75 c0       	rjmp	.+234    	; 0x24ec <uip_process+0x350>
    2402:	20 91 9a 07 	lds	r18, 0x079A	; 0x80079a <uip_buf+0x1c>
    2406:	30 91 9b 07 	lds	r19, 0x079B	; 0x80079b <uip_buf+0x1d>
    240a:	80 91 50 02 	lds	r24, 0x0250	; 0x800250 <uip_all_zeroes_addr+0x2>
    240e:	90 91 51 02 	lds	r25, 0x0251	; 0x800251 <uip_all_zeroes_addr+0x3>
    2412:	28 17       	cp	r18, r24
    2414:	39 07       	cpc	r19, r25
    2416:	09 f0       	breq	.+2      	; 0x241a <uip_process+0x27e>
    2418:	69 c0       	rjmp	.+210    	; 0x24ec <uip_process+0x350>
    241a:	80 91 52 02 	lds	r24, 0x0252	; 0x800252 <uip_broadcast_addr>
    241e:	90 91 53 02 	lds	r25, 0x0253	; 0x800253 <uip_broadcast_addr+0x1>
    2422:	a0 91 54 02 	lds	r26, 0x0254	; 0x800254 <uip_broadcast_addr+0x2>
    2426:	b0 91 55 02 	lds	r27, 0x0255	; 0x800255 <uip_broadcast_addr+0x3>
    242a:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uip_buf+0x1a>
    242e:	90 93 99 07 	sts	0x0799, r25	; 0x800799 <uip_buf+0x1b>
    2432:	a0 93 9a 07 	sts	0x079A, r26	; 0x80079a <uip_buf+0x1c>
    2436:	b0 93 9b 07 	sts	0x079B, r27	; 0x80079b <uip_buf+0x1d>
    243a:	58 c0       	rjmp	.+176    	; 0x24ec <uip_process+0x350>
    243c:	28 17       	cp	r18, r24
    243e:	39 07       	cpc	r19, r25
    2440:	09 f0       	breq	.+2      	; 0x2444 <uip_process+0x2a8>
    2442:	f0 c5       	rjmp	.+3040   	; 0x3024 <uip_process+0xe88>
    2444:	20 91 9e 07 	lds	r18, 0x079E	; 0x80079e <uip_buf+0x20>
    2448:	30 91 9f 07 	lds	r19, 0x079F	; 0x80079f <uip_buf+0x21>
    244c:	80 91 7c 07 	lds	r24, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    2450:	90 91 7d 07 	lds	r25, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    2454:	28 17       	cp	r18, r24
    2456:	39 07       	cpc	r19, r25
    2458:	09 f0       	breq	.+2      	; 0x245c <uip_process+0x2c0>
    245a:	e4 c5       	rjmp	.+3016   	; 0x3024 <uip_process+0xe88>
    245c:	e5 dd       	rcall	.-1078   	; 0x2028 <uip_ipchksum>
    245e:	01 96       	adiw	r24, 0x01	; 1
    2460:	09 f0       	breq	.+2      	; 0x2464 <uip_process+0x2c8>
    2462:	e0 c5       	rjmp	.+3008   	; 0x3024 <uip_process+0xe88>
    2464:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uip_buf+0x17>
    2468:	86 30       	cpi	r24, 0x06	; 6
    246a:	09 f4       	brne	.+2      	; 0x246e <uip_process+0x2d2>
    246c:	5c c1       	rjmp	.+696    	; 0x2726 <uip_process+0x58a>
    246e:	81 31       	cpi	r24, 0x11	; 17
    2470:	e9 f1       	breq	.+122    	; 0x24ec <uip_process+0x350>
    2472:	81 30       	cpi	r24, 0x01	; 1
    2474:	09 f0       	breq	.+2      	; 0x2478 <uip_process+0x2dc>
    2476:	d6 c5       	rjmp	.+2988   	; 0x3024 <uip_process+0xe88>
    2478:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uip_buf+0x22>
    247c:	88 30       	cpi	r24, 0x08	; 8
    247e:	09 f0       	breq	.+2      	; 0x2482 <uip_process+0x2e6>
    2480:	d1 c5       	rjmp	.+2978   	; 0x3024 <uip_process+0xe88>
    2482:	10 92 a0 07 	sts	0x07A0, r1	; 0x8007a0 <uip_buf+0x22>
    2486:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <uip_buf+0x24>
    248a:	90 91 a3 07 	lds	r25, 0x07A3	; 0x8007a3 <uip_buf+0x25>
    248e:	87 3f       	cpi	r24, 0xF7	; 247
    2490:	6f ef       	ldi	r22, 0xFF	; 255
    2492:	96 07       	cpc	r25, r22
    2494:	10 f0       	brcs	.+4      	; 0x249a <uip_process+0x2fe>
    2496:	09 96       	adiw	r24, 0x09	; 9
    2498:	01 c0       	rjmp	.+2      	; 0x249c <uip_process+0x300>
    249a:	08 96       	adiw	r24, 0x08	; 8
    249c:	90 93 a3 07 	sts	0x07A3, r25	; 0x8007a3 <uip_buf+0x25>
    24a0:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <uip_buf+0x24>
    24a4:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uip_buf+0x1a>
    24a8:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uip_buf+0x1b>
    24ac:	a0 91 9a 07 	lds	r26, 0x079A	; 0x80079a <uip_buf+0x1c>
    24b0:	b0 91 9b 07 	lds	r27, 0x079B	; 0x80079b <uip_buf+0x1d>
    24b4:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uip_buf+0x1e>
    24b8:	90 93 9d 07 	sts	0x079D, r25	; 0x80079d <uip_buf+0x1f>
    24bc:	a0 93 9e 07 	sts	0x079E, r26	; 0x80079e <uip_buf+0x20>
    24c0:	b0 93 9f 07 	sts	0x079F, r27	; 0x80079f <uip_buf+0x21>
    24c4:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    24c8:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    24cc:	a0 91 7c 07 	lds	r26, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    24d0:	b0 91 7d 07 	lds	r27, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    24d4:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uip_buf+0x1a>
    24d8:	90 93 99 07 	sts	0x0799, r25	; 0x800799 <uip_buf+0x1b>
    24dc:	a0 93 9a 07 	sts	0x079A, r26	; 0x80079a <uip_buf+0x1c>
    24e0:	b0 93 9b 07 	sts	0x079B, r27	; 0x80079b <uip_buf+0x1d>
    24e4:	80 e4       	ldi	r24, 0x40	; 64
    24e6:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <uip_buf+0x16>
    24ea:	7a c5       	rjmp	.+2804   	; 0x2fe0 <uip_process+0xe44>
    24ec:	0c 51       	subi	r16, 0x1C	; 28
    24ee:	11 09       	sbc	r17, r1
    24f0:	10 93 07 06 	sts	0x0607, r17	; 0x800607 <uip_len+0x1>
    24f4:	00 93 06 06 	sts	0x0606, r16	; 0x800606 <uip_len>
    24f8:	8c e6       	ldi	r24, 0x6C	; 108
    24fa:	9d e0       	ldi	r25, 0x0D	; 13
    24fc:	90 93 10 06 	sts	0x0610, r25	; 0x800610 <uip_udp_conn+0x1>
    2500:	80 93 0f 06 	sts	0x060F, r24	; 0x80060f <uip_udp_conn>
    2504:	a0 90 a2 07 	lds	r10, 0x07A2	; 0x8007a2 <uip_buf+0x24>
    2508:	b0 90 a3 07 	lds	r11, 0x07A3	; 0x8007a3 <uip_buf+0x25>
    250c:	20 91 a0 07 	lds	r18, 0x07A0	; 0x8007a0 <uip_buf+0x22>
    2510:	30 91 a1 07 	lds	r19, 0x07A1	; 0x8007a1 <uip_buf+0x23>
    2514:	40 91 50 02 	lds	r20, 0x0250	; 0x800250 <uip_all_zeroes_addr+0x2>
    2518:	50 91 51 02 	lds	r21, 0x0251	; 0x800251 <uip_all_zeroes_addr+0x3>
    251c:	60 91 52 02 	lds	r22, 0x0252	; 0x800252 <uip_broadcast_addr>
    2520:	70 91 53 02 	lds	r23, 0x0253	; 0x800253 <uip_broadcast_addr+0x1>
    2524:	a0 91 54 02 	lds	r26, 0x0254	; 0x800254 <uip_broadcast_addr+0x2>
    2528:	b0 91 55 02 	lds	r27, 0x0255	; 0x800255 <uip_broadcast_addr+0x3>
    252c:	00 91 98 07 	lds	r16, 0x0798	; 0x800798 <uip_buf+0x1a>
    2530:	10 91 99 07 	lds	r17, 0x0799	; 0x800799 <uip_buf+0x1b>
    2534:	e0 90 9a 07 	lds	r14, 0x079A	; 0x80079a <uip_buf+0x1c>
    2538:	f0 90 9b 07 	lds	r15, 0x079B	; 0x80079b <uip_buf+0x1d>
    253c:	e0 91 0f 06 	lds	r30, 0x060F	; 0x80060f <uip_udp_conn>
    2540:	f0 91 10 06 	lds	r31, 0x0610	; 0x800610 <uip_udp_conn+0x1>
    2544:	8d e0       	ldi	r24, 0x0D	; 13
    2546:	ea 38       	cpi	r30, 0x8A	; 138
    2548:	f8 07       	cpc	r31, r24
    254a:	88 f5       	brcc	.+98     	; 0x25ae <uip_process+0x412>
    254c:	84 81       	ldd	r24, Z+4	; 0x04
    254e:	95 81       	ldd	r25, Z+5	; 0x05
    2550:	00 97       	sbiw	r24, 0x00	; 0
    2552:	39 f1       	breq	.+78     	; 0x25a2 <uip_process+0x406>
    2554:	8a 15       	cp	r24, r10
    2556:	9b 05       	cpc	r25, r11
    2558:	21 f5       	brne	.+72     	; 0x25a2 <uip_process+0x406>
    255a:	86 81       	ldd	r24, Z+6	; 0x06
    255c:	97 81       	ldd	r25, Z+7	; 0x07
    255e:	00 97       	sbiw	r24, 0x00	; 0
    2560:	19 f0       	breq	.+6      	; 0x2568 <uip_process+0x3cc>
    2562:	82 17       	cp	r24, r18
    2564:	93 07       	cpc	r25, r19
    2566:	e9 f4       	brne	.+58     	; 0x25a2 <uip_process+0x406>
    2568:	80 81       	ld	r24, Z
    256a:	91 81       	ldd	r25, Z+1	; 0x01
    256c:	c8 17       	cp	r28, r24
    256e:	d9 07       	cpc	r29, r25
    2570:	31 f4       	brne	.+12     	; 0x257e <uip_process+0x3e2>
    2572:	c2 80       	ldd	r12, Z+2	; 0x02
    2574:	d3 80       	ldd	r13, Z+3	; 0x03
    2576:	c4 16       	cp	r12, r20
    2578:	d5 06       	cpc	r13, r21
    257a:	09 f4       	brne	.+2      	; 0x257e <uip_process+0x3e2>
    257c:	66 c0       	rjmp	.+204    	; 0x264a <uip_process+0x4ae>
    257e:	86 17       	cp	r24, r22
    2580:	97 07       	cpc	r25, r23
    2582:	31 f4       	brne	.+12     	; 0x2590 <uip_process+0x3f4>
    2584:	c2 80       	ldd	r12, Z+2	; 0x02
    2586:	d3 80       	ldd	r13, Z+3	; 0x03
    2588:	ca 16       	cp	r12, r26
    258a:	db 06       	cpc	r13, r27
    258c:	09 f4       	brne	.+2      	; 0x2590 <uip_process+0x3f4>
    258e:	5d c0       	rjmp	.+186    	; 0x264a <uip_process+0x4ae>
    2590:	80 17       	cp	r24, r16
    2592:	91 07       	cpc	r25, r17
    2594:	31 f4       	brne	.+12     	; 0x25a2 <uip_process+0x406>
    2596:	82 81       	ldd	r24, Z+2	; 0x02
    2598:	93 81       	ldd	r25, Z+3	; 0x03
    259a:	e8 16       	cp	r14, r24
    259c:	f9 06       	cpc	r15, r25
    259e:	09 f4       	brne	.+2      	; 0x25a2 <uip_process+0x406>
    25a0:	54 c0       	rjmp	.+168    	; 0x264a <uip_process+0x4ae>
    25a2:	7e 96       	adiw	r30, 0x1e	; 30
    25a4:	f0 93 10 06 	sts	0x0610, r31	; 0x800610 <uip_udp_conn+0x1>
    25a8:	e0 93 0f 06 	sts	0x060F, r30	; 0x80060f <uip_udp_conn>
    25ac:	c7 cf       	rjmp	.-114    	; 0x253c <uip_process+0x3a0>
    25ae:	8c e1       	ldi	r24, 0x1C	; 28
    25b0:	ec e8       	ldi	r30, 0x8C	; 140
    25b2:	f7 e0       	ldi	r31, 0x07	; 7
    25b4:	a8 ea       	ldi	r26, 0xA8	; 168
    25b6:	b7 e0       	ldi	r27, 0x07	; 7
    25b8:	01 90       	ld	r0, Z+
    25ba:	0d 92       	st	X+, r0
    25bc:	8a 95       	dec	r24
    25be:	e1 f7       	brne	.-8      	; 0x25b8 <uip_process+0x41c>
    25c0:	83 e0       	ldi	r24, 0x03	; 3
    25c2:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <uip_buf+0x22>
    25c6:	80 93 a1 07 	sts	0x07A1, r24	; 0x8007a1 <uip_buf+0x23>
    25ca:	10 92 a3 07 	sts	0x07A3, r1	; 0x8007a3 <uip_buf+0x25>
    25ce:	10 92 a2 07 	sts	0x07A2, r1	; 0x8007a2 <uip_buf+0x24>
    25d2:	64 e2       	ldi	r22, 0x24	; 36
    25d4:	70 e0       	ldi	r23, 0x00	; 0
    25d6:	80 ea       	ldi	r24, 0xA0	; 160
    25d8:	97 e0       	ldi	r25, 0x07	; 7
    25da:	1d dd       	rcall	.-1478   	; 0x2016 <uip_chksum>
    25dc:	80 95       	com	r24
    25de:	90 95       	com	r25
    25e0:	90 93 a3 07 	sts	0x07A3, r25	; 0x8007a3 <uip_buf+0x25>
    25e4:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <uip_buf+0x24>
    25e8:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uip_buf+0x1a>
    25ec:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uip_buf+0x1b>
    25f0:	a0 91 9a 07 	lds	r26, 0x079A	; 0x80079a <uip_buf+0x1c>
    25f4:	b0 91 9b 07 	lds	r27, 0x079B	; 0x80079b <uip_buf+0x1d>
    25f8:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uip_buf+0x1e>
    25fc:	90 93 9d 07 	sts	0x079D, r25	; 0x80079d <uip_buf+0x1f>
    2600:	a0 93 9e 07 	sts	0x079E, r26	; 0x80079e <uip_buf+0x20>
    2604:	b0 93 9f 07 	sts	0x079F, r27	; 0x80079f <uip_buf+0x21>
    2608:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    260c:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    2610:	a0 91 7c 07 	lds	r26, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    2614:	b0 91 7d 07 	lds	r27, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    2618:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uip_buf+0x1a>
    261c:	90 93 99 07 	sts	0x0799, r25	; 0x800799 <uip_buf+0x1b>
    2620:	a0 93 9a 07 	sts	0x079A, r26	; 0x80079a <uip_buf+0x1c>
    2624:	b0 93 9b 07 	sts	0x079B, r27	; 0x80079b <uip_buf+0x1d>
    2628:	88 e3       	ldi	r24, 0x38	; 56
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    2630:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    2634:	10 92 8e 07 	sts	0x078E, r1	; 0x80078e <uip_buf+0x10>
    2638:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uip_buf+0x11>
    263c:	80 e4       	ldi	r24, 0x40	; 64
    263e:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <uip_buf+0x16>
    2642:	81 e0       	ldi	r24, 0x01	; 1
    2644:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uip_buf+0x17>
    2648:	cb c4       	rjmp	.+2454   	; 0x2fe0 <uip_process+0xe44>
    264a:	10 92 14 06 	sts	0x0614, r1	; 0x800614 <uip_conn+0x1>
    264e:	10 92 13 06 	sts	0x0613, r1	; 0x800613 <uip_conn>
    2652:	82 e0       	ldi	r24, 0x02	; 2
    2654:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2658:	88 ea       	ldi	r24, 0xA8	; 168
    265a:	97 e0       	ldi	r25, 0x07	; 7
    265c:	90 93 12 06 	sts	0x0612, r25	; 0x800612 <uip_appdata+0x1>
    2660:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <uip_appdata>
    2664:	90 93 09 06 	sts	0x0609, r25	; 0x800609 <uip_sappdata+0x1>
    2668:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <uip_sappdata>
    266c:	10 92 6b 0d 	sts	0x0D6B, r1	; 0x800d6b <uip_slen+0x1>
    2670:	10 92 6a 0d 	sts	0x0D6A, r1	; 0x800d6a <uip_slen>
    2674:	0e 94 83 09 	call	0x1306	; 0x1306 <uIPManagement_UDPCallback>
    2678:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uip_slen>
    267c:	90 91 6b 0d 	lds	r25, 0x0D6B	; 0x800d6b <uip_slen+0x1>
    2680:	00 97       	sbiw	r24, 0x00	; 0
    2682:	09 f4       	brne	.+2      	; 0x2686 <uip_process+0x4ea>
    2684:	cf c4       	rjmp	.+2462   	; 0x3024 <uip_process+0xe88>
    2686:	9c 01       	movw	r18, r24
    2688:	24 5e       	subi	r18, 0xE4	; 228
    268a:	3f 4f       	sbci	r19, 0xFF	; 255
    268c:	30 93 07 06 	sts	0x0607, r19	; 0x800607 <uip_len+0x1>
    2690:	20 93 06 06 	sts	0x0606, r18	; 0x800606 <uip_len>
    2694:	30 93 8e 07 	sts	0x078E, r19	; 0x80078e <uip_buf+0x10>
    2698:	20 93 8f 07 	sts	0x078F, r18	; 0x80078f <uip_buf+0x11>
    269c:	e0 91 0f 06 	lds	r30, 0x060F	; 0x80060f <uip_udp_conn>
    26a0:	f0 91 10 06 	lds	r31, 0x0610	; 0x800610 <uip_udp_conn+0x1>
    26a4:	20 85       	ldd	r18, Z+8	; 0x08
    26a6:	20 93 94 07 	sts	0x0794, r18	; 0x800794 <uip_buf+0x16>
    26aa:	21 e1       	ldi	r18, 0x11	; 17
    26ac:	20 93 95 07 	sts	0x0795, r18	; 0x800795 <uip_buf+0x17>
    26b0:	08 96       	adiw	r24, 0x08	; 8
    26b2:	98 27       	eor	r25, r24
    26b4:	89 27       	eor	r24, r25
    26b6:	98 27       	eor	r25, r24
    26b8:	90 93 a5 07 	sts	0x07A5, r25	; 0x8007a5 <uip_buf+0x27>
    26bc:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <uip_buf+0x26>
    26c0:	10 92 a7 07 	sts	0x07A7, r1	; 0x8007a7 <uip_buf+0x29>
    26c4:	10 92 a6 07 	sts	0x07A6, r1	; 0x8007a6 <uip_buf+0x28>
    26c8:	84 81       	ldd	r24, Z+4	; 0x04
    26ca:	95 81       	ldd	r25, Z+5	; 0x05
    26cc:	90 93 a1 07 	sts	0x07A1, r25	; 0x8007a1 <uip_buf+0x23>
    26d0:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <uip_buf+0x22>
    26d4:	86 81       	ldd	r24, Z+6	; 0x06
    26d6:	97 81       	ldd	r25, Z+7	; 0x07
    26d8:	90 93 a3 07 	sts	0x07A3, r25	; 0x8007a3 <uip_buf+0x25>
    26dc:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <uip_buf+0x24>
    26e0:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    26e4:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    26e8:	a0 91 7c 07 	lds	r26, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    26ec:	b0 91 7d 07 	lds	r27, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    26f0:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uip_buf+0x1a>
    26f4:	90 93 99 07 	sts	0x0799, r25	; 0x800799 <uip_buf+0x1b>
    26f8:	a0 93 9a 07 	sts	0x079A, r26	; 0x80079a <uip_buf+0x1c>
    26fc:	b0 93 9b 07 	sts	0x079B, r27	; 0x80079b <uip_buf+0x1d>
    2700:	80 81       	ld	r24, Z
    2702:	91 81       	ldd	r25, Z+1	; 0x01
    2704:	a2 81       	ldd	r26, Z+2	; 0x02
    2706:	b3 81       	ldd	r27, Z+3	; 0x03
    2708:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uip_buf+0x1e>
    270c:	90 93 9d 07 	sts	0x079D, r25	; 0x80079d <uip_buf+0x1f>
    2710:	a0 93 9e 07 	sts	0x079E, r26	; 0x80079e <uip_buf+0x20>
    2714:	b0 93 9f 07 	sts	0x079F, r27	; 0x80079f <uip_buf+0x21>
    2718:	84 eb       	ldi	r24, 0xB4	; 180
    271a:	97 e0       	ldi	r25, 0x07	; 7
    271c:	90 93 12 06 	sts	0x0612, r25	; 0x800612 <uip_appdata+0x1>
    2720:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <uip_appdata>
    2724:	5d c4       	rjmp	.+2234   	; 0x2fe0 <uip_process+0xe44>
    2726:	90 dc       	rcall	.-1760   	; 0x2048 <uip_tcpchksum>
    2728:	01 96       	adiw	r24, 0x01	; 1
    272a:	09 f0       	breq	.+2      	; 0x272e <uip_process+0x592>
    272c:	7b c4       	rjmp	.+2294   	; 0x3024 <uip_process+0xe88>
    272e:	40 91 a2 07 	lds	r20, 0x07A2	; 0x8007a2 <uip_buf+0x24>
    2732:	50 91 a3 07 	lds	r21, 0x07A3	; 0x8007a3 <uip_buf+0x25>
    2736:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uip_buf+0x22>
    273a:	90 91 a1 07 	lds	r25, 0x07A1	; 0x8007a1 <uip_buf+0x23>
    273e:	60 91 98 07 	lds	r22, 0x0798	; 0x800798 <uip_buf+0x1a>
    2742:	70 91 99 07 	lds	r23, 0x0799	; 0x800799 <uip_buf+0x1b>
    2746:	e0 91 9a 07 	lds	r30, 0x079A	; 0x80079a <uip_buf+0x1c>
    274a:	f0 91 9b 07 	lds	r31, 0x079B	; 0x80079b <uip_buf+0x1d>
    274e:	c5 e1       	ldi	r28, 0x15	; 21
    2750:	d6 e0       	ldi	r29, 0x06	; 6
    2752:	29 8d       	ldd	r18, Y+25	; 0x19
    2754:	22 23       	and	r18, r18
    2756:	a9 f0       	breq	.+42     	; 0x2782 <uip_process+0x5e6>
    2758:	ac 81       	ldd	r26, Y+4	; 0x04
    275a:	bd 81       	ldd	r27, Y+5	; 0x05
    275c:	4a 17       	cp	r20, r26
    275e:	5b 07       	cpc	r21, r27
    2760:	81 f4       	brne	.+32     	; 0x2782 <uip_process+0x5e6>
    2762:	ae 81       	ldd	r26, Y+6	; 0x06
    2764:	bf 81       	ldd	r27, Y+7	; 0x07
    2766:	8a 17       	cp	r24, r26
    2768:	9b 07       	cpc	r25, r27
    276a:	59 f4       	brne	.+22     	; 0x2782 <uip_process+0x5e6>
    276c:	a8 81       	ld	r26, Y
    276e:	b9 81       	ldd	r27, Y+1	; 0x01
    2770:	6a 17       	cp	r22, r26
    2772:	7b 07       	cpc	r23, r27
    2774:	31 f4       	brne	.+12     	; 0x2782 <uip_process+0x5e6>
    2776:	aa 81       	ldd	r26, Y+2	; 0x02
    2778:	bb 81       	ldd	r27, Y+3	; 0x03
    277a:	ea 17       	cp	r30, r26
    277c:	fb 07       	cpc	r31, r27
    277e:	09 f4       	brne	.+2      	; 0x2782 <uip_process+0x5e6>
    2780:	65 c1       	rjmp	.+714    	; 0x2a4c <uip_process+0x8b0>
    2782:	cf 58       	subi	r28, 0x8F	; 143
    2784:	df 4f       	sbci	r29, 0xFF	; 255
    2786:	27 e0       	ldi	r18, 0x07	; 7
    2788:	c8 36       	cpi	r28, 0x68	; 104
    278a:	d2 07       	cpc	r29, r18
    278c:	11 f7       	brne	.-60     	; 0x2752 <uip_process+0x5b6>
    278e:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <uip_buf+0x2f>
    2792:	8f 73       	andi	r24, 0x3F	; 63
    2794:	82 30       	cpi	r24, 0x02	; 2
    2796:	e1 f4       	brne	.+56     	; 0x27d0 <uip_process+0x634>
    2798:	50 93 47 03 	sts	0x0347, r21	; 0x800347 <tmp16+0x1>
    279c:	40 93 46 03 	sts	0x0346, r20	; 0x800346 <tmp16>
    27a0:	80 e0       	ldi	r24, 0x00	; 0
    27a2:	85 30       	cpi	r24, 0x05	; 5
    27a4:	99 f0       	breq	.+38     	; 0x27cc <uip_process+0x630>
    27a6:	e8 2f       	mov	r30, r24
    27a8:	f0 e0       	ldi	r31, 0x00	; 0
    27aa:	ee 0f       	add	r30, r30
    27ac:	ff 1f       	adc	r31, r31
    27ae:	e8 59       	subi	r30, 0x98	; 152
    27b0:	f8 4f       	sbci	r31, 0xF8	; 248
    27b2:	20 81       	ld	r18, Z
    27b4:	31 81       	ldd	r19, Z+1	; 0x01
    27b6:	8f 5f       	subi	r24, 0xFF	; 255
    27b8:	42 17       	cp	r20, r18
    27ba:	53 07       	cpc	r21, r19
    27bc:	91 f7       	brne	.-28     	; 0x27a2 <uip_process+0x606>
    27be:	10 92 48 03 	sts	0x0348, r1	; 0x800348 <c>
    27c2:	80 e0       	ldi	r24, 0x00	; 0
    27c4:	c0 e0       	ldi	r28, 0x00	; 0
    27c6:	d0 e0       	ldi	r29, 0x00	; 0
    27c8:	91 e7       	ldi	r25, 0x71	; 113
    27ca:	7c c0       	rjmp	.+248    	; 0x28c4 <uip_process+0x728>
    27cc:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <c>
    27d0:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <uip_buf+0x2f>
    27d4:	82 fd       	sbrc	r24, 2
    27d6:	26 c4       	rjmp	.+2124   	; 0x3024 <uip_process+0xe88>
    27d8:	84 e1       	ldi	r24, 0x14	; 20
    27da:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <uip_buf+0x2f>
    27de:	88 e2       	ldi	r24, 0x28	; 40
    27e0:	90 e0       	ldi	r25, 0x00	; 0
    27e2:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    27e6:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    27ea:	80 e5       	ldi	r24, 0x50	; 80
    27ec:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <uip_buf+0x2e>
    27f0:	30 91 a7 07 	lds	r19, 0x07A7	; 0x8007a7 <uip_buf+0x29>
    27f4:	80 91 ab 07 	lds	r24, 0x07AB	; 0x8007ab <uip_buf+0x2d>
    27f8:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <uip_buf+0x29>
    27fc:	20 91 a6 07 	lds	r18, 0x07A6	; 0x8007a6 <uip_buf+0x28>
    2800:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <uip_buf+0x2c>
    2804:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <uip_buf+0x28>
    2808:	20 93 aa 07 	sts	0x07AA, r18	; 0x8007aa <uip_buf+0x2c>
    280c:	90 91 a5 07 	lds	r25, 0x07A5	; 0x8007a5 <uip_buf+0x27>
    2810:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <uip_buf+0x2b>
    2814:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <uip_buf+0x27>
    2818:	90 93 a9 07 	sts	0x07A9, r25	; 0x8007a9 <uip_buf+0x2b>
    281c:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <uip_buf+0x26>
    2820:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <c>
    2824:	40 91 a8 07 	lds	r20, 0x07A8	; 0x8007a8 <uip_buf+0x2a>
    2828:	40 93 a4 07 	sts	0x07A4, r20	; 0x8007a4 <uip_buf+0x26>
    282c:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <uip_buf+0x2a>
    2830:	3f 5f       	subi	r19, 0xFF	; 255
    2832:	30 93 ab 07 	sts	0x07AB, r19	; 0x8007ab <uip_buf+0x2d>
    2836:	31 11       	cpse	r19, r1
    2838:	0d c0       	rjmp	.+26     	; 0x2854 <uip_process+0x6b8>
    283a:	2f 5f       	subi	r18, 0xFF	; 255
    283c:	20 93 aa 07 	sts	0x07AA, r18	; 0x8007aa <uip_buf+0x2c>
    2840:	21 11       	cpse	r18, r1
    2842:	08 c0       	rjmp	.+16     	; 0x2854 <uip_process+0x6b8>
    2844:	9f 5f       	subi	r25, 0xFF	; 255
    2846:	90 93 a9 07 	sts	0x07A9, r25	; 0x8007a9 <uip_buf+0x2b>
    284a:	91 11       	cpse	r25, r1
    284c:	03 c0       	rjmp	.+6      	; 0x2854 <uip_process+0x6b8>
    284e:	8f 5f       	subi	r24, 0xFF	; 255
    2850:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <uip_buf+0x2a>
    2854:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uip_buf+0x22>
    2858:	90 91 a1 07 	lds	r25, 0x07A1	; 0x8007a1 <uip_buf+0x23>
    285c:	90 93 47 03 	sts	0x0347, r25	; 0x800347 <tmp16+0x1>
    2860:	80 93 46 03 	sts	0x0346, r24	; 0x800346 <tmp16>
    2864:	20 91 a2 07 	lds	r18, 0x07A2	; 0x8007a2 <uip_buf+0x24>
    2868:	30 91 a3 07 	lds	r19, 0x07A3	; 0x8007a3 <uip_buf+0x25>
    286c:	30 93 a1 07 	sts	0x07A1, r19	; 0x8007a1 <uip_buf+0x23>
    2870:	20 93 a0 07 	sts	0x07A0, r18	; 0x8007a0 <uip_buf+0x22>
    2874:	90 93 a3 07 	sts	0x07A3, r25	; 0x8007a3 <uip_buf+0x25>
    2878:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <uip_buf+0x24>
    287c:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uip_buf+0x1a>
    2880:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uip_buf+0x1b>
    2884:	a0 91 9a 07 	lds	r26, 0x079A	; 0x80079a <uip_buf+0x1c>
    2888:	b0 91 9b 07 	lds	r27, 0x079B	; 0x80079b <uip_buf+0x1d>
    288c:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uip_buf+0x1e>
    2890:	90 93 9d 07 	sts	0x079D, r25	; 0x80079d <uip_buf+0x1f>
    2894:	a0 93 9e 07 	sts	0x079E, r26	; 0x80079e <uip_buf+0x20>
    2898:	b0 93 9f 07 	sts	0x079F, r27	; 0x80079f <uip_buf+0x21>
    289c:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    28a0:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    28a4:	a0 91 7c 07 	lds	r26, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    28a8:	b0 91 7d 07 	lds	r27, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    28ac:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uip_buf+0x1a>
    28b0:	90 93 99 07 	sts	0x0799, r25	; 0x800799 <uip_buf+0x1b>
    28b4:	a0 93 9a 07 	sts	0x079A, r26	; 0x80079a <uip_buf+0x1c>
    28b8:	b0 93 9b 07 	sts	0x079B, r27	; 0x80079b <uip_buf+0x1d>
    28bc:	77 c3       	rjmp	.+1774   	; 0x2fac <uip_process+0xe10>
    28be:	47 30       	cpi	r20, 0x07	; 7
    28c0:	99 f0       	breq	.+38     	; 0x28e8 <uip_process+0x74c>
    28c2:	8f 5f       	subi	r24, 0xFF	; 255
    28c4:	83 30       	cpi	r24, 0x03	; 3
    28c6:	f1 f0       	breq	.+60     	; 0x2904 <uip_process+0x768>
    28c8:	28 2f       	mov	r18, r24
    28ca:	30 e0       	ldi	r19, 0x00	; 0
    28cc:	92 9f       	mul	r25, r18
    28ce:	f0 01       	movw	r30, r0
    28d0:	93 9f       	mul	r25, r19
    28d2:	f0 0d       	add	r31, r0
    28d4:	11 24       	eor	r1, r1
    28d6:	eb 5e       	subi	r30, 0xEB	; 235
    28d8:	f9 4f       	sbci	r31, 0xF9	; 249
    28da:	41 8d       	ldd	r20, Z+25	; 0x19
    28dc:	41 11       	cpse	r20, r1
    28de:	ef cf       	rjmp	.-34     	; 0x28be <uip_process+0x722>
    28e0:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <c>
    28e4:	ef 01       	movw	r28, r30
    28e6:	13 c0       	rjmp	.+38     	; 0x290e <uip_process+0x772>
    28e8:	20 97       	sbiw	r28, 0x00	; 0
    28ea:	21 f0       	breq	.+8      	; 0x28f4 <uip_process+0x758>
    28ec:	52 8d       	ldd	r21, Z+26	; 0x1a
    28ee:	4a 8d       	ldd	r20, Y+26	; 0x1a
    28f0:	45 17       	cp	r20, r21
    28f2:	38 f7       	brcc	.-50     	; 0x28c2 <uip_process+0x726>
    28f4:	92 9f       	mul	r25, r18
    28f6:	e0 01       	movw	r28, r0
    28f8:	93 9f       	mul	r25, r19
    28fa:	d0 0d       	add	r29, r0
    28fc:	11 24       	eor	r1, r1
    28fe:	cb 5e       	subi	r28, 0xEB	; 235
    2900:	d9 4f       	sbci	r29, 0xF9	; 249
    2902:	df cf       	rjmp	.-66     	; 0x28c2 <uip_process+0x726>
    2904:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <c>
    2908:	20 97       	sbiw	r28, 0x00	; 0
    290a:	09 f4       	brne	.+2      	; 0x290e <uip_process+0x772>
    290c:	8b c3       	rjmp	.+1814   	; 0x3024 <uip_process+0xe88>
    290e:	d0 93 14 06 	sts	0x0614, r29	; 0x800614 <uip_conn+0x1>
    2912:	c0 93 13 06 	sts	0x0613, r28	; 0x800613 <uip_conn>
    2916:	83 e0       	ldi	r24, 0x03	; 3
    2918:	8a 8f       	std	Y+26, r24	; 0x1a
    291a:	88 8f       	std	Y+24, r24	; 0x18
    291c:	1e 8a       	std	Y+22, r1	; 0x16
    291e:	84 e0       	ldi	r24, 0x04	; 4
    2920:	8f 8b       	std	Y+23, r24	; 0x17
    2922:	1b 8e       	std	Y+27, r1	; 0x1b
    2924:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <uip_buf+0x24>
    2928:	90 91 a3 07 	lds	r25, 0x07A3	; 0x8007a3 <uip_buf+0x25>
    292c:	9d 83       	std	Y+5, r25	; 0x05
    292e:	8c 83       	std	Y+4, r24	; 0x04
    2930:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uip_buf+0x22>
    2934:	90 91 a1 07 	lds	r25, 0x07A1	; 0x8007a1 <uip_buf+0x23>
    2938:	9f 83       	std	Y+7, r25	; 0x07
    293a:	8e 83       	std	Y+6, r24	; 0x06
    293c:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uip_buf+0x1a>
    2940:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uip_buf+0x1b>
    2944:	a0 91 9a 07 	lds	r26, 0x079A	; 0x80079a <uip_buf+0x1c>
    2948:	b0 91 9b 07 	lds	r27, 0x079B	; 0x80079b <uip_buf+0x1d>
    294c:	88 83       	st	Y, r24
    294e:	99 83       	std	Y+1, r25	; 0x01
    2950:	aa 83       	std	Y+2, r26	; 0x02
    2952:	bb 83       	std	Y+3, r27	; 0x03
    2954:	81 e0       	ldi	r24, 0x01	; 1
    2956:	89 8f       	std	Y+25, r24	; 0x19
    2958:	80 91 4b 03 	lds	r24, 0x034B	; 0x80034b <iss>
    295c:	8c 87       	std	Y+12, r24	; 0x0c
    295e:	80 91 4c 03 	lds	r24, 0x034C	; 0x80034c <iss+0x1>
    2962:	8d 87       	std	Y+13, r24	; 0x0d
    2964:	80 91 4d 03 	lds	r24, 0x034D	; 0x80034d <iss+0x2>
    2968:	8e 87       	std	Y+14, r24	; 0x0e
    296a:	80 91 4e 03 	lds	r24, 0x034E	; 0x80034e <iss+0x3>
    296e:	8f 87       	std	Y+15, r24	; 0x0f
    2970:	81 e0       	ldi	r24, 0x01	; 1
    2972:	90 e0       	ldi	r25, 0x00	; 0
    2974:	99 8b       	std	Y+17, r25	; 0x11
    2976:	88 8b       	std	Y+16, r24	; 0x10
    2978:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <uip_buf+0x29>
    297c:	8b 87       	std	Y+11, r24	; 0x0b
    297e:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <uip_buf+0x28>
    2982:	8a 87       	std	Y+10, r24	; 0x0a
    2984:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <uip_buf+0x27>
    2988:	89 87       	std	Y+9, r24	; 0x09
    298a:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <uip_buf+0x26>
    298e:	88 87       	std	Y+8, r24	; 0x08
    2990:	81 e0       	ldi	r24, 0x01	; 1
    2992:	90 e0       	ldi	r25, 0x00	; 0
    2994:	24 db       	rcall	.-2488   	; 0x1fde <uip_add_rcv_nxt>
    2996:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <uip_buf+0x2e>
    299a:	98 2f       	mov	r25, r24
    299c:	90 7f       	andi	r25, 0xF0	; 240
    299e:	91 35       	cpi	r25, 0x51	; 81
    29a0:	c8 f1       	brcs	.+114    	; 0x2a14 <uip_process+0x878>
    29a2:	82 95       	swap	r24
    29a4:	8f 70       	andi	r24, 0x0F	; 15
    29a6:	90 e0       	ldi	r25, 0x00	; 0
    29a8:	05 97       	sbiw	r24, 0x05	; 5
    29aa:	88 0f       	add	r24, r24
    29ac:	99 1f       	adc	r25, r25
    29ae:	88 0f       	add	r24, r24
    29b0:	99 1f       	adc	r25, r25
    29b2:	ef 2d       	mov	r30, r15
    29b4:	f0 e0       	ldi	r31, 0x00	; 0
    29b6:	e8 17       	cp	r30, r24
    29b8:	f9 07       	cpc	r31, r25
    29ba:	54 f5       	brge	.+84     	; 0x2a10 <uip_process+0x874>
    29bc:	e2 58       	subi	r30, 0x82	; 130
    29be:	f8 4f       	sbci	r31, 0xF8	; 248
    29c0:	26 a9       	ldd	r18, Z+54	; 0x36
    29c2:	22 23       	and	r18, r18
    29c4:	29 f1       	breq	.+74     	; 0x2a10 <uip_process+0x874>
    29c6:	21 30       	cpi	r18, 0x01	; 1
    29c8:	11 f4       	brne	.+4      	; 0x29ce <uip_process+0x832>
    29ca:	f3 94       	inc	r15
    29cc:	f2 cf       	rjmp	.-28     	; 0x29b2 <uip_process+0x816>
    29ce:	22 30       	cpi	r18, 0x02	; 2
    29d0:	d1 f4       	brne	.+52     	; 0x2a06 <uip_process+0x86a>
    29d2:	27 a9       	ldd	r18, Z+55	; 0x37
    29d4:	24 30       	cpi	r18, 0x04	; 4
    29d6:	b9 f4       	brne	.+46     	; 0x2a06 <uip_process+0x86a>
    29d8:	f0 92 48 03 	sts	0x0348, r15	; 0x800348 <c>
    29dc:	80 ad       	ldd	r24, Z+56	; 0x38
    29de:	90 e0       	ldi	r25, 0x00	; 0
    29e0:	98 2f       	mov	r25, r24
    29e2:	88 27       	eor	r24, r24
    29e4:	21 ad       	ldd	r18, Z+57	; 0x39
    29e6:	82 2b       	or	r24, r18
    29e8:	90 93 47 03 	sts	0x0347, r25	; 0x800347 <tmp16+0x1>
    29ec:	80 93 46 03 	sts	0x0346, r24	; 0x800346 <tmp16>
    29f0:	85 3b       	cpi	r24, 0xB5	; 181
    29f2:	65 e0       	ldi	r22, 0x05	; 5
    29f4:	96 07       	cpc	r25, r22
    29f6:	10 f0       	brcs	.+4      	; 0x29fc <uip_process+0x860>
    29f8:	84 eb       	ldi	r24, 0xB4	; 180
    29fa:	95 e0       	ldi	r25, 0x05	; 5
    29fc:	9b 8b       	std	Y+19, r25	; 0x13
    29fe:	8a 8b       	std	Y+18, r24	; 0x12
    2a00:	9d 8b       	std	Y+21, r25	; 0x15
    2a02:	8c 8b       	std	Y+20, r24	; 0x14
    2a04:	07 c0       	rjmp	.+14     	; 0x2a14 <uip_process+0x878>
    2a06:	27 a9       	ldd	r18, Z+55	; 0x37
    2a08:	22 23       	and	r18, r18
    2a0a:	11 f0       	breq	.+4      	; 0x2a10 <uip_process+0x874>
    2a0c:	f2 0e       	add	r15, r18
    2a0e:	d1 cf       	rjmp	.-94     	; 0x29b2 <uip_process+0x816>
    2a10:	f0 92 48 03 	sts	0x0348, r15	; 0x800348 <c>
    2a14:	80 e1       	ldi	r24, 0x10	; 16
    2a16:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <uip_buf+0x2f>
    2a1a:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <uip_buf+0x2f>
    2a1e:	82 60       	ori	r24, 0x02	; 2
    2a20:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <uip_buf+0x2f>
    2a24:	82 e0       	ldi	r24, 0x02	; 2
    2a26:	80 93 b4 07 	sts	0x07B4, r24	; 0x8007b4 <uip_buf+0x36>
    2a2a:	84 e0       	ldi	r24, 0x04	; 4
    2a2c:	80 93 b5 07 	sts	0x07B5, r24	; 0x8007b5 <uip_buf+0x37>
    2a30:	85 e0       	ldi	r24, 0x05	; 5
    2a32:	80 93 b6 07 	sts	0x07B6, r24	; 0x8007b6 <uip_buf+0x38>
    2a36:	84 eb       	ldi	r24, 0xB4	; 180
    2a38:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <uip_buf+0x39>
    2a3c:	8c e2       	ldi	r24, 0x2C	; 44
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
    2a40:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    2a44:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    2a48:	80 e6       	ldi	r24, 0x60	; 96
    2a4a:	5d c2       	rjmp	.+1210   	; 0x2f06 <uip_process+0xd6a>
    2a4c:	d0 93 14 06 	sts	0x0614, r29	; 0x800614 <uip_conn+0x1>
    2a50:	c0 93 13 06 	sts	0x0613, r28	; 0x800613 <uip_conn>
    2a54:	10 92 0e 06 	sts	0x060E, r1	; 0x80060e <uip_flags>
    2a58:	90 91 ad 07 	lds	r25, 0x07AD	; 0x8007ad <uip_buf+0x2f>
    2a5c:	79 2f       	mov	r23, r25
    2a5e:	74 70       	andi	r23, 0x04	; 4
    2a60:	f7 2e       	mov	r15, r23
    2a62:	92 ff       	sbrs	r25, 2
    2a64:	03 c0       	rjmp	.+6      	; 0x2a6c <uip_process+0x8d0>
    2a66:	19 8e       	std	Y+25, r1	; 0x19
    2a68:	80 e2       	ldi	r24, 0x20	; 32
    2a6a:	f9 c1       	rjmp	.+1010   	; 0x2e5e <uip_process+0xcc2>
    2a6c:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <uip_buf+0x2e>
    2a70:	82 95       	swap	r24
    2a72:	8f 70       	andi	r24, 0x0F	; 15
    2a74:	88 0f       	add	r24, r24
    2a76:	88 0f       	add	r24, r24
    2a78:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <c>
    2a7c:	08 1b       	sub	r16, r24
    2a7e:	11 09       	sbc	r17, r1
    2a80:	04 51       	subi	r16, 0x14	; 20
    2a82:	11 09       	sbc	r17, r1
    2a84:	10 93 07 06 	sts	0x0607, r17	; 0x800607 <uip_len+0x1>
    2a88:	00 93 06 06 	sts	0x0606, r16	; 0x800606 <uip_len>
    2a8c:	2f 70       	andi	r18, 0x0F	; 15
    2a8e:	22 30       	cpi	r18, 0x02	; 2
    2a90:	21 f4       	brne	.+8      	; 0x2a9a <uip_process+0x8fe>
    2a92:	89 2f       	mov	r24, r25
    2a94:	8f 73       	andi	r24, 0x3F	; 63
    2a96:	82 31       	cpi	r24, 0x12	; 18
    2a98:	c9 f0       	breq	.+50     	; 0x2acc <uip_process+0x930>
    2a9a:	01 2b       	or	r16, r17
    2a9c:	19 f4       	brne	.+6      	; 0x2aa4 <uip_process+0x908>
    2a9e:	89 2f       	mov	r24, r25
    2aa0:	83 70       	andi	r24, 0x03	; 3
    2aa2:	a1 f0       	breq	.+40     	; 0x2acc <uip_process+0x930>
    2aa4:	20 91 a4 07 	lds	r18, 0x07A4	; 0x8007a4 <uip_buf+0x26>
    2aa8:	88 85       	ldd	r24, Y+8	; 0x08
    2aaa:	28 13       	cpse	r18, r24
    2aac:	22 c2       	rjmp	.+1092   	; 0x2ef2 <uip_process+0xd56>
    2aae:	20 91 a5 07 	lds	r18, 0x07A5	; 0x8007a5 <uip_buf+0x27>
    2ab2:	89 85       	ldd	r24, Y+9	; 0x09
    2ab4:	28 13       	cpse	r18, r24
    2ab6:	1d c2       	rjmp	.+1082   	; 0x2ef2 <uip_process+0xd56>
    2ab8:	20 91 a6 07 	lds	r18, 0x07A6	; 0x8007a6 <uip_buf+0x28>
    2abc:	8a 85       	ldd	r24, Y+10	; 0x0a
    2abe:	28 13       	cpse	r18, r24
    2ac0:	18 c2       	rjmp	.+1072   	; 0x2ef2 <uip_process+0xd56>
    2ac2:	20 91 a7 07 	lds	r18, 0x07A7	; 0x8007a7 <uip_buf+0x29>
    2ac6:	8b 85       	ldd	r24, Y+11	; 0x0b
    2ac8:	28 13       	cpse	r18, r24
    2aca:	13 c2       	rjmp	.+1062   	; 0x2ef2 <uip_process+0xd56>
    2acc:	94 ff       	sbrs	r25, 4
    2ace:	48 c0       	rjmp	.+144    	; 0x2b60 <uip_process+0x9c4>
    2ad0:	68 89       	ldd	r22, Y+16	; 0x10
    2ad2:	79 89       	ldd	r23, Y+17	; 0x11
    2ad4:	61 15       	cp	r22, r1
    2ad6:	71 05       	cpc	r23, r1
    2ad8:	09 f4       	brne	.+2      	; 0x2adc <uip_process+0x940>
    2ada:	42 c0       	rjmp	.+132    	; 0x2b60 <uip_process+0x9c4>
    2adc:	ce 01       	movw	r24, r28
    2ade:	0c 96       	adiw	r24, 0x0c	; 12
    2ae0:	48 da       	rcall	.-2928   	; 0x1f72 <uip_add32>
    2ae2:	30 91 a8 07 	lds	r19, 0x07A8	; 0x8007a8 <uip_buf+0x2a>
    2ae6:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uip_acc32>
    2aea:	38 13       	cpse	r19, r24
    2aec:	39 c0       	rjmp	.+114    	; 0x2b60 <uip_process+0x9c4>
    2aee:	20 91 a9 07 	lds	r18, 0x07A9	; 0x8007a9 <uip_buf+0x2b>
    2af2:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <uip_acc32+0x1>
    2af6:	28 13       	cpse	r18, r24
    2af8:	33 c0       	rjmp	.+102    	; 0x2b60 <uip_process+0x9c4>
    2afa:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <uip_buf+0x2c>
    2afe:	80 91 0c 06 	lds	r24, 0x060C	; 0x80060c <uip_acc32+0x2>
    2b02:	98 13       	cpse	r25, r24
    2b04:	2d c0       	rjmp	.+90     	; 0x2b60 <uip_process+0x9c4>
    2b06:	80 91 ab 07 	lds	r24, 0x07AB	; 0x8007ab <uip_buf+0x2d>
    2b0a:	40 91 0d 06 	lds	r20, 0x060D	; 0x80060d <uip_acc32+0x3>
    2b0e:	84 13       	cpse	r24, r20
    2b10:	27 c0       	rjmp	.+78     	; 0x2b60 <uip_process+0x9c4>
    2b12:	3c 87       	std	Y+12, r19	; 0x0c
    2b14:	2d 87       	std	Y+13, r18	; 0x0d
    2b16:	9e 87       	std	Y+14, r25	; 0x0e
    2b18:	8f 87       	std	Y+15, r24	; 0x0f
    2b1a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2b1c:	81 11       	cpse	r24, r1
    2b1e:	19 c0       	rjmp	.+50     	; 0x2b52 <uip_process+0x9b6>
    2b20:	9e 89       	ldd	r25, Y+22	; 0x16
    2b22:	88 8d       	ldd	r24, Y+24	; 0x18
    2b24:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2b26:	82 1b       	sub	r24, r18
    2b28:	29 2f       	mov	r18, r25
    2b2a:	26 95       	lsr	r18
    2b2c:	26 95       	lsr	r18
    2b2e:	26 95       	lsr	r18
    2b30:	82 1b       	sub	r24, r18
    2b32:	98 0f       	add	r25, r24
    2b34:	9e 8b       	std	Y+22, r25	; 0x16
    2b36:	87 fd       	sbrc	r24, 7
    2b38:	81 95       	neg	r24
    2b3a:	2f 89       	ldd	r18, Y+23	; 0x17
    2b3c:	32 2f       	mov	r19, r18
    2b3e:	36 95       	lsr	r19
    2b40:	36 95       	lsr	r19
    2b42:	23 1b       	sub	r18, r19
    2b44:	82 0f       	add	r24, r18
    2b46:	8f 8b       	std	Y+23, r24	; 0x17
    2b48:	96 95       	lsr	r25
    2b4a:	96 95       	lsr	r25
    2b4c:	96 95       	lsr	r25
    2b4e:	89 0f       	add	r24, r25
    2b50:	88 8f       	std	Y+24, r24	; 0x18
    2b52:	81 e0       	ldi	r24, 0x01	; 1
    2b54:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2b58:	88 8d       	ldd	r24, Y+24	; 0x18
    2b5a:	8a 8f       	std	Y+26, r24	; 0x1a
    2b5c:	19 8a       	std	Y+17, r1	; 0x11
    2b5e:	18 8a       	std	Y+16, r1	; 0x10
    2b60:	29 8d       	ldd	r18, Y+25	; 0x19
    2b62:	e2 2f       	mov	r30, r18
    2b64:	ef 70       	andi	r30, 0x0F	; 15
    2b66:	8e 2f       	mov	r24, r30
    2b68:	90 e0       	ldi	r25, 0x00	; 0
    2b6a:	fc 01       	movw	r30, r24
    2b6c:	31 97       	sbiw	r30, 0x01	; 1
    2b6e:	e8 30       	cpi	r30, 0x08	; 8
    2b70:	f1 05       	cpc	r31, r1
    2b72:	08 f0       	brcs	.+2      	; 0x2b76 <uip_process+0x9da>
    2b74:	57 c2       	rjmp	.+1198   	; 0x3024 <uip_process+0xe88>
    2b76:	e4 5b       	subi	r30, 0xB4	; 180
    2b78:	ff 4f       	sbci	r31, 0xFF	; 255
    2b7a:	0c 94 da 39 	jmp	0x73b4	; 0x73b4 <__tablejump2__>
    2b7e:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2b82:	80 ff       	sbrs	r24, 0
    2b84:	4f c2       	rjmp	.+1182   	; 0x3024 <uip_process+0xe88>
    2b86:	83 e0       	ldi	r24, 0x03	; 3
    2b88:	89 8f       	std	Y+25, r24	; 0x19
    2b8a:	80 e4       	ldi	r24, 0x40	; 64
    2b8c:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2b90:	19 8a       	std	Y+17, r1	; 0x11
    2b92:	18 8a       	std	Y+16, r1	; 0x10
    2b94:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    2b98:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    2b9c:	00 97       	sbiw	r24, 0x00	; 0
    2b9e:	09 f4       	brne	.+2      	; 0x2ba2 <uip_process+0xa06>
    2ba0:	f0 c0       	rjmp	.+480    	; 0x2d82 <uip_process+0xbe6>
    2ba2:	22 e4       	ldi	r18, 0x42	; 66
    2ba4:	20 93 0e 06 	sts	0x060E, r18	; 0x80060e <uip_flags>
    2ba8:	1a da       	rcall	.-3020   	; 0x1fde <uip_add_rcv_nxt>
    2baa:	eb c0       	rjmp	.+470    	; 0x2d82 <uip_process+0xbe6>
    2bac:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2bb0:	80 ff       	sbrs	r24, 0
    2bb2:	60 c0       	rjmp	.+192    	; 0x2c74 <uip_process+0xad8>
    2bb4:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <uip_buf+0x2f>
    2bb8:	8f 73       	andi	r24, 0x3F	; 63
    2bba:	82 31       	cpi	r24, 0x12	; 18
    2bbc:	09 f0       	breq	.+2      	; 0x2bc0 <uip_process+0xa24>
    2bbe:	5a c0       	rjmp	.+180    	; 0x2c74 <uip_process+0xad8>
    2bc0:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <uip_buf+0x2e>
    2bc4:	98 2f       	mov	r25, r24
    2bc6:	90 7f       	andi	r25, 0xF0	; 240
    2bc8:	91 35       	cpi	r25, 0x51	; 81
    2bca:	c8 f1       	brcs	.+114    	; 0x2c3e <uip_process+0xaa2>
    2bcc:	82 95       	swap	r24
    2bce:	8f 70       	andi	r24, 0x0F	; 15
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	05 97       	sbiw	r24, 0x05	; 5
    2bd4:	88 0f       	add	r24, r24
    2bd6:	99 1f       	adc	r25, r25
    2bd8:	88 0f       	add	r24, r24
    2bda:	99 1f       	adc	r25, r25
    2bdc:	ef 2d       	mov	r30, r15
    2bde:	f0 e0       	ldi	r31, 0x00	; 0
    2be0:	e8 17       	cp	r30, r24
    2be2:	f9 07       	cpc	r31, r25
    2be4:	54 f5       	brge	.+84     	; 0x2c3a <uip_process+0xa9e>
    2be6:	e2 58       	subi	r30, 0x82	; 130
    2be8:	f8 4f       	sbci	r31, 0xF8	; 248
    2bea:	26 a9       	ldd	r18, Z+54	; 0x36
    2bec:	22 23       	and	r18, r18
    2bee:	29 f1       	breq	.+74     	; 0x2c3a <uip_process+0xa9e>
    2bf0:	21 30       	cpi	r18, 0x01	; 1
    2bf2:	11 f4       	brne	.+4      	; 0x2bf8 <uip_process+0xa5c>
    2bf4:	f3 94       	inc	r15
    2bf6:	f2 cf       	rjmp	.-28     	; 0x2bdc <uip_process+0xa40>
    2bf8:	22 30       	cpi	r18, 0x02	; 2
    2bfa:	d1 f4       	brne	.+52     	; 0x2c30 <uip_process+0xa94>
    2bfc:	27 a9       	ldd	r18, Z+55	; 0x37
    2bfe:	24 30       	cpi	r18, 0x04	; 4
    2c00:	b9 f4       	brne	.+46     	; 0x2c30 <uip_process+0xa94>
    2c02:	f0 92 48 03 	sts	0x0348, r15	; 0x800348 <c>
    2c06:	80 ad       	ldd	r24, Z+56	; 0x38
    2c08:	90 e0       	ldi	r25, 0x00	; 0
    2c0a:	98 2f       	mov	r25, r24
    2c0c:	88 27       	eor	r24, r24
    2c0e:	21 ad       	ldd	r18, Z+57	; 0x39
    2c10:	82 2b       	or	r24, r18
    2c12:	90 93 47 03 	sts	0x0347, r25	; 0x800347 <tmp16+0x1>
    2c16:	80 93 46 03 	sts	0x0346, r24	; 0x800346 <tmp16>
    2c1a:	85 3b       	cpi	r24, 0xB5	; 181
    2c1c:	25 e0       	ldi	r18, 0x05	; 5
    2c1e:	92 07       	cpc	r25, r18
    2c20:	10 f0       	brcs	.+4      	; 0x2c26 <uip_process+0xa8a>
    2c22:	84 eb       	ldi	r24, 0xB4	; 180
    2c24:	95 e0       	ldi	r25, 0x05	; 5
    2c26:	9b 8b       	std	Y+19, r25	; 0x13
    2c28:	8a 8b       	std	Y+18, r24	; 0x12
    2c2a:	9d 8b       	std	Y+21, r25	; 0x15
    2c2c:	8c 8b       	std	Y+20, r24	; 0x14
    2c2e:	07 c0       	rjmp	.+14     	; 0x2c3e <uip_process+0xaa2>
    2c30:	27 a9       	ldd	r18, Z+55	; 0x37
    2c32:	22 23       	and	r18, r18
    2c34:	11 f0       	breq	.+4      	; 0x2c3a <uip_process+0xa9e>
    2c36:	f2 0e       	add	r15, r18
    2c38:	d1 cf       	rjmp	.-94     	; 0x2bdc <uip_process+0xa40>
    2c3a:	f0 92 48 03 	sts	0x0348, r15	; 0x800348 <c>
    2c3e:	83 e0       	ldi	r24, 0x03	; 3
    2c40:	89 8f       	std	Y+25, r24	; 0x19
    2c42:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <uip_buf+0x26>
    2c46:	88 87       	std	Y+8, r24	; 0x08
    2c48:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <uip_buf+0x27>
    2c4c:	89 87       	std	Y+9, r24	; 0x09
    2c4e:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <uip_buf+0x28>
    2c52:	8a 87       	std	Y+10, r24	; 0x0a
    2c54:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <uip_buf+0x29>
    2c58:	8b 87       	std	Y+11, r24	; 0x0b
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	bf d9       	rcall	.-3202   	; 0x1fde <uip_add_rcv_nxt>
    2c60:	82 e4       	ldi	r24, 0x42	; 66
    2c62:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2c66:	19 8a       	std	Y+17, r1	; 0x11
    2c68:	18 8a       	std	Y+16, r1	; 0x10
    2c6a:	10 92 07 06 	sts	0x0607, r1	; 0x800607 <uip_len+0x1>
    2c6e:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <uip_len>
    2c72:	87 c0       	rjmp	.+270    	; 0x2d82 <uip_process+0xbe6>
    2c74:	80 e2       	ldi	r24, 0x20	; 32
    2c76:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2c7a:	0e 94 73 09 	call	0x12e6	; 0x12e6 <uIPManagement_TCPCallback>
    2c7e:	e0 91 13 06 	lds	r30, 0x0613	; 0x800613 <uip_conn>
    2c82:	f0 91 14 06 	lds	r31, 0x0614	; 0x800614 <uip_conn+0x1>
    2c86:	11 8e       	std	Z+25, r1	; 0x19
    2c88:	a3 cd       	rjmp	.-1210   	; 0x27d0 <uip_process+0x634>
    2c8a:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <uip_buf+0x2f>
    2c8e:	80 ff       	sbrs	r24, 0
    2c90:	27 c0       	rjmp	.+78     	; 0x2ce0 <uip_process+0xb44>
    2c92:	24 fd       	sbrc	r18, 4
    2c94:	25 c0       	rjmp	.+74     	; 0x2ce0 <uip_process+0xb44>
    2c96:	88 89       	ldd	r24, Y+16	; 0x10
    2c98:	99 89       	ldd	r25, Y+17	; 0x11
    2c9a:	89 2b       	or	r24, r25
    2c9c:	09 f0       	breq	.+2      	; 0x2ca0 <uip_process+0xb04>
    2c9e:	c2 c1       	rjmp	.+900    	; 0x3024 <uip_process+0xe88>
    2ca0:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    2ca4:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    2ca8:	01 96       	adiw	r24, 0x01	; 1
    2caa:	99 d9       	rcall	.-3278   	; 0x1fde <uip_add_rcv_nxt>
    2cac:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2cb0:	98 2f       	mov	r25, r24
    2cb2:	90 61       	ori	r25, 0x10	; 16
    2cb4:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <uip_flags>
    2cb8:	20 91 06 06 	lds	r18, 0x0606	; 0x800606 <uip_len>
    2cbc:	30 91 07 06 	lds	r19, 0x0607	; 0x800607 <uip_len+0x1>
    2cc0:	23 2b       	or	r18, r19
    2cc2:	19 f0       	breq	.+6      	; 0x2cca <uip_process+0xb2e>
    2cc4:	82 61       	ori	r24, 0x12	; 18
    2cc6:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2cca:	0e 94 73 09 	call	0x12e6	; 0x12e6 <uIPManagement_TCPCallback>
    2cce:	81 e0       	ldi	r24, 0x01	; 1
    2cd0:	90 e0       	ldi	r25, 0x00	; 0
    2cd2:	99 8b       	std	Y+17, r25	; 0x11
    2cd4:	88 8b       	std	Y+16, r24	; 0x10
    2cd6:	88 e0       	ldi	r24, 0x08	; 8
    2cd8:	89 8f       	std	Y+25, r24	; 0x19
    2cda:	1b 8e       	std	Y+27, r1	; 0x1b
    2cdc:	81 e1       	ldi	r24, 0x11	; 17
    2cde:	0a c1       	rjmp	.+532    	; 0x2ef4 <uip_process+0xd58>
    2ce0:	85 ff       	sbrs	r24, 5
    2ce2:	1c c0       	rjmp	.+56     	; 0x2d1c <uip_process+0xb80>
    2ce4:	80 91 b2 07 	lds	r24, 0x07B2	; 0x8007b2 <uip_buf+0x34>
    2ce8:	90 91 b3 07 	lds	r25, 0x07B3	; 0x8007b3 <uip_buf+0x35>
    2cec:	98 27       	eor	r25, r24
    2cee:	89 27       	eor	r24, r25
    2cf0:	98 27       	eor	r25, r24
    2cf2:	40 91 11 06 	lds	r20, 0x0611	; 0x800611 <uip_appdata>
    2cf6:	50 91 12 06 	lds	r21, 0x0612	; 0x800612 <uip_appdata+0x1>
    2cfa:	48 0f       	add	r20, r24
    2cfc:	59 1f       	adc	r21, r25
    2cfe:	50 93 12 06 	sts	0x0612, r21	; 0x800612 <uip_appdata+0x1>
    2d02:	40 93 11 06 	sts	0x0611, r20	; 0x800611 <uip_appdata>
    2d06:	40 91 06 06 	lds	r20, 0x0606	; 0x800606 <uip_len>
    2d0a:	50 91 07 06 	lds	r21, 0x0607	; 0x800607 <uip_len+0x1>
    2d0e:	ba 01       	movw	r22, r20
    2d10:	68 1b       	sub	r22, r24
    2d12:	79 0b       	sbc	r23, r25
    2d14:	70 93 07 06 	sts	0x0607, r23	; 0x800607 <uip_len+0x1>
    2d18:	60 93 06 06 	sts	0x0606, r22	; 0x800606 <uip_len>
    2d1c:	40 91 06 06 	lds	r20, 0x0606	; 0x800606 <uip_len>
    2d20:	50 91 07 06 	lds	r21, 0x0607	; 0x800607 <uip_len+0x1>
    2d24:	41 15       	cp	r20, r1
    2d26:	51 05       	cpc	r21, r1
    2d28:	49 f0       	breq	.+18     	; 0x2d3c <uip_process+0xba0>
    2d2a:	24 fd       	sbrc	r18, 4
    2d2c:	07 c0       	rjmp	.+14     	; 0x2d3c <uip_process+0xba0>
    2d2e:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <uip_flags>
    2d32:	92 60       	ori	r25, 0x02	; 2
    2d34:	90 93 0e 06 	sts	0x060E, r25	; 0x80060e <uip_flags>
    2d38:	ca 01       	movw	r24, r20
    2d3a:	51 d9       	rcall	.-3422   	; 0x1fde <uip_add_rcv_nxt>
    2d3c:	80 91 ae 07 	lds	r24, 0x07AE	; 0x8007ae <uip_buf+0x30>
    2d40:	90 e0       	ldi	r25, 0x00	; 0
    2d42:	98 2f       	mov	r25, r24
    2d44:	88 27       	eor	r24, r24
    2d46:	20 91 af 07 	lds	r18, 0x07AF	; 0x8007af <uip_buf+0x31>
    2d4a:	82 0f       	add	r24, r18
    2d4c:	91 1d       	adc	r25, r1
    2d4e:	90 93 47 03 	sts	0x0347, r25	; 0x800347 <tmp16+0x1>
    2d52:	80 93 46 03 	sts	0x0346, r24	; 0x800346 <tmp16>
    2d56:	2c 89       	ldd	r18, Y+20	; 0x14
    2d58:	3d 89       	ldd	r19, Y+21	; 0x15
    2d5a:	28 17       	cp	r18, r24
    2d5c:	39 07       	cpc	r19, r25
    2d5e:	10 f0       	brcs	.+4      	; 0x2d64 <uip_process+0xbc8>
    2d60:	89 2b       	or	r24, r25
    2d62:	21 f4       	brne	.+8      	; 0x2d6c <uip_process+0xbd0>
    2d64:	30 93 47 03 	sts	0x0347, r19	; 0x800347 <tmp16+0x1>
    2d68:	20 93 46 03 	sts	0x0346, r18	; 0x800346 <tmp16>
    2d6c:	80 91 46 03 	lds	r24, 0x0346	; 0x800346 <tmp16>
    2d70:	90 91 47 03 	lds	r25, 0x0347	; 0x800347 <tmp16+0x1>
    2d74:	9b 8b       	std	Y+19, r25	; 0x13
    2d76:	8a 8b       	std	Y+18, r24	; 0x12
    2d78:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2d7c:	83 70       	andi	r24, 0x03	; 3
    2d7e:	09 f4       	brne	.+2      	; 0x2d82 <uip_process+0xbe6>
    2d80:	51 c1       	rjmp	.+674    	; 0x3024 <uip_process+0xe88>
    2d82:	10 92 6b 0d 	sts	0x0D6B, r1	; 0x800d6b <uip_slen+0x1>
    2d86:	10 92 6a 0d 	sts	0x0D6A, r1	; 0x800d6a <uip_slen>
    2d8a:	0e 94 73 09 	call	0x12e6	; 0x12e6 <uIPManagement_TCPCallback>
    2d8e:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2d92:	85 ff       	sbrs	r24, 5
    2d94:	07 c0       	rjmp	.+14     	; 0x2da4 <uip_process+0xc08>
    2d96:	10 92 6b 0d 	sts	0x0D6B, r1	; 0x800d6b <uip_slen+0x1>
    2d9a:	10 92 6a 0d 	sts	0x0D6A, r1	; 0x800d6a <uip_slen>
    2d9e:	19 8e       	std	Y+25, r1	; 0x19
    2da0:	84 e1       	ldi	r24, 0x14	; 20
    2da2:	a8 c0       	rjmp	.+336    	; 0x2ef4 <uip_process+0xd58>
    2da4:	84 ff       	sbrs	r24, 4
    2da6:	0a c0       	rjmp	.+20     	; 0x2dbc <uip_process+0xc20>
    2da8:	10 92 6b 0d 	sts	0x0D6B, r1	; 0x800d6b <uip_slen+0x1>
    2dac:	10 92 6a 0d 	sts	0x0D6A, r1	; 0x800d6a <uip_slen>
    2db0:	81 e0       	ldi	r24, 0x01	; 1
    2db2:	90 e0       	ldi	r25, 0x00	; 0
    2db4:	99 8b       	std	Y+17, r25	; 0x11
    2db6:	88 8b       	std	Y+16, r24	; 0x10
    2db8:	84 e0       	ldi	r24, 0x04	; 4
    2dba:	8e cf       	rjmp	.-228    	; 0x2cd8 <uip_process+0xb3c>
    2dbc:	20 91 6a 0d 	lds	r18, 0x0D6A	; 0x800d6a <uip_slen>
    2dc0:	30 91 6b 0d 	lds	r19, 0x0D6B	; 0x800d6b <uip_slen+0x1>
    2dc4:	21 15       	cp	r18, r1
    2dc6:	31 05       	cpc	r19, r1
    2dc8:	e1 f0       	breq	.+56     	; 0x2e02 <uip_process+0xc66>
    2dca:	80 ff       	sbrs	r24, 0
    2dcc:	02 c0       	rjmp	.+4      	; 0x2dd2 <uip_process+0xc36>
    2dce:	19 8a       	std	Y+17, r1	; 0x11
    2dd0:	18 8a       	std	Y+16, r1	; 0x10
    2dd2:	88 89       	ldd	r24, Y+16	; 0x10
    2dd4:	99 89       	ldd	r25, Y+17	; 0x11
    2dd6:	00 97       	sbiw	r24, 0x00	; 0
    2dd8:	81 f4       	brne	.+32     	; 0x2dfa <uip_process+0xc5e>
    2dda:	8a 89       	ldd	r24, Y+18	; 0x12
    2ddc:	9b 89       	ldd	r25, Y+19	; 0x13
    2dde:	82 17       	cp	r24, r18
    2de0:	93 07       	cpc	r25, r19
    2de2:	20 f4       	brcc	.+8      	; 0x2dec <uip_process+0xc50>
    2de4:	90 93 6b 0d 	sts	0x0D6B, r25	; 0x800d6b <uip_slen+0x1>
    2de8:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uip_slen>
    2dec:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uip_slen>
    2df0:	90 91 6b 0d 	lds	r25, 0x0D6B	; 0x800d6b <uip_slen+0x1>
    2df4:	99 8b       	std	Y+17, r25	; 0x11
    2df6:	88 8b       	std	Y+16, r24	; 0x10
    2df8:	04 c0       	rjmp	.+8      	; 0x2e02 <uip_process+0xc66>
    2dfa:	90 93 6b 0d 	sts	0x0D6B, r25	; 0x800d6b <uip_slen+0x1>
    2dfe:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uip_slen>
    2e02:	1b 8e       	std	Y+27, r1	; 0x1b
    2e04:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <uip_sappdata>
    2e08:	90 91 09 06 	lds	r25, 0x0609	; 0x800609 <uip_sappdata+0x1>
    2e0c:	90 93 12 06 	sts	0x0612, r25	; 0x800612 <uip_appdata+0x1>
    2e10:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <uip_appdata>
    2e14:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uip_slen>
    2e18:	90 91 6b 0d 	lds	r25, 0x0D6B	; 0x800d6b <uip_slen+0x1>
    2e1c:	89 2b       	or	r24, r25
    2e1e:	59 f0       	breq	.+22     	; 0x2e36 <uip_process+0xc9a>
    2e20:	88 89       	ldd	r24, Y+16	; 0x10
    2e22:	99 89       	ldd	r25, Y+17	; 0x11
    2e24:	00 97       	sbiw	r24, 0x00	; 0
    2e26:	39 f0       	breq	.+14     	; 0x2e36 <uip_process+0xc9a>
    2e28:	88 96       	adiw	r24, 0x28	; 40
    2e2a:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    2e2e:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    2e32:	88 e1       	ldi	r24, 0x18	; 24
    2e34:	0b c0       	rjmp	.+22     	; 0x2e4c <uip_process+0xcb0>
    2e36:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2e3a:	81 ff       	sbrs	r24, 1
    2e3c:	f3 c0       	rjmp	.+486    	; 0x3024 <uip_process+0xe88>
    2e3e:	88 e2       	ldi	r24, 0x28	; 40
    2e40:	90 e0       	ldi	r25, 0x00	; 0
    2e42:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    2e46:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    2e4a:	80 e1       	ldi	r24, 0x10	; 16
    2e4c:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <uip_buf+0x2f>
    2e50:	59 c0       	rjmp	.+178    	; 0x2f04 <uip_process+0xd68>
    2e52:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2e56:	80 ff       	sbrs	r24, 0
    2e58:	e5 c0       	rjmp	.+458    	; 0x3024 <uip_process+0xe88>
    2e5a:	19 8e       	std	Y+25, r1	; 0x19
    2e5c:	80 e1       	ldi	r24, 0x10	; 16
    2e5e:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2e62:	0e 94 73 09 	call	0x12e6	; 0x12e6 <uIPManagement_TCPCallback>
    2e66:	de c0       	rjmp	.+444    	; 0x3024 <uip_process+0xe88>
    2e68:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    2e6c:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    2e70:	00 97       	sbiw	r24, 0x00	; 0
    2e72:	09 f0       	breq	.+2      	; 0x2e76 <uip_process+0xcda>
    2e74:	b4 d8       	rcall	.-3736   	; 0x1fde <uip_add_rcv_nxt>
    2e76:	90 91 ad 07 	lds	r25, 0x07AD	; 0x8007ad <uip_buf+0x2f>
    2e7a:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2e7e:	90 ff       	sbrs	r25, 0
    2e80:	0b c0       	rjmp	.+22     	; 0x2e98 <uip_process+0xcfc>
    2e82:	80 ff       	sbrs	r24, 0
    2e84:	06 c0       	rjmp	.+12     	; 0x2e92 <uip_process+0xcf6>
    2e86:	87 e0       	ldi	r24, 0x07	; 7
    2e88:	89 8f       	std	Y+25, r24	; 0x19
    2e8a:	1a 8e       	std	Y+26, r1	; 0x1a
    2e8c:	19 8a       	std	Y+17, r1	; 0x11
    2e8e:	18 8a       	std	Y+16, r1	; 0x10
    2e90:	18 c0       	rjmp	.+48     	; 0x2ec2 <uip_process+0xd26>
    2e92:	86 e0       	ldi	r24, 0x06	; 6
    2e94:	89 8f       	std	Y+25, r24	; 0x19
    2e96:	15 c0       	rjmp	.+42     	; 0x2ec2 <uip_process+0xd26>
    2e98:	80 ff       	sbrs	r24, 0
    2e9a:	1c c0       	rjmp	.+56     	; 0x2ed4 <uip_process+0xd38>
    2e9c:	85 e0       	ldi	r24, 0x05	; 5
    2e9e:	89 8f       	std	Y+25, r24	; 0x19
    2ea0:	19 8a       	std	Y+17, r1	; 0x11
    2ea2:	18 8a       	std	Y+16, r1	; 0x10
    2ea4:	bf c0       	rjmp	.+382    	; 0x3024 <uip_process+0xe88>
    2ea6:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    2eaa:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    2eae:	00 97       	sbiw	r24, 0x00	; 0
    2eb0:	09 f0       	breq	.+2      	; 0x2eb4 <uip_process+0xd18>
    2eb2:	95 d8       	rcall	.-3798   	; 0x1fde <uip_add_rcv_nxt>
    2eb4:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <uip_buf+0x2f>
    2eb8:	80 ff       	sbrs	r24, 0
    2eba:	0c c0       	rjmp	.+24     	; 0x2ed4 <uip_process+0xd38>
    2ebc:	87 e0       	ldi	r24, 0x07	; 7
    2ebe:	89 8f       	std	Y+25, r24	; 0x19
    2ec0:	1a 8e       	std	Y+26, r1	; 0x1a
    2ec2:	81 e0       	ldi	r24, 0x01	; 1
    2ec4:	90 e0       	ldi	r25, 0x00	; 0
    2ec6:	8b d8       	rcall	.-3818   	; 0x1fde <uip_add_rcv_nxt>
    2ec8:	80 e1       	ldi	r24, 0x10	; 16
    2eca:	80 93 0e 06 	sts	0x060E, r24	; 0x80060e <uip_flags>
    2ece:	0e 94 73 09 	call	0x12e6	; 0x12e6 <uIPManagement_TCPCallback>
    2ed2:	0f c0       	rjmp	.+30     	; 0x2ef2 <uip_process+0xd56>
    2ed4:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    2ed8:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    2edc:	89 2b       	or	r24, r25
    2ede:	49 f4       	brne	.+18     	; 0x2ef2 <uip_process+0xd56>
    2ee0:	a1 c0       	rjmp	.+322    	; 0x3024 <uip_process+0xe88>
    2ee2:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <uip_flags>
    2ee6:	80 ff       	sbrs	r24, 0
    2ee8:	9d c0       	rjmp	.+314    	; 0x3024 <uip_process+0xe88>
    2eea:	87 e0       	ldi	r24, 0x07	; 7
    2eec:	89 8f       	std	Y+25, r24	; 0x19
    2eee:	1a 8e       	std	Y+26, r1	; 0x1a
    2ef0:	99 c0       	rjmp	.+306    	; 0x3024 <uip_process+0xe88>
    2ef2:	80 e1       	ldi	r24, 0x10	; 16
    2ef4:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <uip_buf+0x2f>
    2ef8:	88 e2       	ldi	r24, 0x28	; 40
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    2f00:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    2f04:	80 e5       	ldi	r24, 0x50	; 80
    2f06:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <uip_buf+0x2e>
    2f0a:	88 85       	ldd	r24, Y+8	; 0x08
    2f0c:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <uip_buf+0x2a>
    2f10:	89 85       	ldd	r24, Y+9	; 0x09
    2f12:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <uip_buf+0x2b>
    2f16:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f18:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <uip_buf+0x2c>
    2f1c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2f1e:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <uip_buf+0x2d>
    2f22:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f24:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <uip_buf+0x26>
    2f28:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f2a:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <uip_buf+0x27>
    2f2e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f30:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <uip_buf+0x28>
    2f34:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f36:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <uip_buf+0x29>
    2f3a:	86 e0       	ldi	r24, 0x06	; 6
    2f3c:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uip_buf+0x17>
    2f40:	8c 81       	ldd	r24, Y+4	; 0x04
    2f42:	9d 81       	ldd	r25, Y+5	; 0x05
    2f44:	90 93 a1 07 	sts	0x07A1, r25	; 0x8007a1 <uip_buf+0x23>
    2f48:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <uip_buf+0x22>
    2f4c:	8e 81       	ldd	r24, Y+6	; 0x06
    2f4e:	9f 81       	ldd	r25, Y+7	; 0x07
    2f50:	90 93 a3 07 	sts	0x07A3, r25	; 0x8007a3 <uip_buf+0x25>
    2f54:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <uip_buf+0x24>
    2f58:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    2f5c:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    2f60:	a0 91 7c 07 	lds	r26, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    2f64:	b0 91 7d 07 	lds	r27, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    2f68:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uip_buf+0x1a>
    2f6c:	90 93 99 07 	sts	0x0799, r25	; 0x800799 <uip_buf+0x1b>
    2f70:	a0 93 9a 07 	sts	0x079A, r26	; 0x80079a <uip_buf+0x1c>
    2f74:	b0 93 9b 07 	sts	0x079B, r27	; 0x80079b <uip_buf+0x1d>
    2f78:	88 81       	ld	r24, Y
    2f7a:	99 81       	ldd	r25, Y+1	; 0x01
    2f7c:	aa 81       	ldd	r26, Y+2	; 0x02
    2f7e:	bb 81       	ldd	r27, Y+3	; 0x03
    2f80:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uip_buf+0x1e>
    2f84:	90 93 9d 07 	sts	0x079D, r25	; 0x80079d <uip_buf+0x1f>
    2f88:	a0 93 9e 07 	sts	0x079E, r26	; 0x80079e <uip_buf+0x20>
    2f8c:	b0 93 9f 07 	sts	0x079F, r27	; 0x80079f <uip_buf+0x21>
    2f90:	89 8d       	ldd	r24, Y+25	; 0x19
    2f92:	84 ff       	sbrs	r24, 4
    2f94:	05 c0       	rjmp	.+10     	; 0x2fa0 <uip_process+0xe04>
    2f96:	10 92 af 07 	sts	0x07AF, r1	; 0x8007af <uip_buf+0x31>
    2f9a:	10 92 ae 07 	sts	0x07AE, r1	; 0x8007ae <uip_buf+0x30>
    2f9e:	06 c0       	rjmp	.+12     	; 0x2fac <uip_process+0xe10>
    2fa0:	85 e0       	ldi	r24, 0x05	; 5
    2fa2:	80 93 ae 07 	sts	0x07AE, r24	; 0x8007ae <uip_buf+0x30>
    2fa6:	84 eb       	ldi	r24, 0xB4	; 180
    2fa8:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <uip_buf+0x31>
    2fac:	80 e4       	ldi	r24, 0x40	; 64
    2fae:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <uip_buf+0x16>
    2fb2:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    2fb6:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    2fba:	90 93 8e 07 	sts	0x078E, r25	; 0x80078e <uip_buf+0x10>
    2fbe:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uip_buf+0x11>
    2fc2:	10 92 b3 07 	sts	0x07B3, r1	; 0x8007b3 <uip_buf+0x35>
    2fc6:	10 92 b2 07 	sts	0x07B2, r1	; 0x8007b2 <uip_buf+0x34>
    2fca:	10 92 b1 07 	sts	0x07B1, r1	; 0x8007b1 <uip_buf+0x33>
    2fce:	10 92 b0 07 	sts	0x07B0, r1	; 0x8007b0 <uip_buf+0x32>
    2fd2:	3a d8       	rcall	.-3980   	; 0x2048 <uip_tcpchksum>
    2fd4:	80 95       	com	r24
    2fd6:	90 95       	com	r25
    2fd8:	90 93 b1 07 	sts	0x07B1, r25	; 0x8007b1 <uip_buf+0x33>
    2fdc:	80 93 b0 07 	sts	0x07B0, r24	; 0x8007b0 <uip_buf+0x32>
    2fe0:	85 e4       	ldi	r24, 0x45	; 69
    2fe2:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <uip_buf+0xe>
    2fe6:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <uip_buf+0xf>
    2fea:	10 92 93 07 	sts	0x0793, r1	; 0x800793 <uip_buf+0x15>
    2fee:	10 92 92 07 	sts	0x0792, r1	; 0x800792 <uip_buf+0x14>
    2ff2:	80 91 4f 03 	lds	r24, 0x034F	; 0x80034f <ipid>
    2ff6:	90 91 50 03 	lds	r25, 0x0350	; 0x800350 <ipid+0x1>
    2ffa:	01 96       	adiw	r24, 0x01	; 1
    2ffc:	90 93 50 03 	sts	0x0350, r25	; 0x800350 <ipid+0x1>
    3000:	80 93 4f 03 	sts	0x034F, r24	; 0x80034f <ipid>
    3004:	90 93 90 07 	sts	0x0790, r25	; 0x800790 <uip_buf+0x12>
    3008:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <uip_buf+0x13>
    300c:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <uip_buf+0x19>
    3010:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <uip_buf+0x18>
    3014:	09 d8       	rcall	.-4078   	; 0x2028 <uip_ipchksum>
    3016:	80 95       	com	r24
    3018:	90 95       	com	r25
    301a:	90 93 97 07 	sts	0x0797, r25	; 0x800797 <uip_buf+0x19>
    301e:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <uip_buf+0x18>
    3022:	04 c0       	rjmp	.+8      	; 0x302c <uip_process+0xe90>
    3024:	10 92 07 06 	sts	0x0607, r1	; 0x800607 <uip_len+0x1>
    3028:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <uip_len>
    302c:	10 92 0e 06 	sts	0x060E, r1	; 0x80060e <uip_flags>
    3030:	df 91       	pop	r29
    3032:	cf 91       	pop	r28
    3034:	1f 91       	pop	r17
    3036:	0f 91       	pop	r16
    3038:	ff 90       	pop	r15
    303a:	ef 90       	pop	r14
    303c:	df 90       	pop	r13
    303e:	cf 90       	pop	r12
    3040:	bf 90       	pop	r11
    3042:	af 90       	pop	r10
    3044:	08 95       	ret

00003046 <uip_send>:
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    3046:	9c 01       	movw	r18, r24
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
    3048:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <uip_sappdata>
    304c:	90 91 09 06 	lds	r25, 0x0609	; 0x800609 <uip_sappdata+0x1>
    3050:	48 e6       	ldi	r20, 0x68	; 104
    3052:	5d e0       	ldi	r21, 0x0D	; 13
    3054:	48 1b       	sub	r20, r24
    3056:	59 0b       	sbc	r21, r25
    3058:	64 17       	cp	r22, r20
    305a:	75 07       	cpc	r23, r21
    305c:	0c f4       	brge	.+2      	; 0x3060 <uip_send+0x1a>
    305e:	ab 01       	movw	r20, r22
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
    3060:	14 16       	cp	r1, r20
    3062:	15 06       	cpc	r1, r21
    3064:	54 f4       	brge	.+20     	; 0x307a <uip_send+0x34>
    uip_slen = copylen;
    3066:	50 93 6b 0d 	sts	0x0D6B, r21	; 0x800d6b <uip_slen+0x1>
    306a:	40 93 6a 0d 	sts	0x0D6A, r20	; 0x800d6a <uip_slen>
    if(data != uip_sappdata) {
    306e:	82 17       	cp	r24, r18
    3070:	93 07       	cpc	r25, r19
    3072:	19 f0       	breq	.+6      	; 0x307a <uip_send+0x34>
      memcpy(uip_sappdata, (data), uip_slen);
    3074:	b9 01       	movw	r22, r18
    3076:	0c 94 2c 3a 	jmp	0x7458	; 0x7458 <memcpy>
    307a:	08 95       	ret

0000307c <uip_arp_update.constprop.0>:
  }

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
    307c:	ef 92       	push	r14
    307e:	ff 92       	push	r15
    3080:	0f 93       	push	r16
    3082:	1f 93       	push	r17
    3084:	cf 93       	push	r28
    3086:	df 93       	push	r29
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {

    tabptr = &arp_table[i];
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3088:	20 91 4e 02 	lds	r18, 0x024E	; 0x80024e <uip_all_zeroes_addr>
    308c:	30 91 4f 02 	lds	r19, 0x024F	; 0x80024f <uip_all_zeroes_addr+0x1>
    3090:	40 91 50 02 	lds	r20, 0x0250	; 0x800250 <uip_all_zeroes_addr+0x2>
    3094:	50 91 51 02 	lds	r21, 0x0251	; 0x800251 <uip_all_zeroes_addr+0x3>

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    3098:	00 91 9a 07 	lds	r16, 0x079A	; 0x80079a <uip_buf+0x1c>
    309c:	10 91 9b 07 	lds	r17, 0x079B	; 0x80079b <uip_buf+0x1d>
    30a0:	e0 90 9c 07 	lds	r14, 0x079C	; 0x80079c <uip_buf+0x1e>
    30a4:	f0 90 9d 07 	lds	r15, 0x079D	; 0x80079d <uip_buf+0x1f>
    30a8:	80 e0       	ldi	r24, 0x00	; 0
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {

    tabptr = &arp_table[i];
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    30aa:	9b e0       	ldi	r25, 0x0B	; 11
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    30ac:	88 30       	cpi	r24, 0x08	; 8
    30ae:	59 f1       	breq	.+86     	; 0x3106 <uip_arp_update.constprop.0+0x8a>

    tabptr = &arp_table[i];
    30b0:	68 2f       	mov	r22, r24
    30b2:	70 e0       	ldi	r23, 0x00	; 0
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    30b4:	96 9f       	mul	r25, r22
    30b6:	f0 01       	movw	r30, r0
    30b8:	97 9f       	mul	r25, r23
    30ba:	f0 0d       	add	r31, r0
    30bc:	11 24       	eor	r1, r1
    30be:	e7 5a       	subi	r30, 0xA7	; 167
    30c0:	fc 4f       	sbci	r31, 0xFC	; 252
    30c2:	a0 81       	ld	r26, Z
    30c4:	b1 81       	ldd	r27, Z+1	; 0x01
    30c6:	a2 17       	cp	r26, r18
    30c8:	b3 07       	cpc	r27, r19
    30ca:	31 f4       	brne	.+12     	; 0x30d8 <uip_arp_update.constprop.0+0x5c>
    30cc:	02 80       	ldd	r0, Z+2	; 0x02
    30ce:	f3 81       	ldd	r31, Z+3	; 0x03
    30d0:	e0 2d       	mov	r30, r0
    30d2:	e4 17       	cp	r30, r20
    30d4:	f5 07       	cpc	r31, r21
    30d6:	a9 f0       	breq	.+42     	; 0x3102 <uip_arp_update.constprop.0+0x86>

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    30d8:	a0 17       	cp	r26, r16
    30da:	b1 07       	cpc	r27, r17
    30dc:	91 f4       	brne	.+36     	; 0x3102 <uip_arp_update.constprop.0+0x86>
    30de:	96 9f       	mul	r25, r22
    30e0:	d0 01       	movw	r26, r0
    30e2:	97 9f       	mul	r25, r23
    30e4:	b0 0d       	add	r27, r0
    30e6:	11 24       	eor	r1, r1
    30e8:	ed 01       	movw	r28, r26
    30ea:	c7 5a       	subi	r28, 0xA7	; 167
    30ec:	dc 4f       	sbci	r29, 0xFC	; 252
    30ee:	6a 81       	ldd	r22, Y+2	; 0x02
    30f0:	7b 81       	ldd	r23, Y+3	; 0x03
    30f2:	e6 16       	cp	r14, r22
    30f4:	f7 06       	cpc	r15, r23
    30f6:	29 f4       	brne	.+10     	; 0x3102 <uip_arp_update.constprop.0+0x86>
    30f8:	80 93 54 03 	sts	0x0354, r24	; 0x800354 <i>

	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    30fc:	a3 5a       	subi	r26, 0xA3	; 163
    30fe:	bc 4f       	sbci	r27, 0xFC	; 252
    3100:	50 c0       	rjmp	.+160    	; 0x31a2 <uip_arp_update.constprop.0+0x126>
    3102:	8f 5f       	subi	r24, 0xFF	; 255
    3104:	d3 cf       	rjmp	.-90     	; 0x30ac <uip_arp_update.constprop.0+0x30>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3106:	80 e0       	ldi	r24, 0x00	; 0
    tabptr = &arp_table[i];
    3108:	9b e0       	ldi	r25, 0x0B	; 11

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    310a:	88 30       	cpi	r24, 0x08	; 8
    310c:	a1 f0       	breq	.+40     	; 0x3136 <uip_arp_update.constprop.0+0xba>
    tabptr = &arp_table[i];
    310e:	98 9f       	mul	r25, r24
    3110:	e0 01       	movw	r28, r0
    3112:	11 24       	eor	r1, r1
    3114:	c7 5a       	subi	r28, 0xA7	; 167
    3116:	dc 4f       	sbci	r29, 0xFC	; 252
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3118:	68 81       	ld	r22, Y
    311a:	79 81       	ldd	r23, Y+1	; 0x01
    311c:	26 17       	cp	r18, r22
    311e:	37 07       	cpc	r19, r23
    3120:	41 f4       	brne	.+16     	; 0x3132 <uip_arp_update.constprop.0+0xb6>
    3122:	6a 81       	ldd	r22, Y+2	; 0x02
    3124:	7b 81       	ldd	r23, Y+3	; 0x03
    3126:	46 17       	cp	r20, r22
    3128:	57 07       	cpc	r21, r23
    312a:	19 f4       	brne	.+6      	; 0x3132 <uip_arp_update.constprop.0+0xb6>
    312c:	80 93 54 03 	sts	0x0354, r24	; 0x800354 <i>
    3130:	2b c0       	rjmp	.+86     	; 0x3188 <uip_arp_update.constprop.0+0x10c>
    3132:	8f 5f       	subi	r24, 0xFF	; 255
    3134:	ea cf       	rjmp	.-44     	; 0x310a <uip_arp_update.constprop.0+0x8e>
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    3136:	20 91 52 03 	lds	r18, 0x0352	; 0x800352 <arptime>
    313a:	42 2f       	mov	r20, r18
    313c:	50 e0       	ldi	r21, 0x00	; 0
    313e:	80 e0       	ldi	r24, 0x00	; 0
    3140:	c0 e0       	ldi	r28, 0x00	; 0
    3142:	90 e0       	ldi	r25, 0x00	; 0
    3144:	6b e0       	ldi	r22, 0x0B	; 11
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3146:	88 30       	cpi	r24, 0x08	; 8
    3148:	99 f0       	breq	.+38     	; 0x3170 <uip_arp_update.constprop.0+0xf4>
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    314a:	68 9f       	mul	r22, r24
    314c:	f0 01       	movw	r30, r0
    314e:	11 24       	eor	r1, r1
    3150:	e7 5a       	subi	r30, 0xA7	; 167
    3152:	fc 4f       	sbci	r31, 0xFC	; 252
    3154:	32 85       	ldd	r19, Z+10	; 0x0a
    3156:	da 01       	movw	r26, r20
    3158:	a3 1b       	sub	r26, r19
    315a:	b1 09       	sbc	r27, r1
    315c:	e9 2f       	mov	r30, r25
    315e:	f0 e0       	ldi	r31, 0x00	; 0
    3160:	ea 17       	cp	r30, r26
    3162:	fb 07       	cpc	r31, r27
    3164:	1c f4       	brge	.+6      	; 0x316c <uip_arp_update.constprop.0+0xf0>
	tmpage = arptime - tabptr->time;
    3166:	92 2f       	mov	r25, r18
    3168:	93 1b       	sub	r25, r19
    316a:	c8 2f       	mov	r28, r24
    316c:	8f 5f       	subi	r24, 0xFF	; 255
    316e:	eb cf       	rjmp	.-42     	; 0x3146 <uip_arp_update.constprop.0+0xca>
    3170:	90 93 51 03 	sts	0x0351, r25	; 0x800351 <tmpage>
    3174:	c0 93 53 03 	sts	0x0353, r28	; 0x800353 <c>
	c = i;
      }
    }
    i = c;
    3178:	c0 93 54 03 	sts	0x0354, r28	; 0x800354 <i>
    tabptr = &arp_table[i];
    317c:	8b e0       	ldi	r24, 0x0B	; 11
    317e:	c8 9f       	mul	r28, r24
    3180:	e0 01       	movw	r28, r0
    3182:	11 24       	eor	r1, r1
    3184:	c7 5a       	subi	r28, 0xA7	; 167
    3186:	dc 4f       	sbci	r29, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  uip_ipaddr_copy(&tabptr->ipaddr, ipaddr);
    3188:	40 91 9a 07 	lds	r20, 0x079A	; 0x80079a <uip_buf+0x1c>
    318c:	50 91 9b 07 	lds	r21, 0x079B	; 0x80079b <uip_buf+0x1d>
    3190:	60 91 9c 07 	lds	r22, 0x079C	; 0x80079c <uip_buf+0x1e>
    3194:	70 91 9d 07 	lds	r23, 0x079D	; 0x80079d <uip_buf+0x1f>
    3198:	de 01       	movw	r26, r28
    319a:	4d 93       	st	X+, r20
    319c:	5d 93       	st	X+, r21
    319e:	6d 93       	st	X+, r22
    31a0:	7d 93       	st	X+, r23
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    31a2:	86 e0       	ldi	r24, 0x06	; 6
    31a4:	e4 e9       	ldi	r30, 0x94	; 148
    31a6:	f7 e0       	ldi	r31, 0x07	; 7
    31a8:	01 90       	ld	r0, Z+
    31aa:	0d 92       	st	X+, r0
    31ac:	8a 95       	dec	r24
    31ae:	e1 f7       	brne	.-8      	; 0x31a8 <uip_arp_update.constprop.0+0x12c>
  tabptr->time = arptime;
    31b0:	80 91 52 03 	lds	r24, 0x0352	; 0x800352 <arptime>
    31b4:	8a 87       	std	Y+10, r24	; 0x0a
}
    31b6:	df 91       	pop	r29
    31b8:	cf 91       	pop	r28
    31ba:	1f 91       	pop	r17
    31bc:	0f 91       	pop	r16
    31be:	ff 90       	pop	r15
    31c0:	ef 90       	pop	r14
    31c2:	08 95       	ret

000031c4 <uip_arp_init>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    31c4:	10 92 54 03 	sts	0x0354, r1	; 0x800354 <i>
    memset(&arp_table[i].ipaddr, 0, 4);
    31c8:	9b e0       	ldi	r25, 0x0B	; 11
    31ca:	24 e0       	ldi	r18, 0x04	; 4
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    31cc:	80 91 54 03 	lds	r24, 0x0354	; 0x800354 <i>
    31d0:	88 30       	cpi	r24, 0x08	; 8
    31d2:	70 f4       	brcc	.+28     	; 0x31f0 <uip_arp_init+0x2c>
    memset(&arp_table[i].ipaddr, 0, 4);
    31d4:	98 9f       	mul	r25, r24
    31d6:	f0 01       	movw	r30, r0
    31d8:	11 24       	eor	r1, r1
    31da:	e7 5a       	subi	r30, 0xA7	; 167
    31dc:	fc 4f       	sbci	r31, 0xFC	; 252
    31de:	df 01       	movw	r26, r30
    31e0:	32 2f       	mov	r19, r18
    31e2:	1d 92       	st	X+, r1
    31e4:	3a 95       	dec	r19
    31e6:	e9 f7       	brne	.-6      	; 0x31e2 <uip_arp_init+0x1e>
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    31e8:	8f 5f       	subi	r24, 0xFF	; 255
    31ea:	80 93 54 03 	sts	0x0354, r24	; 0x800354 <i>
    31ee:	ee cf       	rjmp	.-36     	; 0x31cc <uip_arp_init+0x8>
    memset(&arp_table[i].ipaddr, 0, 4);
  }
}
    31f0:	08 95       	ret

000031f2 <uip_arp_timer>:
 *
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_timer(void)
{
    31f2:	cf 93       	push	r28
    31f4:	df 93       	push	r29
  struct arp_entry *tabptr = NULL;

  ++arptime;
    31f6:	80 91 52 03 	lds	r24, 0x0352	; 0x800352 <arptime>
    31fa:	8f 5f       	subi	r24, 0xFF	; 255
    31fc:	80 93 52 03 	sts	0x0352, r24	; 0x800352 <arptime>
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3200:	10 92 54 03 	sts	0x0354, r1	; 0x800354 <i>
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    3204:	3b e0       	ldi	r19, 0x0B	; 11
    3206:	40 91 4e 02 	lds	r20, 0x024E	; 0x80024e <uip_all_zeroes_addr>
    320a:	50 91 4f 02 	lds	r21, 0x024F	; 0x80024f <uip_all_zeroes_addr+0x1>
    320e:	60 91 50 02 	lds	r22, 0x0250	; 0x800250 <uip_all_zeroes_addr+0x2>
    3212:	70 91 51 02 	lds	r23, 0x0251	; 0x800251 <uip_all_zeroes_addr+0x3>
    3216:	90 e0       	ldi	r25, 0x00	; 0
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    3218:	a4 e0       	ldi	r26, 0x04	; 4
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    321a:	20 91 54 03 	lds	r18, 0x0354	; 0x800354 <i>
    321e:	28 30       	cpi	r18, 0x08	; 8
    3220:	f8 f4       	brcc	.+62     	; 0x3260 <uip_arp_timer+0x6e>
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    3222:	32 9f       	mul	r19, r18
    3224:	f0 01       	movw	r30, r0
    3226:	11 24       	eor	r1, r1
    3228:	e7 5a       	subi	r30, 0xA7	; 167
    322a:	fc 4f       	sbci	r31, 0xFC	; 252
    322c:	c0 81       	ld	r28, Z
    322e:	d1 81       	ldd	r29, Z+1	; 0x01
    3230:	c4 17       	cp	r28, r20
    3232:	d5 07       	cpc	r29, r21
    3234:	89 f4       	brne	.+34     	; 0x3258 <uip_arp_timer+0x66>
    3236:	c2 81       	ldd	r28, Z+2	; 0x02
    3238:	d3 81       	ldd	r29, Z+3	; 0x03
    323a:	c6 17       	cp	r28, r22
    323c:	d7 07       	cpc	r29, r23
    323e:	61 f4       	brne	.+24     	; 0x3258 <uip_arp_timer+0x66>
    3240:	b2 85       	ldd	r27, Z+10	; 0x0a
    3242:	ec 01       	movw	r28, r24
    3244:	cb 1b       	sub	r28, r27
    3246:	d1 09       	sbc	r29, r1
    3248:	c8 37       	cpi	r28, 0x78	; 120
    324a:	d1 05       	cpc	r29, r1
    324c:	2c f0       	brlt	.+10     	; 0x3258 <uip_arp_timer+0x66>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    324e:	ef 01       	movw	r28, r30
    3250:	ba 2f       	mov	r27, r26
    3252:	19 92       	st	Y+, r1
    3254:	ba 95       	dec	r27
    3256:	e9 f7       	brne	.-6      	; 0x3252 <uip_arp_timer+0x60>
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3258:	2f 5f       	subi	r18, 0xFF	; 255
    325a:	20 93 54 03 	sts	0x0354, r18	; 0x800354 <i>
    325e:	dd cf       	rjmp	.-70     	; 0x321a <uip_arp_timer+0x28>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    }
  }

}
    3260:	df 91       	pop	r29
    3262:	cf 91       	pop	r28
    3264:	08 95       	ret

00003266 <uip_arp_arpin>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
  if(uip_len < sizeof(struct arp_hdr)) {
    3266:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    326a:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    uip_len = 0;
    326e:	10 92 07 06 	sts	0x0607, r1	; 0x800607 <uip_len+0x1>
    3272:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <uip_len>
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
  if(uip_len < sizeof(struct arp_hdr)) {
    3276:	8a 97       	sbiw	r24, 0x2a	; 42
    3278:	08 f4       	brcc	.+2      	; 0x327c <uip_arp_arpin+0x16>
    uip_len = 0;
    return;
    327a:	08 95       	ret
  }
  uip_len = 0;

  switch(BUF->opcode) {
    327c:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <uip_buf+0x14>
    3280:	90 91 93 07 	lds	r25, 0x0793	; 0x800793 <uip_buf+0x15>
    3284:	81 15       	cp	r24, r1
    3286:	21 e0       	ldi	r18, 0x01	; 1
    3288:	92 07       	cpc	r25, r18
    328a:	29 f0       	breq	.+10     	; 0x3296 <uip_arp_arpin+0x30>
    328c:	81 15       	cp	r24, r1
    328e:	92 40       	sbci	r25, 0x02	; 2
    3290:	09 f4       	brne	.+2      	; 0x3294 <uip_arp_arpin+0x2e>
    3292:	71 c0       	rjmp	.+226    	; 0x3376 <uip_arp_arpin+0x110>
    3294:	08 95       	ret
    PRINTF("uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n",
	   BUF->dipaddr.u8[0], BUF->dipaddr.u8[1],
	   BUF->dipaddr.u8[2], BUF->dipaddr.u8[3],
	   uip_hostaddr.u8[0], uip_hostaddr.u8[1],
	   uip_hostaddr.u8[2], uip_hostaddr.u8[3]);
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    3296:	20 91 a4 07 	lds	r18, 0x07A4	; 0x8007a4 <uip_buf+0x26>
    329a:	30 91 a5 07 	lds	r19, 0x07A5	; 0x8007a5 <uip_buf+0x27>
    329e:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    32a2:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    32a6:	28 17       	cp	r18, r24
    32a8:	39 07       	cpc	r19, r25
    32aa:	09 f0       	breq	.+2      	; 0x32ae <uip_arp_arpin+0x48>
    32ac:	7b c0       	rjmp	.+246    	; 0x33a4 <uip_arp_arpin+0x13e>
    32ae:	20 91 a6 07 	lds	r18, 0x07A6	; 0x8007a6 <uip_buf+0x28>
    32b2:	30 91 a7 07 	lds	r19, 0x07A7	; 0x8007a7 <uip_buf+0x29>
    32b6:	80 91 7c 07 	lds	r24, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    32ba:	90 91 7d 07 	lds	r25, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    32be:	28 17       	cp	r18, r24
    32c0:	39 07       	cpc	r19, r25
    32c2:	09 f0       	breq	.+2      	; 0x32c6 <uip_arp_arpin+0x60>
    32c4:	6f c0       	rjmp	.+222    	; 0x33a4 <uip_arp_arpin+0x13e>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    32c6:	da de       	rcall	.-588    	; 0x307c <uip_arp_update.constprop.0>

      BUF->opcode = HTONS(ARP_REPLY);
    32c8:	80 e0       	ldi	r24, 0x00	; 0
    32ca:	92 e0       	ldi	r25, 0x02	; 2
    32cc:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <uip_buf+0x15>
    32d0:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <uip_buf+0x14>

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    32d4:	86 e0       	ldi	r24, 0x06	; 6
    32d6:	e4 e9       	ldi	r30, 0x94	; 148
    32d8:	f7 e0       	ldi	r31, 0x07	; 7
    32da:	ae e9       	ldi	r26, 0x9E	; 158
    32dc:	b7 e0       	ldi	r27, 0x07	; 7
    32de:	01 90       	ld	r0, Z+
    32e0:	0d 92       	st	X+, r0
    32e2:	8a 95       	dec	r24
    32e4:	e1 f7       	brne	.-8      	; 0x32de <uip_arp_arpin+0x78>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    32e6:	86 e0       	ldi	r24, 0x06	; 6
    32e8:	e0 e4       	ldi	r30, 0x40	; 64
    32ea:	f3 e0       	ldi	r31, 0x03	; 3
    32ec:	a4 e9       	ldi	r26, 0x94	; 148
    32ee:	b7 e0       	ldi	r27, 0x07	; 7
    32f0:	01 90       	ld	r0, Z+
    32f2:	0d 92       	st	X+, r0
    32f4:	8a 95       	dec	r24
    32f6:	e1 f7       	brne	.-8      	; 0x32f0 <uip_arp_arpin+0x8a>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    32f8:	86 e0       	ldi	r24, 0x06	; 6
    32fa:	e0 e4       	ldi	r30, 0x40	; 64
    32fc:	f3 e0       	ldi	r31, 0x03	; 3
    32fe:	a4 e8       	ldi	r26, 0x84	; 132
    3300:	b7 e0       	ldi	r27, 0x07	; 7
    3302:	01 90       	ld	r0, Z+
    3304:	0d 92       	st	X+, r0
    3306:	8a 95       	dec	r24
    3308:	e1 f7       	brne	.-8      	; 0x3302 <uip_arp_arpin+0x9c>
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    330a:	86 e0       	ldi	r24, 0x06	; 6
    330c:	ee e9       	ldi	r30, 0x9E	; 158
    330e:	f7 e0       	ldi	r31, 0x07	; 7
    3310:	ae e7       	ldi	r26, 0x7E	; 126
    3312:	b7 e0       	ldi	r27, 0x07	; 7
    3314:	01 90       	ld	r0, Z+
    3316:	0d 92       	st	X+, r0
    3318:	8a 95       	dec	r24
    331a:	e1 f7       	brne	.-8      	; 0x3314 <uip_arp_arpin+0xae>

      uip_ipaddr_copy(&BUF->dipaddr, &BUF->sipaddr);
    331c:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uip_buf+0x1c>
    3320:	90 91 9b 07 	lds	r25, 0x079B	; 0x80079b <uip_buf+0x1d>
    3324:	a0 91 9c 07 	lds	r26, 0x079C	; 0x80079c <uip_buf+0x1e>
    3328:	b0 91 9d 07 	lds	r27, 0x079D	; 0x80079d <uip_buf+0x1f>
    332c:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <uip_buf+0x26>
    3330:	90 93 a5 07 	sts	0x07A5, r25	; 0x8007a5 <uip_buf+0x27>
    3334:	a0 93 a6 07 	sts	0x07A6, r26	; 0x8007a6 <uip_buf+0x28>
    3338:	b0 93 a7 07 	sts	0x07A7, r27	; 0x8007a7 <uip_buf+0x29>
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    333c:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    3340:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    3344:	a0 91 7c 07 	lds	r26, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    3348:	b0 91 7d 07 	lds	r27, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    334c:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <uip_buf+0x1c>
    3350:	90 93 9b 07 	sts	0x079B, r25	; 0x80079b <uip_buf+0x1d>
    3354:	a0 93 9c 07 	sts	0x079C, r26	; 0x80079c <uip_buf+0x1e>
    3358:	b0 93 9d 07 	sts	0x079D, r27	; 0x80079d <uip_buf+0x1f>

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    335c:	88 e0       	ldi	r24, 0x08	; 8
    335e:	96 e0       	ldi	r25, 0x06	; 6
    3360:	90 93 8b 07 	sts	0x078B, r25	; 0x80078b <uip_buf+0xd>
    3364:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <uip_buf+0xc>
      uip_len = sizeof(struct arp_hdr);
    3368:	8a e2       	ldi	r24, 0x2A	; 42
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    3370:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    3374:	08 95       	ret
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    3376:	20 91 a4 07 	lds	r18, 0x07A4	; 0x8007a4 <uip_buf+0x26>
    337a:	30 91 a5 07 	lds	r19, 0x07A5	; 0x8007a5 <uip_buf+0x27>
    337e:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    3382:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    3386:	28 17       	cp	r18, r24
    3388:	39 07       	cpc	r19, r25
    338a:	61 f4       	brne	.+24     	; 0x33a4 <uip_arp_arpin+0x13e>
    338c:	20 91 a6 07 	lds	r18, 0x07A6	; 0x8007a6 <uip_buf+0x28>
    3390:	30 91 a7 07 	lds	r19, 0x07A7	; 0x8007a7 <uip_buf+0x29>
    3394:	80 91 7c 07 	lds	r24, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    3398:	90 91 7d 07 	lds	r25, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    339c:	28 17       	cp	r18, r24
    339e:	39 07       	cpc	r19, r25
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    33a0:	09 f4       	brne	.+2      	; 0x33a4 <uip_arp_arpin+0x13e>
    33a2:	6c ce       	rjmp	.-808    	; 0x307c <uip_arp_update.constprop.0>
    33a4:	08 95       	ret

000033a6 <uip_arp_out>:

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr)) {
    33a6:	20 91 9c 07 	lds	r18, 0x079C	; 0x80079c <uip_buf+0x1e>
    33aa:	30 91 9d 07 	lds	r19, 0x079D	; 0x80079d <uip_buf+0x1f>
    33ae:	80 91 52 02 	lds	r24, 0x0252	; 0x800252 <uip_broadcast_addr>
    33b2:	90 91 53 02 	lds	r25, 0x0253	; 0x800253 <uip_broadcast_addr+0x1>
    33b6:	28 17       	cp	r18, r24
    33b8:	39 07       	cpc	r19, r25
    33ba:	79 f4       	brne	.+30     	; 0x33da <uip_arp_out+0x34>
    33bc:	40 91 9e 07 	lds	r20, 0x079E	; 0x80079e <uip_buf+0x20>
    33c0:	50 91 9f 07 	lds	r21, 0x079F	; 0x80079f <uip_buf+0x21>
    33c4:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <uip_broadcast_addr+0x2>
    33c8:	90 91 55 02 	lds	r25, 0x0255	; 0x800255 <uip_broadcast_addr+0x3>
    33cc:	48 17       	cp	r20, r24
    33ce:	59 07       	cpc	r21, r25
    33d0:	21 f4       	brne	.+8      	; 0x33da <uip_arp_out+0x34>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    33d2:	86 e0       	ldi	r24, 0x06	; 6
    33d4:	e6 e5       	ldi	r30, 0x56	; 86
    33d6:	f2 e0       	ldi	r31, 0x02	; 2
    33d8:	c8 c0       	rjmp	.+400    	; 0x356a <uip_arp_out+0x1c4>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask)) {
    33da:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <uip_hostaddr>
    33de:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    33e2:	82 27       	eor	r24, r18
    33e4:	93 27       	eor	r25, r19
    33e6:	20 91 76 07 	lds	r18, 0x0776	; 0x800776 <uip_netmask>
    33ea:	30 91 77 07 	lds	r19, 0x0777	; 0x800777 <uip_netmask+0x1>
    33ee:	82 23       	and	r24, r18
    33f0:	93 23       	and	r25, r19
    33f2:	89 2b       	or	r24, r25
    33f4:	91 f4       	brne	.+36     	; 0x341a <uip_arp_out+0x74>
    33f6:	20 91 9e 07 	lds	r18, 0x079E	; 0x80079e <uip_buf+0x20>
    33fa:	30 91 9f 07 	lds	r19, 0x079F	; 0x80079f <uip_buf+0x21>
    33fe:	80 91 7c 07 	lds	r24, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    3402:	90 91 7d 07 	lds	r25, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    3406:	82 27       	eor	r24, r18
    3408:	93 27       	eor	r25, r19
    340a:	20 91 78 07 	lds	r18, 0x0778	; 0x800778 <uip_netmask+0x2>
    340e:	30 91 79 07 	lds	r19, 0x0779	; 0x800779 <uip_netmask+0x3>
    3412:	82 23       	and	r24, r18
    3414:	93 23       	and	r25, r19
    3416:	89 2b       	or	r24, r25
    3418:	49 f0       	breq	.+18     	; 0x342c <uip_arp_out+0x86>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(&ipaddr, &uip_draddr);
    341a:	80 91 72 07 	lds	r24, 0x0772	; 0x800772 <uip_draddr>
    341e:	90 91 73 07 	lds	r25, 0x0773	; 0x800773 <uip_draddr+0x1>
    3422:	a0 91 74 07 	lds	r26, 0x0774	; 0x800774 <uip_draddr+0x2>
    3426:	b0 91 75 07 	lds	r27, 0x0775	; 0x800775 <uip_draddr+0x3>
    342a:	08 c0       	rjmp	.+16     	; 0x343c <uip_arp_out+0x96>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    342c:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uip_buf+0x1e>
    3430:	90 91 9d 07 	lds	r25, 0x079D	; 0x80079d <uip_buf+0x1f>
    3434:	a0 91 9e 07 	lds	r26, 0x079E	; 0x80079e <uip_buf+0x20>
    3438:	b0 91 9f 07 	lds	r27, 0x079F	; 0x80079f <uip_buf+0x21>
    343c:	80 93 55 03 	sts	0x0355, r24	; 0x800355 <ipaddr>
    3440:	90 93 56 03 	sts	0x0356, r25	; 0x800356 <ipaddr+0x1>
    3444:	a0 93 57 03 	sts	0x0357, r26	; 0x800357 <ipaddr+0x2>
    3448:	b0 93 58 03 	sts	0x0358, r27	; 0x800358 <ipaddr+0x3>
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    344c:	20 91 55 03 	lds	r18, 0x0355	; 0x800355 <ipaddr>
    3450:	30 91 56 03 	lds	r19, 0x0356	; 0x800356 <ipaddr+0x1>
    3454:	40 91 57 03 	lds	r20, 0x0357	; 0x800357 <ipaddr+0x2>
    3458:	50 91 58 03 	lds	r21, 0x0358	; 0x800358 <ipaddr+0x3>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    345c:	80 e0       	ldi	r24, 0x00	; 0
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    345e:	9b e0       	ldi	r25, 0x0B	; 11
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3460:	88 30       	cpi	r24, 0x08	; 8
    3462:	b1 f0       	breq	.+44     	; 0x3490 <uip_arp_out+0xea>
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    3464:	98 9f       	mul	r25, r24
    3466:	f0 01       	movw	r30, r0
    3468:	11 24       	eor	r1, r1
    346a:	df 01       	movw	r26, r30
    346c:	a7 5a       	subi	r26, 0xA7	; 167
    346e:	bc 4f       	sbci	r27, 0xFC	; 252
    3470:	6d 91       	ld	r22, X+
    3472:	7c 91       	ld	r23, X
    3474:	11 97       	sbiw	r26, 0x01	; 1
    3476:	26 17       	cp	r18, r22
    3478:	37 07       	cpc	r19, r23
    347a:	41 f4       	brne	.+16     	; 0x348c <uip_arp_out+0xe6>
    347c:	12 96       	adiw	r26, 0x02	; 2
    347e:	6d 91       	ld	r22, X+
    3480:	7c 91       	ld	r23, X
    3482:	13 97       	sbiw	r26, 0x03	; 3
    3484:	46 17       	cp	r20, r22
    3486:	57 07       	cpc	r21, r23
    3488:	09 f4       	brne	.+2      	; 0x348c <uip_arp_out+0xe6>
    348a:	6a c0       	rjmp	.+212    	; 0x3560 <uip_arp_out+0x1ba>
    348c:	8f 5f       	subi	r24, 0xFF	; 255
    348e:	e8 cf       	rjmp	.-48     	; 0x3460 <uip_arp_out+0xba>
    3490:	80 93 54 03 	sts	0x0354, r24	; 0x800354 <i>

    if(i == UIP_ARPTAB_SIZE) {
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    3494:	46 e0       	ldi	r20, 0x06	; 6
    3496:	50 e0       	ldi	r21, 0x00	; 0
    3498:	6f ef       	ldi	r22, 0xFF	; 255
    349a:	70 e0       	ldi	r23, 0x00	; 0
    349c:	8e e7       	ldi	r24, 0x7E	; 126
    349e:	97 e0       	ldi	r25, 0x07	; 7
    34a0:	0e 94 35 3a 	call	0x746a	; 0x746a <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    34a4:	86 e0       	ldi	r24, 0x06	; 6
    34a6:	ee e9       	ldi	r30, 0x9E	; 158
    34a8:	f7 e0       	ldi	r31, 0x07	; 7
    34aa:	df 01       	movw	r26, r30
    34ac:	98 2f       	mov	r25, r24
    34ae:	1d 92       	st	X+, r1
    34b0:	9a 95       	dec	r25
    34b2:	e9 f7       	brne	.-6      	; 0x34ae <uip_arp_out+0x108>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    34b4:	e0 e4       	ldi	r30, 0x40	; 64
    34b6:	f3 e0       	ldi	r31, 0x03	; 3
    34b8:	a4 e8       	ldi	r26, 0x84	; 132
    34ba:	b7 e0       	ldi	r27, 0x07	; 7
    34bc:	98 2f       	mov	r25, r24
    34be:	01 90       	ld	r0, Z+
    34c0:	0d 92       	st	X+, r0
    34c2:	9a 95       	dec	r25
    34c4:	e1 f7       	brne	.-8      	; 0x34be <uip_arp_out+0x118>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    34c6:	e0 e4       	ldi	r30, 0x40	; 64
    34c8:	f3 e0       	ldi	r31, 0x03	; 3
    34ca:	a4 e9       	ldi	r26, 0x94	; 148
    34cc:	b7 e0       	ldi	r27, 0x07	; 7
    34ce:	98 2f       	mov	r25, r24
    34d0:	01 90       	ld	r0, Z+
    34d2:	0d 92       	st	X+, r0
    34d4:	9a 95       	dec	r25
    34d6:	e1 f7       	brne	.-8      	; 0x34d0 <uip_arp_out+0x12a>

      uip_ipaddr_copy(&BUF->dipaddr, &ipaddr);
    34d8:	40 91 55 03 	lds	r20, 0x0355	; 0x800355 <ipaddr>
    34dc:	50 91 56 03 	lds	r21, 0x0356	; 0x800356 <ipaddr+0x1>
    34e0:	60 91 57 03 	lds	r22, 0x0357	; 0x800357 <ipaddr+0x2>
    34e4:	70 91 58 03 	lds	r23, 0x0358	; 0x800358 <ipaddr+0x3>
    34e8:	40 93 a4 07 	sts	0x07A4, r20	; 0x8007a4 <uip_buf+0x26>
    34ec:	50 93 a5 07 	sts	0x07A5, r21	; 0x8007a5 <uip_buf+0x27>
    34f0:	60 93 a6 07 	sts	0x07A6, r22	; 0x8007a6 <uip_buf+0x28>
    34f4:	70 93 a7 07 	sts	0x07A7, r23	; 0x8007a7 <uip_buf+0x29>
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    34f8:	40 91 7a 07 	lds	r20, 0x077A	; 0x80077a <uip_hostaddr>
    34fc:	50 91 7b 07 	lds	r21, 0x077B	; 0x80077b <uip_hostaddr+0x1>
    3500:	60 91 7c 07 	lds	r22, 0x077C	; 0x80077c <uip_hostaddr+0x2>
    3504:	70 91 7d 07 	lds	r23, 0x077D	; 0x80077d <uip_hostaddr+0x3>
    3508:	40 93 9a 07 	sts	0x079A, r20	; 0x80079a <uip_buf+0x1c>
    350c:	50 93 9b 07 	sts	0x079B, r21	; 0x80079b <uip_buf+0x1d>
    3510:	60 93 9c 07 	sts	0x079C, r22	; 0x80079c <uip_buf+0x1e>
    3514:	70 93 9d 07 	sts	0x079D, r23	; 0x80079d <uip_buf+0x1f>
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    3518:	20 e0       	ldi	r18, 0x00	; 0
    351a:	31 e0       	ldi	r19, 0x01	; 1
    351c:	30 93 93 07 	sts	0x0793, r19	; 0x800793 <uip_buf+0x15>
    3520:	20 93 92 07 	sts	0x0792, r18	; 0x800792 <uip_buf+0x14>
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    3524:	30 93 8d 07 	sts	0x078D, r19	; 0x80078d <uip_buf+0xf>
    3528:	20 93 8c 07 	sts	0x078C, r18	; 0x80078c <uip_buf+0xe>
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    352c:	28 e0       	ldi	r18, 0x08	; 8
    352e:	30 e0       	ldi	r19, 0x00	; 0
    3530:	30 93 8f 07 	sts	0x078F, r19	; 0x80078f <uip_buf+0x11>
    3534:	20 93 8e 07 	sts	0x078E, r18	; 0x80078e <uip_buf+0x10>
      BUF->hwlen = 6;
    3538:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <uip_buf+0x12>
      BUF->protolen = 4;
    353c:	84 e0       	ldi	r24, 0x04	; 4
    353e:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <uip_buf+0x13>
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    3542:	88 e0       	ldi	r24, 0x08	; 8
    3544:	96 e0       	ldi	r25, 0x06	; 6
    3546:	90 93 8b 07 	sts	0x078B, r25	; 0x80078b <uip_buf+0xd>
    354a:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <uip_buf+0xc>

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    354e:	84 eb       	ldi	r24, 0xB4	; 180
    3550:	97 e0       	ldi	r25, 0x07	; 7
    3552:	90 93 12 06 	sts	0x0612, r25	; 0x800612 <uip_appdata+0x1>
    3556:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <uip_appdata>

      uip_len = sizeof(struct arp_hdr);
    355a:	8a e2       	ldi	r24, 0x2A	; 42
    355c:	90 e0       	ldi	r25, 0x00	; 0
    355e:	1f c0       	rjmp	.+62     	; 0x359e <uip_arp_out+0x1f8>
    3560:	80 93 54 03 	sts	0x0354, r24	; 0x800354 <i>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    3564:	e3 5a       	subi	r30, 0xA3	; 163
    3566:	fc 4f       	sbci	r31, 0xFC	; 252
    3568:	86 e0       	ldi	r24, 0x06	; 6
    356a:	ae e7       	ldi	r26, 0x7E	; 126
    356c:	b7 e0       	ldi	r27, 0x07	; 7
    356e:	01 90       	ld	r0, Z+
    3570:	0d 92       	st	X+, r0
    3572:	8a 95       	dec	r24
    3574:	e1 f7       	brne	.-8      	; 0x356e <uip_arp_out+0x1c8>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    3576:	86 e0       	ldi	r24, 0x06	; 6
    3578:	e0 e4       	ldi	r30, 0x40	; 64
    357a:	f3 e0       	ldi	r31, 0x03	; 3
    357c:	a4 e8       	ldi	r26, 0x84	; 132
    357e:	b7 e0       	ldi	r27, 0x07	; 7
    3580:	01 90       	ld	r0, Z+
    3582:	0d 92       	st	X+, r0
    3584:	8a 95       	dec	r24
    3586:	e1 f7       	brne	.-8      	; 0x3580 <uip_arp_out+0x1da>

  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    3588:	88 e0       	ldi	r24, 0x08	; 8
    358a:	90 e0       	ldi	r25, 0x00	; 0
    358c:	90 93 8b 07 	sts	0x078B, r25	; 0x80078b <uip_buf+0xd>
    3590:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <uip_buf+0xc>

  uip_len += sizeof(struct uip_eth_hdr);
    3594:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <uip_len>
    3598:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <uip_len+0x1>
    359c:	0e 96       	adiw	r24, 0x0e	; 14
    359e:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    35a2:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    35a6:	08 95       	ret

000035a8 <timer_set>:
 */
void
timer_restart(struct timer *t)
{
  t->start = clock_time();
}
    35a8:	cf 93       	push	r28
    35aa:	df 93       	push	r29
    35ac:	ec 01       	movw	r28, r24
    35ae:	7b 83       	std	Y+3, r23	; 0x03
    35b0:	6a 83       	std	Y+2, r22	; 0x02
    35b2:	48 d0       	rcall	.+144    	; 0x3644 <clock_time>
    35b4:	99 83       	std	Y+1, r25	; 0x01
    35b6:	88 83       	st	Y, r24
    35b8:	df 91       	pop	r29
    35ba:	cf 91       	pop	r28
    35bc:	08 95       	ret

000035be <timer_reset>:
    35be:	fc 01       	movw	r30, r24
    35c0:	20 81       	ld	r18, Z
    35c2:	31 81       	ldd	r19, Z+1	; 0x01
    35c4:	82 81       	ldd	r24, Z+2	; 0x02
    35c6:	93 81       	ldd	r25, Z+3	; 0x03
    35c8:	82 0f       	add	r24, r18
    35ca:	93 1f       	adc	r25, r19
    35cc:	91 83       	std	Z+1, r25	; 0x01
    35ce:	80 83       	st	Z, r24
    35d0:	08 95       	ret

000035d2 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    35d2:	cf 93       	push	r28
    35d4:	df 93       	push	r29
    35d6:	ec 01       	movw	r28, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    35d8:	35 d0       	rcall	.+106    	; 0x3644 <clock_time>
    35da:	28 81       	ld	r18, Y
    35dc:	39 81       	ldd	r19, Y+1	; 0x01
    35de:	ac 01       	movw	r20, r24
    35e0:	42 1b       	sub	r20, r18
    35e2:	53 0b       	sbc	r21, r19
    35e4:	81 e0       	ldi	r24, 0x01	; 1
    35e6:	90 e0       	ldi	r25, 0x00	; 0
    35e8:	2a 81       	ldd	r18, Y+2	; 0x02
    35ea:	3b 81       	ldd	r19, Y+3	; 0x03
    35ec:	42 17       	cp	r20, r18
    35ee:	53 07       	cpc	r21, r19
    35f0:	10 f4       	brcc	.+4      	; 0x35f6 <timer_expired+0x24>
    35f2:	80 e0       	ldi	r24, 0x00	; 0
    35f4:	90 e0       	ldi	r25, 0x00	; 0
}
    35f6:	df 91       	pop	r29
    35f8:	cf 91       	pop	r28
    35fa:	08 95       	ret

000035fc <__vector_17>:
//Counted time
volatile clock_time_t clock_datetime = 0;

//Overflow interrupt
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
{
    35fc:	1f 92       	push	r1
    35fe:	0f 92       	push	r0
    3600:	0f b6       	in	r0, 0x3f	; 63
    3602:	0f 92       	push	r0
    3604:	11 24       	eor	r1, r1
    3606:	8f 93       	push	r24
    3608:	9f 93       	push	r25
	clock_datetime += 1;
    360a:	80 91 b1 03 	lds	r24, 0x03B1	; 0x8003b1 <clock_datetime>
    360e:	90 91 b2 03 	lds	r25, 0x03B2	; 0x8003b2 <clock_datetime+0x1>
    3612:	01 96       	adiw	r24, 0x01	; 1
    3614:	90 93 b2 03 	sts	0x03B2, r25	; 0x8003b2 <clock_datetime+0x1>
    3618:	80 93 b1 03 	sts	0x03B1, r24	; 0x8003b1 <clock_datetime>
}
    361c:	9f 91       	pop	r25
    361e:	8f 91       	pop	r24
    3620:	0f 90       	pop	r0
    3622:	0f be       	out	0x3f, r0	; 63
    3624:	0f 90       	pop	r0
    3626:	1f 90       	pop	r1
    3628:	18 95       	reti

0000362a <clock_init>:

//Initialise the clock
void clock_init()
{
	OCR1A  = (((F_CPU / 1024) / 100) - 1);
    362a:	8d e4       	ldi	r24, 0x4D	; 77
    362c:	90 e0       	ldi	r25, 0x00	; 0
    362e:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    3632:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	TCCR1B = ((1 << WGM12) | (1 << CS12) | (1 << CS10));
    3636:	8d e0       	ldi	r24, 0x0D	; 13
    3638:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	TIMSK1 = (1 << OCIE1A);
    363c:	82 e0       	ldi	r24, 0x02	; 2
    363e:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    3642:	08 95       	ret

00003644 <clock_time>:
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    3644:	f8 94       	cli
clock_time_t clock_time()
{
	clock_time_t time;

	GlobalInterruptDisable();
	time = clock_datetime;
    3646:	80 91 b1 03 	lds	r24, 0x03B1	; 0x8003b1 <clock_datetime>
    364a:	90 91 b2 03 	lds	r25, 0x03B2	; 0x8003b2 <clock_datetime+0x1>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    364e:	78 94       	sei
	GlobalInterruptEnable();

	return time;
}
    3650:	08 95       	ret

00003652 <uip_split_output>:
{
#if UIP_TCP
  u16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP  && uip_len == UIP_BUFSIZE) {
    3652:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uip_buf+0x17>
    3656:	40 91 06 06 	lds	r20, 0x0606	; 0x800606 <uip_len>
    365a:	50 91 07 06 	lds	r21, 0x0607	; 0x800607 <uip_len+0x1>
    365e:	86 30       	cpi	r24, 0x06	; 6
    3660:	09 f0       	breq	.+2      	; 0x3664 <uip_split_output+0x12>
    3662:	8a c0       	rjmp	.+276    	; 0x3778 <uip_split_output+0x126>
    3664:	4a 3e       	cpi	r20, 0xEA	; 234
    3666:	85 e0       	ldi	r24, 0x05	; 5
    3668:	58 07       	cpc	r21, r24
    366a:	09 f0       	breq	.+2      	; 0x366e <uip_split_output+0x1c>
    366c:	85 c0       	rjmp	.+266    	; 0x3778 <uip_split_output+0x126>
      ++len2;
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    366e:	80 e1       	ldi	r24, 0x10	; 16
    3670:	93 e0       	ldi	r25, 0x03	; 3
    3672:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    3676:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len - UIP_LLH_LEN) >> 8;
    367a:	83 e0       	ldi	r24, 0x03	; 3
    367c:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <uip_buf+0x10>
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    3680:	82 e0       	ldi	r24, 0x02	; 2
    3682:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uip_buf+0x11>
#endif /* UIP_CONF_IPV6 */

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    3686:	10 92 b1 07 	sts	0x07B1, r1	; 0x8007b1 <uip_buf+0x33>
    368a:	10 92 b0 07 	sts	0x07B0, r1	; 0x8007b0 <uip_buf+0x32>
    BUF->tcpchksum = ~(uip_tcpchksum());
    368e:	0e 94 24 10 	call	0x2048	; 0x2048 <uip_tcpchksum>
    3692:	80 95       	com	r24
    3694:	90 95       	com	r25
    3696:	90 93 b1 07 	sts	0x07B1, r25	; 0x8007b1 <uip_buf+0x33>
    369a:	80 93 b0 07 	sts	0x07B0, r24	; 0x8007b0 <uip_buf+0x32>

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    369e:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <uip_buf+0x19>
    36a2:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <uip_buf+0x18>
    BUF->ipchksum = ~(uip_ipchksum());
    36a6:	0e 94 14 10 	call	0x2028	; 0x2028 <uip_ipchksum>
    36aa:	80 95       	com	r24
    36ac:	90 95       	com	r25
    36ae:	90 93 97 07 	sts	0x0797, r25	; 0x800797 <uip_buf+0x19>
    36b2:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <uip_buf+0x18>

    /* Transmit the first packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    36b6:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
    36ba:	40 91 06 06 	lds	r20, 0x0606	; 0x800606 <uip_len>
    36be:	50 91 07 06 	lds	r21, 0x0607	; 0x800607 <uip_len+0x1>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    36c2:	6e e7       	ldi	r22, 0x7E	; 126
    36c4:	77 e0       	ldi	r23, 0x07	; 7

    /* Transmit the first packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    36c6:	81 30       	cpi	r24, 0x01	; 1
    36c8:	29 f4       	brne	.+10     	; 0x36d4 <uip_split_output+0x82>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    36ca:	87 e3       	ldi	r24, 0x37	; 55
    36cc:	91 e0       	ldi	r25, 0x01	; 1
    36ce:	0e 94 35 35 	call	0x6a6a	; 0x6a6a <RNDIS_Device_SendPacket>
    36d2:	04 c0       	rjmp	.+8      	; 0x36dc <uip_split_output+0x8a>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    36d4:	82 ed       	ldi	r24, 0xD2	; 210
    36d6:	91 e0       	ldi	r25, 0x01	; 1
    36d8:	0e 94 43 39 	call	0x7286	; 0x7286 <RNDIS_Host_SendPacket>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is determined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    36dc:	80 e1       	ldi	r24, 0x10	; 16
    36de:	93 e0       	ldi	r25, 0x03	; 3
    36e0:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <uip_len+0x1>
    36e4:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <uip_len>
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len  - UIP_LLH_LEN) >> 8;
    36e8:	83 e0       	ldi	r24, 0x03	; 3
    36ea:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <uip_buf+0x10>
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    36ee:	82 e0       	ldi	r24, 0x02	; 2
    36f0:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uip_buf+0x11>
#endif /* UIP_CONF_IPV6 */

    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
    36f4:	a0 91 11 06 	lds	r26, 0x0611	; 0x800611 <uip_appdata>
    36f8:	b0 91 12 06 	lds	r27, 0x0612	; 0x800612 <uip_appdata+0x1>
    36fc:	fd 01       	movw	r30, r26
    36fe:	e6 52       	subi	r30, 0x26	; 38
    3700:	fd 4f       	sbci	r31, 0xFD	; 253
    3702:	8a ed       	ldi	r24, 0xDA	; 218
    3704:	92 e0       	ldi	r25, 0x02	; 2
    3706:	01 90       	ld	r0, Z+
    3708:	0d 92       	st	X+, r0
    370a:	01 97       	sbiw	r24, 0x01	; 1
    370c:	e1 f7       	brne	.-8      	; 0x3706 <uip_split_output+0xb4>

    uip_add32(BUF->seqno, len1);
    370e:	6a ed       	ldi	r22, 0xDA	; 218
    3710:	72 e0       	ldi	r23, 0x02	; 2
    3712:	84 ea       	ldi	r24, 0xA4	; 164
    3714:	97 e0       	ldi	r25, 0x07	; 7
    3716:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
    371a:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <uip_acc32>
    371e:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <uip_buf+0x26>
    BUF->seqno[1] = uip_acc32[1];
    3722:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <uip_acc32+0x1>
    3726:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <uip_buf+0x27>
    BUF->seqno[2] = uip_acc32[2];
    372a:	80 91 0c 06 	lds	r24, 0x060C	; 0x80060c <uip_acc32+0x2>
    372e:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <uip_buf+0x28>
    BUF->seqno[3] = uip_acc32[3];
    3732:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <uip_acc32+0x3>
    3736:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <uip_buf+0x29>

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    373a:	10 92 b1 07 	sts	0x07B1, r1	; 0x8007b1 <uip_buf+0x33>
    373e:	10 92 b0 07 	sts	0x07B0, r1	; 0x8007b0 <uip_buf+0x32>
    BUF->tcpchksum = ~(uip_tcpchksum());
    3742:	0e 94 24 10 	call	0x2048	; 0x2048 <uip_tcpchksum>
    3746:	80 95       	com	r24
    3748:	90 95       	com	r25
    374a:	90 93 b1 07 	sts	0x07B1, r25	; 0x8007b1 <uip_buf+0x33>
    374e:	80 93 b0 07 	sts	0x07B0, r24	; 0x8007b0 <uip_buf+0x32>

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    3752:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <uip_buf+0x19>
    3756:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <uip_buf+0x18>
    BUF->ipchksum = ~(uip_ipchksum());
    375a:	0e 94 14 10 	call	0x2028	; 0x2028 <uip_ipchksum>
    375e:	80 95       	com	r24
    3760:	90 95       	com	r25
    3762:	90 93 97 07 	sts	0x0797, r25	; 0x800797 <uip_buf+0x19>
    3766:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <uip_buf+0x18>

    /* Transmit the second packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    376a:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
    376e:	40 91 06 06 	lds	r20, 0x0606	; 0x800606 <uip_len>
    3772:	50 91 07 06 	lds	r21, 0x0607	; 0x800607 <uip_len+0x1>
    3776:	02 c0       	rjmp	.+4      	; 0x377c <uip_split_output+0x12a>

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
	tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    3778:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    377c:	6e e7       	ldi	r22, 0x7E	; 126
    377e:	77 e0       	ldi	r23, 0x07	; 7

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
	tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    3780:	81 30       	cpi	r24, 0x01	; 1
    3782:	21 f4       	brne	.+8      	; 0x378c <uip_split_output+0x13a>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    3784:	87 e3       	ldi	r24, 0x37	; 55
    3786:	91 e0       	ldi	r25, 0x01	; 1
    3788:	0c 94 35 35 	jmp	0x6a6a	; 0x6a6a <RNDIS_Device_SendPacket>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    378c:	82 ed       	ldi	r24, 0xD2	; 210
    378e:	91 e0       	ldi	r25, 0x01	; 1
    3790:	0c 94 43 39 	jmp	0x7286	; 0x7286 <RNDIS_Host_SendPacket>

00003794 <disk_initialize>:
    3794:	80 e0       	ldi	r24, 0x00	; 0
    3796:	08 95       	ret

00003798 <disk_status>:
DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    3798:	80 e0       	ldi	r24, 0x00	; 0
    379a:	08 95       	ret

0000379c <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	BYTE count		/* Number of sectors to read (1..255) */
)
{
    379c:	0f 93       	push	r16
    379e:	fb 01       	movw	r30, r22
    37a0:	ca 01       	movw	r24, r20
    37a2:	b9 01       	movw	r22, r18
	DataflashManager_ReadBlocks_RAM(sector, count, buff);
    37a4:	40 2f       	mov	r20, r16
    37a6:	50 e0       	ldi	r21, 0x00	; 0
    37a8:	9f 01       	movw	r18, r30
    37aa:	0e 94 87 07 	call	0xf0e	; 0xf0e <DataflashManager_ReadBlocks_RAM>
	return RES_OK;
}
    37ae:	80 e0       	ldi	r24, 0x00	; 0
    37b0:	0f 91       	pop	r16
    37b2:	08 95       	ret

000037b4 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    37b4:	cf 92       	push	r12
    37b6:	df 92       	push	r13
    37b8:	ef 92       	push	r14
    37ba:	ff 92       	push	r15
    37bc:	0f 93       	push	r16
    37be:	cf 93       	push	r28
    37c0:	df 93       	push	r29
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
    37c2:	fc 01       	movw	r30, r24
    37c4:	c6 8c       	ldd	r12, Z+30	; 0x1e
    37c6:	d7 8c       	ldd	r13, Z+31	; 0x1f
    37c8:	e0 a0       	ldd	r14, Z+32	; 0x20
    37ca:	f1 a0       	ldd	r15, Z+33	; 0x21
    37cc:	c4 16       	cp	r12, r20
    37ce:	d5 06       	cpc	r13, r21
    37d0:	e6 06       	cpc	r14, r22
    37d2:	f7 06       	cpc	r15, r23
    37d4:	b9 f0       	breq	.+46     	; 0x3804 <move_window+0x50>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    37d6:	41 15       	cp	r20, r1
    37d8:	51 05       	cpc	r21, r1
    37da:	61 05       	cpc	r22, r1
    37dc:	71 05       	cpc	r23, r1
    37de:	91 f0       	breq	.+36     	; 0x3804 <move_window+0x50>
    37e0:	6a 01       	movw	r12, r20
    37e2:	7b 01       	movw	r14, r22
    37e4:	ec 01       	movw	r28, r24
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    37e6:	bc 01       	movw	r22, r24
    37e8:	6e 5d       	subi	r22, 0xDE	; 222
    37ea:	7f 4f       	sbci	r23, 0xFF	; 255
    37ec:	01 e0       	ldi	r16, 0x01	; 1
    37ee:	a7 01       	movw	r20, r14
    37f0:	96 01       	movw	r18, r12
    37f2:	81 81       	ldd	r24, Z+1	; 0x01
    37f4:	d3 df       	rcall	.-90     	; 0x379c <disk_read>
    37f6:	81 11       	cpse	r24, r1
    37f8:	07 c0       	rjmp	.+14     	; 0x3808 <move_window+0x54>
				return FR_DISK_ERR;
			fs->winsect = sector;
    37fa:	ce 8e       	std	Y+30, r12	; 0x1e
    37fc:	df 8e       	std	Y+31, r13	; 0x1f
    37fe:	e8 a2       	std	Y+32, r14	; 0x20
    3800:	f9 a2       	std	Y+33, r15	; 0x21
    3802:	03 c0       	rjmp	.+6      	; 0x380a <move_window+0x56>
		}
	}

	return FR_OK;
    3804:	80 e0       	ldi	r24, 0x00	; 0
    3806:	01 c0       	rjmp	.+2      	; 0x380a <move_window+0x56>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    3808:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    380a:	df 91       	pop	r29
    380c:	cf 91       	pop	r28
    380e:	0f 91       	pop	r16
    3810:	ff 90       	pop	r15
    3812:	ef 90       	pop	r14
    3814:	df 90       	pop	r13
    3816:	cf 90       	pop	r12
    3818:	08 95       	ret

0000381a <check_fs>:
static
BYTE check_fs (	/* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    381a:	0f 93       	push	r16
    381c:	cf 93       	push	r28
    381e:	df 93       	push	r29
    3820:	ec 01       	movw	r28, r24
    3822:	9a 01       	movw	r18, r20
    3824:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    3826:	bc 01       	movw	r22, r24
    3828:	6e 5d       	subi	r22, 0xDE	; 222
    382a:	7f 4f       	sbci	r23, 0xFF	; 255
    382c:	01 e0       	ldi	r16, 0x01	; 1
    382e:	89 81       	ldd	r24, Y+1	; 0x01
    3830:	b5 df       	rcall	.-150    	; 0x379c <disk_read>
    3832:	81 11       	cpse	r24, r1
    3834:	22 c0       	rjmp	.+68     	; 0x387a <check_fs+0x60>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    3836:	fe 01       	movw	r30, r28
    3838:	e0 5e       	subi	r30, 0xE0	; 224
    383a:	fd 4f       	sbci	r31, 0xFD	; 253
    383c:	80 81       	ld	r24, Z
    383e:	91 81       	ldd	r25, Z+1	; 0x01
    3840:	85 35       	cpi	r24, 0x55	; 85
    3842:	9a 4a       	sbci	r25, 0xAA	; 170
    3844:	e1 f4       	brne	.+56     	; 0x387e <check_fs+0x64>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    3846:	e8 5c       	subi	r30, 0xC8	; 200
    3848:	f1 40       	sbci	r31, 0x01	; 1
    384a:	80 81       	ld	r24, Z
    384c:	91 81       	ldd	r25, Z+1	; 0x01
    384e:	a2 81       	ldd	r26, Z+2	; 0x02
    3850:	b3 81       	ldd	r27, Z+3	; 0x03
    3852:	bb 27       	eor	r27, r27
    3854:	86 34       	cpi	r24, 0x46	; 70
    3856:	91 44       	sbci	r25, 0x41	; 65
    3858:	a4 45       	sbci	r26, 0x54	; 84
    385a:	b1 05       	cpc	r27, r1
    385c:	91 f0       	breq	.+36     	; 0x3882 <check_fs+0x68>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    385e:	cc 58       	subi	r28, 0x8C	; 140
    3860:	df 4f       	sbci	r29, 0xFF	; 255
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    3862:	48 81       	ld	r20, Y
    3864:	59 81       	ldd	r21, Y+1	; 0x01
    3866:	6a 81       	ldd	r22, Y+2	; 0x02
    3868:	7b 81       	ldd	r23, Y+3	; 0x03
    386a:	77 27       	eor	r23, r23
    386c:	81 e0       	ldi	r24, 0x01	; 1
    386e:	46 34       	cpi	r20, 0x46	; 70
    3870:	51 44       	sbci	r21, 0x41	; 65
    3872:	64 45       	sbci	r22, 0x54	; 84
    3874:	71 05       	cpc	r23, r1
    3876:	31 f4       	brne	.+12     	; 0x3884 <check_fs+0x6a>
    3878:	04 c0       	rjmp	.+8      	; 0x3882 <check_fs+0x68>
    387a:	83 e0       	ldi	r24, 0x03	; 3
    387c:	03 c0       	rjmp	.+6      	; 0x3884 <check_fs+0x6a>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    387e:	82 e0       	ldi	r24, 0x02	; 2
    3880:	01 c0       	rjmp	.+2      	; 0x3884 <check_fs+0x6a>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    3882:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    3884:	df 91       	pop	r29
    3886:	cf 91       	pop	r28
    3888:	0f 91       	pop	r16
    388a:	08 95       	ret

0000388c <validate>:
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
    388c:	00 97       	sbiw	r24, 0x00	; 0
    388e:	79 f0       	breq	.+30     	; 0x38ae <validate+0x22>
    3890:	fc 01       	movw	r30, r24
    3892:	20 81       	ld	r18, Z
    3894:	22 23       	and	r18, r18
    3896:	59 f0       	breq	.+22     	; 0x38ae <validate+0x22>
    3898:	26 81       	ldd	r18, Z+6	; 0x06
    389a:	37 81       	ldd	r19, Z+7	; 0x07
    389c:	26 17       	cp	r18, r22
    389e:	37 07       	cpc	r19, r23
    38a0:	31 f4       	brne	.+12     	; 0x38ae <validate+0x22>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
    38a2:	81 81       	ldd	r24, Z+1	; 0x01
    38a4:	79 df       	rcall	.-270    	; 0x3798 <disk_status>
    38a6:	80 fd       	sbrc	r24, 0
    38a8:	04 c0       	rjmp	.+8      	; 0x38b2 <validate+0x26>
		return FR_NOT_READY;

	return FR_OK;
    38aa:	80 e0       	ldi	r24, 0x00	; 0
    38ac:	08 95       	ret
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
    38ae:	89 e0       	ldi	r24, 0x09	; 9
    38b0:	08 95       	ret

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;
    38b2:	83 e0       	ldi	r24, 0x03	; 3

	return FR_OK;
}
    38b4:	08 95       	ret

000038b6 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    38b6:	0f 93       	push	r16
    38b8:	1f 93       	push	r17
    38ba:	fc 01       	movw	r30, r24
	clst -= 2;
    38bc:	9a 01       	movw	r18, r20
    38be:	ab 01       	movw	r20, r22
    38c0:	22 50       	subi	r18, 0x02	; 2
    38c2:	31 09       	sbc	r19, r1
    38c4:	41 09       	sbc	r20, r1
    38c6:	51 09       	sbc	r21, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    38c8:	82 85       	ldd	r24, Z+10	; 0x0a
    38ca:	93 85       	ldd	r25, Z+11	; 0x0b
    38cc:	a4 85       	ldd	r26, Z+12	; 0x0c
    38ce:	b5 85       	ldd	r27, Z+13	; 0x0d
    38d0:	02 97       	sbiw	r24, 0x02	; 2
    38d2:	a1 09       	sbc	r26, r1
    38d4:	b1 09       	sbc	r27, r1
    38d6:	28 17       	cp	r18, r24
    38d8:	39 07       	cpc	r19, r25
    38da:	4a 07       	cpc	r20, r26
    38dc:	5b 07       	cpc	r21, r27
    38de:	68 f4       	brcc	.+26     	; 0x38fa <clust2sect+0x44>
	return clst * fs->csize + fs->database;
    38e0:	a2 81       	ldd	r26, Z+2	; 0x02
    38e2:	b0 e0       	ldi	r27, 0x00	; 0
    38e4:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <__muluhisi3>
    38e8:	02 8d       	ldd	r16, Z+26	; 0x1a
    38ea:	13 8d       	ldd	r17, Z+27	; 0x1b
    38ec:	24 8d       	ldd	r18, Z+28	; 0x1c
    38ee:	35 8d       	ldd	r19, Z+29	; 0x1d
    38f0:	60 0f       	add	r22, r16
    38f2:	71 1f       	adc	r23, r17
    38f4:	82 1f       	adc	r24, r18
    38f6:	93 1f       	adc	r25, r19
    38f8:	03 c0       	rjmp	.+6      	; 0x3900 <clust2sect+0x4a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    38fa:	60 e0       	ldi	r22, 0x00	; 0
    38fc:	70 e0       	ldi	r23, 0x00	; 0
    38fe:	cb 01       	movw	r24, r22
	return clst * fs->csize + fs->database;
}
    3900:	1f 91       	pop	r17
    3902:	0f 91       	pop	r16
    3904:	08 95       	ret

00003906 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    3906:	af 92       	push	r10
    3908:	bf 92       	push	r11
    390a:	cf 92       	push	r12
    390c:	df 92       	push	r13
    390e:	ef 92       	push	r14
    3910:	ff 92       	push	r15
    3912:	0f 93       	push	r16
    3914:	1f 93       	push	r17
    3916:	cf 93       	push	r28
    3918:	df 93       	push	r29
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    391a:	42 30       	cpi	r20, 0x02	; 2
    391c:	51 05       	cpc	r21, r1
    391e:	61 05       	cpc	r22, r1
    3920:	71 05       	cpc	r23, r1
    3922:	08 f4       	brcc	.+2      	; 0x3926 <get_fat+0x20>
    3924:	a5 c0       	rjmp	.+330    	; 0x3a70 <get_fat+0x16a>
    3926:	fc 01       	movw	r30, r24
    3928:	02 85       	ldd	r16, Z+10	; 0x0a
    392a:	13 85       	ldd	r17, Z+11	; 0x0b
    392c:	24 85       	ldd	r18, Z+12	; 0x0c
    392e:	35 85       	ldd	r19, Z+13	; 0x0d
    3930:	40 17       	cp	r20, r16
    3932:	51 07       	cpc	r21, r17
    3934:	62 07       	cpc	r22, r18
    3936:	73 07       	cpc	r23, r19
    3938:	08 f0       	brcs	.+2      	; 0x393c <get_fat+0x36>
    393a:	9a c0       	rjmp	.+308    	; 0x3a70 <get_fat+0x16a>
    393c:	6a 01       	movw	r12, r20
    393e:	7b 01       	movw	r14, r22
    3940:	ec 01       	movw	r28, r24
		return 1;

	switch (fs->fs_type) {
    3942:	80 81       	ld	r24, Z
    3944:	82 30       	cpi	r24, 0x02	; 2
    3946:	09 f4       	brne	.+2      	; 0x394a <get_fat+0x44>
    3948:	48 c0       	rjmp	.+144    	; 0x39da <get_fat+0xd4>
    394a:	83 30       	cpi	r24, 0x03	; 3
    394c:	09 f4       	brne	.+2      	; 0x3950 <get_fat+0x4a>
    394e:	65 c0       	rjmp	.+202    	; 0x3a1a <get_fat+0x114>
    3950:	81 30       	cpi	r24, 0x01	; 1
    3952:	09 f0       	breq	.+2      	; 0x3956 <get_fat+0x50>
    3954:	92 c0       	rjmp	.+292    	; 0x3a7a <get_fat+0x174>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    3956:	5a 01       	movw	r10, r20
    3958:	b6 94       	lsr	r11
    395a:	a7 94       	ror	r10
    395c:	ac 0c       	add	r10, r12
    395e:	bd 1c       	adc	r11, r13
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3960:	c5 01       	movw	r24, r10
    3962:	89 2f       	mov	r24, r25
    3964:	99 27       	eor	r25, r25
    3966:	86 95       	lsr	r24
    3968:	4a 89       	ldd	r20, Y+18	; 0x12
    396a:	5b 89       	ldd	r21, Y+19	; 0x13
    396c:	6c 89       	ldd	r22, Y+20	; 0x14
    396e:	7d 89       	ldd	r23, Y+21	; 0x15
    3970:	48 0f       	add	r20, r24
    3972:	59 1f       	adc	r21, r25
    3974:	61 1d       	adc	r22, r1
    3976:	71 1d       	adc	r23, r1
    3978:	ce 01       	movw	r24, r28
    397a:	1c df       	rcall	.-456    	; 0x37b4 <move_window>
    397c:	81 11       	cpse	r24, r1
    397e:	7d c0       	rjmp	.+250    	; 0x3a7a <get_fat+0x174>
		wc = fs->win[bc % SS(fs)]; bc++;
    3980:	f5 01       	movw	r30, r10
    3982:	f1 70       	andi	r31, 0x01	; 1
    3984:	ec 0f       	add	r30, r28
    3986:	fd 1f       	adc	r31, r29
    3988:	12 a1       	ldd	r17, Z+34	; 0x22
    398a:	ff ef       	ldi	r31, 0xFF	; 255
    398c:	af 1a       	sub	r10, r31
    398e:	bf 0a       	sbc	r11, r31
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3990:	c5 01       	movw	r24, r10
    3992:	89 2f       	mov	r24, r25
    3994:	99 27       	eor	r25, r25
    3996:	86 95       	lsr	r24
    3998:	4a 89       	ldd	r20, Y+18	; 0x12
    399a:	5b 89       	ldd	r21, Y+19	; 0x13
    399c:	6c 89       	ldd	r22, Y+20	; 0x14
    399e:	7d 89       	ldd	r23, Y+21	; 0x15
    39a0:	48 0f       	add	r20, r24
    39a2:	59 1f       	adc	r21, r25
    39a4:	61 1d       	adc	r22, r1
    39a6:	71 1d       	adc	r23, r1
    39a8:	ce 01       	movw	r24, r28
    39aa:	04 df       	rcall	.-504    	; 0x37b4 <move_window>
    39ac:	81 11       	cpse	r24, r1
    39ae:	65 c0       	rjmp	.+202    	; 0x3a7a <get_fat+0x174>
		wc |= fs->win[bc % SS(fs)] << 8;
    39b0:	c5 01       	movw	r24, r10
    39b2:	91 70       	andi	r25, 0x01	; 1
    39b4:	fe 01       	movw	r30, r28
    39b6:	e8 0f       	add	r30, r24
    39b8:	f9 1f       	adc	r31, r25
    39ba:	82 a1       	ldd	r24, Z+34	; 0x22
    39bc:	61 2f       	mov	r22, r17
    39be:	70 e0       	ldi	r23, 0x00	; 0
    39c0:	78 2b       	or	r23, r24
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    39c2:	c0 fe       	sbrs	r12, 0
    39c4:	06 c0       	rjmp	.+12     	; 0x39d2 <get_fat+0xcc>
    39c6:	54 e0       	ldi	r21, 0x04	; 4
    39c8:	76 95       	lsr	r23
    39ca:	67 95       	ror	r22
    39cc:	5a 95       	dec	r21
    39ce:	e1 f7       	brne	.-8      	; 0x39c8 <get_fat+0xc2>
    39d0:	01 c0       	rjmp	.+2      	; 0x39d4 <get_fat+0xce>
    39d2:	7f 70       	andi	r23, 0x0F	; 15
    39d4:	80 e0       	ldi	r24, 0x00	; 0
    39d6:	90 e0       	ldi	r25, 0x00	; 0
    39d8:	53 c0       	rjmp	.+166    	; 0x3a80 <get_fat+0x17a>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    39da:	77 27       	eor	r23, r23
    39dc:	6f 2d       	mov	r22, r15
    39de:	5e 2d       	mov	r21, r14
    39e0:	4d 2d       	mov	r20, r13
    39e2:	82 89       	ldd	r24, Z+18	; 0x12
    39e4:	93 89       	ldd	r25, Z+19	; 0x13
    39e6:	a4 89       	ldd	r26, Z+20	; 0x14
    39e8:	b5 89       	ldd	r27, Z+21	; 0x15
    39ea:	48 0f       	add	r20, r24
    39ec:	59 1f       	adc	r21, r25
    39ee:	6a 1f       	adc	r22, r26
    39f0:	7b 1f       	adc	r23, r27
    39f2:	cf 01       	movw	r24, r30
    39f4:	df de       	rcall	.-578    	; 0x37b4 <move_window>
    39f6:	81 11       	cpse	r24, r1
    39f8:	40 c0       	rjmp	.+128    	; 0x3a7a <get_fat+0x174>
		p = &fs->win[clst * 2 % SS(fs)];
    39fa:	cc 0c       	add	r12, r12
    39fc:	dd 1c       	adc	r13, r13
    39fe:	ee 1c       	adc	r14, r14
    3a00:	ff 1c       	adc	r15, r15
    3a02:	e8 94       	clt
    3a04:	c0 f8       	bld	r12, 0
    3a06:	81 e0       	ldi	r24, 0x01	; 1
    3a08:	d8 22       	and	r13, r24
    3a0a:	ee 24       	eor	r14, r14
    3a0c:	ff 24       	eor	r15, r15
		return LD_WORD(p);
    3a0e:	fe 01       	movw	r30, r28
    3a10:	ec 0d       	add	r30, r12
    3a12:	fd 1d       	adc	r31, r13
    3a14:	62 a1       	ldd	r22, Z+34	; 0x22
    3a16:	73 a1       	ldd	r23, Z+35	; 0x23
    3a18:	dd cf       	rjmp	.-70     	; 0x39d4 <get_fat+0xce>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    3a1a:	82 89       	ldd	r24, Z+18	; 0x12
    3a1c:	93 89       	ldd	r25, Z+19	; 0x13
    3a1e:	a4 89       	ldd	r26, Z+20	; 0x14
    3a20:	b5 89       	ldd	r27, Z+21	; 0x15
    3a22:	27 e0       	ldi	r18, 0x07	; 7
    3a24:	76 95       	lsr	r23
    3a26:	67 95       	ror	r22
    3a28:	57 95       	ror	r21
    3a2a:	47 95       	ror	r20
    3a2c:	2a 95       	dec	r18
    3a2e:	d1 f7       	brne	.-12     	; 0x3a24 <get_fat+0x11e>
    3a30:	48 0f       	add	r20, r24
    3a32:	59 1f       	adc	r21, r25
    3a34:	6a 1f       	adc	r22, r26
    3a36:	7b 1f       	adc	r23, r27
    3a38:	cf 01       	movw	r24, r30
    3a3a:	bc de       	rcall	.-648    	; 0x37b4 <move_window>
    3a3c:	81 11       	cpse	r24, r1
    3a3e:	1d c0       	rjmp	.+58     	; 0x3a7a <get_fat+0x174>
		p = &fs->win[clst * 4 % SS(fs)];
    3a40:	82 e0       	ldi	r24, 0x02	; 2
    3a42:	cc 0c       	add	r12, r12
    3a44:	dd 1c       	adc	r13, r13
    3a46:	ee 1c       	adc	r14, r14
    3a48:	ff 1c       	adc	r15, r15
    3a4a:	8a 95       	dec	r24
    3a4c:	d1 f7       	brne	.-12     	; 0x3a42 <get_fat+0x13c>
    3a4e:	ec ef       	ldi	r30, 0xFC	; 252
    3a50:	ce 22       	and	r12, r30
    3a52:	e1 e0       	ldi	r30, 0x01	; 1
    3a54:	de 22       	and	r13, r30
    3a56:	ee 24       	eor	r14, r14
    3a58:	ff 24       	eor	r15, r15
		return LD_DWORD(p) & 0x0FFFFFFF;
    3a5a:	fe 01       	movw	r30, r28
    3a5c:	ec 0d       	add	r30, r12
    3a5e:	fd 1d       	adc	r31, r13
    3a60:	82 a1       	ldd	r24, Z+34	; 0x22
    3a62:	93 a1       	ldd	r25, Z+35	; 0x23
    3a64:	a4 a1       	ldd	r26, Z+36	; 0x24
    3a66:	b5 a1       	ldd	r27, Z+37	; 0x25
    3a68:	bc 01       	movw	r22, r24
    3a6a:	cd 01       	movw	r24, r26
    3a6c:	9f 70       	andi	r25, 0x0F	; 15
    3a6e:	08 c0       	rjmp	.+16     	; 0x3a80 <get_fat+0x17a>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;
    3a70:	61 e0       	ldi	r22, 0x01	; 1
    3a72:	70 e0       	ldi	r23, 0x00	; 0
    3a74:	80 e0       	ldi	r24, 0x00	; 0
    3a76:	90 e0       	ldi	r25, 0x00	; 0
    3a78:	03 c0       	rjmp	.+6      	; 0x3a80 <get_fat+0x17a>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    3a7a:	6f ef       	ldi	r22, 0xFF	; 255
    3a7c:	7f ef       	ldi	r23, 0xFF	; 255
    3a7e:	cb 01       	movw	r24, r22
}
    3a80:	df 91       	pop	r29
    3a82:	cf 91       	pop	r28
    3a84:	1f 91       	pop	r17
    3a86:	0f 91       	pop	r16
    3a88:	ff 90       	pop	r15
    3a8a:	ef 90       	pop	r14
    3a8c:	df 90       	pop	r13
    3a8e:	cf 90       	pop	r12
    3a90:	bf 90       	pop	r11
    3a92:	af 90       	pop	r10
    3a94:	08 95       	ret

00003a96 <dir_sdi.constprop.3>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (
    3a96:	0f 93       	push	r16
    3a98:	1f 93       	push	r17
    3a9a:	cf 93       	push	r28
    3a9c:	df 93       	push	r29
    3a9e:	ec 01       	movw	r28, r24
{
	DWORD clst;
	WORD ic;


	dj->index = idx;
    3aa0:	1d 82       	std	Y+5, r1	; 0x05
    3aa2:	1c 82       	std	Y+4, r1	; 0x04
	clst = dj->sclust;
    3aa4:	4e 81       	ldd	r20, Y+6	; 0x06
    3aa6:	5f 81       	ldd	r21, Y+7	; 0x07
    3aa8:	68 85       	ldd	r22, Y+8	; 0x08
    3aaa:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    3aac:	41 30       	cpi	r20, 0x01	; 1
    3aae:	51 05       	cpc	r21, r1
    3ab0:	61 05       	cpc	r22, r1
    3ab2:	71 05       	cpc	r23, r1
    3ab4:	11 f4       	brne	.+4      	; 0x3aba <dir_sdi.constprop.3+0x24>
		return FR_INT_ERR;
    3ab6:	82 e0       	ldi	r24, 0x02	; 2
    3ab8:	61 c0       	rjmp	.+194    	; 0x3b7c <dir_sdi.constprop.3+0xe6>
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    3aba:	08 81       	ld	r16, Y
    3abc:	19 81       	ldd	r17, Y+1	; 0x01
    3abe:	f8 01       	movw	r30, r16
    3ac0:	82 85       	ldd	r24, Z+10	; 0x0a
    3ac2:	93 85       	ldd	r25, Z+11	; 0x0b
    3ac4:	a4 85       	ldd	r26, Z+12	; 0x0c
    3ac6:	b5 85       	ldd	r27, Z+13	; 0x0d
    3ac8:	48 17       	cp	r20, r24
    3aca:	59 07       	cpc	r21, r25
    3acc:	6a 07       	cpc	r22, r26
    3ace:	7b 07       	cpc	r23, r27
    3ad0:	90 f7       	brcc	.-28     	; 0x3ab6 <dir_sdi.constprop.3+0x20>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    3ad2:	41 15       	cp	r20, r1
    3ad4:	51 05       	cpc	r21, r1
    3ad6:	61 05       	cpc	r22, r1
    3ad8:	71 05       	cpc	r23, r1
    3ada:	f1 f4       	brne	.+60     	; 0x3b18 <dir_sdi.constprop.3+0x82>
    3adc:	80 81       	ld	r24, Z
    3ade:	83 30       	cpi	r24, 0x03	; 3
    3ae0:	49 f4       	brne	.+18     	; 0x3af4 <dir_sdi.constprop.3+0x5e>
		clst = dj->fs->dirbase;
    3ae2:	46 89       	ldd	r20, Z+22	; 0x16
    3ae4:	57 89       	ldd	r21, Z+23	; 0x17
    3ae6:	60 8d       	ldd	r22, Z+24	; 0x18
    3ae8:	71 8d       	ldd	r23, Z+25	; 0x19

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    3aea:	41 15       	cp	r20, r1
    3aec:	51 05       	cpc	r21, r1
    3aee:	61 05       	cpc	r22, r1
    3af0:	71 05       	cpc	r23, r1
    3af2:	91 f4       	brne	.+36     	; 0x3b18 <dir_sdi.constprop.3+0x82>
		dj->clust = clst;
    3af4:	1a 86       	std	Y+10, r1	; 0x0a
    3af6:	1b 86       	std	Y+11, r1	; 0x0b
    3af8:	1c 86       	std	Y+12, r1	; 0x0c
    3afa:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    3afc:	f8 01       	movw	r30, r16
    3afe:	80 85       	ldd	r24, Z+8	; 0x08
    3b00:	91 85       	ldd	r25, Z+9	; 0x09
    3b02:	89 2b       	or	r24, r25
    3b04:	c1 f2       	breq	.-80     	; 0x3ab6 <dir_sdi.constprop.3+0x20>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    3b06:	86 89       	ldd	r24, Z+22	; 0x16
    3b08:	97 89       	ldd	r25, Z+23	; 0x17
    3b0a:	a0 8d       	ldd	r26, Z+24	; 0x18
    3b0c:	b1 8d       	ldd	r27, Z+25	; 0x19
    3b0e:	8e 87       	std	Y+14, r24	; 0x0e
    3b10:	9f 87       	std	Y+15, r25	; 0x0f
    3b12:	a8 8b       	std	Y+16, r26	; 0x10
    3b14:	b9 8b       	std	Y+17, r27	; 0x11
    3b16:	2b c0       	rjmp	.+86     	; 0x3b6e <dir_sdi.constprop.3+0xd8>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    3b18:	f8 01       	movw	r30, r16
    3b1a:	82 81       	ldd	r24, Z+2	; 0x02
		while (idx >= ic) {	/* Follow cluster chain */
    3b1c:	81 11       	cpse	r24, r1
    3b1e:	1d c0       	rjmp	.+58     	; 0x3b5a <dir_sdi.constprop.3+0xc4>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    3b20:	88 81       	ld	r24, Y
    3b22:	99 81       	ldd	r25, Y+1	; 0x01
    3b24:	f0 de       	rcall	.-544    	; 0x3906 <get_fat>
    3b26:	ab 01       	movw	r20, r22
    3b28:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3b2a:	4f 3f       	cpi	r20, 0xFF	; 255
    3b2c:	ff ef       	ldi	r31, 0xFF	; 255
    3b2e:	5f 07       	cpc	r21, r31
    3b30:	6f 07       	cpc	r22, r31
    3b32:	7f 07       	cpc	r23, r31
    3b34:	11 f1       	breq	.+68     	; 0x3b7a <dir_sdi.constprop.3+0xe4>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    3b36:	42 30       	cpi	r20, 0x02	; 2
    3b38:	51 05       	cpc	r21, r1
    3b3a:	61 05       	cpc	r22, r1
    3b3c:	71 05       	cpc	r23, r1
    3b3e:	08 f4       	brcc	.+2      	; 0x3b42 <dir_sdi.constprop.3+0xac>
    3b40:	ba cf       	rjmp	.-140    	; 0x3ab6 <dir_sdi.constprop.3+0x20>
    3b42:	e8 81       	ld	r30, Y
    3b44:	f9 81       	ldd	r31, Y+1	; 0x01
    3b46:	82 85       	ldd	r24, Z+10	; 0x0a
    3b48:	93 85       	ldd	r25, Z+11	; 0x0b
    3b4a:	a4 85       	ldd	r26, Z+12	; 0x0c
    3b4c:	b5 85       	ldd	r27, Z+13	; 0x0d
    3b4e:	48 17       	cp	r20, r24
    3b50:	59 07       	cpc	r21, r25
    3b52:	6a 07       	cpc	r22, r26
    3b54:	7b 07       	cpc	r23, r27
    3b56:	20 f3       	brcs	.-56     	; 0x3b20 <dir_sdi.constprop.3+0x8a>
    3b58:	ae cf       	rjmp	.-164    	; 0x3ab6 <dir_sdi.constprop.3+0x20>
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    3b5a:	4a 87       	std	Y+10, r20	; 0x0a
    3b5c:	5b 87       	std	Y+11, r21	; 0x0b
    3b5e:	6c 87       	std	Y+12, r22	; 0x0c
    3b60:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    3b62:	c8 01       	movw	r24, r16
    3b64:	a8 de       	rcall	.-688    	; 0x38b6 <clust2sect>
    3b66:	6e 87       	std	Y+14, r22	; 0x0e
    3b68:	7f 87       	std	Y+15, r23	; 0x0f
    3b6a:	88 8b       	std	Y+16, r24	; 0x10
    3b6c:	99 8b       	std	Y+17, r25	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    3b6e:	c8 01       	movw	r24, r16
    3b70:	82 96       	adiw	r24, 0x22	; 34
    3b72:	9b 8b       	std	Y+19, r25	; 0x13
    3b74:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
    3b76:	80 e0       	ldi	r24, 0x00	; 0
    3b78:	01 c0       	rjmp	.+2      	; 0x3b7c <dir_sdi.constprop.3+0xe6>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3b7a:	81 e0       	ldi	r24, 0x01	; 1
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    3b7c:	df 91       	pop	r29
    3b7e:	cf 91       	pop	r28
    3b80:	1f 91       	pop	r17
    3b82:	0f 91       	pop	r16
    3b84:	08 95       	ret

00003b86 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)			/* Check if the drive number is valid */
    3b86:	81 11       	cpse	r24, r1
    3b88:	12 c0       	rjmp	.+36     	; 0x3bae <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];				/* Get current fs object */
    3b8a:	e0 91 b5 03 	lds	r30, 0x03B5	; 0x8003b5 <FatFs>
    3b8e:	f0 91 b6 03 	lds	r31, 0x03B6	; 0x8003b6 <FatFs+0x1>

	if (rfs) {
    3b92:	30 97       	sbiw	r30, 0x00	; 0
    3b94:	09 f0       	breq	.+2      	; 0x3b98 <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT					/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;			/* Clear old fs object */
    3b96:	10 82       	st	Z, r1
	}

	if (fs) {
    3b98:	61 15       	cp	r22, r1
    3b9a:	71 05       	cpc	r23, r1
    3b9c:	11 f0       	breq	.+4      	; 0x3ba2 <f_mount+0x1c>
		fs->fs_type = 0;			/* Clear new fs object */
    3b9e:	fb 01       	movw	r30, r22
    3ba0:	10 82       	st	Z, r1
#if _FS_REENTRANT					/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;				/* Register new fs object */
    3ba2:	70 93 b6 03 	sts	0x03B6, r23	; 0x8003b6 <FatFs+0x1>
    3ba6:	60 93 b5 03 	sts	0x03B5, r22	; 0x8003b5 <FatFs>

	return FR_OK;
    3baa:	80 e0       	ldi	r24, 0x00	; 0
    3bac:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)			/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    3bae:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;				/* Register new fs object */

	return FR_OK;
}
    3bb0:	08 95       	ret

00003bb2 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3bb2:	2f 92       	push	r2
    3bb4:	3f 92       	push	r3
    3bb6:	4f 92       	push	r4
    3bb8:	5f 92       	push	r5
    3bba:	6f 92       	push	r6
    3bbc:	7f 92       	push	r7
    3bbe:	8f 92       	push	r8
    3bc0:	9f 92       	push	r9
    3bc2:	af 92       	push	r10
    3bc4:	bf 92       	push	r11
    3bc6:	cf 92       	push	r12
    3bc8:	df 92       	push	r13
    3bca:	ef 92       	push	r14
    3bcc:	ff 92       	push	r15
    3bce:	0f 93       	push	r16
    3bd0:	1f 93       	push	r17
    3bd2:	cf 93       	push	r28
    3bd4:	df 93       	push	r29
    3bd6:	cd b7       	in	r28, 0x3d	; 61
    3bd8:	de b7       	in	r29, 0x3e	; 62
    3bda:	e3 97       	sbiw	r28, 0x33	; 51
    3bdc:	0f b6       	in	r0, 0x3f	; 63
    3bde:	f8 94       	cli
    3be0:	de bf       	out	0x3e, r29	; 62
    3be2:	0f be       	out	0x3f, r0	; 63
    3be4:	cd bf       	out	0x3d, r28	; 61
    3be6:	9c a3       	std	Y+36, r25	; 0x24
    3be8:	8b a3       	std	Y+35, r24	; 0x23
    3bea:	1b 01       	movw	r2, r22
    3bec:	4b ab       	std	Y+51, r20	; 0x33
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
    3bee:	dc 01       	movw	r26, r24
    3bf0:	1d 92       	st	X+, r1
    3bf2:	1c 92       	st	X, r1
	WORD nrsv;
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    3bf4:	fb 01       	movw	r30, r22
    3bf6:	80 81       	ld	r24, Z
    3bf8:	90 e0       	ldi	r25, 0x00	; 0
    3bfa:	c0 97       	sbiw	r24, 0x30	; 48
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    3bfc:	8a 30       	cpi	r24, 0x0A	; 10
    3bfe:	91 05       	cpc	r25, r1
    3c00:	48 f4       	brcc	.+18     	; 0x3c14 <f_open+0x62>
    3c02:	21 81       	ldd	r18, Z+1	; 0x01
    3c04:	2a 33       	cpi	r18, 0x3A	; 58
    3c06:	31 f4       	brne	.+12     	; 0x3c14 <f_open+0x62>
		p += 2; *path = p;				/* Return pointer to the path name */
    3c08:	f2 e0       	ldi	r31, 0x02	; 2
    3c0a:	2f 0e       	add	r2, r31
    3c0c:	31 1c       	adc	r3, r1
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    3c0e:	89 2b       	or	r24, r25
    3c10:	09 f0       	breq	.+2      	; 0x3c14 <f_open+0x62>
    3c12:	7c c1       	rjmp	.+760    	; 0x3f0c <f_open+0x35a>
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    3c14:	00 91 b5 03 	lds	r16, 0x03B5	; 0x8003b5 <FatFs>
    3c18:	10 91 b6 03 	lds	r17, 0x03B6	; 0x8003b6 <FatFs+0x1>
    3c1c:	1a 83       	std	Y+2, r17	; 0x02
    3c1e:	09 83       	std	Y+1, r16	; 0x01
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    3c20:	01 15       	cp	r16, r1
    3c22:	11 05       	cpc	r17, r1
    3c24:	09 f4       	brne	.+2      	; 0x3c28 <f_open+0x76>
    3c26:	74 c1       	rjmp	.+744    	; 0x3f10 <f_open+0x35e>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
    3c28:	d8 01       	movw	r26, r16
    3c2a:	8c 91       	ld	r24, X
    3c2c:	81 11       	cpse	r24, r1
    3c2e:	08 c0       	rjmp	.+16     	; 0x3c40 <f_open+0x8e>
	}

	/* The logical drive must be mounted. */
	/* Following code attempts to mount a volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    3c30:	f8 01       	movw	r30, r16
    3c32:	10 82       	st	Z, r1
	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
    3c34:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    3c36:	80 e0       	ldi	r24, 0x00	; 0
    3c38:	ad dd       	rcall	.-1190   	; 0x3794 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    3c3a:	80 fd       	sbrc	r24, 0
    3c3c:	6b c1       	rjmp	.+726    	; 0x3f14 <f_open+0x362>
    3c3e:	07 c0       	rjmp	.+14     	; 0x3c4e <f_open+0x9c>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
    3c40:	d8 01       	movw	r26, r16
    3c42:	11 96       	adiw	r26, 0x01	; 1
    3c44:	8c 91       	ld	r24, X
    3c46:	a8 dd       	rcall	.-1200   	; 0x3798 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    3c48:	80 fd       	sbrc	r24, 0
    3c4a:	f2 cf       	rjmp	.-28     	; 0x3c30 <f_open+0x7e>
    3c4c:	65 c1       	rjmp	.+714    	; 0x3f18 <f_open+0x366>
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
    3c4e:	40 e0       	ldi	r20, 0x00	; 0
    3c50:	50 e0       	ldi	r21, 0x00	; 0
    3c52:	ba 01       	movw	r22, r20
    3c54:	c8 01       	movw	r24, r16
    3c56:	e1 dd       	rcall	.-1086   	; 0x381a <check_fs>
	if (fmt == 1) {						/* Not an FAT-VBR, the disk may be partitioned */
    3c58:	81 30       	cpi	r24, 0x01	; 1
    3c5a:	89 f4       	brne	.+34     	; 0x3c7e <f_open+0xcc>
		/* Check the partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(vol) * SZ_PTE];/* Partition table */
		if (tbl[4]) {									/* Is the partition existing? */
    3c5c:	f8 01       	movw	r30, r16
    3c5e:	ec 51       	subi	r30, 0x1C	; 28
    3c60:	fe 4f       	sbci	r31, 0xFE	; 254
    3c62:	80 81       	ld	r24, Z
    3c64:	88 23       	and	r24, r24
    3c66:	09 f4       	brne	.+2      	; 0x3c6a <f_open+0xb8>
    3c68:	5b c1       	rjmp	.+694    	; 0x3f20 <f_open+0x36e>
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
    3c6a:	34 96       	adiw	r30, 0x04	; 4
    3c6c:	40 80       	ld	r4, Z
    3c6e:	51 80       	ldd	r5, Z+1	; 0x01
    3c70:	62 80       	ldd	r6, Z+2	; 0x02
    3c72:	73 80       	ldd	r7, Z+3	; 0x03
			fmt = check_fs(fs, bsect);					/* Check the partition */
    3c74:	b3 01       	movw	r22, r6
    3c76:	a2 01       	movw	r20, r4
    3c78:	c8 01       	movw	r24, r16
    3c7a:	cf dd       	rcall	.-1122   	; 0x381a <check_fs>
    3c7c:	03 c0       	rjmp	.+6      	; 0x3c84 <f_open+0xd2>
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
    3c7e:	41 2c       	mov	r4, r1
    3c80:	51 2c       	mov	r5, r1
    3c82:	32 01       	movw	r6, r4
		if (tbl[4]) {									/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);					/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    3c84:	83 30       	cpi	r24, 0x03	; 3
    3c86:	09 f4       	brne	.+2      	; 0x3c8a <f_open+0xd8>
    3c88:	49 c1       	rjmp	.+658    	; 0x3f1c <f_open+0x36a>
	if (fmt) return FR_NO_FILESYSTEM;					/* No FAT volume is found */
    3c8a:	81 11       	cpse	r24, r1
    3c8c:	49 c1       	rjmp	.+658    	; 0x3f20 <f_open+0x36e>

	/* Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    3c8e:	f8 01       	movw	r30, r16
    3c90:	85 a5       	ldd	r24, Z+45	; 0x2d
    3c92:	96 a5       	ldd	r25, Z+46	; 0x2e
    3c94:	81 15       	cp	r24, r1
    3c96:	92 40       	sbci	r25, 0x02	; 2
    3c98:	09 f0       	breq	.+2      	; 0x3c9c <f_open+0xea>
    3c9a:	42 c1       	rjmp	.+644    	; 0x3f20 <f_open+0x36e>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    3c9c:	d8 01       	movw	r26, r16
    3c9e:	d8 96       	adiw	r26, 0x38	; 56
    3ca0:	8d 90       	ld	r8, X+
    3ca2:	9c 90       	ld	r9, X
    3ca4:	d9 97       	sbiw	r26, 0x39	; 57
    3ca6:	a1 2c       	mov	r10, r1
    3ca8:	b1 2c       	mov	r11, r1
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    3caa:	81 14       	cp	r8, r1
    3cac:	91 04       	cpc	r9, r1
    3cae:	a1 04       	cpc	r10, r1
    3cb0:	b1 04       	cpc	r11, r1
    3cb2:	39 f4       	brne	.+14     	; 0x3cc2 <f_open+0x110>
    3cb4:	f8 01       	movw	r30, r16
    3cb6:	ea 5b       	subi	r30, 0xBA	; 186
    3cb8:	ff 4f       	sbci	r31, 0xFF	; 255
    3cba:	80 80       	ld	r8, Z
    3cbc:	91 80       	ldd	r9, Z+1	; 0x01
    3cbe:	a2 80       	ldd	r10, Z+2	; 0x02
    3cc0:	b3 80       	ldd	r11, Z+3	; 0x03
	fs->fsize = fasize;
    3cc2:	f8 01       	movw	r30, r16
    3cc4:	86 86       	std	Z+14, r8	; 0x0e
    3cc6:	97 86       	std	Z+15, r9	; 0x0f
    3cc8:	a0 8a       	std	Z+16, r10	; 0x10
    3cca:	b1 8a       	std	Z+17, r11	; 0x11

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    3ccc:	a2 a9       	ldd	r26, Z+50	; 0x32
    3cce:	a3 83       	std	Z+3, r26	; 0x03
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    3cd0:	8f ef       	ldi	r24, 0xFF	; 255
    3cd2:	8a 0f       	add	r24, r26
    3cd4:	82 30       	cpi	r24, 0x02	; 2
    3cd6:	08 f0       	brcs	.+2      	; 0x3cda <f_open+0x128>
    3cd8:	23 c1       	rjmp	.+582    	; 0x3f20 <f_open+0x36e>
	fasize *= b;										/* Number of sectors for FAT area */
    3cda:	b0 e0       	ldi	r27, 0x00	; 0
    3cdc:	a5 01       	movw	r20, r10
    3cde:	94 01       	movw	r18, r8
    3ce0:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <__muluhisi3>
    3ce4:	6b a7       	std	Y+43, r22	; 0x2b
    3ce6:	7c a7       	std	Y+44, r23	; 0x2c
    3ce8:	8d a7       	std	Y+45, r24	; 0x2d
    3cea:	9e a7       	std	Y+46, r25	; 0x2e

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    3cec:	27 a5       	ldd	r18, Z+47	; 0x2f
    3cee:	22 83       	std	Z+2, r18	; 0x02
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    3cf0:	22 23       	and	r18, r18
    3cf2:	09 f4       	brne	.+2      	; 0x3cf6 <f_open+0x144>
    3cf4:	15 c1       	rjmp	.+554    	; 0x3f20 <f_open+0x36e>
    3cf6:	82 2f       	mov	r24, r18
    3cf8:	90 e0       	ldi	r25, 0x00	; 0
    3cfa:	ac 01       	movw	r20, r24
    3cfc:	41 50       	subi	r20, 0x01	; 1
    3cfe:	51 09       	sbc	r21, r1
    3d00:	84 23       	and	r24, r20
    3d02:	95 23       	and	r25, r21
    3d04:	89 2b       	or	r24, r25
    3d06:	09 f0       	breq	.+2      	; 0x3d0a <f_open+0x158>
    3d08:	0b c1       	rjmp	.+534    	; 0x3f20 <f_open+0x36e>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    3d0a:	c3 a8       	ldd	r12, Z+51	; 0x33
    3d0c:	d4 a8       	ldd	r13, Z+52	; 0x34
    3d0e:	da a6       	std	Y+42, r13	; 0x2a
    3d10:	c9 a6       	std	Y+41, r12	; 0x29
    3d12:	d1 86       	std	Z+9, r13	; 0x09
    3d14:	c0 86       	std	Z+8, r12	; 0x08
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    3d16:	c6 01       	movw	r24, r12
    3d18:	8f 70       	andi	r24, 0x0F	; 15
    3d1a:	99 27       	eor	r25, r25
    3d1c:	89 2b       	or	r24, r25
    3d1e:	09 f0       	breq	.+2      	; 0x3d22 <f_open+0x170>
    3d20:	ff c0       	rjmp	.+510    	; 0x3f20 <f_open+0x36e>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    3d22:	65 a9       	ldd	r22, Z+53	; 0x35
    3d24:	76 a9       	ldd	r23, Z+54	; 0x36
    3d26:	cb 01       	movw	r24, r22
    3d28:	a0 e0       	ldi	r26, 0x00	; 0
    3d2a:	b0 e0       	ldi	r27, 0x00	; 0
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    3d2c:	00 97       	sbiw	r24, 0x00	; 0
    3d2e:	a1 05       	cpc	r26, r1
    3d30:	b1 05       	cpc	r27, r1
    3d32:	31 f4       	brne	.+12     	; 0x3d40 <f_open+0x18e>
    3d34:	ee 5b       	subi	r30, 0xBE	; 190
    3d36:	ff 4f       	sbci	r31, 0xFF	; 255
    3d38:	80 81       	ld	r24, Z
    3d3a:	91 81       	ldd	r25, Z+1	; 0x01
    3d3c:	a2 81       	ldd	r26, Z+2	; 0x02
    3d3e:	b3 81       	ldd	r27, Z+3	; 0x03

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    3d40:	f8 01       	movw	r30, r16
    3d42:	40 a9       	ldd	r20, Z+48	; 0x30
    3d44:	51 a9       	ldd	r21, Z+49	; 0x31
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    3d46:	41 15       	cp	r20, r1
    3d48:	51 05       	cpc	r21, r1
    3d4a:	09 f4       	brne	.+2      	; 0x3d4e <f_open+0x19c>
    3d4c:	e9 c0       	rjmp	.+466    	; 0x3f20 <f_open+0x36e>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    3d4e:	6a 01       	movw	r12, r20
    3d50:	e1 2c       	mov	r14, r1
    3d52:	f1 2c       	mov	r15, r1
    3d54:	cf a6       	std	Y+47, r12	; 0x2f
    3d56:	d8 aa       	std	Y+48, r13	; 0x30
    3d58:	e9 aa       	std	Y+49, r14	; 0x31
    3d5a:	fa aa       	std	Y+50, r15	; 0x32
    3d5c:	49 a5       	ldd	r20, Y+41	; 0x29
    3d5e:	5a a5       	ldd	r21, Y+42	; 0x2a
    3d60:	64 e0       	ldi	r22, 0x04	; 4
    3d62:	56 95       	lsr	r21
    3d64:	47 95       	ror	r20
    3d66:	6a 95       	dec	r22
    3d68:	e1 f7       	brne	.-8      	; 0x3d62 <f_open+0x1b0>
    3d6a:	c4 0e       	add	r12, r20
    3d6c:	d5 1e       	adc	r13, r21
    3d6e:	e1 1c       	adc	r14, r1
    3d70:	f1 1c       	adc	r15, r1
    3d72:	4b a5       	ldd	r20, Y+43	; 0x2b
    3d74:	5c a5       	ldd	r21, Y+44	; 0x2c
    3d76:	6d a5       	ldd	r22, Y+45	; 0x2d
    3d78:	7e a5       	ldd	r23, Y+46	; 0x2e
    3d7a:	4c 0d       	add	r20, r12
    3d7c:	5d 1d       	adc	r21, r13
    3d7e:	6e 1d       	adc	r22, r14
    3d80:	7f 1d       	adc	r23, r15
    3d82:	4d a3       	std	Y+37, r20	; 0x25
    3d84:	5e a3       	std	Y+38, r21	; 0x26
    3d86:	6f a3       	std	Y+39, r22	; 0x27
    3d88:	78 a7       	std	Y+40, r23	; 0x28
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    3d8a:	84 17       	cp	r24, r20
    3d8c:	95 07       	cpc	r25, r21
    3d8e:	a6 07       	cpc	r26, r22
    3d90:	b7 07       	cpc	r27, r23
    3d92:	08 f4       	brcc	.+2      	; 0x3d96 <f_open+0x1e4>
    3d94:	c5 c0       	rjmp	.+394    	; 0x3f20 <f_open+0x36e>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    3d96:	bc 01       	movw	r22, r24
    3d98:	cd 01       	movw	r24, r26
    3d9a:	cd a0       	ldd	r12, Y+37	; 0x25
    3d9c:	de a0       	ldd	r13, Y+38	; 0x26
    3d9e:	ef a0       	ldd	r14, Y+39	; 0x27
    3da0:	f8 a4       	ldd	r15, Y+40	; 0x28
    3da2:	6c 19       	sub	r22, r12
    3da4:	7d 09       	sbc	r23, r13
    3da6:	8e 09       	sbc	r24, r14
    3da8:	9f 09       	sbc	r25, r15
    3daa:	30 e0       	ldi	r19, 0x00	; 0
    3dac:	40 e0       	ldi	r20, 0x00	; 0
    3dae:	50 e0       	ldi	r21, 0x00	; 0
    3db0:	0e 94 b8 39 	call	0x7370	; 0x7370 <__udivmodsi4>
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    3db4:	21 15       	cp	r18, r1
    3db6:	31 05       	cpc	r19, r1
    3db8:	41 05       	cpc	r20, r1
    3dba:	51 05       	cpc	r21, r1
    3dbc:	09 f4       	brne	.+2      	; 0x3dc0 <f_open+0x20e>
    3dbe:	b0 c0       	rjmp	.+352    	; 0x3f20 <f_open+0x36e>
    3dc0:	69 01       	movw	r12, r18
    3dc2:	7a 01       	movw	r14, r20
    3dc4:	62 e0       	ldi	r22, 0x02	; 2
    3dc6:	c6 0e       	add	r12, r22
    3dc8:	d1 1c       	adc	r13, r1
    3dca:	e1 1c       	adc	r14, r1
    3dcc:	f1 1c       	adc	r15, r1
    3dce:	8d a1       	ldd	r24, Y+37	; 0x25
    3dd0:	9e a1       	ldd	r25, Y+38	; 0x26
    3dd2:	af a1       	ldd	r26, Y+39	; 0x27
    3dd4:	b8 a5       	ldd	r27, Y+40	; 0x28
    3dd6:	84 0d       	add	r24, r4
    3dd8:	95 1d       	adc	r25, r5
    3dda:	a6 1d       	adc	r26, r6
    3ddc:	b7 1d       	adc	r27, r7
    3dde:	8d a3       	std	Y+37, r24	; 0x25
    3de0:	9e a3       	std	Y+38, r25	; 0x26
    3de2:	af a3       	std	Y+39, r26	; 0x27
    3de4:	b8 a7       	std	Y+40, r27	; 0x28
    3de6:	8f a5       	ldd	r24, Y+47	; 0x2f
    3de8:	98 a9       	ldd	r25, Y+48	; 0x30
    3dea:	a9 a9       	ldd	r26, Y+49	; 0x31
    3dec:	ba a9       	ldd	r27, Y+50	; 0x32
    3dee:	84 0d       	add	r24, r4
    3df0:	95 1d       	adc	r25, r5
    3df2:	a6 1d       	adc	r26, r6
    3df4:	b7 1d       	adc	r27, r7
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    3df6:	26 3f       	cpi	r18, 0xF6	; 246
    3df8:	ef e0       	ldi	r30, 0x0F	; 15
    3dfa:	3e 07       	cpc	r19, r30
    3dfc:	41 05       	cpc	r20, r1
    3dfe:	51 05       	cpc	r21, r1
    3e00:	80 f1       	brcs	.+96     	; 0x3e62 <f_open+0x2b0>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    3e02:	26 3f       	cpi	r18, 0xF6	; 246
    3e04:	3f 4f       	sbci	r19, 0xFF	; 255
    3e06:	41 05       	cpc	r20, r1
    3e08:	51 05       	cpc	r21, r1
    3e0a:	08 f4       	brcc	.+2      	; 0x3e0e <f_open+0x25c>
    3e0c:	82 c2       	rjmp	.+1284   	; 0x4312 <f_open+0x760>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    3e0e:	f8 01       	movw	r30, r16
    3e10:	c2 86       	std	Z+10, r12	; 0x0a
    3e12:	d3 86       	std	Z+11, r13	; 0x0b
    3e14:	e4 86       	std	Z+12, r14	; 0x0c
    3e16:	f5 86       	std	Z+13, r15	; 0x0d
	fs->database = bsect + sysect;						/* Data start sector */
    3e18:	2d a1       	ldd	r18, Y+37	; 0x25
    3e1a:	3e a1       	ldd	r19, Y+38	; 0x26
    3e1c:	4f a1       	ldd	r20, Y+39	; 0x27
    3e1e:	58 a5       	ldd	r21, Y+40	; 0x28
    3e20:	22 8f       	std	Z+26, r18	; 0x1a
    3e22:	33 8f       	std	Z+27, r19	; 0x1b
    3e24:	44 8f       	std	Z+28, r20	; 0x1c
    3e26:	55 8f       	std	Z+29, r21	; 0x1d
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    3e28:	82 8b       	std	Z+18, r24	; 0x12
    3e2a:	93 8b       	std	Z+19, r25	; 0x13
    3e2c:	a4 8b       	std	Z+20, r26	; 0x14
    3e2e:	b5 8b       	std	Z+21, r27	; 0x15
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    3e30:	29 a5       	ldd	r18, Y+41	; 0x29
    3e32:	3a a5       	ldd	r19, Y+42	; 0x2a
    3e34:	23 2b       	or	r18, r19
    3e36:	09 f0       	breq	.+2      	; 0x3e3a <f_open+0x288>
    3e38:	73 c0       	rjmp	.+230    	; 0x3f20 <f_open+0x36e>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    3e3a:	e2 5b       	subi	r30, 0xB2	; 178
    3e3c:	ff 4f       	sbci	r31, 0xFF	; 255
    3e3e:	80 81       	ld	r24, Z
    3e40:	91 81       	ldd	r25, Z+1	; 0x01
    3e42:	a2 81       	ldd	r26, Z+2	; 0x02
    3e44:	b3 81       	ldd	r27, Z+3	; 0x03
    3e46:	f8 01       	movw	r30, r16
    3e48:	86 8b       	std	Z+22, r24	; 0x16
    3e4a:	97 8b       	std	Z+23, r25	; 0x17
    3e4c:	a0 8f       	std	Z+24, r26	; 0x18
    3e4e:	b1 8f       	std	Z+25, r27	; 0x19
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    3e50:	42 e0       	ldi	r20, 0x02	; 2
    3e52:	cc 0c       	add	r12, r12
    3e54:	dd 1c       	adc	r13, r13
    3e56:	ee 1c       	adc	r14, r14
    3e58:	ff 1c       	adc	r15, r15
    3e5a:	4a 95       	dec	r20
    3e5c:	d1 f7       	brne	.-12     	; 0x3e52 <f_open+0x2a0>
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    3e5e:	23 e0       	ldi	r18, 0x03	; 3
    3e60:	2d c0       	rjmp	.+90     	; 0x3ebc <f_open+0x30a>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    3e62:	21 e0       	ldi	r18, 0x01	; 1
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    3e64:	f8 01       	movw	r30, r16
    3e66:	c2 86       	std	Z+10, r12	; 0x0a
    3e68:	d3 86       	std	Z+11, r13	; 0x0b
    3e6a:	e4 86       	std	Z+12, r14	; 0x0c
    3e6c:	f5 86       	std	Z+13, r15	; 0x0d
	fs->database = bsect + sysect;						/* Data start sector */
    3e6e:	4d a1       	ldd	r20, Y+37	; 0x25
    3e70:	5e a1       	ldd	r21, Y+38	; 0x26
    3e72:	6f a1       	ldd	r22, Y+39	; 0x27
    3e74:	78 a5       	ldd	r23, Y+40	; 0x28
    3e76:	42 8f       	std	Z+26, r20	; 0x1a
    3e78:	53 8f       	std	Z+27, r21	; 0x1b
    3e7a:	64 8f       	std	Z+28, r22	; 0x1c
    3e7c:	75 8f       	std	Z+29, r23	; 0x1d
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    3e7e:	82 8b       	std	Z+18, r24	; 0x12
    3e80:	93 8b       	std	Z+19, r25	; 0x13
    3e82:	a4 8b       	std	Z+20, r26	; 0x14
    3e84:	b5 8b       	std	Z+21, r27	; 0x15
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    3e86:	49 a5       	ldd	r20, Y+41	; 0x29
    3e88:	5a a5       	ldd	r21, Y+42	; 0x2a
    3e8a:	45 2b       	or	r20, r21
    3e8c:	09 f4       	brne	.+2      	; 0x3e90 <f_open+0x2de>
    3e8e:	48 c0       	rjmp	.+144    	; 0x3f20 <f_open+0x36e>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    3e90:	4b a4       	ldd	r4, Y+43	; 0x2b
    3e92:	5c a4       	ldd	r5, Y+44	; 0x2c
    3e94:	6d a4       	ldd	r6, Y+45	; 0x2d
    3e96:	7e a4       	ldd	r7, Y+46	; 0x2e
    3e98:	48 0e       	add	r4, r24
    3e9a:	59 1e       	adc	r5, r25
    3e9c:	6a 1e       	adc	r6, r26
    3e9e:	7b 1e       	adc	r7, r27
    3ea0:	d8 01       	movw	r26, r16
    3ea2:	56 96       	adiw	r26, 0x16	; 22
    3ea4:	4d 92       	st	X+, r4
    3ea6:	5d 92       	st	X+, r5
    3ea8:	6d 92       	st	X+, r6
    3eaa:	7c 92       	st	X, r7
    3eac:	59 97       	sbiw	r26, 0x19	; 25
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    3eae:	22 30       	cpi	r18, 0x02	; 2
    3eb0:	09 f0       	breq	.+2      	; 0x3eb4 <f_open+0x302>
    3eb2:	31 c2       	rjmp	.+1122   	; 0x4316 <f_open+0x764>
    3eb4:	cc 0c       	add	r12, r12
    3eb6:	dd 1c       	adc	r13, r13
    3eb8:	ee 1c       	adc	r14, r14
    3eba:	ff 1c       	adc	r15, r15
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    3ebc:	ff ef       	ldi	r31, 0xFF	; 255
    3ebe:	cf 0e       	add	r12, r31
    3ec0:	f1 e0       	ldi	r31, 0x01	; 1
    3ec2:	df 1e       	adc	r13, r31
    3ec4:	e1 1c       	adc	r14, r1
    3ec6:	f1 1c       	adc	r15, r1
    3ec8:	99 e0       	ldi	r25, 0x09	; 9
    3eca:	f6 94       	lsr	r15
    3ecc:	e7 94       	ror	r14
    3ece:	d7 94       	ror	r13
    3ed0:	c7 94       	ror	r12
    3ed2:	9a 95       	dec	r25
    3ed4:	d1 f7       	brne	.-12     	; 0x3eca <f_open+0x318>
    3ed6:	8c 14       	cp	r8, r12
    3ed8:	9d 04       	cpc	r9, r13
    3eda:	ae 04       	cpc	r10, r14
    3edc:	bf 04       	cpc	r11, r15
    3ede:	00 f1       	brcs	.+64     	; 0x3f20 <f_open+0x36e>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    3ee0:	d8 01       	movw	r26, r16
    3ee2:	2c 93       	st	X, r18
	fs->id = ++Fsid;		/* File system mount ID */
    3ee4:	80 91 b3 03 	lds	r24, 0x03B3	; 0x8003b3 <Fsid>
    3ee8:	90 91 b4 03 	lds	r25, 0x03B4	; 0x8003b4 <Fsid+0x1>
    3eec:	01 96       	adiw	r24, 0x01	; 1
    3eee:	90 93 b4 03 	sts	0x03B4, r25	; 0x8003b4 <Fsid+0x1>
    3ef2:	80 93 b3 03 	sts	0x03B3, r24	; 0x8003b3 <Fsid>
    3ef6:	17 96       	adiw	r26, 0x07	; 7
    3ef8:	9c 93       	st	X, r25
    3efa:	8e 93       	st	-X, r24
    3efc:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    3efe:	f8 01       	movw	r30, r16
    3f00:	16 8e       	std	Z+30, r1	; 0x1e
    3f02:	17 8e       	std	Z+31, r1	; 0x1f
    3f04:	10 a2       	std	Z+32, r1	; 0x20
    3f06:	11 a2       	std	Z+33, r1	; 0x21
	fs->wflag = 0;
    3f08:	14 82       	std	Z+4, r1	; 0x04
    3f0a:	06 c0       	rjmp	.+12     	; 0x3f18 <f_open+0x366>
#endif
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    3f0c:	1b e0       	ldi	r17, 0x0B	; 11
    3f0e:	09 c0       	rjmp	.+18     	; 0x3f22 <f_open+0x370>
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    3f10:	1c e0       	ldi	r17, 0x0C	; 12
    3f12:	07 c0       	rjmp	.+14     	; 0x3f22 <f_open+0x370>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    3f14:	13 e0       	ldi	r17, 0x03	; 3
    3f16:	05 c0       	rjmp	.+10     	; 0x3f22 <f_open+0x370>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
#if !_FS_READONLY
			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
#endif
			return FR_OK;				/* The file system object is valid */
    3f18:	10 e0       	ldi	r17, 0x00	; 0
    3f1a:	03 c0       	rjmp	.+6      	; 0x3f22 <f_open+0x370>
		if (tbl[4]) {									/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);					/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    3f1c:	11 e0       	ldi	r17, 0x01	; 1
    3f1e:	01 c0       	rjmp	.+2      	; 0x3f22 <f_open+0x370>
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    3f20:	1d e0       	ldi	r17, 0x0D	; 13
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
    3f22:	ce 01       	movw	r24, r28
    3f24:	47 96       	adiw	r24, 0x17	; 23
    3f26:	9e 8b       	std	Y+22, r25	; 0x16
    3f28:	8d 8b       	std	Y+21, r24	; 0x15
	if (res == FR_OK)
    3f2a:	11 11       	cpse	r17, r1
    3f2c:	b3 c1       	rjmp	.+870    	; 0x4294 <f_open+0x6e2>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    3f2e:	d1 01       	movw	r26, r2
    3f30:	8c 91       	ld	r24, X
    3f32:	8f 32       	cpi	r24, 0x2F	; 47
    3f34:	11 f0       	breq	.+4      	; 0x3f3a <f_open+0x388>
    3f36:	8c 35       	cpi	r24, 0x5C	; 92
    3f38:	19 f4       	brne	.+6      	; 0x3f40 <f_open+0x38e>
		path++;
    3f3a:	bf ef       	ldi	r27, 0xFF	; 255
    3f3c:	2b 1a       	sub	r2, r27
    3f3e:	3b 0a       	sbc	r3, r27
	dj->sclust = 0;						/* Start from the root dir */
    3f40:	1f 82       	std	Y+7, r1	; 0x07
    3f42:	18 86       	std	Y+8, r1	; 0x08
    3f44:	19 86       	std	Y+9, r1	; 0x09
    3f46:	1a 86       	std	Y+10, r1	; 0x0a
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    3f48:	f1 01       	movw	r30, r2
    3f4a:	80 81       	ld	r24, Z
    3f4c:	80 32       	cpi	r24, 0x20	; 32
    3f4e:	28 f0       	brcs	.+10     	; 0x3f5a <f_open+0x3a8>
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    3f50:	00 e2       	ldi	r16, 0x20	; 32
    3f52:	b0 2e       	mov	r11, r16
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    3f54:	85 e0       	ldi	r24, 0x05	; 5
    3f56:	a8 2e       	mov	r10, r24
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
    3f58:	23 c0       	rjmp	.+70     	; 0x3fa0 <f_open+0x3ee>
    3f5a:	ce 01       	movw	r24, r28
    3f5c:	01 96       	adiw	r24, 0x01	; 1
    3f5e:	9b dd       	rcall	.-1226   	; 0x3a96 <dir_sdi.constprop.3>
		dj->dir = 0;
    3f60:	1c 8a       	std	Y+20, r1	; 0x14
    3f62:	1b 8a       	std	Y+19, r1	; 0x13
		if (!fp->lockid) res = FR_INT_ERR;
#endif
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
    3f64:	88 23       	and	r24, r24
    3f66:	09 f4       	brne	.+2      	; 0x3f6a <f_open+0x3b8>
    3f68:	70 c1       	rjmp	.+736    	; 0x424a <f_open+0x698>
    3f6a:	95 c1       	rjmp	.+810    	; 0x4296 <f_open+0x6e4>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    3f6c:	92 fd       	sbrc	r25, 2
    3f6e:	6d c1       	rjmp	.+730    	; 0x424a <f_open+0x698>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    3f70:	eb 89       	ldd	r30, Y+19	; 0x13
    3f72:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    3f74:	83 85       	ldd	r24, Z+11	; 0x0b
    3f76:	84 ff       	sbrs	r24, 4
    3f78:	e5 c1       	rjmp	.+970    	; 0x4344 <f_open+0x792>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
    3f7a:	84 89       	ldd	r24, Z+20	; 0x14
    3f7c:	95 89       	ldd	r25, Z+21	; 0x15
    3f7e:	a0 e0       	ldi	r26, 0x00	; 0
    3f80:	b0 e0       	ldi	r27, 0x00	; 0
    3f82:	dc 01       	movw	r26, r24
    3f84:	99 27       	eor	r25, r25
    3f86:	88 27       	eor	r24, r24
    3f88:	42 8d       	ldd	r20, Z+26	; 0x1a
    3f8a:	53 8d       	ldd	r21, Z+27	; 0x1b
    3f8c:	60 e0       	ldi	r22, 0x00	; 0
    3f8e:	70 e0       	ldi	r23, 0x00	; 0
    3f90:	84 2b       	or	r24, r20
    3f92:	95 2b       	or	r25, r21
    3f94:	a6 2b       	or	r26, r22
    3f96:	b7 2b       	or	r27, r23
    3f98:	8f 83       	std	Y+7, r24	; 0x07
    3f9a:	98 87       	std	Y+8, r25	; 0x08
    3f9c:	a9 87       	std	Y+9, r26	; 0x09
    3f9e:	ba 87       	std	Y+10, r27	; 0x0a
    3fa0:	91 01       	movw	r18, r2
    3fa2:	19 01       	movw	r2, r18
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    3fa4:	d9 01       	movw	r26, r18
    3fa6:	8c 91       	ld	r24, X
    3fa8:	2f 5f       	subi	r18, 0xFF	; 255
    3faa:	3f 4f       	sbci	r19, 0xFF	; 255
    3fac:	8f 32       	cpi	r24, 0x2F	; 47
    3fae:	c9 f3       	breq	.-14     	; 0x3fa2 <f_open+0x3f0>
    3fb0:	8c 35       	cpi	r24, 0x5C	; 92
    3fb2:	b9 f3       	breq	.-18     	; 0x3fa2 <f_open+0x3f0>
	sfn = dj->fn;
    3fb4:	ed 89       	ldd	r30, Y+21	; 0x15
    3fb6:	fe 89       	ldd	r31, Y+22	; 0x16
    3fb8:	cf 01       	movw	r24, r30
    3fba:	9f 01       	movw	r18, r30
    3fbc:	25 5f       	subi	r18, 0xF5	; 245
    3fbe:	3f 4f       	sbci	r19, 0xFF	; 255
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    3fc0:	82 17       	cp	r24, r18
    3fc2:	93 07       	cpc	r25, r19
    3fc4:	21 f0       	breq	.+8      	; 0x3fce <f_open+0x41c>
		*d++ = (BYTE)val;
    3fc6:	dc 01       	movw	r26, r24
    3fc8:	bd 92       	st	X+, r11
    3fca:	cd 01       	movw	r24, r26
    3fcc:	f9 cf       	rjmp	.-14     	; 0x3fc0 <f_open+0x40e>
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    3fce:	80 e0       	ldi	r24, 0x00	; 0
    3fd0:	90 e0       	ldi	r25, 0x00	; 0
    3fd2:	60 e0       	ldi	r22, 0x00	; 0
    3fd4:	70 e0       	ldi	r23, 0x00	; 0
    3fd6:	48 e0       	ldi	r20, 0x08	; 8
    3fd8:	50 e0       	ldi	r21, 0x00	; 0
    3fda:	91 2c       	mov	r9, r1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    3fdc:	9b 01       	movw	r18, r22
    3fde:	2f 5f       	subi	r18, 0xFF	; 255
    3fe0:	3f 4f       	sbci	r19, 0xFF	; 255
    3fe2:	71 01       	movw	r14, r2
    3fe4:	e6 0e       	add	r14, r22
    3fe6:	f7 1e       	adc	r15, r23
    3fe8:	d7 01       	movw	r26, r14
    3fea:	0c 91       	ld	r16, X
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    3fec:	01 32       	cpi	r16, 0x21	; 33
    3fee:	08 f4       	brcc	.+2      	; 0x3ff2 <f_open+0x440>
    3ff0:	63 c0       	rjmp	.+198    	; 0x40b8 <f_open+0x506>
    3ff2:	0f 32       	cpi	r16, 0x2F	; 47
    3ff4:	09 f4       	brne	.+2      	; 0x3ff8 <f_open+0x446>
    3ff6:	60 c0       	rjmp	.+192    	; 0x40b8 <f_open+0x506>
    3ff8:	0c 35       	cpi	r16, 0x5C	; 92
    3ffa:	09 f4       	brne	.+2      	; 0x3ffe <f_open+0x44c>
    3ffc:	5d c0       	rjmp	.+186    	; 0x40b8 <f_open+0x506>
		if (c == '.' || i >= ni) {
    3ffe:	0e 32       	cpi	r16, 0x2E	; 46
    4000:	19 f0       	breq	.+6      	; 0x4008 <f_open+0x456>
    4002:	84 17       	cp	r24, r20
    4004:	95 07       	cpc	r25, r21
    4006:	78 f0       	brcs	.+30     	; 0x4026 <f_open+0x474>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    4008:	48 30       	cpi	r20, 0x08	; 8
    400a:	51 05       	cpc	r21, r1
    400c:	09 f0       	breq	.+2      	; 0x4010 <f_open+0x45e>
    400e:	41 c1       	rjmp	.+642    	; 0x4292 <f_open+0x6e0>
    4010:	0e 32       	cpi	r16, 0x2E	; 46
    4012:	09 f0       	breq	.+2      	; 0x4016 <f_open+0x464>
    4014:	3e c1       	rjmp	.+636    	; 0x4292 <f_open+0x6e0>
			i = 8; ni = 11;
			b <<= 2; continue;
    4016:	99 0c       	add	r9, r9
    4018:	99 0c       	add	r9, r9
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    401a:	88 e0       	ldi	r24, 0x08	; 8
    401c:	90 e0       	ldi	r25, 0x00	; 0
    401e:	4b e0       	ldi	r20, 0x0B	; 11
    4020:	50 e0       	ldi	r21, 0x00	; 0
    4022:	b9 01       	movw	r22, r18
    4024:	db cf       	rjmp	.-74     	; 0x3fdc <f_open+0x42a>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    4026:	07 ff       	sbrs	r16, 7
    4028:	03 c0       	rjmp	.+6      	; 0x4030 <f_open+0x47e>
			b |= 3;						/* Eliminate NT flag */
    402a:	b9 2d       	mov	r27, r9
    402c:	b3 60       	ori	r27, 0x03	; 3
    402e:	9b 2e       	mov	r9, r27
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    4030:	af e7       	ldi	r26, 0x7F	; 127
    4032:	fa 2e       	mov	r15, r26
    4034:	f0 0e       	add	r15, r16
    4036:	be e1       	ldi	r27, 0x1E	; 30
    4038:	cb 2e       	mov	r12, r27
    403a:	cf 14       	cp	r12, r15
    403c:	38 f4       	brcc	.+14     	; 0x404c <f_open+0x49a>
    403e:	a0 e2       	ldi	r26, 0x20	; 32
    4040:	fa 2e       	mov	r15, r26
    4042:	f0 0e       	add	r15, r16
    4044:	bc e1       	ldi	r27, 0x1C	; 28
    4046:	db 2e       	mov	r13, r27
    4048:	df 14       	cp	r13, r15
    404a:	28 f1       	brcs	.+74     	; 0x4096 <f_open+0x4e4>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    404c:	6e 5f       	subi	r22, 0xFE	; 254
    404e:	7f 4f       	sbci	r23, 0xFF	; 255
    4050:	22 0d       	add	r18, r2
    4052:	33 1d       	adc	r19, r3
    4054:	d9 01       	movw	r26, r18
    4056:	fc 90       	ld	r15, X
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    4058:	20 ec       	ldi	r18, 0xC0	; 192
    405a:	2f 0d       	add	r18, r15
    405c:	2f 33       	cpi	r18, 0x3F	; 63
    405e:	28 f0       	brcs	.+10     	; 0x406a <f_open+0x4b8>
    4060:	20 e8       	ldi	r18, 0x80	; 128
    4062:	2f 0d       	add	r18, r15
    4064:	2d 37       	cpi	r18, 0x7D	; 125
    4066:	08 f0       	brcs	.+2      	; 0x406a <f_open+0x4b8>
    4068:	14 c1       	rjmp	.+552    	; 0x4292 <f_open+0x6e0>
    406a:	9a 01       	movw	r18, r20
    406c:	21 50       	subi	r18, 0x01	; 1
    406e:	31 09       	sbc	r19, r1
    4070:	82 17       	cp	r24, r18
    4072:	93 07       	cpc	r25, r19
    4074:	08 f0       	brcs	.+2      	; 0x4078 <f_open+0x4c6>
    4076:	0d c1       	rjmp	.+538    	; 0x4292 <f_open+0x6e0>
				return FR_INVALID_NAME;
			sfn[i++] = c;
    4078:	9f 01       	movw	r18, r30
    407a:	28 0f       	add	r18, r24
    407c:	39 1f       	adc	r19, r25
    407e:	d9 01       	movw	r26, r18
    4080:	0c 93       	st	X, r16
			sfn[i++] = d;
    4082:	9c 01       	movw	r18, r24
    4084:	2f 5f       	subi	r18, 0xFF	; 255
    4086:	3f 4f       	sbci	r19, 0xFF	; 255
    4088:	2e 0f       	add	r18, r30
    408a:	3f 1f       	adc	r19, r31
    408c:	02 96       	adiw	r24, 0x02	; 2
    408e:	d9 01       	movw	r26, r18
    4090:	fc 92       	st	X, r15
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    4092:	9b 01       	movw	r18, r22
    4094:	c6 cf       	rjmp	.-116    	; 0x4022 <f_open+0x470>
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    4096:	c0 2e       	mov	r12, r16
    4098:	d1 2c       	mov	r13, r1
    409a:	b8 e2       	ldi	r27, 0x28	; 40
    409c:	eb 2e       	mov	r14, r27
    409e:	b3 e0       	ldi	r27, 0x03	; 3
    40a0:	fb 2e       	mov	r15, r27
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    40a2:	d7 01       	movw	r26, r14
    40a4:	6d 91       	ld	r22, X+
    40a6:	7d 01       	movw	r14, r26
    40a8:	66 23       	and	r22, r22
    40aa:	09 f4       	brne	.+2      	; 0x40ae <f_open+0x4fc>
    40ac:	d7 c0       	rjmp	.+430    	; 0x425c <f_open+0x6aa>
    40ae:	70 e0       	ldi	r23, 0x00	; 0
    40b0:	c6 16       	cp	r12, r22
    40b2:	d7 06       	cpc	r13, r23
    40b4:	b1 f7       	brne	.-20     	; 0x40a2 <f_open+0x4f0>
    40b6:	ed c0       	rjmp	.+474    	; 0x4292 <f_open+0x6e0>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    40b8:	22 0e       	add	r2, r18
    40ba:	33 1e       	adc	r3, r19
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    40bc:	01 32       	cpi	r16, 0x21	; 33
    40be:	10 f0       	brcs	.+4      	; 0x40c4 <f_open+0x512>
    40c0:	20 e0       	ldi	r18, 0x00	; 0
    40c2:	01 c0       	rjmp	.+2      	; 0x40c6 <f_open+0x514>
    40c4:	24 e0       	ldi	r18, 0x04	; 4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    40c6:	89 2b       	or	r24, r25
    40c8:	09 f4       	brne	.+2      	; 0x40cc <f_open+0x51a>
    40ca:	e3 c0       	rjmp	.+454    	; 0x4292 <f_open+0x6e0>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    40cc:	80 81       	ld	r24, Z
    40ce:	85 3e       	cpi	r24, 0xE5	; 229
    40d0:	09 f4       	brne	.+2      	; 0x40d4 <f_open+0x522>
    40d2:	a0 82       	st	Z, r10

	if (ni == 8) b <<= 2;
    40d4:	48 30       	cpi	r20, 0x08	; 8
    40d6:	51 05       	cpc	r21, r1
    40d8:	11 f4       	brne	.+4      	; 0x40de <f_open+0x52c>
    40da:	99 0c       	add	r9, r9
    40dc:	99 0c       	add	r9, r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    40de:	89 2d       	mov	r24, r9
    40e0:	83 70       	andi	r24, 0x03	; 3
    40e2:	81 30       	cpi	r24, 0x01	; 1
    40e4:	09 f4       	brne	.+2      	; 0x40e8 <f_open+0x536>
    40e6:	20 61       	ori	r18, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    40e8:	89 2d       	mov	r24, r9
    40ea:	8c 70       	andi	r24, 0x0C	; 12
    40ec:	84 30       	cpi	r24, 0x04	; 4
    40ee:	09 f4       	brne	.+2      	; 0x40f2 <f_open+0x540>

	sfn[NS] = c;		/* Store NT flag, File name is created */
    40f0:	28 60       	ori	r18, 0x08	; 8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    40f2:	23 87       	std	Z+11, r18	; 0x0b
    40f4:	ce 01       	movw	r24, r28
    40f6:	01 96       	adiw	r24, 0x01	; 1
    40f8:	ce dc       	rcall	.-1636   	; 0x3a96 <dir_sdi.constprop.3>
	if (res != FR_OK) return res;
    40fa:	81 11       	cpse	r24, r1
    40fc:	9a c0       	rjmp	.+308    	; 0x4232 <f_open+0x680>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    40fe:	4f 85       	ldd	r20, Y+15	; 0x0f
    4100:	58 89       	ldd	r21, Y+16	; 0x10
    4102:	69 89       	ldd	r22, Y+17	; 0x11
    4104:	7a 89       	ldd	r23, Y+18	; 0x12
    4106:	89 81       	ldd	r24, Y+1	; 0x01
    4108:	9a 81       	ldd	r25, Y+2	; 0x02
    410a:	54 db       	rcall	.-2392   	; 0x37b4 <move_window>
		if (res != FR_OK) break;
    410c:	81 11       	cpse	r24, r1
    410e:	91 c0       	rjmp	.+290    	; 0x4232 <f_open+0x680>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    4110:	eb 89       	ldd	r30, Y+19	; 0x13
    4112:	fc 89       	ldd	r31, Y+20	; 0x14
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    4114:	90 81       	ld	r25, Z
    4116:	99 23       	and	r25, r25
    4118:	09 f4       	brne	.+2      	; 0x411c <f_open+0x56a>
    411a:	8a c0       	rjmp	.+276    	; 0x4230 <f_open+0x67e>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    411c:	93 85       	ldd	r25, Z+11	; 0x0b
    411e:	93 fd       	sbrc	r25, 3
    4120:	0d c0       	rjmp	.+26     	; 0x413c <f_open+0x58a>
    4122:	ad 89       	ldd	r26, Y+21	; 0x15
    4124:	be 89       	ldd	r27, Y+22	; 0x16
    4126:	af 01       	movw	r20, r30
    4128:	45 5f       	subi	r20, 0xF5	; 245
    412a:	5f 4f       	sbci	r21, 0xFF	; 255
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    412c:	4e 17       	cp	r20, r30
    412e:	5f 07       	cpc	r21, r31
    4130:	09 f4       	brne	.+2      	; 0x4134 <f_open+0x582>
    4132:	7f c0       	rjmp	.+254    	; 0x4232 <f_open+0x680>
    4134:	21 91       	ld	r18, Z+
    4136:	9d 91       	ld	r25, X+
    4138:	29 17       	cp	r18, r25
    413a:	c1 f3       	breq	.-16     	; 0x412c <f_open+0x57a>
{
	DWORD clst;
	WORD i;


	i = dj->index + 1;
    413c:	cd 80       	ldd	r12, Y+5	; 0x05
    413e:	de 80       	ldd	r13, Y+6	; 0x06
    4140:	bf ef       	ldi	r27, 0xFF	; 255
    4142:	cb 1a       	sub	r12, r27
    4144:	db 0a       	sbc	r13, r27
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    4146:	09 f4       	brne	.+2      	; 0x414a <f_open+0x598>
    4148:	a0 c0       	rjmp	.+320    	; 0x428a <f_open+0x6d8>
    414a:	8f 85       	ldd	r24, Y+15	; 0x0f
    414c:	98 89       	ldd	r25, Y+16	; 0x10
    414e:	a9 89       	ldd	r26, Y+17	; 0x11
    4150:	ba 89       	ldd	r27, Y+18	; 0x12
    4152:	00 97       	sbiw	r24, 0x00	; 0
    4154:	a1 05       	cpc	r26, r1
    4156:	b1 05       	cpc	r27, r1
    4158:	09 f4       	brne	.+2      	; 0x415c <f_open+0x5aa>
    415a:	97 c0       	rjmp	.+302    	; 0x428a <f_open+0x6d8>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    415c:	76 01       	movw	r14, r12
    415e:	ef e0       	ldi	r30, 0x0F	; 15
    4160:	ee 22       	and	r14, r30
    4162:	ff 24       	eor	r15, r15
    4164:	e1 14       	cp	r14, r1
    4166:	f1 04       	cpc	r15, r1
    4168:	09 f0       	breq	.+2      	; 0x416c <f_open+0x5ba>
    416a:	53 c0       	rjmp	.+166    	; 0x4212 <f_open+0x660>
		dj->sect++;					/* Next sector */
    416c:	01 96       	adiw	r24, 0x01	; 1
    416e:	a1 1d       	adc	r26, r1
    4170:	b1 1d       	adc	r27, r1
    4172:	8f 87       	std	Y+15, r24	; 0x0f
    4174:	98 8b       	std	Y+16, r25	; 0x10
    4176:	a9 8b       	std	Y+17, r26	; 0x11
    4178:	ba 8b       	std	Y+18, r27	; 0x12

		if (dj->clust == 0) {	/* Static table */
    417a:	4b 85       	ldd	r20, Y+11	; 0x0b
    417c:	5c 85       	ldd	r21, Y+12	; 0x0c
    417e:	6d 85       	ldd	r22, Y+13	; 0x0d
    4180:	7e 85       	ldd	r23, Y+14	; 0x0e
    4182:	89 81       	ldd	r24, Y+1	; 0x01
    4184:	9a 81       	ldd	r25, Y+2	; 0x02
    4186:	41 15       	cp	r20, r1
    4188:	51 05       	cpc	r21, r1
    418a:	61 05       	cpc	r22, r1
    418c:	71 05       	cpc	r23, r1
    418e:	51 f4       	brne	.+20     	; 0x41a4 <f_open+0x5f2>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    4190:	dc 01       	movw	r26, r24
    4192:	18 96       	adiw	r26, 0x08	; 8
    4194:	8d 91       	ld	r24, X+
    4196:	9c 91       	ld	r25, X
    4198:	19 97       	sbiw	r26, 0x09	; 9
    419a:	c8 16       	cp	r12, r24
    419c:	d9 06       	cpc	r13, r25
    419e:	08 f0       	brcs	.+2      	; 0x41a2 <f_open+0x5f0>
    41a0:	74 c0       	rjmp	.+232    	; 0x428a <f_open+0x6d8>
    41a2:	37 c0       	rjmp	.+110    	; 0x4212 <f_open+0x660>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    41a4:	fc 01       	movw	r30, r24
    41a6:	22 81       	ldd	r18, Z+2	; 0x02
    41a8:	30 e0       	ldi	r19, 0x00	; 0
    41aa:	21 50       	subi	r18, 0x01	; 1
    41ac:	31 09       	sbc	r19, r1
    41ae:	f6 01       	movw	r30, r12
    41b0:	a4 e0       	ldi	r26, 0x04	; 4
    41b2:	f6 95       	lsr	r31
    41b4:	e7 95       	ror	r30
    41b6:	aa 95       	dec	r26
    41b8:	e1 f7       	brne	.-8      	; 0x41b2 <f_open+0x600>
    41ba:	2e 23       	and	r18, r30
    41bc:	3f 23       	and	r19, r31
    41be:	23 2b       	or	r18, r19
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    41c0:	41 f5       	brne	.+80     	; 0x4212 <f_open+0x660>
    41c2:	a1 db       	rcall	.-2238   	; 0x3906 <get_fat>
    41c4:	ab 01       	movw	r20, r22
    41c6:	bc 01       	movw	r22, r24
				if (clst <= 1) return FR_INT_ERR;
    41c8:	42 30       	cpi	r20, 0x02	; 2
    41ca:	51 05       	cpc	r21, r1
    41cc:	61 05       	cpc	r22, r1
    41ce:	71 05       	cpc	r23, r1
    41d0:	08 f4       	brcc	.+2      	; 0x41d4 <f_open+0x622>
    41d2:	ba c0       	rjmp	.+372    	; 0x4348 <f_open+0x796>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    41d4:	4f 3f       	cpi	r20, 0xFF	; 255
    41d6:	ff ef       	ldi	r31, 0xFF	; 255
    41d8:	5f 07       	cpc	r21, r31
    41da:	6f 07       	cpc	r22, r31
    41dc:	7f 07       	cpc	r23, r31
    41de:	09 f4       	brne	.+2      	; 0x41e2 <f_open+0x630>
    41e0:	b5 c0       	rjmp	.+362    	; 0x434c <f_open+0x79a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    41e2:	89 81       	ldd	r24, Y+1	; 0x01
    41e4:	9a 81       	ldd	r25, Y+2	; 0x02
    41e6:	dc 01       	movw	r26, r24
    41e8:	1a 96       	adiw	r26, 0x0a	; 10
    41ea:	4d 90       	ld	r4, X+
    41ec:	5d 90       	ld	r5, X+
    41ee:	6d 90       	ld	r6, X+
    41f0:	7c 90       	ld	r7, X
    41f2:	1d 97       	sbiw	r26, 0x0d	; 13
    41f4:	44 15       	cp	r20, r4
    41f6:	55 05       	cpc	r21, r5
    41f8:	66 05       	cpc	r22, r6
    41fa:	77 05       	cpc	r23, r7
    41fc:	08 f0       	brcs	.+2      	; 0x4200 <f_open+0x64e>
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    41fe:	45 c0       	rjmp	.+138    	; 0x428a <f_open+0x6d8>
    4200:	4b 87       	std	Y+11, r20	; 0x0b
    4202:	5c 87       	std	Y+12, r21	; 0x0c
    4204:	6d 87       	std	Y+13, r22	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
    4206:	7e 87       	std	Y+14, r23	; 0x0e
    4208:	56 db       	rcall	.-2388   	; 0x38b6 <clust2sect>
    420a:	6f 87       	std	Y+15, r22	; 0x0f
    420c:	78 8b       	std	Y+16, r23	; 0x10
    420e:	89 8b       	std	Y+17, r24	; 0x11
    4210:	9a 8b       	std	Y+18, r25	; 0x12
			}
		}
	}

	dj->index = i;
    4212:	de 82       	std	Y+6, r13	; 0x06
    4214:	cd 82       	std	Y+5, r12	; 0x05
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    4216:	89 81       	ldd	r24, Y+1	; 0x01
    4218:	9a 81       	ldd	r25, Y+2	; 0x02
    421a:	82 96       	adiw	r24, 0x22	; 34
    421c:	45 e0       	ldi	r20, 0x05	; 5
    421e:	ee 0c       	add	r14, r14
    4220:	ff 1c       	adc	r15, r15
    4222:	4a 95       	dec	r20
    4224:	e1 f7       	brne	.-8      	; 0x421e <f_open+0x66c>
    4226:	e8 0e       	add	r14, r24
    4228:	f9 1e       	adc	r15, r25
    422a:	fc 8a       	std	Y+20, r15	; 0x14
    422c:	eb 8a       	std	Y+19, r14	; 0x13
    422e:	67 cf       	rjmp	.-306    	; 0x40fe <f_open+0x54c>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    4230:	84 e0       	ldi	r24, 0x04	; 4
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    4232:	ed 89       	ldd	r30, Y+21	; 0x15
    4234:	fe 89       	ldd	r31, Y+22	; 0x16
    4236:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
    4238:	88 23       	and	r24, r24
    423a:	09 f4       	brne	.+2      	; 0x423e <f_open+0x68c>
    423c:	97 ce       	rjmp	.-722    	; 0x3f6c <f_open+0x3ba>
    423e:	18 2f       	mov	r17, r24
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    4240:	14 30       	cpi	r17, 0x04	; 4
    4242:	41 f5       	brne	.+80     	; 0x4294 <f_open+0x6e2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    4244:	92 ff       	sbrs	r25, 2
    4246:	7e c0       	rjmp	.+252    	; 0x4344 <f_open+0x792>
    4248:	25 c0       	rjmp	.+74     	; 0x4294 <f_open+0x6e2>
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
    424a:	eb 89       	ldd	r30, Y+19	; 0x13
    424c:	fc 89       	ldd	r31, Y+20	; 0x14
#endif
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
		if (!dir) {						/* Current dir itself */
    424e:	30 97       	sbiw	r30, 0x00	; 0
    4250:	f1 f0       	breq	.+60     	; 0x428e <f_open+0x6dc>
			res = FR_INVALID_NAME;
		} else {
			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
    4252:	83 85       	ldd	r24, Z+11	; 0x0b
    4254:	84 ff       	sbrs	r24, 4
    4256:	21 c0       	rjmp	.+66     	; 0x429a <f_open+0x6e8>
				res = FR_NO_FILE;
    4258:	84 e0       	ldi	r24, 0x04	; 4
    425a:	1d c0       	rjmp	.+58     	; 0x4296 <f_open+0x6e4>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    425c:	6f eb       	ldi	r22, 0xBF	; 191
    425e:	60 0f       	add	r22, r16
    4260:	6a 31       	cpi	r22, 0x1A	; 26
    4262:	20 f4       	brcc	.+8      	; 0x426c <f_open+0x6ba>
				b |= 2;
    4264:	b9 2d       	mov	r27, r9
    4266:	b2 60       	ori	r27, 0x02	; 2
    4268:	9b 2e       	mov	r9, r27
    426a:	08 c0       	rjmp	.+16     	; 0x427c <f_open+0x6ca>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    426c:	6f e9       	ldi	r22, 0x9F	; 159
    426e:	60 0f       	add	r22, r16
    4270:	6a 31       	cpi	r22, 0x1A	; 26
    4272:	20 f4       	brcc	.+8      	; 0x427c <f_open+0x6ca>
					b |= 1; c -= 0x20;
    4274:	69 2d       	mov	r22, r9
    4276:	61 60       	ori	r22, 0x01	; 1
    4278:	96 2e       	mov	r9, r22
    427a:	00 52       	subi	r16, 0x20	; 32
				}
			}
			sfn[i++] = c;
    427c:	bf 01       	movw	r22, r30
    427e:	68 0f       	add	r22, r24
    4280:	79 1f       	adc	r23, r25
    4282:	db 01       	movw	r26, r22
    4284:	0c 93       	st	X, r16
    4286:	01 96       	adiw	r24, 0x01	; 1
    4288:	cc ce       	rjmp	.-616    	; 0x4022 <f_open+0x470>
	WORD i;


	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    428a:	14 e0       	ldi	r17, 0x04	; 4
    428c:	60 c0       	rjmp	.+192    	; 0x434e <f_open+0x79c>
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
		if (!dir) {						/* Current dir itself */
			res = FR_INVALID_NAME;
    428e:	86 e0       	ldi	r24, 0x06	; 6
    4290:	02 c0       	rjmp	.+4      	; 0x4296 <f_open+0x6e4>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    4292:	16 e0       	ldi	r17, 0x06	; 6
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
		if (!dir) {						/* Current dir itself */
			res = FR_INVALID_NAME;
    4294:	81 2f       	mov	r24, r17
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
			if (res != FR_OK) {				/* Failed to find the object */
    4296:	18 2f       	mov	r17, r24
    4298:	5e c0       	rjmp	.+188    	; 0x4356 <f_open+0x7a4>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
    429a:	8b a9       	ldd	r24, Y+51	; 0x33
    429c:	81 70       	andi	r24, 0x01	; 1
    429e:	ab a1       	ldd	r26, Y+35	; 0x23
    42a0:	bc a1       	ldd	r27, Y+36	; 0x24
    42a2:	14 96       	adiw	r26, 0x04	; 4
    42a4:	8c 93       	st	X, r24
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    42a6:	84 89       	ldd	r24, Z+20	; 0x14
    42a8:	95 89       	ldd	r25, Z+21	; 0x15
    42aa:	a0 e0       	ldi	r26, 0x00	; 0
    42ac:	b0 e0       	ldi	r27, 0x00	; 0
    42ae:	dc 01       	movw	r26, r24
    42b0:	99 27       	eor	r25, r25
    42b2:	88 27       	eor	r24, r24
    42b4:	42 8d       	ldd	r20, Z+26	; 0x1a
    42b6:	53 8d       	ldd	r21, Z+27	; 0x1b
    42b8:	60 e0       	ldi	r22, 0x00	; 0
    42ba:	70 e0       	ldi	r23, 0x00	; 0
    42bc:	48 2b       	or	r20, r24
    42be:	59 2b       	or	r21, r25
    42c0:	6a 2b       	or	r22, r26
    42c2:	7b 2b       	or	r23, r27
    42c4:	ab a1       	ldd	r26, Y+35	; 0x23
    42c6:	bc a1       	ldd	r27, Y+36	; 0x24
    42c8:	1e 96       	adiw	r26, 0x0e	; 14
    42ca:	4d 93       	st	X+, r20
    42cc:	5d 93       	st	X+, r21
    42ce:	6d 93       	st	X+, r22
    42d0:	7c 93       	st	X, r23
    42d2:	51 97       	sbiw	r26, 0x11	; 17
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    42d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    42d6:	95 8d       	ldd	r25, Z+29	; 0x1d
    42d8:	a6 8d       	ldd	r26, Z+30	; 0x1e
    42da:	b7 8d       	ldd	r27, Z+31	; 0x1f
    42dc:	eb a1       	ldd	r30, Y+35	; 0x23
    42de:	fc a1       	ldd	r31, Y+36	; 0x24
    42e0:	82 87       	std	Z+10, r24	; 0x0a
    42e2:	93 87       	std	Z+11, r25	; 0x0b
    42e4:	a4 87       	std	Z+12, r26	; 0x0c
    42e6:	b5 87       	std	Z+13, r27	; 0x0d
		fp->fptr = 0;						/* File pointer */
    42e8:	df 01       	movw	r26, r30
    42ea:	16 82       	std	Z+6, r1	; 0x06
    42ec:	17 82       	std	Z+7, r1	; 0x07
    42ee:	10 86       	std	Z+8, r1	; 0x08
    42f0:	11 86       	std	Z+9, r1	; 0x09
		fp->dsect = 0;
    42f2:	16 8a       	std	Z+22, r1	; 0x16
    42f4:	17 8a       	std	Z+23, r1	; 0x17
    42f6:	10 8e       	std	Z+24, r1	; 0x18
    42f8:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    42fa:	e9 81       	ldd	r30, Y+1	; 0x01
    42fc:	fa 81       	ldd	r31, Y+2	; 0x02
    42fe:	11 96       	adiw	r26, 0x01	; 1
    4300:	fc 93       	st	X, r31
    4302:	ee 93       	st	-X, r30
    4304:	86 81       	ldd	r24, Z+6	; 0x06
    4306:	97 81       	ldd	r25, Z+7	; 0x07
    4308:	13 96       	adiw	r26, 0x03	; 3
    430a:	9c 93       	st	X, r25
    430c:	8e 93       	st	-X, r24
    430e:	12 97       	sbiw	r26, 0x02	; 2
	}

	LEAVE_FF(dj.fs, res);
    4310:	22 c0       	rjmp	.+68     	; 0x4356 <f_open+0x7a4>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    4312:	22 e0       	ldi	r18, 0x02	; 2
    4314:	a7 cd       	rjmp	.-1202   	; 0x3e64 <f_open+0x2b2>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    4316:	a3 e0       	ldi	r26, 0x03	; 3
    4318:	b0 e0       	ldi	r27, 0x00	; 0
    431a:	a7 01       	movw	r20, r14
    431c:	96 01       	movw	r18, r12
    431e:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <__muluhisi3>
    4322:	dc 01       	movw	r26, r24
    4324:	cb 01       	movw	r24, r22
    4326:	b6 95       	lsr	r27
    4328:	a7 95       	ror	r26
    432a:	97 95       	ror	r25
    432c:	87 95       	ror	r24
    432e:	e1 e0       	ldi	r30, 0x01	; 1
    4330:	ce 22       	and	r12, r30
    4332:	dd 24       	eor	r13, r13
    4334:	ee 24       	eor	r14, r14
    4336:	ff 24       	eor	r15, r15
    4338:	c8 0e       	add	r12, r24
    433a:	d9 1e       	adc	r13, r25
    433c:	ea 1e       	adc	r14, r26
    433e:	fb 1e       	adc	r15, r27
    4340:	21 e0       	ldi	r18, 0x01	; 1
    4342:	bc cd       	rjmp	.-1160   	; 0x3ebc <f_open+0x30a>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    4344:	15 e0       	ldi	r17, 0x05	; 5
    4346:	a6 cf       	rjmp	.-180    	; 0x4294 <f_open+0x6e2>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    4348:	12 e0       	ldi	r17, 0x02	; 2
    434a:	01 c0       	rjmp	.+2      	; 0x434e <f_open+0x79c>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    434c:	11 e0       	ldi	r17, 0x01	; 1
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    434e:	ed 89       	ldd	r30, Y+21	; 0x15
    4350:	fe 89       	ldd	r31, Y+22	; 0x16
    4352:	93 85       	ldd	r25, Z+11	; 0x0b
    4354:	75 cf       	rjmp	.-278    	; 0x4240 <f_open+0x68e>
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
    4356:	81 2f       	mov	r24, r17
    4358:	e3 96       	adiw	r28, 0x33	; 51
    435a:	0f b6       	in	r0, 0x3f	; 63
    435c:	f8 94       	cli
    435e:	de bf       	out	0x3e, r29	; 62
    4360:	0f be       	out	0x3f, r0	; 63
    4362:	cd bf       	out	0x3d, r28	; 61
    4364:	df 91       	pop	r29
    4366:	cf 91       	pop	r28
    4368:	1f 91       	pop	r17
    436a:	0f 91       	pop	r16
    436c:	ff 90       	pop	r15
    436e:	ef 90       	pop	r14
    4370:	df 90       	pop	r13
    4372:	cf 90       	pop	r12
    4374:	bf 90       	pop	r11
    4376:	af 90       	pop	r10
    4378:	9f 90       	pop	r9
    437a:	8f 90       	pop	r8
    437c:	7f 90       	pop	r7
    437e:	6f 90       	pop	r6
    4380:	5f 90       	pop	r5
    4382:	4f 90       	pop	r4
    4384:	3f 90       	pop	r3
    4386:	2f 90       	pop	r2
    4388:	08 95       	ret

0000438a <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    438a:	4f 92       	push	r4
    438c:	5f 92       	push	r5
    438e:	6f 92       	push	r6
    4390:	7f 92       	push	r7
    4392:	8f 92       	push	r8
    4394:	9f 92       	push	r9
    4396:	af 92       	push	r10
    4398:	bf 92       	push	r11
    439a:	cf 92       	push	r12
    439c:	df 92       	push	r13
    439e:	ef 92       	push	r14
    43a0:	ff 92       	push	r15
    43a2:	0f 93       	push	r16
    43a4:	1f 93       	push	r17
    43a6:	cf 93       	push	r28
    43a8:	df 93       	push	r29
    43aa:	ec 01       	movw	r28, r24
    43ac:	6b 01       	movw	r12, r22
    43ae:	7a 01       	movw	r14, r20
    43b0:	59 01       	movw	r10, r18
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
    43b2:	f9 01       	movw	r30, r18
    43b4:	11 82       	std	Z+1, r1	; 0x01
    43b6:	10 82       	st	Z, r1

	res = validate(fp->fs, fp->id);				/* Check validity */
    43b8:	6a 81       	ldd	r22, Y+2	; 0x02
    43ba:	7b 81       	ldd	r23, Y+3	; 0x03
    43bc:	88 81       	ld	r24, Y
    43be:	99 81       	ldd	r25, Y+1	; 0x01
    43c0:	65 da       	rcall	.-2870   	; 0x388c <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    43c2:	81 11       	cpse	r24, r1
    43c4:	f5 c0       	rjmp	.+490    	; 0x45b0 <f_read+0x226>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    43c6:	8c 81       	ldd	r24, Y+4	; 0x04
    43c8:	87 fd       	sbrc	r24, 7
    43ca:	ef c0       	rjmp	.+478    	; 0x45aa <f_read+0x220>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    43cc:	80 ff       	sbrs	r24, 0
    43ce:	ef c0       	rjmp	.+478    	; 0x45ae <f_read+0x224>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    43d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    43d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    43d4:	ac 85       	ldd	r26, Y+12	; 0x0c
    43d6:	bd 85       	ldd	r27, Y+13	; 0x0d
    43d8:	4e 81       	ldd	r20, Y+6	; 0x06
    43da:	5f 81       	ldd	r21, Y+7	; 0x07
    43dc:	68 85       	ldd	r22, Y+8	; 0x08
    43de:	79 85       	ldd	r23, Y+9	; 0x09
    43e0:	84 1b       	sub	r24, r20
    43e2:	95 0b       	sbc	r25, r21
    43e4:	a6 0b       	sbc	r26, r22
    43e6:	b7 0b       	sbc	r27, r23
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    43e8:	a7 01       	movw	r20, r14
    43ea:	60 e0       	ldi	r22, 0x00	; 0
    43ec:	70 e0       	ldi	r23, 0x00	; 0
    43ee:	84 17       	cp	r24, r20
    43f0:	95 07       	cpc	r25, r21
    43f2:	a6 07       	cpc	r26, r22
    43f4:	b7 07       	cpc	r27, r23
    43f6:	08 f4       	brcc	.+2      	; 0x43fa <f_read+0x70>
    43f8:	7c 01       	movw	r14, r24
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    43fa:	41 2c       	mov	r4, r1
    43fc:	32 e0       	ldi	r19, 0x02	; 2
    43fe:	53 2e       	mov	r5, r19
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    4400:	e1 14       	cp	r14, r1
    4402:	f1 04       	cpc	r15, r1
    4404:	09 f4       	brne	.+2      	; 0x4408 <f_read+0x7e>
    4406:	cf c0       	rjmp	.+414    	; 0x45a6 <f_read+0x21c>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    4408:	4e 81       	ldd	r20, Y+6	; 0x06
    440a:	5f 81       	ldd	r21, Y+7	; 0x07
    440c:	68 85       	ldd	r22, Y+8	; 0x08
    440e:	79 85       	ldd	r23, Y+9	; 0x09
    4410:	db 01       	movw	r26, r22
    4412:	ca 01       	movw	r24, r20
    4414:	91 70       	andi	r25, 0x01	; 1
    4416:	aa 27       	eor	r26, r26
    4418:	bb 27       	eor	r27, r27
    441a:	89 2b       	or	r24, r25
    441c:	8a 2b       	or	r24, r26
    441e:	8b 2b       	or	r24, r27
    4420:	09 f0       	breq	.+2      	; 0x4424 <f_read+0x9a>
    4422:	6a c0       	rjmp	.+212    	; 0x44f8 <f_read+0x16e>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    4424:	88 81       	ld	r24, Y
    4426:	99 81       	ldd	r25, Y+1	; 0x01
    4428:	fc 01       	movw	r30, r24
    442a:	12 81       	ldd	r17, Z+2	; 0x02
    442c:	11 50       	subi	r17, 0x01	; 1
    442e:	3a 01       	movw	r6, r20
    4430:	4b 01       	movw	r8, r22
    4432:	29 e0       	ldi	r18, 0x09	; 9
    4434:	96 94       	lsr	r9
    4436:	87 94       	ror	r8
    4438:	77 94       	ror	r7
    443a:	67 94       	ror	r6
    443c:	2a 95       	dec	r18
    443e:	d1 f7       	brne	.-12     	; 0x4434 <f_read+0xaa>
    4440:	16 21       	and	r17, r6
			if (!csect) {						/* On the cluster boundary? */
    4442:	f1 f4       	brne	.+60     	; 0x4480 <f_read+0xf6>
				if (fp->fptr == 0) {			/* On the top of the file? */
    4444:	45 2b       	or	r20, r21
    4446:	46 2b       	or	r20, r22
    4448:	47 2b       	or	r20, r23
    444a:	29 f4       	brne	.+10     	; 0x4456 <f_read+0xcc>
					clst = fp->sclust;			/* Follow from the origin */
    444c:	6e 85       	ldd	r22, Y+14	; 0x0e
    444e:	7f 85       	ldd	r23, Y+15	; 0x0f
    4450:	88 89       	ldd	r24, Y+16	; 0x10
    4452:	99 89       	ldd	r25, Y+17	; 0x11
    4454:	05 c0       	rjmp	.+10     	; 0x4460 <f_read+0xd6>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    4456:	4a 89       	ldd	r20, Y+18	; 0x12
    4458:	5b 89       	ldd	r21, Y+19	; 0x13
    445a:	6c 89       	ldd	r22, Y+20	; 0x14
    445c:	7d 89       	ldd	r23, Y+21	; 0x15
    445e:	53 da       	rcall	.-2906   	; 0x3906 <get_fat>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    4460:	62 30       	cpi	r22, 0x02	; 2
    4462:	71 05       	cpc	r23, r1
    4464:	81 05       	cpc	r24, r1
    4466:	91 05       	cpc	r25, r1
    4468:	c0 f0       	brcs	.+48     	; 0x449a <f_read+0x110>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    446a:	6f 3f       	cpi	r22, 0xFF	; 255
    446c:	ff ef       	ldi	r31, 0xFF	; 255
    446e:	7f 07       	cpc	r23, r31
    4470:	8f 07       	cpc	r24, r31
    4472:	9f 07       	cpc	r25, r31
    4474:	09 f4       	brne	.+2      	; 0x4478 <f_read+0xee>
    4476:	54 c0       	rjmp	.+168    	; 0x4520 <f_read+0x196>
				fp->clust = clst;				/* Update current cluster */
    4478:	6a 8b       	std	Y+18, r22	; 0x12
    447a:	7b 8b       	std	Y+19, r23	; 0x13
    447c:	8c 8b       	std	Y+20, r24	; 0x14
    447e:	9d 8b       	std	Y+21, r25	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    4480:	68 80       	ld	r6, Y
    4482:	79 80       	ldd	r7, Y+1	; 0x01
    4484:	4a 89       	ldd	r20, Y+18	; 0x12
    4486:	5b 89       	ldd	r21, Y+19	; 0x13
    4488:	6c 89       	ldd	r22, Y+20	; 0x14
    448a:	7d 89       	ldd	r23, Y+21	; 0x15
    448c:	c3 01       	movw	r24, r6
    448e:	13 da       	rcall	.-3034   	; 0x38b6 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    4490:	61 15       	cp	r22, r1
    4492:	71 05       	cpc	r23, r1
    4494:	81 05       	cpc	r24, r1
    4496:	91 05       	cpc	r25, r1
    4498:	21 f4       	brne	.+8      	; 0x44a2 <f_read+0x118>
    449a:	8c 81       	ldd	r24, Y+4	; 0x04
    449c:	80 68       	ori	r24, 0x80	; 128
    449e:	8c 83       	std	Y+4, r24	; 0x04
    44a0:	84 c0       	rjmp	.+264    	; 0x45aa <f_read+0x220>
			sect += csect;
    44a2:	9b 01       	movw	r18, r22
    44a4:	ac 01       	movw	r20, r24
    44a6:	21 0f       	add	r18, r17
    44a8:	31 1d       	adc	r19, r1
    44aa:	41 1d       	adc	r20, r1
    44ac:	51 1d       	adc	r21, r1
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    44ae:	47 01       	movw	r8, r14
    44b0:	89 2c       	mov	r8, r9
    44b2:	99 24       	eor	r9, r9
    44b4:	86 94       	lsr	r8
			if (cc) {							/* Read maximum contiguous sectors directly */
    44b6:	81 14       	cp	r8, r1
    44b8:	91 04       	cpc	r9, r1
    44ba:	d1 f0       	breq	.+52     	; 0x44f0 <f_read+0x166>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    44bc:	f3 01       	movw	r30, r6
    44be:	82 81       	ldd	r24, Z+2	; 0x02
    44c0:	61 2f       	mov	r22, r17
    44c2:	70 e0       	ldi	r23, 0x00	; 0
    44c4:	fb 01       	movw	r30, r22
    44c6:	e8 0d       	add	r30, r8
    44c8:	f9 1d       	adc	r31, r9
    44ca:	90 e0       	ldi	r25, 0x00	; 0
    44cc:	8e 17       	cp	r24, r30
    44ce:	9f 07       	cpc	r25, r31
    44d0:	18 f4       	brcc	.+6      	; 0x44d8 <f_read+0x14e>
					cc = fp->fs->csize - csect;
    44d2:	4c 01       	movw	r8, r24
    44d4:	86 1a       	sub	r8, r22
    44d6:	97 0a       	sbc	r9, r23
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    44d8:	08 2d       	mov	r16, r8
    44da:	b6 01       	movw	r22, r12
    44dc:	f3 01       	movw	r30, r6
    44de:	81 81       	ldd	r24, Z+1	; 0x01
    44e0:	5d d9       	rcall	.-3398   	; 0x379c <disk_read>
    44e2:	81 11       	cpse	r24, r1
    44e4:	1d c0       	rjmp	.+58     	; 0x4520 <f_read+0x196>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    44e6:	84 01       	movw	r16, r8
    44e8:	10 2f       	mov	r17, r16
    44ea:	00 27       	eor	r16, r16
    44ec:	11 0f       	add	r17, r17
				continue;
    44ee:	43 c0       	rjmp	.+134    	; 0x4576 <f_read+0x1ec>
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
    44f0:	2e 8b       	std	Y+22, r18	; 0x16
    44f2:	3f 8b       	std	Y+23, r19	; 0x17
    44f4:	48 8f       	std	Y+24, r20	; 0x18
    44f6:	59 8f       	std	Y+25, r21	; 0x19
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    44f8:	8e 81       	ldd	r24, Y+6	; 0x06
    44fa:	9f 81       	ldd	r25, Y+7	; 0x07
    44fc:	91 70       	andi	r25, 0x01	; 1
    44fe:	92 01       	movw	r18, r4
    4500:	28 1b       	sub	r18, r24
    4502:	39 0b       	sbc	r19, r25
    4504:	87 01       	movw	r16, r14
    4506:	2e 15       	cp	r18, r14
    4508:	3f 05       	cpc	r19, r15
    450a:	08 f4       	brcc	.+2      	; 0x450e <f_read+0x184>
    450c:	89 01       	movw	r16, r18
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    450e:	4e 89       	ldd	r20, Y+22	; 0x16
    4510:	5f 89       	ldd	r21, Y+23	; 0x17
    4512:	68 8d       	ldd	r22, Y+24	; 0x18
    4514:	79 8d       	ldd	r23, Y+25	; 0x19
    4516:	88 81       	ld	r24, Y
    4518:	99 81       	ldd	r25, Y+1	; 0x01
    451a:	4c d9       	rcall	.-3432   	; 0x37b4 <move_window>
    451c:	88 23       	and	r24, r24
    451e:	29 f0       	breq	.+10     	; 0x452a <f_read+0x1a0>
			ABORT(fp->fs, FR_DISK_ERR);
    4520:	8c 81       	ldd	r24, Y+4	; 0x04
    4522:	80 68       	ori	r24, 0x80	; 128
    4524:	8c 83       	std	Y+4, r24	; 0x04
    4526:	81 e0       	ldi	r24, 0x01	; 1
    4528:	43 c0       	rjmp	.+134    	; 0x45b0 <f_read+0x226>
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    452a:	8e 81       	ldd	r24, Y+6	; 0x06
    452c:	9f 81       	ldd	r25, Y+7	; 0x07
    452e:	a8 85       	ldd	r26, Y+8	; 0x08
    4530:	b9 85       	ldd	r27, Y+9	; 0x09
    4532:	91 70       	andi	r25, 0x01	; 1
    4534:	aa 27       	eor	r26, r26
    4536:	bb 27       	eor	r27, r27
    4538:	82 96       	adiw	r24, 0x22	; 34
    453a:	28 81       	ld	r18, Y
    453c:	39 81       	ldd	r19, Y+1	; 0x01
    453e:	82 0f       	add	r24, r18
    4540:	93 1f       	adc	r25, r19
    4542:	dc 01       	movw	r26, r24
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    4544:	f6 01       	movw	r30, r12
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    4546:	98 01       	movw	r18, r16
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof(int)) {
    4548:	22 30       	cpi	r18, 0x02	; 2
    454a:	31 05       	cpc	r19, r1
    454c:	38 f0       	brcs	.+14     	; 0x455c <f_read+0x1d2>
		*(int*)d = *(int*)s;
    454e:	4d 91       	ld	r20, X+
    4550:	5d 91       	ld	r21, X+
    4552:	41 93       	st	Z+, r20
    4554:	51 93       	st	Z+, r21
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
    4556:	22 50       	subi	r18, 0x02	; 2
    4558:	31 09       	sbc	r19, r1
    455a:	f6 cf       	rjmp	.-20     	; 0x4548 <f_read+0x1be>
    455c:	98 01       	movw	r18, r16
    455e:	2e 7f       	andi	r18, 0xFE	; 254
    4560:	dc 01       	movw	r26, r24
    4562:	a2 0f       	add	r26, r18
    4564:	b3 1f       	adc	r27, r19
    4566:	f6 01       	movw	r30, r12
    4568:	e2 0f       	add	r30, r18
    456a:	f3 1f       	adc	r31, r19
	}
#endif
	while (cnt--)
    456c:	02 17       	cp	r16, r18
    456e:	13 07       	cpc	r17, r19
    4570:	11 f0       	breq	.+4      	; 0x4576 <f_read+0x1ec>
		*d++ = *s++;
    4572:	8c 91       	ld	r24, X
    4574:	80 83       	st	Z, r24
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    4576:	c0 0e       	add	r12, r16
    4578:	d1 1e       	adc	r13, r17
    457a:	8e 81       	ldd	r24, Y+6	; 0x06
    457c:	9f 81       	ldd	r25, Y+7	; 0x07
    457e:	a8 85       	ldd	r26, Y+8	; 0x08
    4580:	b9 85       	ldd	r27, Y+9	; 0x09
    4582:	80 0f       	add	r24, r16
    4584:	91 1f       	adc	r25, r17
    4586:	a1 1d       	adc	r26, r1
    4588:	b1 1d       	adc	r27, r1
    458a:	8e 83       	std	Y+6, r24	; 0x06
    458c:	9f 83       	std	Y+7, r25	; 0x07
    458e:	a8 87       	std	Y+8, r26	; 0x08
    4590:	b9 87       	std	Y+9, r27	; 0x09
    4592:	f5 01       	movw	r30, r10
    4594:	80 81       	ld	r24, Z
    4596:	91 81       	ldd	r25, Z+1	; 0x01
    4598:	80 0f       	add	r24, r16
    459a:	91 1f       	adc	r25, r17
    459c:	91 83       	std	Z+1, r25	; 0x01
    459e:	80 83       	st	Z, r24
    45a0:	e0 1a       	sub	r14, r16
    45a2:	f1 0a       	sbc	r15, r17
    45a4:	2d cf       	rjmp	.-422    	; 0x4400 <f_read+0x76>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
    45a6:	80 e0       	ldi	r24, 0x00	; 0
    45a8:	03 c0       	rjmp	.+6      	; 0x45b0 <f_read+0x226>
	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    45aa:	82 e0       	ldi	r24, 0x02	; 2
    45ac:	01 c0       	rjmp	.+2      	; 0x45b0 <f_read+0x226>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    45ae:	87 e0       	ldi	r24, 0x07	; 7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    45b0:	df 91       	pop	r29
    45b2:	cf 91       	pop	r28
    45b4:	1f 91       	pop	r17
    45b6:	0f 91       	pop	r16
    45b8:	ff 90       	pop	r15
    45ba:	ef 90       	pop	r14
    45bc:	df 90       	pop	r13
    45be:	cf 90       	pop	r12
    45c0:	bf 90       	pop	r11
    45c2:	af 90       	pop	r10
    45c4:	9f 90       	pop	r9
    45c6:	8f 90       	pop	r8
    45c8:	7f 90       	pop	r7
    45ca:	6f 90       	pop	r6
    45cc:	5f 90       	pop	r5
    45ce:	4f 90       	pop	r4
    45d0:	08 95       	ret

000045d2 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    45d2:	cf 93       	push	r28
    45d4:	df 93       	push	r29
    45d6:	ec 01       	movw	r28, r24
	FRESULT res;

#if _FS_READONLY
	FATFS *fs = fp->fs;
	res = validate(fs, fp->id);
    45d8:	6a 81       	ldd	r22, Y+2	; 0x02
    45da:	7b 81       	ldd	r23, Y+3	; 0x03
    45dc:	88 81       	ld	r24, Y
    45de:	99 81       	ldd	r25, Y+1	; 0x01
    45e0:	55 d9       	rcall	.-3414   	; 0x388c <validate>
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    45e2:	81 11       	cpse	r24, r1
    45e4:	02 c0       	rjmp	.+4      	; 0x45ea <f_close+0x18>
    45e6:	19 82       	std	Y+1, r1	; 0x01
    45e8:	18 82       	st	Y, r1
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
    45ea:	df 91       	pop	r29
    45ec:	cf 91       	pop	r28
    45ee:	08 95       	ret

000045f0 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    45f0:	4f 92       	push	r4
    45f2:	5f 92       	push	r5
    45f4:	6f 92       	push	r6
    45f6:	7f 92       	push	r7
    45f8:	8f 92       	push	r8
    45fa:	9f 92       	push	r9
    45fc:	af 92       	push	r10
    45fe:	bf 92       	push	r11
    4600:	cf 92       	push	r12
    4602:	df 92       	push	r13
    4604:	ef 92       	push	r14
    4606:	ff 92       	push	r15
    4608:	cf 93       	push	r28
    460a:	df 93       	push	r29
    460c:	00 d0       	rcall	.+0      	; 0x460e <f_lseek+0x1e>
    460e:	00 d0       	rcall	.+0      	; 0x4610 <f_lseek+0x20>
    4610:	00 d0       	rcall	.+0      	; 0x4612 <f_lseek+0x22>
    4612:	cd b7       	in	r28, 0x3d	; 61
    4614:	de b7       	in	r29, 0x3e	; 62
    4616:	9e 83       	std	Y+6, r25	; 0x06
    4618:	8d 83       	std	Y+5, r24	; 0x05
    461a:	4a 01       	movw	r8, r20
    461c:	5b 01       	movw	r10, r22
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    461e:	dc 01       	movw	r26, r24
    4620:	12 96       	adiw	r26, 0x02	; 2
    4622:	6d 91       	ld	r22, X+
    4624:	7c 91       	ld	r23, X
    4626:	13 97       	sbiw	r26, 0x03	; 3
    4628:	8d 91       	ld	r24, X+
    462a:	9c 91       	ld	r25, X
    462c:	2f d9       	rcall	.-3490   	; 0x388c <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    462e:	81 11       	cpse	r24, r1
    4630:	2e c1       	rjmp	.+604    	; 0x488e <f_lseek+0x29e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    4632:	ed 81       	ldd	r30, Y+5	; 0x05
    4634:	fe 81       	ldd	r31, Y+6	; 0x06
    4636:	84 81       	ldd	r24, Z+4	; 0x04
    4638:	87 fd       	sbrc	r24, 7
    463a:	28 c1       	rjmp	.+592    	; 0x488c <f_lseek+0x29c>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    463c:	c2 84       	ldd	r12, Z+10	; 0x0a
    463e:	d3 84       	ldd	r13, Z+11	; 0x0b
    4640:	e4 84       	ldd	r14, Z+12	; 0x0c
    4642:	f5 84       	ldd	r15, Z+13	; 0x0d
    4644:	8c 14       	cp	r8, r12
    4646:	9d 04       	cpc	r9, r13
    4648:	ae 04       	cpc	r10, r14
    464a:	bf 04       	cpc	r11, r15
    464c:	10 f4       	brcc	.+4      	; 0x4652 <f_lseek+0x62>
    464e:	75 01       	movw	r14, r10
    4650:	64 01       	movw	r12, r8
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
    4652:	ad 81       	ldd	r26, Y+5	; 0x05
    4654:	be 81       	ldd	r27, Y+6	; 0x06
    4656:	16 96       	adiw	r26, 0x06	; 6
    4658:	4d 90       	ld	r4, X+
    465a:	5d 90       	ld	r5, X+
    465c:	6d 90       	ld	r6, X+
    465e:	7c 90       	ld	r7, X
    4660:	19 97       	sbiw	r26, 0x09	; 9
		fp->fptr = nsect = 0;
    4662:	fd 01       	movw	r30, r26
    4664:	16 82       	std	Z+6, r1	; 0x06
    4666:	17 82       	std	Z+7, r1	; 0x07
    4668:	10 86       	std	Z+8, r1	; 0x08
    466a:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    466c:	c1 14       	cp	r12, r1
    466e:	d1 04       	cpc	r13, r1
    4670:	e1 04       	cpc	r14, r1
    4672:	f1 04       	cpc	r15, r1
    4674:	09 f4       	brne	.+2      	; 0x4678 <f_lseek+0x88>
    4676:	08 c1       	rjmp	.+528    	; 0x4888 <f_lseek+0x298>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    4678:	ad 81       	ldd	r26, Y+5	; 0x05
    467a:	be 81       	ldd	r27, Y+6	; 0x06
    467c:	ed 91       	ld	r30, X+
    467e:	fc 91       	ld	r31, X
    4680:	82 80       	ldd	r8, Z+2	; 0x02
    4682:	91 2c       	mov	r9, r1
    4684:	a1 2c       	mov	r10, r1
    4686:	b1 2c       	mov	r11, r1
    4688:	39 e0       	ldi	r19, 0x09	; 9
    468a:	88 0c       	add	r8, r8
    468c:	99 1c       	adc	r9, r9
    468e:	aa 1c       	adc	r10, r10
    4690:	bb 1c       	adc	r11, r11
    4692:	3a 95       	dec	r19
    4694:	d1 f7       	brne	.-12     	; 0x468a <f_lseek+0x9a>
			if (ifptr > 0 &&
    4696:	41 14       	cp	r4, r1
    4698:	51 04       	cpc	r5, r1
    469a:	61 04       	cpc	r6, r1
    469c:	71 04       	cpc	r7, r1
    469e:	09 f4       	brne	.+2      	; 0x46a2 <f_lseek+0xb2>
    46a0:	49 c0       	rjmp	.+146    	; 0x4734 <f_lseek+0x144>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    46a2:	b1 e0       	ldi	r27, 0x01	; 1
    46a4:	4b 1a       	sub	r4, r27
    46a6:	51 08       	sbc	r5, r1
    46a8:	61 08       	sbc	r6, r1
    46aa:	71 08       	sbc	r7, r1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    46ac:	c7 01       	movw	r24, r14
    46ae:	b6 01       	movw	r22, r12
    46b0:	61 50       	subi	r22, 0x01	; 1
    46b2:	71 09       	sbc	r23, r1
    46b4:	81 09       	sbc	r24, r1
    46b6:	91 09       	sbc	r25, r1
    46b8:	a5 01       	movw	r20, r10
    46ba:	94 01       	movw	r18, r8
    46bc:	0e 94 b8 39 	call	0x7370	; 0x7370 <__udivmodsi4>
    46c0:	29 83       	std	Y+1, r18	; 0x01
    46c2:	3a 83       	std	Y+2, r19	; 0x02
    46c4:	4b 83       	std	Y+3, r20	; 0x03
    46c6:	5c 83       	std	Y+4, r21	; 0x04
    46c8:	c3 01       	movw	r24, r6
    46ca:	b2 01       	movw	r22, r4
    46cc:	a5 01       	movw	r20, r10
    46ce:	94 01       	movw	r18, r8
    46d0:	0e 94 b8 39 	call	0x7370	; 0x7370 <__udivmodsi4>
    46d4:	89 81       	ldd	r24, Y+1	; 0x01
    46d6:	9a 81       	ldd	r25, Y+2	; 0x02
    46d8:	ab 81       	ldd	r26, Y+3	; 0x03
    46da:	bc 81       	ldd	r27, Y+4	; 0x04
    46dc:	82 17       	cp	r24, r18
    46de:	93 07       	cpc	r25, r19
    46e0:	a4 07       	cpc	r26, r20
    46e2:	b5 07       	cpc	r27, r21
    46e4:	38 f1       	brcs	.+78     	; 0x4734 <f_lseek+0x144>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    46e6:	88 27       	eor	r24, r24
    46e8:	99 27       	eor	r25, r25
    46ea:	dc 01       	movw	r26, r24
    46ec:	88 19       	sub	r24, r8
    46ee:	99 09       	sbc	r25, r9
    46f0:	aa 09       	sbc	r26, r10
    46f2:	bb 09       	sbc	r27, r11
    46f4:	48 22       	and	r4, r24
    46f6:	59 22       	and	r5, r25
    46f8:	6a 22       	and	r6, r26
    46fa:	7b 22       	and	r7, r27
    46fc:	ad 81       	ldd	r26, Y+5	; 0x05
    46fe:	be 81       	ldd	r27, Y+6	; 0x06
    4700:	16 96       	adiw	r26, 0x06	; 6
    4702:	4d 92       	st	X+, r4
    4704:	5d 92       	st	X+, r5
    4706:	6d 92       	st	X+, r6
    4708:	7c 92       	st	X, r7
    470a:	19 97       	sbiw	r26, 0x09	; 9
				ofs -= fp->fptr;
				clst = fp->clust;
    470c:	52 96       	adiw	r26, 0x12	; 18
    470e:	4d 91       	ld	r20, X+
    4710:	5d 91       	ld	r21, X+
    4712:	6d 91       	ld	r22, X+
    4714:	7c 91       	ld	r23, X
    4716:	55 97       	sbiw	r26, 0x15	; 21
					fp->sclust = clst;
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
    4718:	41 15       	cp	r20, r1
    471a:	51 05       	cpc	r21, r1
    471c:	61 05       	cpc	r22, r1
    471e:	71 05       	cpc	r23, r1
    4720:	21 f4       	brne	.+8      	; 0x472a <f_lseek+0x13a>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    4722:	c1 2c       	mov	r12, r1
    4724:	d1 2c       	mov	r13, r1
    4726:	76 01       	movw	r14, r12
    4728:	95 c0       	rjmp	.+298    	; 0x4854 <f_lseek+0x264>
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
    472a:	c4 18       	sub	r12, r4
    472c:	d5 08       	sbc	r13, r5
    472e:	e6 08       	sbc	r14, r6
    4730:	f7 08       	sbc	r15, r7
    4732:	3c c0       	rjmp	.+120    	; 0x47ac <f_lseek+0x1bc>
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    4734:	ed 81       	ldd	r30, Y+5	; 0x05
    4736:	fe 81       	ldd	r31, Y+6	; 0x06
    4738:	46 85       	ldd	r20, Z+14	; 0x0e
    473a:	57 85       	ldd	r21, Z+15	; 0x0f
    473c:	60 89       	ldd	r22, Z+16	; 0x10
    473e:	71 89       	ldd	r23, Z+17	; 0x11
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					fp->sclust = clst;
				}
#endif
				fp->clust = clst;
    4740:	42 8b       	std	Z+18, r20	; 0x12
    4742:	53 8b       	std	Z+19, r21	; 0x13
    4744:	64 8b       	std	Z+20, r22	; 0x14
    4746:	75 8b       	std	Z+21, r23	; 0x15
			}
			if (clst != 0) {
    4748:	41 15       	cp	r20, r1
    474a:	51 05       	cpc	r21, r1
    474c:	61 05       	cpc	r22, r1
    474e:	71 05       	cpc	r23, r1
    4750:	69 f5       	brne	.+90     	; 0x47ac <f_lseek+0x1bc>
    4752:	9a c0       	rjmp	.+308    	; 0x4888 <f_lseek+0x298>
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    4754:	42 30       	cpi	r20, 0x02	; 2
    4756:	51 05       	cpc	r21, r1
    4758:	61 05       	cpc	r22, r1
    475a:	71 05       	cpc	r23, r1
    475c:	08 f4       	brcc	.+2      	; 0x4760 <f_lseek+0x170>
    475e:	42 c0       	rjmp	.+132    	; 0x47e4 <f_lseek+0x1f4>
    4760:	ad 81       	ldd	r26, Y+5	; 0x05
    4762:	be 81       	ldd	r27, Y+6	; 0x06
    4764:	ed 91       	ld	r30, X+
    4766:	fc 91       	ld	r31, X
    4768:	82 85       	ldd	r24, Z+10	; 0x0a
    476a:	93 85       	ldd	r25, Z+11	; 0x0b
    476c:	a4 85       	ldd	r26, Z+12	; 0x0c
    476e:	b5 85       	ldd	r27, Z+13	; 0x0d
    4770:	48 17       	cp	r20, r24
    4772:	59 07       	cpc	r21, r25
    4774:	6a 07       	cpc	r22, r26
    4776:	7b 07       	cpc	r23, r27
    4778:	a8 f5       	brcc	.+106    	; 0x47e4 <f_lseek+0x1f4>
					fp->clust = clst;
    477a:	ad 81       	ldd	r26, Y+5	; 0x05
    477c:	be 81       	ldd	r27, Y+6	; 0x06
    477e:	52 96       	adiw	r26, 0x12	; 18
    4780:	4d 93       	st	X+, r20
    4782:	5d 93       	st	X+, r21
    4784:	6d 93       	st	X+, r22
    4786:	7c 93       	st	X, r23
    4788:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    478a:	fd 01       	movw	r30, r26
    478c:	86 81       	ldd	r24, Z+6	; 0x06
    478e:	97 81       	ldd	r25, Z+7	; 0x07
    4790:	a0 85       	ldd	r26, Z+8	; 0x08
    4792:	b1 85       	ldd	r27, Z+9	; 0x09
    4794:	88 0d       	add	r24, r8
    4796:	99 1d       	adc	r25, r9
    4798:	aa 1d       	adc	r26, r10
    479a:	bb 1d       	adc	r27, r11
    479c:	86 83       	std	Z+6, r24	; 0x06
    479e:	97 83       	std	Z+7, r25	; 0x07
    47a0:	a0 87       	std	Z+8, r26	; 0x08
    47a2:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    47a4:	c8 18       	sub	r12, r8
    47a6:	d9 08       	sbc	r13, r9
    47a8:	ea 08       	sbc	r14, r10
    47aa:	fb 08       	sbc	r15, r11
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    47ac:	ed 81       	ldd	r30, Y+5	; 0x05
    47ae:	fe 81       	ldd	r31, Y+6	; 0x06
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    47b0:	8c 14       	cp	r8, r12
    47b2:	9d 04       	cpc	r9, r13
    47b4:	ae 04       	cpc	r10, r14
    47b6:	bf 04       	cpc	r11, r15
    47b8:	d8 f4       	brcc	.+54     	; 0x47f0 <f_lseek+0x200>
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    47ba:	80 81       	ld	r24, Z
    47bc:	91 81       	ldd	r25, Z+1	; 0x01
    47be:	a3 d8       	rcall	.-3770   	; 0x3906 <get_fat>
    47c0:	ab 01       	movw	r20, r22
    47c2:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    47c4:	4f 3f       	cpi	r20, 0xFF	; 255
    47c6:	ff ef       	ldi	r31, 0xFF	; 255
    47c8:	5f 07       	cpc	r21, r31
    47ca:	6f 07       	cpc	r22, r31
    47cc:	7f 07       	cpc	r23, r31
    47ce:	11 f6       	brne	.-124    	; 0x4754 <f_lseek+0x164>
    47d0:	ad 81       	ldd	r26, Y+5	; 0x05
    47d2:	be 81       	ldd	r27, Y+6	; 0x06
    47d4:	14 96       	adiw	r26, 0x04	; 4
    47d6:	8c 91       	ld	r24, X
    47d8:	14 97       	sbiw	r26, 0x04	; 4
    47da:	80 68       	ori	r24, 0x80	; 128
    47dc:	14 96       	adiw	r26, 0x04	; 4
    47de:	8c 93       	st	X, r24
    47e0:	81 e0       	ldi	r24, 0x01	; 1
    47e2:	55 c0       	rjmp	.+170    	; 0x488e <f_lseek+0x29e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    47e4:	ed 81       	ldd	r30, Y+5	; 0x05
    47e6:	fe 81       	ldd	r31, Y+6	; 0x06
    47e8:	84 81       	ldd	r24, Z+4	; 0x04
    47ea:	80 68       	ori	r24, 0x80	; 128
    47ec:	84 83       	std	Z+4, r24	; 0x04
    47ee:	4e c0       	rjmp	.+156    	; 0x488c <f_lseek+0x29c>
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    47f0:	86 81       	ldd	r24, Z+6	; 0x06
    47f2:	97 81       	ldd	r25, Z+7	; 0x07
    47f4:	a0 85       	ldd	r26, Z+8	; 0x08
    47f6:	b1 85       	ldd	r27, Z+9	; 0x09
    47f8:	8c 0d       	add	r24, r12
    47fa:	9d 1d       	adc	r25, r13
    47fc:	ae 1d       	adc	r26, r14
    47fe:	bf 1d       	adc	r27, r15
    4800:	86 83       	std	Z+6, r24	; 0x06
    4802:	97 83       	std	Z+7, r25	; 0x07
    4804:	a0 87       	std	Z+8, r26	; 0x08
    4806:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    4808:	d7 01       	movw	r26, r14
    480a:	c6 01       	movw	r24, r12
    480c:	91 70       	andi	r25, 0x01	; 1
    480e:	aa 27       	eor	r26, r26
    4810:	bb 27       	eor	r27, r27
    4812:	89 2b       	or	r24, r25
    4814:	8a 2b       	or	r24, r26
    4816:	8b 2b       	or	r24, r27
    4818:	09 f4       	brne	.+2      	; 0x481c <f_lseek+0x22c>
    481a:	83 cf       	rjmp	.-250    	; 0x4722 <f_lseek+0x132>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    481c:	80 81       	ld	r24, Z
    481e:	91 81       	ldd	r25, Z+1	; 0x01
    4820:	4a d8       	rcall	.-3948   	; 0x38b6 <clust2sect>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    4822:	61 15       	cp	r22, r1
    4824:	71 05       	cpc	r23, r1
    4826:	81 05       	cpc	r24, r1
    4828:	91 05       	cpc	r25, r1
    482a:	49 f4       	brne	.+18     	; 0x483e <f_lseek+0x24e>
    482c:	ad 81       	ldd	r26, Y+5	; 0x05
    482e:	be 81       	ldd	r27, Y+6	; 0x06
    4830:	14 96       	adiw	r26, 0x04	; 4
    4832:	8c 91       	ld	r24, X
    4834:	14 97       	sbiw	r26, 0x04	; 4
    4836:	80 68       	ori	r24, 0x80	; 128
    4838:	14 96       	adiw	r26, 0x04	; 4
    483a:	8c 93       	st	X, r24
    483c:	27 c0       	rjmp	.+78     	; 0x488c <f_lseek+0x29c>
					nsect += ofs / SS(fp->fs);
    483e:	29 e0       	ldi	r18, 0x09	; 9
    4840:	f6 94       	lsr	r15
    4842:	e7 94       	ror	r14
    4844:	d7 94       	ror	r13
    4846:	c7 94       	ror	r12
    4848:	2a 95       	dec	r18
    484a:	d1 f7       	brne	.-12     	; 0x4840 <f_lseek+0x250>
    484c:	c6 0e       	add	r12, r22
    484e:	d7 1e       	adc	r13, r23
    4850:	e8 1e       	adc	r14, r24
    4852:	f9 1e       	adc	r15, r25
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    4854:	ed 81       	ldd	r30, Y+5	; 0x05
    4856:	fe 81       	ldd	r31, Y+6	; 0x06
    4858:	86 81       	ldd	r24, Z+6	; 0x06
    485a:	97 81       	ldd	r25, Z+7	; 0x07
    485c:	a0 85       	ldd	r26, Z+8	; 0x08
    485e:	b1 85       	ldd	r27, Z+9	; 0x09
    4860:	91 70       	andi	r25, 0x01	; 1
    4862:	aa 27       	eor	r26, r26
    4864:	bb 27       	eor	r27, r27
    4866:	89 2b       	or	r24, r25
    4868:	8a 2b       	or	r24, r26
    486a:	8b 2b       	or	r24, r27
    486c:	69 f0       	breq	.+26     	; 0x4888 <f_lseek+0x298>
    486e:	86 89       	ldd	r24, Z+22	; 0x16
    4870:	97 89       	ldd	r25, Z+23	; 0x17
    4872:	a0 8d       	ldd	r26, Z+24	; 0x18
    4874:	b1 8d       	ldd	r27, Z+25	; 0x19
    4876:	c8 16       	cp	r12, r24
    4878:	d9 06       	cpc	r13, r25
    487a:	ea 06       	cpc	r14, r26
    487c:	fb 06       	cpc	r15, r27
    487e:	21 f0       	breq	.+8      	; 0x4888 <f_lseek+0x298>
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
    4880:	c6 8a       	std	Z+22, r12	; 0x16
    4882:	d7 8a       	std	Z+23, r13	; 0x17
    4884:	e0 8e       	std	Z+24, r14	; 0x18
    4886:	f1 8e       	std	Z+25, r15	; 0x19
    4888:	80 e0       	ldi	r24, 0x00	; 0
    488a:	01 c0       	rjmp	.+2      	; 0x488e <f_lseek+0x29e>


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    488c:	82 e0       	ldi	r24, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    488e:	26 96       	adiw	r28, 0x06	; 6
    4890:	0f b6       	in	r0, 0x3f	; 63
    4892:	f8 94       	cli
    4894:	de bf       	out	0x3e, r29	; 62
    4896:	0f be       	out	0x3f, r0	; 63
    4898:	cd bf       	out	0x3d, r28	; 61
    489a:	df 91       	pop	r29
    489c:	cf 91       	pop	r28
    489e:	ff 90       	pop	r15
    48a0:	ef 90       	pop	r14
    48a2:	df 90       	pop	r13
    48a4:	cf 90       	pop	r12
    48a6:	bf 90       	pop	r11
    48a8:	af 90       	pop	r10
    48aa:	9f 90       	pop	r9
    48ac:	8f 90       	pop	r8
    48ae:	7f 90       	pop	r7
    48b0:	6f 90       	pop	r6
    48b2:	5f 90       	pop	r5
    48b4:	4f 90       	pop	r4
    48b6:	08 95       	ret

000048b8 <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    48b8:	98 2f       	mov	r25, r24
    48ba:	97 30       	cpi	r25, 0x07	; 7
    48bc:	68 f5       	brcc	.+90     	; 0x4918 <Endpoint_ConfigureEndpoint_Prv+0x60>
    48be:	90 93 e9 00 	sts	0x00E9, r25	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    48c2:	98 17       	cp	r25, r24
    48c4:	39 f0       	breq	.+14     	; 0x48d4 <Endpoint_ConfigureEndpoint_Prv+0x1c>
    48c6:	70 91 ec 00 	lds	r23, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    48ca:	20 91 ed 00 	lds	r18, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    48ce:	50 91 f0 00 	lds	r21, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    48d2:	03 c0       	rjmp	.+6      	; 0x48da <Endpoint_ConfigureEndpoint_Prv+0x22>
    48d4:	24 2f       	mov	r18, r20
    48d6:	76 2f       	mov	r23, r22
    48d8:	50 e0       	ldi	r21, 0x00	; 0
    48da:	21 fd       	sbrc	r18, 1
    48dc:	02 c0       	rjmp	.+4      	; 0x48e2 <Endpoint_ConfigureEndpoint_Prv+0x2a>
    48de:	9f 5f       	subi	r25, 0xFF	; 255
    48e0:	ec cf       	rjmp	.-40     	; 0x48ba <Endpoint_ConfigureEndpoint_Prv+0x2>
    48e2:	30 91 eb 00 	lds	r19, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    48e6:	3e 7f       	andi	r19, 0xFE	; 254
    48e8:	30 93 eb 00 	sts	0x00EB, r19	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    48ec:	30 91 ed 00 	lds	r19, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    48f0:	3d 7f       	andi	r19, 0xFD	; 253
    48f2:	30 93 ed 00 	sts	0x00ED, r19	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    48f6:	30 91 eb 00 	lds	r19, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    48fa:	31 60       	ori	r19, 0x01	; 1
    48fc:	30 93 eb 00 	sts	0x00EB, r19	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    4900:	70 93 ec 00 	sts	0x00EC, r23	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    4904:	20 93 ed 00 	sts	0x00ED, r18	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    4908:	50 93 f0 00 	sts	0x00F0, r21	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    490c:	20 91 ee 00 	lds	r18, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
    4910:	27 fd       	sbrc	r18, 7
    4912:	e5 cf       	rjmp	.-54     	; 0x48de <Endpoint_ConfigureEndpoint_Prv+0x26>
    4914:	80 e0       	ldi	r24, 0x00	; 0
    4916:	08 95       	ret
    4918:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    491c:	81 e0       	ldi	r24, 0x01	; 1
    491e:	08 95       	ret

00004920 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    4920:	80 91 8f 0d 	lds	r24, 0x0D8F	; 0x800d8f <USB_ControlRequest>
    4924:	87 ff       	sbrs	r24, 7
    4926:	0f c0       	rjmp	.+30     	; 0x4946 <Endpoint_ClearStatusStage+0x26>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4928:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		while (!(Endpoint_IsOUTReceived()))
    492c:	82 fd       	sbrc	r24, 2
    492e:	04 c0       	rjmp	.+8      	; 0x4938 <Endpoint_ClearStatusStage+0x18>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    4930:	8e b3       	in	r24, 0x1e	; 30
    4932:	81 11       	cpse	r24, r1
    4934:	f9 cf       	rjmp	.-14     	; 0x4928 <Endpoint_ClearStatusStage+0x8>
    4936:	10 c0       	rjmp	.+32     	; 0x4958 <Endpoint_ClearStatusStage+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4938:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    493c:	8b 77       	andi	r24, 0x7B	; 123
    493e:	0a c0       	rjmp	.+20     	; 0x4954 <Endpoint_ClearStatusStage+0x34>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    4940:	8e b3       	in	r24, 0x1e	; 30
    4942:	88 23       	and	r24, r24
    4944:	49 f0       	breq	.+18     	; 0x4958 <Endpoint_ClearStatusStage+0x38>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4946:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    494a:	80 ff       	sbrs	r24, 0
    494c:	f9 cf       	rjmp	.-14     	; 0x4940 <Endpoint_ClearStatusStage+0x20>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    494e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    4952:	8e 77       	andi	r24, 0x7E	; 126
    4954:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    4958:	08 95       	ret

0000495a <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    495a:	20 91 e4 00 	lds	r18, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    495e:	30 91 e5 00 	lds	r19, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
    4962:	95 e6       	ldi	r25, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    4964:	40 91 ec 00 	lds	r20, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    4968:	84 2f       	mov	r24, r20
    496a:	81 70       	andi	r24, 0x01	; 1
    496c:	40 ff       	sbrs	r20, 0
    496e:	22 c0       	rjmp	.+68     	; 0x49b4 <Endpoint_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4970:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    4974:	80 fd       	sbrc	r24, 0
    4976:	1c c0       	rjmp	.+56     	; 0x49b0 <Endpoint_WaitUntilReady+0x56>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4978:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    497a:	88 23       	and	r24, r24
    497c:	99 f0       	breq	.+38     	; 0x49a4 <Endpoint_WaitUntilReady+0x4a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    497e:	85 30       	cpi	r24, 0x05	; 5
    4980:	99 f0       	breq	.+38     	; 0x49a8 <Endpoint_WaitUntilReady+0x4e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    4982:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    4986:	85 fd       	sbrc	r24, 5
    4988:	11 c0       	rjmp	.+34     	; 0x49ac <Endpoint_WaitUntilReady+0x52>
    498a:	40 91 e4 00 	lds	r20, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    498e:	50 91 e5 00 	lds	r21, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    4992:	24 17       	cp	r18, r20
    4994:	35 07       	cpc	r19, r21
    4996:	31 f3       	breq	.-52     	; 0x4964 <Endpoint_WaitUntilReady+0xa>
    4998:	91 50       	subi	r25, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    499a:	11 f0       	breq	.+4      	; 0x49a0 <Endpoint_WaitUntilReady+0x46>
    499c:	9a 01       	movw	r18, r20
    499e:	e2 cf       	rjmp	.-60     	; 0x4964 <Endpoint_WaitUntilReady+0xa>
			  return ENDPOINT_READYWAIT_Timeout;
    49a0:	84 e0       	ldi	r24, 0x04	; 4
    49a2:	08 95       	ret
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    49a4:	82 e0       	ldi	r24, 0x02	; 2
    49a6:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    49a8:	83 e0       	ldi	r24, 0x03	; 3
    49aa:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    49ac:	81 e0       	ldi	r24, 0x01	; 1
    49ae:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    49b0:	80 e0       	ldi	r24, 0x00	; 0
    49b2:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    49b4:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    49b8:	42 ff       	sbrs	r20, 2
    49ba:	de cf       	rjmp	.-68     	; 0x4978 <Endpoint_WaitUntilReady+0x1e>

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    49bc:	08 95       	ret

000049be <USB_Host_ResetDevice>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    49be:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    49c2:	81 70       	andi	r24, 0x01	; 1
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    49c4:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    49c8:	9d 7f       	andi	r25, 0xFD	; 253
    49ca:	90 93 a0 00 	sts	0x00A0, r25	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
			 *  woken up automatically and the bus resumed after the reset has been correctly issued.
			 */
			static inline void USB_Host_ResetBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResetBus(void)
			{
				UHCON |=  (1 << RESET);
    49ce:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    49d2:	92 60       	ori	r25, 0x02	; 2
    49d4:	90 93 9e 00 	sts	0x009E, r25	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
			 *  \return Boolean \c true if no bus reset is currently being sent, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusResetComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusResetComplete(void)
			{
				return ((UHCON & (1 << RESET)) ? false : true);
    49d8:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
	bool BusSuspended = USB_Host_IsBusSuspended();

	USB_INT_Disable(USB_INT_DDISCI);

	USB_Host_ResetBus();
	while (!(USB_Host_IsBusResetComplete()));
    49dc:	91 fd       	sbrc	r25, 1
    49de:	fc cf       	rjmp	.-8      	; 0x49d8 <USB_Host_ResetDevice+0x1a>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    49e0:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    49e4:	91 60       	ori	r25, 0x01	; 1
    49e6:	90 93 9e 00 	sts	0x009E, r25	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
	USB_Host_ResumeBus();
	
	USB_Host_ConfigurationNumber = 0;
    49ea:	10 92 8d 0d 	sts	0x0D8D, r1	; 0x800d8d <USB_Host_ConfigurationNumber>
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    49ee:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    49f2:	90 72       	andi	r25, 0x20	; 32
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    49f4:	20 91 a0 00 	lds	r18, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    49f8:	2f 7d       	andi	r18, 0xDF	; 223
    49fa:	20 93 a0 00 	sts	0x00A0, r18	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    49fe:	20 91 9f 00 	lds	r18, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4a02:	2f 7d       	andi	r18, 0xDF	; 223
    4a04:	20 93 9f 00 	sts	0x009F, r18	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4a08:	2a e0       	ldi	r18, 0x0A	; 10
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    4a0a:	30 91 9f 00 	lds	r19, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
		/* Workaround for powerless-pull-up devices. After a USB bus reset,
		   all disconnection interrupts are suppressed while a USB frame is
		   looked for - if it is found within 10ms, the device is still
		   present.                                                        */

		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    4a0e:	35 ff       	sbrs	r19, 5
    4a10:	0b c0       	rjmp	.+22     	; 0x4a28 <USB_Host_ResetDevice+0x6a>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4a12:	20 91 9f 00 	lds	r18, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4a16:	2f 7d       	andi	r18, 0xDF	; 223
    4a18:	20 93 9f 00 	sts	0x009F, r18	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    4a1c:	20 91 9f 00 	lds	r18, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4a20:	2d 7f       	andi	r18, 0xFD	; 253
    4a22:	20 93 9f 00 	sts	0x009F, r18	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4a26:	08 c0       	rjmp	.+16     	; 0x4a38 <USB_Host_ResetDevice+0x7a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4a28:	ef ec       	ldi	r30, 0xCF	; 207
    4a2a:	f7 e0       	ldi	r31, 0x07	; 7
    4a2c:	31 97       	sbiw	r30, 0x01	; 1
    4a2e:	f1 f7       	brne	.-4      	; 0x4a2c <USB_Host_ResetDevice+0x6e>
    4a30:	00 c0       	rjmp	.+0      	; 0x4a32 <USB_Host_ResetDevice+0x74>
    4a32:	00 00       	nop
    4a34:	21 50       	subi	r18, 0x01	; 1
	bool HSOFIEnabled = USB_INT_IsEnabled(USB_INT_HSOFI);

	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	for (uint8_t MSRem = 10; MSRem != 0; MSRem--)
    4a36:	49 f7       	brne	.-46     	; 0x4a0a <USB_Host_ResetDevice+0x4c>
		}

		Delay_MS(1);
	}

	if (HSOFIEnabled)
    4a38:	99 23       	and	r25, r25
    4a3a:	29 f0       	breq	.+10     	; 0x4a46 <USB_Host_ResetDevice+0x88>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    4a3c:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    4a40:	90 62       	ori	r25, 0x20	; 32
    4a42:	90 93 a0 00 	sts	0x00A0, r25	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
	  USB_INT_Enable(USB_INT_HSOFI);

	if (BusSuspended)
    4a46:	81 11       	cpse	r24, r1
    4a48:	05 c0       	rjmp	.+10     	; 0x4a54 <USB_Host_ResetDevice+0x96>
			 *        some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    4a4a:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    4a4e:	8e 7f       	andi	r24, 0xFE	; 254
    4a50:	80 93 9e 00 	sts	0x009E, r24	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    4a54:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    4a58:	82 60       	ori	r24, 0x02	; 2
    4a5a:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    4a5e:	08 95       	ret

00004a60 <USB_Host_WaitMS>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    4a60:	20 91 9e 00 	lds	r18, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    4a64:	21 70       	andi	r18, 0x01	; 1
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    4a66:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    4a6a:	90 72       	andi	r25, 0x20	; 32
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    4a6c:	30 91 a0 00 	lds	r19, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    4a70:	3f 7d       	andi	r19, 0xDF	; 223
    4a72:	30 93 a0 00 	sts	0x00A0, r19	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4a76:	30 91 9f 00 	lds	r19, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4a7a:	3f 7d       	andi	r19, 0xDF	; 223
    4a7c:	30 93 9f 00 	sts	0x009F, r19	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4a80:	30 91 9e 00 	lds	r19, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    4a84:	31 60       	ori	r19, 0x01	; 1
    4a86:	30 93 9e 00 	sts	0x009E, r19	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	USB_Host_ResumeBus();

	while (MS)
    4a8a:	88 23       	and	r24, r24
    4a8c:	59 f1       	breq	.+86     	; 0x4ae4 <USB_Host_WaitMS+0x84>
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    4a8e:	30 91 9f 00 	lds	r19, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
	{
		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    4a92:	35 ff       	sbrs	r19, 5
    4a94:	06 c0       	rjmp	.+12     	; 0x4aa2 <USB_Host_WaitMS+0x42>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4a96:	30 91 9f 00 	lds	r19, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4a9a:	3f 7d       	andi	r19, 0xDF	; 223
    4a9c:	30 93 9f 00 	sts	0x009F, r19	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
		{
			USB_INT_Clear(USB_INT_HSOFI);
			MS--;
    4aa0:	81 50       	subi	r24, 0x01	; 1
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
    4aa2:	30 91 97 0d 	lds	r19, 0x0D97	; 0x800d97 <USB_HostState>
    4aa6:	31 30       	cpi	r19, 0x01	; 1
    4aa8:	e1 f0       	breq	.+56     	; 0x4ae2 <USB_Host_WaitMS+0x82>
    4aaa:	30 91 ba 03 	lds	r19, 0x03BA	; 0x8003ba <USB_CurrentMode>
    4aae:	32 30       	cpi	r19, 0x02	; 2
    4ab0:	c1 f4       	brne	.+48     	; 0x4ae2 <USB_Host_WaitMS+0x82>
			 *  \return Boolean \c true if an error has occurred on the selected pipe, \c false otherwise.
			 */
			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsError(void)
			{
				return ((UPINTX & (1 << PERRI)) ? true : false);
    4ab2:	30 91 a6 00 	lds	r19, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;

			break;
		}

		if (Pipe_IsError() == true)
    4ab6:	34 ff       	sbrs	r19, 4
    4ab8:	09 c0       	rjmp	.+18     	; 0x4acc <USB_Host_WaitMS+0x6c>

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    4aba:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
				UPINTX &= ~(1 << PERRI);
    4abe:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    4ac2:	8f 7e       	andi	r24, 0xEF	; 239
    4ac4:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
		{
			Pipe_ClearError();
			ErrorCode = HOST_WAITERROR_PipeError;
    4ac8:	82 e0       	ldi	r24, 0x02	; 2

			break;
    4aca:	0c c0       	rjmp	.+24     	; 0x4ae4 <USB_Host_WaitMS+0x84>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    4acc:	30 91 a6 00 	lds	r19, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
		}

		if (Pipe_IsStalled() == true)
    4ad0:	31 ff       	sbrs	r19, 1
    4ad2:	db cf       	rjmp	.-74     	; 0x4a8a <USB_Host_WaitMS+0x2a>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearStall(void)
			{
				UPINTX &= ~(1 << RXSTALLI);
    4ad4:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    4ad8:	8d 7f       	andi	r24, 0xFD	; 253
    4ada:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
		{
			Pipe_ClearStall();
			ErrorCode = HOST_WAITERROR_SetupStalled;
    4ade:	83 e0       	ldi	r24, 0x03	; 3

			break;
    4ae0:	01 c0       	rjmp	.+2      	; 0x4ae4 <USB_Host_WaitMS+0x84>
			MS--;
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
		{
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;
    4ae2:	81 e0       	ldi	r24, 0x01	; 1

			break;
		}
	}

	if (BusSuspended)
    4ae4:	21 11       	cpse	r18, r1
    4ae6:	05 c0       	rjmp	.+10     	; 0x4af2 <USB_Host_WaitMS+0x92>
			 *        some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    4ae8:	20 91 9e 00 	lds	r18, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    4aec:	2e 7f       	andi	r18, 0xFE	; 254
    4aee:	20 93 9e 00 	sts	0x009E, r18	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
	  USB_Host_SuspendBus();

	if (HSOFIEnabled)
    4af2:	99 23       	and	r25, r25
    4af4:	29 f0       	breq	.+10     	; 0x4b00 <USB_Host_WaitMS+0xa0>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    4af6:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    4afa:	90 62       	ori	r25, 0x20	; 32
    4afc:	90 93 a0 00 	sts	0x00A0, r25	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
	  USB_INT_Enable(USB_INT_HSOFI);

	return ErrorCode;
}
    4b00:	08 95       	ret

00004b02 <USB_Host_ProcessNextHostState>:

#define  __INCLUDE_FROM_HOST_C
#include "../Host.h"

void USB_Host_ProcessNextHostState(void)
{
    4b02:	ef 92       	push	r14
    4b04:	0f 93       	push	r16
    4b06:	1f 93       	push	r17
    4b08:	cf 93       	push	r28
    4b0a:	df 93       	push	r29
    4b0c:	cd b7       	in	r28, 0x3d	; 61
    4b0e:	de b7       	in	r29, 0x3e	; 62
    4b10:	28 97       	sbiw	r28, 0x08	; 8
    4b12:	0f b6       	in	r0, 0x3f	; 63
    4b14:	f8 94       	cli
    4b16:	de bf       	out	0x3e, r29	; 62
    4b18:	0f be       	out	0x3f, r0	; 63
    4b1a:	cd bf       	out	0x3d, r28	; 61
	uint8_t SubErrorCode = HOST_ENUMERROR_NoError;

	static uint16_t WaitMSRemaining;
	static uint8_t  PostWaitState;

	switch (USB_HostState)
    4b1c:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <USB_HostState>
    4b20:	8e 2f       	mov	r24, r30
    4b22:	90 e0       	ldi	r25, 0x00	; 0
    4b24:	8a 30       	cpi	r24, 0x0A	; 10
    4b26:	91 05       	cpc	r25, r1
    4b28:	08 f0       	brcs	.+2      	; 0x4b2c <USB_Host_ProcessNextHostState+0x2a>
    4b2a:	fb c0       	rjmp	.+502    	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
    4b2c:	fc 01       	movw	r30, r24
    4b2e:	ec 5a       	subi	r30, 0xAC	; 172
    4b30:	ff 4f       	sbci	r31, 0xFF	; 255
    4b32:	0c 94 da 39 	jmp	0x73b4	; 0x73b4 <__tablejump2__>
	{
		case HOST_STATE_WaitForDevice:
			if (WaitMSRemaining)
    4b36:	00 91 b8 03 	lds	r16, 0x03B8	; 0x8003b8 <WaitMSRemaining.3389>
    4b3a:	10 91 b9 03 	lds	r17, 0x03B9	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4b3e:	01 15       	cp	r16, r1
    4b40:	11 05       	cpc	r17, r1
    4b42:	09 f4       	brne	.+2      	; 0x4b46 <USB_Host_ProcessNextHostState+0x44>
    4b44:	ee c0       	rjmp	.+476    	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
			{
				if ((SubErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    4b46:	81 e0       	ldi	r24, 0x01	; 1
    4b48:	8b df       	rcall	.-234    	; 0x4a60 <USB_Host_WaitMS>
    4b4a:	88 23       	and	r24, r24
    4b4c:	31 f0       	breq	.+12     	; 0x4b5a <USB_Host_ProcessNextHostState+0x58>
				{
					USB_HostState = PostWaitState;
    4b4e:	90 91 b7 03 	lds	r25, 0x03B7	; 0x8003b7 <PostWaitState.3390>
    4b52:	90 93 97 0d 	sts	0x0D97, r25	; 0x800d97 <USB_HostState>
					ErrorCode     = HOST_ENUMERROR_WaitStage;
    4b56:	91 e0       	ldi	r25, 0x01	; 1
					break;
    4b58:	d4 c0       	rjmp	.+424    	; 0x4d02 <USB_Host_ProcessNextHostState+0x200>
				}

				if (!(--WaitMSRemaining))
    4b5a:	01 50       	subi	r16, 0x01	; 1
    4b5c:	11 09       	sbc	r17, r1
    4b5e:	10 93 b9 03 	sts	0x03B9, r17	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4b62:	00 93 b8 03 	sts	0x03B8, r16	; 0x8003b8 <WaitMSRemaining.3389>
    4b66:	01 2b       	or	r16, r17
    4b68:	09 f0       	breq	.+2      	; 0x4b6c <USB_Host_ProcessNextHostState+0x6a>
    4b6a:	db c0       	rjmp	.+438    	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
				  USB_HostState = PostWaitState;
    4b6c:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <PostWaitState.3390>
    4b70:	07 c0       	rjmp	.+14     	; 0x4b80 <USB_Host_ProcessNextHostState+0x7e>
			}

			break;
		case HOST_STATE_Powered:
			WaitMSRemaining = HOST_DEVICE_SETTLE_DELAY_MS;
    4b72:	88 ee       	ldi	r24, 0xE8	; 232
    4b74:	93 e0       	ldi	r25, 0x03	; 3
    4b76:	90 93 b9 03 	sts	0x03B9, r25	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4b7a:	80 93 b8 03 	sts	0x03B8, r24	; 0x8003b8 <WaitMSRemaining.3389>

			USB_HostState = HOST_STATE_Powered_WaitForDeviceSettle;
    4b7e:	83 e0       	ldi	r24, 0x03	; 3
    4b80:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <USB_HostState>
			break;
    4b84:	ce c0       	rjmp	.+412    	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
		case HOST_STATE_Powered_WaitForDeviceSettle:
			if (WaitMSRemaining--)
    4b86:	80 91 b8 03 	lds	r24, 0x03B8	; 0x8003b8 <WaitMSRemaining.3389>
    4b8a:	90 91 b9 03 	lds	r25, 0x03B9	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4b8e:	9c 01       	movw	r18, r24
    4b90:	21 50       	subi	r18, 0x01	; 1
    4b92:	31 09       	sbc	r19, r1
    4b94:	30 93 b9 03 	sts	0x03B9, r19	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4b98:	20 93 b8 03 	sts	0x03B8, r18	; 0x8003b8 <WaitMSRemaining.3389>
    4b9c:	89 2b       	or	r24, r25
    4b9e:	39 f0       	breq	.+14     	; 0x4bae <USB_Host_ProcessNextHostState+0xac>
    4ba0:	8f ec       	ldi	r24, 0xCF	; 207
    4ba2:	97 e0       	ldi	r25, 0x07	; 7
    4ba4:	01 97       	sbiw	r24, 0x01	; 1
    4ba6:	f1 f7       	brne	.-4      	; 0x4ba4 <USB_Host_ProcessNextHostState+0xa2>
    4ba8:	00 c0       	rjmp	.+0      	; 0x4baa <USB_Host_ProcessNextHostState+0xa8>
    4baa:	00 00       	nop
    4bac:	ba c0       	rjmp	.+372    	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
			}

			static inline void USB_Host_VBUS_Manual_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				PORTE  &= ~(1 << 7);
    4bae:	77 98       	cbi	0x0e, 7	; 14

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    4bb0:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    4bb4:	80 61       	ori	r24, 0x10	; 16
    4bb6:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
			}

			static inline void USB_Host_VBUS_Auto_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Enable(void)
			{
				OTGCON &= ~(1 << VBUSHWC);
    4bba:	80 91 dd 00 	lds	r24, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
    4bbe:	8b 7f       	andi	r24, 0xFB	; 251
    4bc0:	80 93 dd 00 	sts	0x00DD, r24	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
				UHWCON |=  (1 << UVCONE);
    4bc4:	80 91 d7 00 	lds	r24, 0x00D7	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
    4bc8:	80 61       	ori	r24, 0x10	; 16
    4bca:	80 93 d7 00 	sts	0x00D7, r24	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
			}

			static inline void USB_Host_VBUS_Auto_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_On(void)
			{
				OTGCON |=  (1 << VBUSREQ);
    4bce:	80 91 dd 00 	lds	r24, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
    4bd2:	82 60       	ori	r24, 0x02	; 2
    4bd4:	80 93 dd 00 	sts	0x00DD, r24	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>

				USB_OTGPAD_On();
				USB_Host_VBUS_Auto_Enable();
				USB_Host_VBUS_Auto_On();

				USB_HostState = HOST_STATE_Powered_WaitForConnect;
    4bd8:	84 e0       	ldi	r24, 0x04	; 4
    4bda:	d2 cf       	rjmp	.-92     	; 0x4b80 <USB_Host_ProcessNextHostState+0x7e>
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
    4bdc:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
			}

			break;
		case HOST_STATE_Powered_WaitForConnect:
			if (USB_INT_HasOccurred(USB_INT_DCONNI))
    4be0:	80 ff       	sbrs	r24, 0
    4be2:	9f c0       	rjmp	.+318    	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    4be4:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4be8:	8e 7f       	andi	r24, 0xFE	; 254
    4bea:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    4bee:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    4bf2:	8d 7f       	andi	r24, 0xFD	; 253
    4bf4:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    4bf8:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
    4bfc:	8d 7f       	andi	r24, 0xFD	; 253
    4bfe:	80 93 df 00 	sts	0x00DF, r24	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
    4c02:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    4c06:	82 60       	ori	r24, 0x02	; 2
    4c08:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4c0c:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    4c10:	81 60       	ori	r24, 0x01	; 1
    4c12:	80 93 9e 00 	sts	0x009E, r24	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>

				USB_INT_Clear(USB_INT_VBERRI);
				USB_INT_Enable(USB_INT_VBERRI);

				USB_Host_ResumeBus();
				Pipe_ClearPipes();
    4c16:	ed d0       	rcall	.+474    	; 0x4df2 <Pipe_ClearPipes>

				HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Powered_DoReset);
    4c18:	10 92 97 0d 	sts	0x0D97, r1	; 0x800d97 <USB_HostState>
    4c1c:	84 e6       	ldi	r24, 0x64	; 100
    4c1e:	90 e0       	ldi	r25, 0x00	; 0
    4c20:	90 93 b9 03 	sts	0x03B9, r25	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4c24:	80 93 b8 03 	sts	0x03B8, r24	; 0x8003b8 <WaitMSRemaining.3389>
    4c28:	85 e0       	ldi	r24, 0x05	; 5
			}

			break;
		case HOST_STATE_Powered_DoReset:
			USB_Host_ResetDevice();
    4c2a:	5e c0       	rjmp	.+188    	; 0x4ce8 <USB_Host_ProcessNextHostState+0x1e6>
    4c2c:	c8 de       	rcall	.-624    	; 0x49be <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Powered_ConfigPipe);
    4c2e:	10 92 97 0d 	sts	0x0D97, r1	; 0x800d97 <USB_HostState>
    4c32:	88 ec       	ldi	r24, 0xC8	; 200
    4c34:	90 e0       	ldi	r25, 0x00	; 0
    4c36:	90 93 b9 03 	sts	0x03B9, r25	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4c3a:	80 93 b8 03 	sts	0x03B8, r24	; 0x8003b8 <WaitMSRemaining.3389>
    4c3e:	86 e0       	ldi	r24, 0x06	; 6
    4c40:	53 c0       	rjmp	.+166    	; 0x4ce8 <USB_Host_ProcessNextHostState+0x1e6>
			break;
		case HOST_STATE_Powered_ConfigPipe:
			Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL,
    4c42:	e1 2c       	mov	r14, r1
    4c44:	00 e4       	ldi	r16, 0x40	; 64
    4c46:	10 e0       	ldi	r17, 0x00	; 0
    4c48:	20 e0       	ldi	r18, 0x00	; 0
    4c4a:	40 e0       	ldi	r20, 0x00	; 0
    4c4c:	60 e0       	ldi	r22, 0x00	; 0
    4c4e:	80 e0       	ldi	r24, 0x00	; 0
    4c50:	74 d0       	rcall	.+232    	; 0x4d3a <Pipe_ConfigurePipe>
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    4c52:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7e00ac>
							   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
							   PIPE_CONTROLPIPE_DEFAULT_SIZE, PIPE_BANK_SINGLE);

			if (!(Pipe_IsConfigured()))
    4c56:	87 fd       	sbrc	r24, 7
    4c58:	03 c0       	rjmp	.+6      	; 0x4c60 <USB_Host_ProcessNextHostState+0x15e>
			{
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
    4c5a:	80 e0       	ldi	r24, 0x00	; 0
							   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
							   PIPE_CONTROLPIPE_DEFAULT_SIZE, PIPE_BANK_SINGLE);

			if (!(Pipe_IsConfigured()))
			{
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
    4c5c:	94 e0       	ldi	r25, 0x04	; 4
    4c5e:	51 c0       	rjmp	.+162    	; 0x4d02 <USB_Host_ProcessNextHostState+0x200>
				SubErrorCode = 0;
				break;
			}

			USB_HostState = HOST_STATE_Default;
    4c60:	87 e0       	ldi	r24, 0x07	; 7
    4c62:	8e cf       	rjmp	.-228    	; 0x4b80 <USB_Host_ProcessNextHostState+0x7e>
			break;
		case HOST_STATE_Default:
			USB_ControlRequest = (USB_Request_Header_t)
    4c64:	88 e0       	ldi	r24, 0x08	; 8
    4c66:	ec e5       	ldi	r30, 0x5C	; 92
    4c68:	f2 e0       	ldi	r31, 0x02	; 2
    4c6a:	af e8       	ldi	r26, 0x8F	; 143
    4c6c:	bd e0       	ldi	r27, 0x0D	; 13
    4c6e:	01 90       	ld	r0, Z+
    4c70:	0d 92       	st	X+, r0
    4c72:	8a 95       	dec	r24
    4c74:	e1 f7       	brne	.-8      	; 0x4c6e <USB_Host_ProcessNextHostState+0x16c>
					.wLength       = 8,
				};

			uint8_t DataBuffer[8];

			if ((SubErrorCode = USB_Host_SendControlRequest(DataBuffer)) != HOST_SENDCONTROL_Successful)
    4c76:	ce 01       	movw	r24, r28
    4c78:	01 96       	adiw	r24, 0x01	; 1
    4c7a:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <USB_Host_SendControlRequest>
    4c7e:	81 11       	cpse	r24, r1
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			USB_Host_ControlPipeSize = DataBuffer[offsetof(USB_Descriptor_Device_t, Endpoint0Size)];
    4c80:	3f c0       	rjmp	.+126    	; 0x4d00 <USB_Host_ProcessNextHostState+0x1fe>
    4c82:	88 85       	ldd	r24, Y+8	; 0x08
    4c84:	80 93 fe 01 	sts	0x01FE, r24	; 0x8001fe <USB_Host_ControlPipeSize>

			USB_Host_ResetDevice();
    4c88:	9a de       	rcall	.-716    	; 0x49be <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
    4c8a:	10 92 97 0d 	sts	0x0D97, r1	; 0x800d97 <USB_HostState>
    4c8e:	88 ec       	ldi	r24, 0xC8	; 200
    4c90:	90 e0       	ldi	r25, 0x00	; 0
    4c92:	90 93 b9 03 	sts	0x03B9, r25	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4c96:	80 93 b8 03 	sts	0x03B8, r24	; 0x8003b8 <WaitMSRemaining.3389>
    4c9a:	88 e0       	ldi	r24, 0x08	; 8
    4c9c:	25 c0       	rjmp	.+74     	; 0x4ce8 <USB_Host_ProcessNextHostState+0x1e6>
			break;
		case HOST_STATE_Default_PostReset:
			Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL,
    4c9e:	00 91 fe 01 	lds	r16, 0x01FE	; 0x8001fe <USB_Host_ControlPipeSize>
    4ca2:	10 e0       	ldi	r17, 0x00	; 0
    4ca4:	e1 2c       	mov	r14, r1
    4ca6:	20 e0       	ldi	r18, 0x00	; 0
    4ca8:	40 e0       	ldi	r20, 0x00	; 0
    4caa:	60 e0       	ldi	r22, 0x00	; 0
    4cac:	80 e0       	ldi	r24, 0x00	; 0
    4cae:	45 d0       	rcall	.+138    	; 0x4d3a <Pipe_ConfigurePipe>
    4cb0:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7e00ac>
			                   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
			                   USB_Host_ControlPipeSize, PIPE_BANK_SINGLE);

			if (!(Pipe_IsConfigured()))
    4cb4:	87 ff       	sbrs	r24, 7
    4cb6:	d1 cf       	rjmp	.-94     	; 0x4c5a <USB_Host_ProcessNextHostState+0x158>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_ControlRequest = (USB_Request_Header_t)
    4cb8:	88 e0       	ldi	r24, 0x08	; 8
    4cba:	e4 e6       	ldi	r30, 0x64	; 100
    4cbc:	f2 e0       	ldi	r31, 0x02	; 2
    4cbe:	af e8       	ldi	r26, 0x8F	; 143
    4cc0:	bd e0       	ldi	r27, 0x0D	; 13
    4cc2:	01 90       	ld	r0, Z+
    4cc4:	0d 92       	st	X+, r0
    4cc6:	8a 95       	dec	r24
    4cc8:	e1 f7       	brne	.-8      	; 0x4cc2 <USB_Host_ProcessNextHostState+0x1c0>
					.wValue        = USB_HOST_DEVICEADDRESS,
					.wIndex        = 0,
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
    4cca:	80 e0       	ldi	r24, 0x00	; 0
    4ccc:	90 e0       	ldi	r25, 0x00	; 0
    4cce:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <USB_Host_SendControlRequest>
    4cd2:	81 11       	cpse	r24, r1
    4cd4:	15 c0       	rjmp	.+42     	; 0x4d00 <USB_Host_ProcessNextHostState+0x1fe>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Default_PostAddressSet);
    4cd6:	10 92 97 0d 	sts	0x0D97, r1	; 0x800d97 <USB_HostState>
    4cda:	84 e6       	ldi	r24, 0x64	; 100
    4cdc:	90 e0       	ldi	r25, 0x00	; 0
    4cde:	90 93 b9 03 	sts	0x03B9, r25	; 0x8003b9 <WaitMSRemaining.3389+0x1>
    4ce2:	80 93 b8 03 	sts	0x03B8, r24	; 0x8003b8 <WaitMSRemaining.3389>
    4ce6:	89 e0       	ldi	r24, 0x09	; 9
    4ce8:	80 93 b7 03 	sts	0x03B7, r24	; 0x8003b7 <PostWaitState.3390>
			break;
    4cec:	1a c0       	rjmp	.+52     	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
			}

			static inline void USB_Host_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SetDeviceAddress(const uint8_t Address)
			{
				UHADDR  =  (Address & 0x7F);
    4cee:	81 e0       	ldi	r24, 0x01	; 1
    4cf0:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7e00a1>
		case HOST_STATE_Default_PostAddressSet:
			USB_Host_SetDeviceAddress(USB_HOST_DEVICEADDRESS);

			USB_HostState = HOST_STATE_Addressed;
    4cf4:	8a e0       	ldi	r24, 0x0A	; 10
    4cf6:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <USB_HostState>

			EVENT_USB_Host_DeviceEnumerationComplete();
    4cfa:	0e 94 06 03 	call	0x60c	; 0x60c <EVENT_USB_Host_DeviceEnumerationComplete>
			break;
    4cfe:	11 c0       	rjmp	.+34     	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
    4d00:	93 e0       	ldi	r25, 0x03	; 3

			EVENT_USB_Host_DeviceEnumerationComplete();
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
    4d02:	20 91 97 0d 	lds	r18, 0x0D97	; 0x800d97 <USB_HostState>
    4d06:	21 30       	cpi	r18, 0x01	; 1
    4d08:	61 f0       	breq	.+24     	; 0x4d22 <USB_Host_ProcessNextHostState+0x220>
	{
		EVENT_USB_Host_DeviceEnumerationFailed(ErrorCode, SubErrorCode);
    4d0a:	68 2f       	mov	r22, r24
    4d0c:	89 2f       	mov	r24, r25
    4d0e:	0e 94 81 03 	call	0x702	; 0x702 <EVENT_USB_Host_DeviceEnumerationFailed>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    4d12:	80 91 dd 00 	lds	r24, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
    4d16:	81 60       	ori	r24, 0x01	; 1
    4d18:	80 93 dd 00 	sts	0x00DD, r24	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>

		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_DeviceUnattached();
    4d1c:	0e 94 04 03 	call	0x608	; 0x608 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    4d20:	e6 d0       	rcall	.+460    	; 0x4eee <USB_ResetInterface>
	}
}
    4d22:	28 96       	adiw	r28, 0x08	; 8
    4d24:	0f b6       	in	r0, 0x3f	; 63
    4d26:	f8 94       	cli
    4d28:	de bf       	out	0x3e, r29	; 62
    4d2a:	0f be       	out	0x3f, r0	; 63
    4d2c:	cd bf       	out	0x3d, r28	; 61
    4d2e:	df 91       	pop	r29
    4d30:	cf 91       	pop	r28
    4d32:	1f 91       	pop	r17
    4d34:	0f 91       	pop	r16
    4d36:	ef 90       	pop	r14
    4d38:	08 95       	ret

00004d3a <Pipe_ConfigurePipe>:
                        const uint8_t Type,
                        const uint8_t Token,
                        const uint8_t EndpointNumber,
                        const uint16_t Size,
                        const uint8_t Banks)
{
    4d3a:	ef 92       	push	r14
    4d3c:	0f 93       	push	r16
    4d3e:	1f 93       	push	r17

		Pipe_SelectPipe(PNum);
		
		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
    4d40:	2f 70       	andi	r18, 0x0F	; 15
    4d42:	42 2b       	or	r20, r18
    4d44:	90 e4       	ldi	r25, 0x40	; 64
    4d46:	69 9f       	mul	r22, r25
    4d48:	b0 01       	movw	r22, r0
    4d4a:	11 24       	eor	r1, r1
    4d4c:	64 2b       	or	r22, r20

	Pipe_SetInfiniteINRequests();

	return Pipe_IsConfigured();
#else	
	for (uint8_t PNum = Number; PNum < PIPE_TOTAL_PIPES; PNum++)
    4d4e:	38 2f       	mov	r19, r24
		Pipe_SelectPipe(PNum);
		
		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    4d50:	2e 2d       	mov	r18, r14
    4d52:	22 60       	ori	r18, 0x02	; 2

	Pipe_SetInfiniteINRequests();

	return Pipe_IsConfigured();
#else	
	for (uint8_t PNum = Number; PNum < PIPE_TOTAL_PIPES; PNum++)
    4d54:	37 30       	cpi	r19, 0x07	; 7
    4d56:	08 f0       	brcs	.+2      	; 0x4d5a <Pipe_ConfigurePipe+0x20>
    4d58:	45 c0       	rjmp	.+138    	; 0x4de4 <Pipe_ConfigurePipe+0xaa>
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    4d5a:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
		uint8_t UPCFG2XTemp;
		uint8_t UPIENXTemp;

		Pipe_SelectPipe(PNum);
		
		if (PNum == Number)
    4d5e:	38 13       	cpse	r19, r24
    4d60:	13 c0       	rjmp	.+38     	; 0x4d88 <Pipe_ConfigurePipe+0x4e>
    4d62:	48 e0       	ldi	r20, 0x08	; 8
    4d64:	50 e0       	ldi	r21, 0x00	; 0
    4d66:	90 e0       	ldi	r25, 0x00	; 0
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
    4d68:	40 17       	cp	r20, r16
    4d6a:	51 07       	cpc	r21, r17
    4d6c:	38 f0       	brcs	.+14     	; 0x4d7c <Pipe_ConfigurePipe+0x42>
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    4d6e:	92 95       	swap	r25
    4d70:	90 7f       	andi	r25, 0xF0	; 240
    4d72:	92 2b       	or	r25, r18

		Pipe_SelectPipe(PNum);
		
		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
    4d74:	e6 2f       	mov	r30, r22
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
			UPCFG2XTemp = 0;
			UPIENXTemp  = 0;
    4d76:	50 e0       	ldi	r21, 0x00	; 0
		
		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
			UPCFG2XTemp = 0;
    4d78:	70 e0       	ldi	r23, 0x00	; 0
    4d7a:	0e c0       	rjmp	.+28     	; 0x4d98 <Pipe_ConfigurePipe+0x5e>
    4d7c:	95 30       	cpi	r25, 0x05	; 5
    4d7e:	b9 f3       	breq	.-18     	; 0x4d6e <Pipe_ConfigurePipe+0x34>
				{
					MaskVal++;
    4d80:	9f 5f       	subi	r25, 0xFF	; 255
					CheckBytes <<= 1;
    4d82:	44 0f       	add	r20, r20
    4d84:	55 1f       	adc	r21, r21
    4d86:	f0 cf       	rjmp	.-32     	; 0x4d68 <Pipe_ConfigurePipe+0x2e>
			UPIENXTemp  = 0;
		}
		else
		{
			UPCFG0XTemp = UPCFG0X;
    4d88:	e0 91 aa 00 	lds	r30, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
			UPCFG1XTemp = UPCFG1X;
    4d8c:	90 91 ab 00 	lds	r25, 0x00AB	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7e00ab>
			UPCFG2XTemp = UPCFG2X;
    4d90:	70 91 ad 00 	lds	r23, 0x00AD	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7e00ad>
			UPIENXTemp  = UPIENX;
    4d94:	50 91 ae 00 	lds	r21, 0x00AE	; 0x8000ae <__TEXT_REGION_LENGTH__+0x7e00ae>
		}

		if (!(UPCFG1XTemp & (1 << ALLOC)))
    4d98:	91 fd       	sbrc	r25, 1
    4d9a:	02 c0       	rjmp	.+4      	; 0x4da0 <Pipe_ConfigurePipe+0x66>

	Pipe_SetInfiniteINRequests();

	return Pipe_IsConfigured();
#else	
	for (uint8_t PNum = Number; PNum < PIPE_TOTAL_PIPES; PNum++)
    4d9c:	3f 5f       	subi	r19, 0xFF	; 255
    4d9e:	da cf       	rjmp	.-76     	; 0x4d54 <Pipe_ConfigurePipe+0x1a>
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    4da0:	40 91 a9 00 	lds	r20, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    4da4:	4e 7f       	andi	r20, 0xFE	; 254
    4da6:	40 93 a9 00 	sts	0x00A9, r20	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>

		if (!(UPCFG1XTemp & (1 << ALLOC)))
		  continue;
		  
		Pipe_DisablePipe();
		UPCFG1X &= ~(1 << ALLOC);
    4daa:	40 91 ab 00 	lds	r20, 0x00AB	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7e00ab>
    4dae:	4d 7f       	andi	r20, 0xFD	; 253
    4db0:	40 93 ab 00 	sts	0x00AB, r20	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7e00ab>
			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePipe().
			 */
			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_EnablePipe(void)
			{
				UPCONX |= (1 << PEN);
    4db4:	40 91 a9 00 	lds	r20, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    4db8:	41 60       	ori	r20, 0x01	; 1
    4dba:	40 93 a9 00 	sts	0x00A9, r20	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>

		Pipe_EnablePipe();
		UPCFG0X = UPCFG0XTemp;
    4dbe:	e0 93 aa 00 	sts	0x00AA, r30	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
		UPCFG1X = UPCFG1XTemp;
    4dc2:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7e00ab>
		UPCFG2X = UPCFG2XTemp;
    4dc6:	70 93 ad 00 	sts	0x00AD, r23	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7e00ad>
		UPIENX  = UPIENXTemp;
    4dca:	50 93 ae 00 	sts	0x00AE, r21	; 0x8000ae <__TEXT_REGION_LENGTH__+0x7e00ae>

			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetInfiniteINRequests(void)
			{
				UPCONX |= (1 << INMODE);
    4dce:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    4dd2:	90 62       	ori	r25, 0x20	; 32
    4dd4:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    4dd8:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7e00ac>

		Pipe_SetInfiniteINRequests();
	
		if (!(Pipe_IsConfigured()))
    4ddc:	97 fd       	sbrc	r25, 7
    4dde:	de cf       	rjmp	.-68     	; 0x4d9c <Pipe_ConfigurePipe+0x62>
		  return false;		
    4de0:	80 e0       	ldi	r24, 0x00	; 0
    4de2:	03 c0       	rjmp	.+6      	; 0x4dea <Pipe_ConfigurePipe+0xb0>
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    4de4:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
	}
		
	Pipe_SelectPipe(Number);	
	return true;
    4de8:	81 e0       	ldi	r24, 0x01	; 1
#endif
}
    4dea:	1f 91       	pop	r17
    4dec:	0f 91       	pop	r16
    4dee:	ef 90       	pop	r14
    4df0:	08 95       	ret

00004df2 <Pipe_ClearPipes>:

void Pipe_ClearPipes(void)
{
	UPINT = 0;
    4df2:	10 92 f8 00 	sts	0x00F8, r1	; 0x8000f8 <__TEXT_REGION_LENGTH__+0x7e00f8>

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    4df6:	80 e0       	ldi	r24, 0x00	; 0
    4df8:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
	{
		Pipe_SelectPipe(PNum);
		UPIENX  = 0;
    4dfc:	10 92 ae 00 	sts	0x00AE, r1	; 0x8000ae <__TEXT_REGION_LENGTH__+0x7e00ae>
		UPINTX  = 0;
    4e00:	10 92 a6 00 	sts	0x00A6, r1	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
		UPCFG1X = 0;
    4e04:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7e00ab>
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    4e08:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    4e0c:	9e 7f       	andi	r25, 0xFE	; 254
    4e0e:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    4e12:	8f 5f       	subi	r24, 0xFF	; 255
    4e14:	87 30       	cpi	r24, 0x07	; 7
    4e16:	81 f7       	brne	.-32     	; 0x4df8 <Pipe_ClearPipes+0x6>
		UPIENX  = 0;
		UPINTX  = 0;
		UPCFG1X = 0;
		Pipe_DisablePipe();
	}
}
    4e18:	08 95       	ret

00004e1a <Pipe_IsEndpointBound>:
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return (UPNUM & PIPE_PIPENUM_MASK);
    4e1a:	30 91 a7 00 	lds	r19, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
    4e1e:	37 70       	andi	r19, 0x07	; 7

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    4e20:	90 e0       	ldi	r25, 0x00	; 0
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    4e22:	90 93 a7 00 	sts	0x00A7, r25	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    4e26:	20 91 ac 00 	lds	r18, 0x00AC	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7e00ac>
	{
		Pipe_SelectPipe(PNum);

		if (!(Pipe_IsConfigured()))
    4e2a:	27 ff       	sbrs	r18, 7
    4e2c:	0f c0       	rjmp	.+30     	; 0x4e4c <Pipe_IsEndpointBound+0x32>
			 *  \return Endpoint address the currently selected pipe is bound to.
			 */
			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
			{
				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
    4e2e:	20 91 aa 00 	lds	r18, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    4e32:	42 2f       	mov	r20, r18
    4e34:	4f 70       	andi	r20, 0x0F	; 15
			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    4e36:	20 91 aa 00 	lds	r18, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
			 *  \return Endpoint address the currently selected pipe is bound to.
			 */
			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
			{
				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
    4e3a:	20 73       	andi	r18, 0x30	; 48
    4e3c:	20 31       	cpi	r18, 0x10	; 16
    4e3e:	11 f0       	breq	.+4      	; 0x4e44 <Pipe_IsEndpointBound+0x2a>
    4e40:	20 e0       	ldi	r18, 0x00	; 0
    4e42:	01 c0       	rjmp	.+2      	; 0x4e46 <Pipe_IsEndpointBound+0x2c>
    4e44:	20 e8       	ldi	r18, 0x80	; 128
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
    4e46:	24 2b       	or	r18, r20
    4e48:	82 17       	cp	r24, r18
    4e4a:	39 f0       	breq	.+14     	; 0x4e5a <Pipe_IsEndpointBound+0x40>

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    4e4c:	9f 5f       	subi	r25, 0xFF	; 255
    4e4e:	97 30       	cpi	r25, 0x07	; 7
    4e50:	41 f7       	brne	.-48     	; 0x4e22 <Pipe_IsEndpointBound+0x8>
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    4e52:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
		  return true;
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
    4e56:	80 e0       	ldi	r24, 0x00	; 0
    4e58:	08 95       	ret

		if (!(Pipe_IsConfigured()))
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
		  return true;
    4e5a:	81 e0       	ldi	r24, 0x01	; 1
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
}
    4e5c:	08 95       	ret

00004e5e <Pipe_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Host_GetFrameNumber(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t USB_Host_GetFrameNumber(void)
			{
				return UHFNUM;
    4e5e:	40 91 a2 00 	lds	r20, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7e00a2>
    4e62:	50 91 a3 00 	lds	r21, 0x00A3	; 0x8000a3 <__TEXT_REGION_LENGTH__+0x7e00a3>
    4e66:	85 e6       	ldi	r24, 0x65	; 101
			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    4e68:	90 91 aa 00 	lds	r25, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>

	uint16_t PreviousFrameNumber = USB_Host_GetFrameNumber();

	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    4e6c:	90 73       	andi	r25, 0x30	; 48
    4e6e:	90 31       	cpi	r25, 0x10	; 16
    4e70:	29 f4       	brne	.+10     	; 0x4e7c <Pipe_WaitUntilReady+0x1e>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    4e72:	90 91 a6 00 	lds	r25, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
		{
			if (Pipe_IsINReceived())
    4e76:	90 ff       	sbrs	r25, 0
    4e78:	05 c0       	rjmp	.+10     	; 0x4e84 <Pipe_WaitUntilReady+0x26>
    4e7a:	19 c0       	rjmp	.+50     	; 0x4eae <Pipe_WaitUntilReady+0x50>
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    4e7c:	90 91 a6 00 	lds	r25, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
    4e80:	92 fd       	sbrc	r25, 2
    4e82:	15 c0       	rjmp	.+42     	; 0x4eae <Pipe_WaitUntilReady+0x50>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    4e84:	90 91 a6 00 	lds	r25, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
			  return PIPE_READYWAIT_NoError;
		}

		if (Pipe_IsStalled())
    4e88:	91 fd       	sbrc	r25, 1
    4e8a:	13 c0       	rjmp	.+38     	; 0x4eb2 <Pipe_WaitUntilReady+0x54>
		  return PIPE_READYWAIT_PipeStalled;
		else if (USB_HostState == HOST_STATE_Unattached)
    4e8c:	90 91 97 0d 	lds	r25, 0x0D97	; 0x800d97 <USB_HostState>
    4e90:	91 30       	cpi	r25, 0x01	; 1
    4e92:	89 f0       	breq	.+34     	; 0x4eb6 <Pipe_WaitUntilReady+0x58>
    4e94:	20 91 a2 00 	lds	r18, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7e00a2>
    4e98:	30 91 a3 00 	lds	r19, 0x00A3	; 0x8000a3 <__TEXT_REGION_LENGTH__+0x7e00a3>
		  return PIPE_READYWAIT_DeviceDisconnected;

		uint16_t CurrentFrameNumber = USB_Host_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    4e9c:	42 17       	cp	r20, r18
    4e9e:	53 07       	cpc	r21, r19
    4ea0:	19 f3       	breq	.-58     	; 0x4e68 <Pipe_WaitUntilReady+0xa>
    4ea2:	81 50       	subi	r24, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    4ea4:	11 f0       	breq	.+4      	; 0x4eaa <Pipe_WaitUntilReady+0x4c>
    4ea6:	a9 01       	movw	r20, r18
    4ea8:	df cf       	rjmp	.-66     	; 0x4e68 <Pipe_WaitUntilReady+0xa>
			  return PIPE_READYWAIT_Timeout;
    4eaa:	83 e0       	ldi	r24, 0x03	; 3
    4eac:	08 95       	ret
	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
		{
			if (Pipe_IsINReceived())
			  return PIPE_READYWAIT_NoError;
    4eae:	80 e0       	ldi	r24, 0x00	; 0
    4eb0:	08 95       	ret
			if (Pipe_IsOUTReady())
			  return PIPE_READYWAIT_NoError;
		}

		if (Pipe_IsStalled())
		  return PIPE_READYWAIT_PipeStalled;
    4eb2:	81 e0       	ldi	r24, 0x01	; 1
    4eb4:	08 95       	ret
		else if (USB_HostState == HOST_STATE_Unattached)
		  return PIPE_READYWAIT_DeviceDisconnected;
    4eb6:	82 e0       	ldi	r24, 0x02	; 2

			if (!(TimeoutMSRem--))
			  return PIPE_READYWAIT_Timeout;
		}
	}
}
    4eb8:	08 95       	ret

00004eba <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    4eba:	cb d0       	rcall	.+406    	; 0x5052 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    4ebc:	d6 d0       	rcall	.+428    	; 0x506a <USB_INT_ClearAllInterrupts>
    4ebe:	e0 ee       	ldi	r30, 0xE0	; 224
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    4ec0:	f0 e0       	ldi	r31, 0x00	; 0
    4ec2:	80 81       	ld	r24, Z
    4ec4:	81 60       	ori	r24, 0x01	; 1
    4ec6:	80 83       	st	Z, r24
    4ec8:	e8 ed       	ldi	r30, 0xD8	; 216
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON  &= ~(1 << USBE);
    4eca:	f0 e0       	ldi	r31, 0x00	; 0
    4ecc:	80 81       	ld	r24, Z
    4ece:	8f 77       	andi	r24, 0x7F	; 127
    4ed0:	80 83       	st	Z, r24
    4ed2:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    4ed4:	a7 ed       	ldi	r26, 0xD7	; 215

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  &= ~(1 << UVREGE);
    4ed6:	b0 e0       	ldi	r27, 0x00	; 0
    4ed8:	8c 91       	ld	r24, X
    4eda:	8e 7f       	andi	r24, 0xFE	; 254
    4edc:	8c 93       	st	X, r24
    4ede:	80 81       	ld	r24, Z
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON  &= ~(1 << OTGPADE);
    4ee0:	8f 7e       	andi	r24, 0xEF	; 239
    4ee2:	80 83       	st	Z, r24
    4ee4:	10 92 ba 03 	sts	0x03BA, r1	; 0x8003ba <USB_CurrentMode>
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_Off();
	#endif

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
    4ee8:	10 92 8e 0d 	sts	0x0D8E, r1	; 0x800d8e <USB_IsInitialized>
	#endif

	USB_IsInitialized = false;
    4eec:	08 95       	ret

00004eee <USB_ResetInterface>:
    4eee:	cf 93       	push	r28
}

void USB_ResetInterface(void)
{
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
    4ef0:	c0 91 d7 00 	lds	r28, 0x00D7	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
	#endif

	USB_INT_DisableAllInterrupts();
    4ef4:	ae d0       	rcall	.+348    	; 0x5052 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    4ef6:	b9 d0       	rcall	.+370    	; 0x506a <USB_INT_ClearAllInterrupts>
    4ef8:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    4efc:	8f 77       	andi	r24, 0x7F	; 127
    4efe:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    4f02:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
				USBCON |=  (1 << USBE);
    4f06:	80 68       	ori	r24, 0x80	; 128
    4f08:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    4f0c:	c6 ff       	sbrs	r28, 6

	USB_Controller_Reset();

	#if defined(USB_CAN_BE_BOTH)
	if (UIDModeSelectEnabled)
    4f0e:	05 c0       	rjmp	.+10     	; 0x4f1a <USB_ResetInterface+0x2c>
    4f10:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    4f14:	82 60       	ori	r24, 0x02	; 2
    4f16:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    4f1a:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    4f1e:	8f 7d       	andi	r24, 0xDF	; 223
    4f20:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    4f24:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
	  USB_INT_Enable(USB_INT_IDTI);
	#endif

	USB_CLK_Unfreeze();

	if (USB_CurrentMode == USB_MODE_Device)
    4f28:	81 30       	cpi	r24, 0x01	; 1
    4f2a:	59 f5       	brne	.+86     	; 0x4f82 <USB_ResetInterface+0x94>
    4f2c:	80 91 d7 00 	lds	r24, 0x00D7	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    4f30:	80 68       	ori	r24, 0x80	; 128
    4f32:	80 93 d7 00 	sts	0x00D7, r24	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
    4f36:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    4f38:	1e ba       	out	0x1e, r1	; 30
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    4f3a:	10 92 8a 0d 	sts	0x0D8A, r1	; 0x800d8a <USB_Device_ConfigurationNumber>
	USB_Device_ConfigurationNumber  = 0;
    4f3e:	10 92 8c 0d 	sts	0x0D8C, r1	; 0x800d8c <USB_Device_RemoteWakeupEnabled>

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    4f42:	10 92 8b 0d 	sts	0x0D8B, r1	; 0x800d8b <USB_Device_CurrentlySelfPowered>
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    4f46:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    4f4a:	8b 7f       	andi	r24, 0xFB	; 251
    4f4c:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>
    4f50:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    4f54:	81 60       	ori	r24, 0x01	; 1
    4f56:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    4f5a:	42 e0       	ldi	r20, 0x02	; 2
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    4f5c:	60 e0       	ldi	r22, 0x00	; 0
    4f5e:	80 e0       	ldi	r24, 0x00	; 0
    4f60:	ab dc       	rcall	.-1706   	; 0x48b8 <Endpoint_ConfigureEndpoint_Prv>
    4f62:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    4f66:	8e 7f       	andi	r24, 0xFE	; 254
    4f68:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    4f6c:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    4f70:	81 60       	ori	r24, 0x01	; 1
    4f72:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    4f76:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    4f7a:	88 60       	ori	r24, 0x08	; 8
    4f7c:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    4f80:	38 c0       	rjmp	.+112    	; 0x4ff2 <USB_ResetInterface+0x104>
    4f82:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
		}

		USB_Init_Device();
		#endif
	}
	else if (USB_CurrentMode == USB_MODE_Host)
    4f86:	82 30       	cpi	r24, 0x02	; 2
    4f88:	c9 f5       	brne	.+114    	; 0x4ffc <USB_ResetInterface+0x10e>
    4f8a:	80 91 d7 00 	lds	r24, 0x00D7	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
	{
		#if defined(USB_CAN_BE_HOST)
		UHWCON &= ~(1 << UIMOD);
    4f8e:	8f 77       	andi	r24, 0x7F	; 127
    4f90:	80 93 d7 00 	sts	0x00D7, r24	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
    4f94:	8c e0       	ldi	r24, 0x0C	; 12

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    4f96:	89 bd       	out	0x29, r24	; 41
    4f98:	8e e0       	ldi	r24, 0x0E	; 14
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    4f9a:	89 bd       	out	0x29, r24	; 41
    4f9c:	09 b4       	in	r0, 0x29	; 41

		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			#if defined(USB_CAN_BE_HOST)
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));		
    4f9e:	00 fe       	sbrs	r0, 0
    4fa0:	fd cf       	rjmp	.-6      	; 0x4f9c <USB_ResetInterface+0xae>
    4fa2:	81 e0       	ldi	r24, 0x01	; 1
#endif

#if defined(USB_CAN_BE_HOST)
static void USB_Init_Host(void)
{
	USB_HostState                = HOST_STATE_Unattached;
    4fa4:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <USB_HostState>
    4fa8:	10 92 8d 0d 	sts	0x0D8D, r1	; 0x800d8d <USB_Host_ConfigurationNumber>
	USB_Host_ConfigurationNumber = 0;
    4fac:	80 e4       	ldi	r24, 0x40	; 64
	USB_Host_ControlPipeSize     = PIPE_CONTROLPIPE_DEFAULT_SIZE;
    4fae:	80 93 fe 01 	sts	0x01FE, r24	; 0x8001fe <USB_Host_ControlPipeSize>
    4fb2:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
	#if !defined(__DOXYGEN__)
		/* Macros: */
			static inline void USB_Host_HostMode_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_HostMode_On(void)
			{
				USBCON |=  (1 << HOST);
    4fb6:	80 64       	ori	r24, 0x40	; 64
    4fb8:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    4fbc:	80 91 dd 00 	lds	r24, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    4fc0:	81 60       	ori	r24, 0x01	; 1
    4fc2:	80 93 dd 00 	sts	0x00DD, r24	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
    4fc6:	80 91 dd 00 	lds	r24, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
			}

			static inline void USB_Host_VBUS_Manual_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Enable(void)
			{
				OTGCON |=  (1 << VBUSHWC);
    4fca:	84 60       	ori	r24, 0x04	; 4
    4fcc:	80 93 dd 00 	sts	0x00DD, r24	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
    4fd0:	80 91 d7 00 	lds	r24, 0x00D7	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
				UHWCON &= ~(1 << UVCONE);
    4fd4:	8f 7e       	andi	r24, 0xEF	; 239
    4fd6:	80 93 d7 00 	sts	0x00D7, r24	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
    4fda:	6f 9a       	sbi	0x0d, 7	; 13

				DDRE   |=  (1 << 7);
    4fdc:	77 9a       	sbi	0x0e, 7	; 14
			}

			static inline void USB_Host_VBUS_Manual_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_On(void)
			{
				PORTE  |=  (1 << 7);
    4fde:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN |= (1 << SRPE);						
    4fe2:	81 60       	ori	r24, 0x01	; 1
    4fe4:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    4fe8:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
						break;
					case USB_INT_RSTI:
						UHIEN  |= (1 << RSTE);
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
    4fec:	84 60       	ori	r24, 0x04	; 4
    4fee:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    4ff2:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    4ff6:	8e 7f       	andi	r24, 0xFE	; 254
    4ff8:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>
    4ffc:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    5000:	80 61       	ori	r24, 0x10	; 16
    5002:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    5006:	cf 91       	pop	r28
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    5008:	08 95       	ret

0000500a <USB_Init>:
    500a:	90 91 d7 00 	lds	r25, 0x00D7	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    500e:	91 60       	ori	r25, 0x01	; 1
    5010:	90 93 d7 00 	sts	0x00D7, r25	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif
	}

	#if defined(USB_CAN_BE_BOTH)
	if (Mode == USB_MODE_UID)
    5014:	83 30       	cpi	r24, 0x03	; 3
    5016:	91 f4       	brne	.+36     	; 0x503c <USB_Init+0x32>
	{
		UHWCON |=  (1 << UIDE);
    5018:	80 91 d7 00 	lds	r24, 0x00D7	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
    501c:	80 64       	ori	r24, 0x40	; 64
    501e:	80 93 d7 00 	sts	0x00D7, r24	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    5022:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    5026:	82 60       	ori	r24, 0x02	; 2
    5028:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    502c:	80 91 d9 00 	lds	r24, 0x00D9	; 0x8000d9 <__TEXT_REGION_LENGTH__+0x7e00d9>
    5030:	81 fd       	sbrc	r24, 1
    5032:	02 c0       	rjmp	.+4      	; 0x5038 <USB_Init+0x2e>
				  return USB_MODE_Device;
				else
				  return USB_MODE_Host;
    5034:	82 e0       	ldi	r24, 0x02	; 2
    5036:	07 c0       	rjmp	.+14     	; 0x5046 <USB_Init+0x3c>
			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
				  return USB_MODE_Device;
    5038:	81 e0       	ldi	r24, 0x01	; 1
    503a:	05 c0       	rjmp	.+10     	; 0x5046 <USB_Init+0x3c>
		USB_INT_Enable(USB_INT_IDTI);
		USB_CurrentMode = USB_GetUSBModeFromUID();
	}
	else
	{
		UHWCON &= ~(1 << UIDE);
    503c:	90 91 d7 00 	lds	r25, 0x00D7	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
    5040:	9f 7b       	andi	r25, 0xBF	; 191
    5042:	90 93 d7 00 	sts	0x00D7, r25	; 0x8000d7 <__TEXT_REGION_LENGTH__+0x7e00d7>
		USB_CurrentMode = Mode;
    5046:	80 93 ba 03 	sts	0x03BA, r24	; 0x8003ba <USB_CurrentMode>
	}
	#endif

	USB_IsInitialized = true;
    504a:	81 e0       	ldi	r24, 0x01	; 1
    504c:	80 93 8e 0d 	sts	0x0D8E, r24	; 0x800d8e <USB_IsInitialized>

	USB_ResetInterface();
    5050:	4e cf       	rjmp	.-356    	; 0x4eee <USB_ResetInterface>

00005052 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    5052:	e8 ed       	ldi	r30, 0xD8	; 216
    5054:	f0 e0       	ldi	r31, 0x00	; 0
    5056:	80 81       	ld	r24, Z
    5058:	8c 7f       	andi	r24, 0xFC	; 252
    505a:	80 83       	st	Z, r24
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGIEN  = 0;
    505c:	10 92 de 00 	sts	0x00DE, r1	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
    5060:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    5064:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    5068:	08 95       	ret

0000506a <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    506a:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGINT = 0;
    506e:	10 92 df 00 	sts	0x00DF, r1	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
    5072:	10 92 9f 00 	sts	0x009F, r1	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    5076:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    507a:	08 95       	ret

0000507c <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    507c:	1f 92       	push	r1
    507e:	0f 92       	push	r0
    5080:	0f b6       	in	r0, 0x3f	; 63
    5082:	0f 92       	push	r0
    5084:	11 24       	eor	r1, r1
    5086:	0b b6       	in	r0, 0x3b	; 59
    5088:	0f 92       	push	r0
    508a:	2f 93       	push	r18
    508c:	3f 93       	push	r19
    508e:	4f 93       	push	r20
    5090:	5f 93       	push	r21
    5092:	6f 93       	push	r22
    5094:	7f 93       	push	r23
    5096:	8f 93       	push	r24
    5098:	9f 93       	push	r25
    509a:	af 93       	push	r26
    509c:	bf 93       	push	r27
    509e:	ef 93       	push	r30
    50a0:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    50a2:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    50a6:	82 ff       	sbrs	r24, 2
    50a8:	0a c0       	rjmp	.+20     	; 0x50be <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    50aa:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    50ae:	82 ff       	sbrs	r24, 2
    50b0:	06 c0       	rjmp	.+12     	; 0x50be <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    50b2:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    50b6:	8b 7f       	andi	r24, 0xFB	; 251
    50b8:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    50bc:	70 d6       	rcall	.+3296   	; 0x5d9e <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    50be:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    50c2:	80 ff       	sbrs	r24, 0
    50c4:	1d c0       	rjmp	.+58     	; 0x5100 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    50c6:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    50ca:	80 ff       	sbrs	r24, 0
    50cc:	19 c0       	rjmp	.+50     	; 0x5100 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    50ce:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
    50d2:	8e 7f       	andi	r24, 0xFE	; 254
    50d4:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    50d8:	80 91 d9 00 	lds	r24, 0x00D9	; 0x8000d9 <__TEXT_REGION_LENGTH__+0x7e00d9>
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    50dc:	80 ff       	sbrs	r24, 0
    50de:	0c c0       	rjmp	.+24     	; 0x50f8 <__vector_10+0x7c>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    50e0:	8c e0       	ldi	r24, 0x0C	; 12
    50e2:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    50e4:	8e e0       	ldi	r24, 0x0E	; 14
    50e6:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    50e8:	09 b4       	in	r0, 0x29	; 41
    50ea:	00 fe       	sbrs	r0, 0
    50ec:	fd cf       	rjmp	.-6      	; 0x50e8 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    50ee:	81 e0       	ldi	r24, 0x01	; 1
    50f0:	8e bb       	out	0x1e, r24	; 30
			EVENT_USB_Device_Connect();
    50f2:	0e 94 c9 02 	call	0x592	; 0x592 <EVENT_USB_Device_Connect>
    50f6:	04 c0       	rjmp	.+8      	; 0x5100 <__vector_10+0x84>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    50f8:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    50fa:	1e ba       	out	0x1e, r1	; 30
			EVENT_USB_Device_Disconnect();
    50fc:	0e 94 cc 02 	call	0x598	; 0x598 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    5100:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    5104:	80 ff       	sbrs	r24, 0
    5106:	17 c0       	rjmp	.+46     	; 0x5136 <__vector_10+0xba>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    5108:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    510c:	80 ff       	sbrs	r24, 0
    510e:	13 c0       	rjmp	.+38     	; 0x5136 <__vector_10+0xba>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    5110:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    5114:	8e 7f       	andi	r24, 0xFE	; 254
    5116:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    511a:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    511e:	80 61       	ori	r24, 0x10	; 16
    5120:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    5124:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    5128:	80 62       	ori	r24, 0x20	; 32
    512a:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    512e:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    5130:	85 e0       	ldi	r24, 0x05	; 5
		EVENT_USB_Device_Suspend();
    5132:	8e bb       	out	0x1e, r24	; 30
    5134:	34 d6       	rcall	.+3176   	; 0x5d9e <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    5136:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    513a:	84 ff       	sbrs	r24, 4
    513c:	2c c0       	rjmp	.+88     	; 0x5196 <__vector_10+0x11a>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    513e:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    5142:	84 ff       	sbrs	r24, 4
    5144:	28 c0       	rjmp	.+80     	; 0x5196 <__vector_10+0x11a>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5146:	8c e0       	ldi	r24, 0x0C	; 12
    5148:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    514a:	8e e0       	ldi	r24, 0x0E	; 14
    514c:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    514e:	09 b4       	in	r0, 0x29	; 41
    5150:	00 fe       	sbrs	r0, 0
    5152:	fd cf       	rjmp	.-6      	; 0x514e <__vector_10+0xd2>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    5154:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    5158:	8f 7d       	andi	r24, 0xDF	; 223
    515a:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    515e:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    5162:	8f 7e       	andi	r24, 0xEF	; 239
    5164:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    5168:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    516c:	8f 7e       	andi	r24, 0xEF	; 239
    516e:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    5172:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    5176:	81 60       	ori	r24, 0x01	; 1
    5178:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    517c:	80 91 8a 0d 	lds	r24, 0x0D8A	; 0x800d8a <USB_Device_ConfigurationNumber>
    5180:	81 11       	cpse	r24, r1
    5182:	06 c0       	rjmp	.+12     	; 0x5190 <__vector_10+0x114>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    5184:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    5188:	87 fd       	sbrc	r24, 7
    518a:	02 c0       	rjmp	.+4      	; 0x5190 <__vector_10+0x114>
    518c:	81 e0       	ldi	r24, 0x01	; 1
    518e:	01 c0       	rjmp	.+2      	; 0x5192 <__vector_10+0x116>
    5190:	84 e0       	ldi	r24, 0x04	; 4

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    5192:	8e bb       	out	0x1e, r24	; 30
    5194:	04 d6       	rcall	.+3080   	; 0x5d9e <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    5196:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    519a:	83 ff       	sbrs	r24, 3
    519c:	26 c0       	rjmp	.+76     	; 0x51ea <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    519e:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    51a2:	83 ff       	sbrs	r24, 3
    51a4:	22 c0       	rjmp	.+68     	; 0x51ea <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    51a6:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    51aa:	87 7f       	andi	r24, 0xF7	; 247
    51ac:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    51b0:	82 e0       	ldi	r24, 0x02	; 2
    51b2:	8e bb       	out	0x1e, r24	; 30
		USB_Device_ConfigurationNumber = 0;
    51b4:	10 92 8a 0d 	sts	0x0D8A, r1	; 0x800d8a <USB_Device_ConfigurationNumber>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    51b8:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    51bc:	8e 7f       	andi	r24, 0xFE	; 254
    51be:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    51c2:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    51c6:	8e 7f       	andi	r24, 0xFE	; 254
    51c8:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    51cc:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    51d0:	80 61       	ori	r24, 0x10	; 16
    51d2:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    51d6:	42 e0       	ldi	r20, 0x02	; 2
    51d8:	60 e0       	ldi	r22, 0x00	; 0
    51da:	80 e0       	ldi	r24, 0x00	; 0
    51dc:	6d db       	rcall	.-2342   	; 0x48b8 <Endpoint_ConfigureEndpoint_Prv>
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    51de:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    51e2:	88 60       	ori	r24, 0x08	; 8
    51e4:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    51e8:	da d5       	rcall	.+2996   	; 0x5d9e <USB_Event_Stub>
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    51ea:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
	}
	#endif

	#if defined(USB_CAN_BE_HOST)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_HSOFI) && USB_INT_IsEnabled(USB_INT_HSOFI))
    51ee:	85 ff       	sbrs	r24, 5
    51f0:	0a c0       	rjmp	.+20     	; 0x5206 <__vector_10+0x18a>
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    51f2:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    51f6:	85 ff       	sbrs	r24, 5
    51f8:	06 c0       	rjmp	.+12     	; 0x5206 <__vector_10+0x18a>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    51fa:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    51fe:	8f 7d       	andi	r24, 0xDF	; 223
    5200:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
	{
		USB_INT_Clear(USB_INT_HSOFI);

		EVENT_USB_Host_StartOfFrame();
    5204:	cc d5       	rcall	.+2968   	; 0x5d9e <USB_Event_Stub>
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
    5206:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_DDISCI) && USB_INT_IsEnabled(USB_INT_DDISCI))
    520a:	81 ff       	sbrs	r24, 1
    520c:	16 c0       	rjmp	.+44     	; 0x523a <__vector_10+0x1be>
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
					case USB_INT_DCONNI:
						return (UHIEN  & (1 << DCONNE));
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
    520e:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    5212:	81 ff       	sbrs	r24, 1
    5214:	12 c0       	rjmp	.+36     	; 0x523a <__vector_10+0x1be>
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    5216:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    521a:	8d 7f       	andi	r24, 0xFD	; 253
    521c:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    5220:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
    5224:	8e 7f       	andi	r24, 0xFE	; 254
    5226:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <__TEXT_REGION_LENGTH__+0x7e009f>
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    522a:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    522e:	8d 7f       	andi	r24, 0xFD	; 253
    5230:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
	{
		USB_INT_Clear(USB_INT_DDISCI);
		USB_INT_Clear(USB_INT_DCONNI);
		USB_INT_Disable(USB_INT_DDISCI);

		EVENT_USB_Host_DeviceUnattached();
    5234:	0e 94 04 03 	call	0x608	; 0x608 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    5238:	5a de       	rcall	.-844    	; 0x4eee <USB_ResetInterface>
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
    523a:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
	}

	if (USB_INT_HasOccurred(USB_INT_VBERRI) && USB_INT_IsEnabled(USB_INT_VBERRI))
    523e:	81 ff       	sbrs	r24, 1
    5240:	17 c0       	rjmp	.+46     	; 0x5270 <__vector_10+0x1f4>
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
    5242:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    5246:	81 ff       	sbrs	r24, 1
    5248:	13 c0       	rjmp	.+38     	; 0x5270 <__vector_10+0x1f4>
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    524a:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
    524e:	8d 7f       	andi	r24, 0xFD	; 253
    5250:	80 93 df 00 	sts	0x00DF, r24	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
			}

			static inline void USB_Host_VBUS_Manual_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				PORTE  &= ~(1 << 7);
    5254:	77 98       	cbi	0x0e, 7	; 14
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    5256:	80 91 dd 00 	lds	r24, 0x00DD	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
    525a:	81 60       	ori	r24, 0x01	; 1
    525c:	80 93 dd 00 	sts	0x00DD, r24	; 0x8000dd <__TEXT_REGION_LENGTH__+0x7e00dd>
		USB_INT_Clear(USB_INT_VBERRI);

		USB_Host_VBUS_Manual_Off();
		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_HostError(HOST_ERROR_VBusVoltageDip);
    5260:	80 e0       	ldi	r24, 0x00	; 0
    5262:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <EVENT_USB_Host_HostError>
		EVENT_USB_Host_DeviceUnattached();
    5266:	0e 94 04 03 	call	0x608	; 0x608 <EVENT_USB_Host_DeviceUnattached>

		USB_HostState = HOST_STATE_Unattached;
    526a:	81 e0       	ldi	r24, 0x01	; 1
    526c:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <USB_HostState>
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
					case USB_INT_SRPI:
						return (OTGINT & (1 << SRPI));
    5270:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
	}

	if (USB_INT_HasOccurred(USB_INT_SRPI) && USB_INT_IsEnabled(USB_INT_SRPI))
    5274:	80 ff       	sbrs	r24, 0
    5276:	18 c0       	rjmp	.+48     	; 0x52a8 <__vector_10+0x22c>
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
					case USB_INT_SRPI:
						return (OTGIEN & (1 << SRPE));
    5278:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    527c:	80 ff       	sbrs	r24, 0
    527e:	14 c0       	rjmp	.+40     	; 0x52a8 <__vector_10+0x22c>
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
						break;
					case USB_INT_SRPI:
						OTGINT &= ~(1 << SRPI);
    5280:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
    5284:	8e 7f       	andi	r24, 0xFE	; 254
    5286:	80 93 df 00 	sts	0x00DF, r24	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
						break;
					case USB_INT_VBERRI:
						OTGIEN &= ~(1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN &= ~(1 << SRPE);						
    528a:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    528e:	8e 7f       	andi	r24, 0xFE	; 254
    5290:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	{
		USB_INT_Clear(USB_INT_SRPI);
		USB_INT_Disable(USB_INT_SRPI);

		EVENT_USB_Host_DeviceAttached();
    5294:	0e 94 02 03 	call	0x604	; 0x604 <EVENT_USB_Host_DeviceAttached>
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    5298:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
    529c:	82 60       	ori	r24, 0x02	; 2
    529e:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>

		USB_INT_Enable(USB_INT_DDISCI);

		USB_HostState = HOST_STATE_Powered;
    52a2:	82 e0       	ldi	r24, 0x02	; 2
    52a4:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <USB_HostState>
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
    52a8:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
	}

	if (USB_INT_HasOccurred(USB_INT_BCERRI) && USB_INT_IsEnabled(USB_INT_BCERRI))
    52ac:	82 ff       	sbrs	r24, 2
    52ae:	10 c0       	rjmp	.+32     	; 0x52d0 <__vector_10+0x254>
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
    52b0:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    52b4:	82 ff       	sbrs	r24, 2
    52b6:	0c c0       	rjmp	.+24     	; 0x52d0 <__vector_10+0x254>
						break;
					case USB_INT_RSTI:
						UHINT  &= ~(1 << RSTI);
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
    52b8:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
    52bc:	8b 7f       	andi	r24, 0xFB	; 251
    52be:	80 93 df 00 	sts	0x00DF, r24	; 0x8000df <__TEXT_REGION_LENGTH__+0x7e00df>
	{
		USB_INT_Clear(USB_INT_BCERRI);

		EVENT_USB_Host_DeviceEnumerationFailed(HOST_ENUMERROR_NoDeviceDetected, 0);
    52c2:	60 e0       	ldi	r22, 0x00	; 0
    52c4:	82 e0       	ldi	r24, 0x02	; 2
    52c6:	0e 94 81 03 	call	0x702	; 0x702 <EVENT_USB_Host_DeviceEnumerationFailed>
		EVENT_USB_Host_DeviceUnattached();
    52ca:	0e 94 04 03 	call	0x608	; 0x608 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    52ce:	0f de       	rcall	.-994    	; 0x4eee <USB_ResetInterface>
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
    52d0:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	}
	#endif

	#if defined(USB_CAN_BE_BOTH)
	if (USB_INT_HasOccurred(USB_INT_IDTI) && USB_INT_IsEnabled(USB_INT_IDTI))
    52d4:	81 ff       	sbrs	r24, 1
    52d6:	1e c0       	rjmp	.+60     	; 0x5314 <__vector_10+0x298>
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
    52d8:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    52dc:	81 ff       	sbrs	r24, 1
    52de:	1a c0       	rjmp	.+52     	; 0x5314 <__vector_10+0x298>
						USBINT &= ~(1 << VBUSTI);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBINT &= ~(1 << IDTI);
    52e0:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
    52e4:	8d 7f       	andi	r24, 0xFD	; 253
    52e6:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	{
		USB_INT_Clear(USB_INT_IDTI);

		if (USB_DeviceState != DEVICE_STATE_Unattached)
    52ea:	8e b3       	in	r24, 0x1e	; 30
    52ec:	81 11       	cpse	r24, r1
		  EVENT_USB_Device_Disconnect();
    52ee:	0e 94 cc 02 	call	0x598	; 0x598 <EVENT_USB_Device_Disconnect>

		if (USB_HostState != HOST_STATE_Unattached)
    52f2:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <USB_HostState>
    52f6:	81 30       	cpi	r24, 0x01	; 1
    52f8:	11 f0       	breq	.+4      	; 0x52fe <__vector_10+0x282>
		  EVENT_USB_Host_DeviceUnattached();
    52fa:	0e 94 04 03 	call	0x608	; 0x608 <EVENT_USB_Host_DeviceUnattached>

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    52fe:	80 91 d9 00 	lds	r24, 0x00D9	; 0x8000d9 <__TEXT_REGION_LENGTH__+0x7e00d9>
				  return USB_MODE_Device;
				else
				  return USB_MODE_Host;
    5302:	81 fd       	sbrc	r24, 1
    5304:	02 c0       	rjmp	.+4      	; 0x530a <__vector_10+0x28e>
			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
				  return USB_MODE_Device;
    5306:	82 e0       	ldi	r24, 0x02	; 2

		USB_CurrentMode = USB_GetUSBModeFromUID();
    5308:	01 c0       	rjmp	.+2      	; 0x530c <__vector_10+0x290>
    530a:	81 e0       	ldi	r24, 0x01	; 1
		USB_ResetInterface();
    530c:	80 93 ba 03 	sts	0x03BA, r24	; 0x8003ba <USB_CurrentMode>

		EVENT_USB_UIDChange();
    5310:	ee dd       	rcall	.-1060   	; 0x4eee <USB_ResetInterface>
    5312:	45 d5       	rcall	.+2698   	; 0x5d9e <USB_Event_Stub>
	}
	#endif
}
    5314:	ff 91       	pop	r31
    5316:	ef 91       	pop	r30
    5318:	bf 91       	pop	r27
    531a:	af 91       	pop	r26
    531c:	9f 91       	pop	r25
    531e:	8f 91       	pop	r24
    5320:	7f 91       	pop	r23
    5322:	6f 91       	pop	r22
    5324:	5f 91       	pop	r21
    5326:	4f 91       	pop	r20
    5328:	3f 91       	pop	r19
    532a:	2f 91       	pop	r18
    532c:	0f 90       	pop	r0
    532e:	0b be       	out	0x3b, r0	; 59
    5330:	0f 90       	pop	r0
    5332:	0f be       	out	0x3f, r0	; 63
    5334:	0f 90       	pop	r0
    5336:	1f 90       	pop	r1
    5338:	18 95       	reti

0000533a <__vector_11>:

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
    533a:	1f 92       	push	r1
    533c:	0f 92       	push	r0
    533e:	0f b6       	in	r0, 0x3f	; 63
    5340:	0f 92       	push	r0
    5342:	11 24       	eor	r1, r1
    5344:	0b b6       	in	r0, 0x3b	; 59
    5346:	0f 92       	push	r0
    5348:	ff 92       	push	r15
    534a:	0f 93       	push	r16
    534c:	1f 93       	push	r17
    534e:	2f 93       	push	r18
    5350:	3f 93       	push	r19
    5352:	4f 93       	push	r20
    5354:	5f 93       	push	r21
    5356:	6f 93       	push	r22
    5358:	7f 93       	push	r23
    535a:	8f 93       	push	r24
    535c:	9f 93       	push	r25
    535e:	af 93       	push	r26
    5360:	bf 93       	push	r27
    5362:	cf 93       	push	r28
    5364:	df 93       	push	r29
    5366:	ef 93       	push	r30
    5368:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    536a:	c9 ee       	ldi	r28, 0xE9	; 233
    536c:	d0 e0       	ldi	r29, 0x00	; 0
    536e:	88 81       	ld	r24, Y
    5370:	87 70       	andi	r24, 0x07	; 7
    5372:	f8 2e       	mov	r15, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    5374:	18 82       	st	Y, r1
						break;
					case USB_INT_SOFI:
						UDIEN  &= ~(1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX &= ~(1 << RXSTPE);
    5376:	00 ef       	ldi	r16, 0xF0	; 240
    5378:	10 e0       	ldi	r17, 0x00	; 0
    537a:	f8 01       	movw	r30, r16
    537c:	80 81       	ld	r24, Z
    537e:	87 7f       	andi	r24, 0xF7	; 247
    5380:	80 83       	st	Z, r24
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5382:	78 94       	sei
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);

	GlobalInterruptEnable();

	USB_Device_ProcessControlRequest();
    5384:	b2 d3       	rcall	.+1892   	; 0x5aea <USB_Device_ProcessControlRequest>
    5386:	18 82       	st	Y, r1
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    5388:	f8 01       	movw	r30, r16
    538a:	80 81       	ld	r24, Z
    538c:	88 60       	ori	r24, 0x08	; 8
    538e:	80 83       	st	Z, r24
    5390:	f8 82       	st	Y, r15

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
    5392:	ff 91       	pop	r31
    5394:	ef 91       	pop	r30
    5396:	df 91       	pop	r29
    5398:	cf 91       	pop	r28
    539a:	bf 91       	pop	r27
    539c:	af 91       	pop	r26
    539e:	9f 91       	pop	r25
    53a0:	8f 91       	pop	r24
    53a2:	7f 91       	pop	r23
    53a4:	6f 91       	pop	r22
    53a6:	5f 91       	pop	r21
    53a8:	4f 91       	pop	r20
    53aa:	3f 91       	pop	r19
    53ac:	2f 91       	pop	r18
    53ae:	1f 91       	pop	r17
    53b0:	0f 91       	pop	r16
    53b2:	ff 90       	pop	r15
    53b4:	0f 90       	pop	r0
    53b6:	0b be       	out	0x3b, r0	; 59
    53b8:	0f 90       	pop	r0
    53ba:	0f be       	out	0x3f, r0	; 63
    53bc:	0f 90       	pop	r0
    53be:	1f 90       	pop	r1
    53c0:	18 95       	reti

000053c2 <Endpoint_Null_Stream>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    53c2:	ef 92       	push	r14
    53c4:	ff 92       	push	r15
    53c6:	0f 93       	push	r16
    53c8:	1f 93       	push	r17
    53ca:	cf 93       	push	r28
    53cc:	df 93       	push	r29
    53ce:	ec 01       	movw	r28, r24
    53d0:	8b 01       	movw	r16, r22
    53d2:	c3 da       	rcall	.-2682   	; 0x495a <Endpoint_WaitUntilReady>
    53d4:	81 11       	cpse	r24, r1
    53d6:	2d c0       	rjmp	.+90     	; 0x5432 <Endpoint_Null_Stream+0x70>
    53d8:	01 15       	cp	r16, r1
    53da:	11 05       	cpc	r17, r1
    53dc:	29 f0       	breq	.+10     	; 0x53e8 <Endpoint_Null_Stream+0x26>
    53de:	f8 01       	movw	r30, r16
    53e0:	80 81       	ld	r24, Z
    53e2:	91 81       	ldd	r25, Z+1	; 0x01
    53e4:	c8 1b       	sub	r28, r24
    53e6:	d9 0b       	sbc	r29, r25
    53e8:	e1 2c       	mov	r14, r1
    53ea:	f1 2c       	mov	r15, r1
    53ec:	20 97       	sbiw	r28, 0x00	; 0
    53ee:	01 f1       	breq	.+64     	; 0x5430 <Endpoint_Null_Stream+0x6e>
    53f0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    53f4:	85 fd       	sbrc	r24, 5
    53f6:	15 c0       	rjmp	.+42     	; 0x5422 <Endpoint_Null_Stream+0x60>
    53f8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    53fc:	8e 77       	andi	r24, 0x7E	; 126
    53fe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5402:	01 15       	cp	r16, r1
    5404:	11 05       	cpc	r17, r1
    5406:	49 f0       	breq	.+18     	; 0x541a <Endpoint_Null_Stream+0x58>
    5408:	f8 01       	movw	r30, r16
    540a:	80 81       	ld	r24, Z
    540c:	91 81       	ldd	r25, Z+1	; 0x01
    540e:	e8 0e       	add	r14, r24
    5410:	f9 1e       	adc	r15, r25
    5412:	f1 82       	std	Z+1, r15	; 0x01
    5414:	e0 82       	st	Z, r14
    5416:	85 e0       	ldi	r24, 0x05	; 5
    5418:	0c c0       	rjmp	.+24     	; 0x5432 <Endpoint_Null_Stream+0x70>
    541a:	9f da       	rcall	.-2754   	; 0x495a <Endpoint_WaitUntilReady>
    541c:	88 23       	and	r24, r24
    541e:	31 f3       	breq	.-52     	; 0x53ec <Endpoint_Null_Stream+0x2a>
    5420:	08 c0       	rjmp	.+16     	; 0x5432 <Endpoint_Null_Stream+0x70>
    5422:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    5426:	21 97       	sbiw	r28, 0x01	; 1
    5428:	ff ef       	ldi	r31, 0xFF	; 255
    542a:	ef 1a       	sub	r14, r31
    542c:	ff 0a       	sbc	r15, r31
    542e:	de cf       	rjmp	.-68     	; 0x53ec <Endpoint_Null_Stream+0x2a>
    5430:	80 e0       	ldi	r24, 0x00	; 0
    5432:	df 91       	pop	r29
    5434:	cf 91       	pop	r28
    5436:	1f 91       	pop	r17
    5438:	0f 91       	pop	r16
    543a:	ff 90       	pop	r15
    543c:	ef 90       	pop	r14
    543e:	08 95       	ret

00005440 <Endpoint_Write_Stream_LE>:
    5440:	cf 92       	push	r12
    5442:	df 92       	push	r13
    5444:	ef 92       	push	r14
    5446:	ff 92       	push	r15
    5448:	0f 93       	push	r16
    544a:	1f 93       	push	r17
    544c:	cf 93       	push	r28
    544e:	df 93       	push	r29
    5450:	ec 01       	movw	r28, r24
    5452:	8b 01       	movw	r16, r22
    5454:	7a 01       	movw	r14, r20
    5456:	81 da       	rcall	.-2814   	; 0x495a <Endpoint_WaitUntilReady>
    5458:	81 11       	cpse	r24, r1
    545a:	32 c0       	rjmp	.+100    	; 0x54c0 <Endpoint_Write_Stream_LE+0x80>
    545c:	e1 14       	cp	r14, r1
    545e:	f1 04       	cpc	r15, r1
    5460:	39 f0       	breq	.+14     	; 0x5470 <Endpoint_Write_Stream_LE+0x30>
    5462:	f7 01       	movw	r30, r14
    5464:	80 81       	ld	r24, Z
    5466:	91 81       	ldd	r25, Z+1	; 0x01
    5468:	08 1b       	sub	r16, r24
    546a:	19 0b       	sbc	r17, r25
    546c:	c8 0f       	add	r28, r24
    546e:	d9 1f       	adc	r29, r25
    5470:	c1 2c       	mov	r12, r1
    5472:	d1 2c       	mov	r13, r1
    5474:	01 15       	cp	r16, r1
    5476:	11 05       	cpc	r17, r1
    5478:	11 f1       	breq	.+68     	; 0x54be <Endpoint_Write_Stream_LE+0x7e>
    547a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    547e:	85 fd       	sbrc	r24, 5
    5480:	15 c0       	rjmp	.+42     	; 0x54ac <Endpoint_Write_Stream_LE+0x6c>
    5482:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5486:	8e 77       	andi	r24, 0x7E	; 126
    5488:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    548c:	e1 14       	cp	r14, r1
    548e:	f1 04       	cpc	r15, r1
    5490:	49 f0       	breq	.+18     	; 0x54a4 <Endpoint_Write_Stream_LE+0x64>
    5492:	f7 01       	movw	r30, r14
    5494:	80 81       	ld	r24, Z
    5496:	91 81       	ldd	r25, Z+1	; 0x01
    5498:	c8 0e       	add	r12, r24
    549a:	d9 1e       	adc	r13, r25
    549c:	d1 82       	std	Z+1, r13	; 0x01
    549e:	c0 82       	st	Z, r12
    54a0:	85 e0       	ldi	r24, 0x05	; 5
    54a2:	0e c0       	rjmp	.+28     	; 0x54c0 <Endpoint_Write_Stream_LE+0x80>
    54a4:	5a da       	rcall	.-2892   	; 0x495a <Endpoint_WaitUntilReady>
    54a6:	88 23       	and	r24, r24
    54a8:	29 f3       	breq	.-54     	; 0x5474 <Endpoint_Write_Stream_LE+0x34>
    54aa:	0a c0       	rjmp	.+20     	; 0x54c0 <Endpoint_Write_Stream_LE+0x80>
    54ac:	89 91       	ld	r24, Y+
    54ae:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    54b2:	01 50       	subi	r16, 0x01	; 1
    54b4:	11 09       	sbc	r17, r1
    54b6:	ff ef       	ldi	r31, 0xFF	; 255
    54b8:	cf 1a       	sub	r12, r31
    54ba:	df 0a       	sbc	r13, r31
    54bc:	db cf       	rjmp	.-74     	; 0x5474 <Endpoint_Write_Stream_LE+0x34>
    54be:	80 e0       	ldi	r24, 0x00	; 0
    54c0:	df 91       	pop	r29
    54c2:	cf 91       	pop	r28
    54c4:	1f 91       	pop	r17
    54c6:	0f 91       	pop	r16
    54c8:	ff 90       	pop	r15
    54ca:	ef 90       	pop	r14
    54cc:	df 90       	pop	r13
    54ce:	cf 90       	pop	r12
    54d0:	08 95       	ret

000054d2 <Endpoint_Write_Stream_BE>:
    54d2:	cf 92       	push	r12
    54d4:	df 92       	push	r13
    54d6:	ef 92       	push	r14
    54d8:	ff 92       	push	r15
    54da:	0f 93       	push	r16
    54dc:	1f 93       	push	r17
    54de:	cf 93       	push	r28
    54e0:	df 93       	push	r29
    54e2:	ec 01       	movw	r28, r24
    54e4:	8b 01       	movw	r16, r22
    54e6:	7a 01       	movw	r14, r20
    54e8:	38 da       	rcall	.-2960   	; 0x495a <Endpoint_WaitUntilReady>
    54ea:	81 11       	cpse	r24, r1
    54ec:	37 c0       	rjmp	.+110    	; 0x555c <Endpoint_Write_Stream_BE+0x8a>
    54ee:	c8 01       	movw	r24, r16
    54f0:	01 97       	sbiw	r24, 0x01	; 1
    54f2:	c8 0f       	add	r28, r24
    54f4:	d9 1f       	adc	r29, r25
    54f6:	e1 14       	cp	r14, r1
    54f8:	f1 04       	cpc	r15, r1
    54fa:	39 f0       	breq	.+14     	; 0x550a <Endpoint_Write_Stream_BE+0x38>
    54fc:	f7 01       	movw	r30, r14
    54fe:	80 81       	ld	r24, Z
    5500:	91 81       	ldd	r25, Z+1	; 0x01
    5502:	08 1b       	sub	r16, r24
    5504:	19 0b       	sbc	r17, r25
    5506:	c8 1b       	sub	r28, r24
    5508:	d9 0b       	sbc	r29, r25
    550a:	c1 2c       	mov	r12, r1
    550c:	d1 2c       	mov	r13, r1
    550e:	01 15       	cp	r16, r1
    5510:	11 05       	cpc	r17, r1
    5512:	19 f1       	breq	.+70     	; 0x555a <Endpoint_Write_Stream_BE+0x88>
    5514:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5518:	85 fd       	sbrc	r24, 5
    551a:	15 c0       	rjmp	.+42     	; 0x5546 <Endpoint_Write_Stream_BE+0x74>
    551c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5520:	8e 77       	andi	r24, 0x7E	; 126
    5522:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5526:	e1 14       	cp	r14, r1
    5528:	f1 04       	cpc	r15, r1
    552a:	49 f0       	breq	.+18     	; 0x553e <Endpoint_Write_Stream_BE+0x6c>
    552c:	f7 01       	movw	r30, r14
    552e:	80 81       	ld	r24, Z
    5530:	91 81       	ldd	r25, Z+1	; 0x01
    5532:	c8 0e       	add	r12, r24
    5534:	d9 1e       	adc	r13, r25
    5536:	d1 82       	std	Z+1, r13	; 0x01
    5538:	c0 82       	st	Z, r12
    553a:	85 e0       	ldi	r24, 0x05	; 5
    553c:	0f c0       	rjmp	.+30     	; 0x555c <Endpoint_Write_Stream_BE+0x8a>
    553e:	0d da       	rcall	.-3046   	; 0x495a <Endpoint_WaitUntilReady>
    5540:	88 23       	and	r24, r24
    5542:	29 f3       	breq	.-54     	; 0x550e <Endpoint_Write_Stream_BE+0x3c>
    5544:	0b c0       	rjmp	.+22     	; 0x555c <Endpoint_Write_Stream_BE+0x8a>
    5546:	88 81       	ld	r24, Y
    5548:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    554c:	21 97       	sbiw	r28, 0x01	; 1
    554e:	01 50       	subi	r16, 0x01	; 1
    5550:	11 09       	sbc	r17, r1
    5552:	ff ef       	ldi	r31, 0xFF	; 255
    5554:	cf 1a       	sub	r12, r31
    5556:	df 0a       	sbc	r13, r31
    5558:	da cf       	rjmp	.-76     	; 0x550e <Endpoint_Write_Stream_BE+0x3c>
    555a:	80 e0       	ldi	r24, 0x00	; 0
    555c:	df 91       	pop	r29
    555e:	cf 91       	pop	r28
    5560:	1f 91       	pop	r17
    5562:	0f 91       	pop	r16
    5564:	ff 90       	pop	r15
    5566:	ef 90       	pop	r14
    5568:	df 90       	pop	r13
    556a:	cf 90       	pop	r12
    556c:	08 95       	ret

0000556e <Endpoint_Read_Stream_LE>:
    556e:	cf 92       	push	r12
    5570:	df 92       	push	r13
    5572:	ef 92       	push	r14
    5574:	ff 92       	push	r15
    5576:	0f 93       	push	r16
    5578:	1f 93       	push	r17
    557a:	cf 93       	push	r28
    557c:	df 93       	push	r29
    557e:	ec 01       	movw	r28, r24
    5580:	8b 01       	movw	r16, r22
    5582:	7a 01       	movw	r14, r20
    5584:	ea d9       	rcall	.-3116   	; 0x495a <Endpoint_WaitUntilReady>
    5586:	81 11       	cpse	r24, r1
    5588:	32 c0       	rjmp	.+100    	; 0x55ee <Endpoint_Read_Stream_LE+0x80>
    558a:	e1 14       	cp	r14, r1
    558c:	f1 04       	cpc	r15, r1
    558e:	39 f0       	breq	.+14     	; 0x559e <Endpoint_Read_Stream_LE+0x30>
    5590:	f7 01       	movw	r30, r14
    5592:	80 81       	ld	r24, Z
    5594:	91 81       	ldd	r25, Z+1	; 0x01
    5596:	08 1b       	sub	r16, r24
    5598:	19 0b       	sbc	r17, r25
    559a:	c8 0f       	add	r28, r24
    559c:	d9 1f       	adc	r29, r25
    559e:	c1 2c       	mov	r12, r1
    55a0:	d1 2c       	mov	r13, r1
    55a2:	01 15       	cp	r16, r1
    55a4:	11 05       	cpc	r17, r1
    55a6:	11 f1       	breq	.+68     	; 0x55ec <Endpoint_Read_Stream_LE+0x7e>
    55a8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    55ac:	85 fd       	sbrc	r24, 5
    55ae:	15 c0       	rjmp	.+42     	; 0x55da <Endpoint_Read_Stream_LE+0x6c>
    55b0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    55b4:	8b 77       	andi	r24, 0x7B	; 123
    55b6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    55ba:	e1 14       	cp	r14, r1
    55bc:	f1 04       	cpc	r15, r1
    55be:	49 f0       	breq	.+18     	; 0x55d2 <Endpoint_Read_Stream_LE+0x64>
    55c0:	f7 01       	movw	r30, r14
    55c2:	80 81       	ld	r24, Z
    55c4:	91 81       	ldd	r25, Z+1	; 0x01
    55c6:	c8 0e       	add	r12, r24
    55c8:	d9 1e       	adc	r13, r25
    55ca:	d1 82       	std	Z+1, r13	; 0x01
    55cc:	c0 82       	st	Z, r12
    55ce:	85 e0       	ldi	r24, 0x05	; 5
    55d0:	0e c0       	rjmp	.+28     	; 0x55ee <Endpoint_Read_Stream_LE+0x80>
    55d2:	c3 d9       	rcall	.-3194   	; 0x495a <Endpoint_WaitUntilReady>
    55d4:	88 23       	and	r24, r24
    55d6:	29 f3       	breq	.-54     	; 0x55a2 <Endpoint_Read_Stream_LE+0x34>
    55d8:	0a c0       	rjmp	.+20     	; 0x55ee <Endpoint_Read_Stream_LE+0x80>
    55da:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    55de:	89 93       	st	Y+, r24
    55e0:	01 50       	subi	r16, 0x01	; 1
    55e2:	11 09       	sbc	r17, r1
    55e4:	ff ef       	ldi	r31, 0xFF	; 255
    55e6:	cf 1a       	sub	r12, r31
    55e8:	df 0a       	sbc	r13, r31
    55ea:	db cf       	rjmp	.-74     	; 0x55a2 <Endpoint_Read_Stream_LE+0x34>
    55ec:	80 e0       	ldi	r24, 0x00	; 0
    55ee:	df 91       	pop	r29
    55f0:	cf 91       	pop	r28
    55f2:	1f 91       	pop	r17
    55f4:	0f 91       	pop	r16
    55f6:	ff 90       	pop	r15
    55f8:	ef 90       	pop	r14
    55fa:	df 90       	pop	r13
    55fc:	cf 90       	pop	r12
    55fe:	08 95       	ret

00005600 <Endpoint_Write_Control_Stream_LE>:
    5600:	20 91 95 0d 	lds	r18, 0x0D95	; 0x800d95 <USB_ControlRequest+0x6>
    5604:	30 91 96 0d 	lds	r19, 0x0D96	; 0x800d96 <USB_ControlRequest+0x7>
    5608:	26 17       	cp	r18, r22
    560a:	37 07       	cpc	r19, r23
    560c:	48 f0       	brcs	.+18     	; 0x5620 <Endpoint_Write_Control_Stream_LE+0x20>
    560e:	61 15       	cp	r22, r1
    5610:	71 05       	cpc	r23, r1
    5612:	39 f4       	brne	.+14     	; 0x5622 <Endpoint_Write_Control_Stream_LE+0x22>
    5614:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5618:	2e 77       	andi	r18, 0x7E	; 126
    561a:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    561e:	01 c0       	rjmp	.+2      	; 0x5622 <Endpoint_Write_Control_Stream_LE+0x22>
    5620:	b9 01       	movw	r22, r18
    5622:	fc 01       	movw	r30, r24
    5624:	20 e0       	ldi	r18, 0x00	; 0
    5626:	61 15       	cp	r22, r1
    5628:	71 05       	cpc	r23, r1
    562a:	61 f1       	breq	.+88     	; 0x5684 <Endpoint_Write_Control_Stream_LE+0x84>
    562c:	8e b3       	in	r24, 0x1e	; 30
    562e:	88 23       	and	r24, r24
    5630:	c9 f1       	breq	.+114    	; 0x56a4 <Endpoint_Write_Control_Stream_LE+0xa4>
    5632:	85 30       	cpi	r24, 0x05	; 5
    5634:	c9 f1       	breq	.+114    	; 0x56a8 <Endpoint_Write_Control_Stream_LE+0xa8>
    5636:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    563a:	83 fd       	sbrc	r24, 3
    563c:	31 c0       	rjmp	.+98     	; 0x56a0 <Endpoint_Write_Control_Stream_LE+0xa0>
    563e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5642:	82 fd       	sbrc	r24, 2
    5644:	27 c0       	rjmp	.+78     	; 0x5694 <Endpoint_Write_Control_Stream_LE+0x94>
    5646:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    564a:	80 ff       	sbrs	r24, 0
    564c:	ec cf       	rjmp	.-40     	; 0x5626 <Endpoint_Write_Control_Stream_LE+0x26>
    564e:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    5652:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    5656:	61 15       	cp	r22, r1
    5658:	71 05       	cpc	r23, r1
    565a:	51 f0       	breq	.+20     	; 0x5670 <Endpoint_Write_Control_Stream_LE+0x70>
    565c:	88 30       	cpi	r24, 0x08	; 8
    565e:	91 05       	cpc	r25, r1
    5660:	38 f4       	brcc	.+14     	; 0x5670 <Endpoint_Write_Control_Stream_LE+0x70>
    5662:	21 91       	ld	r18, Z+
    5664:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    5668:	61 50       	subi	r22, 0x01	; 1
    566a:	71 09       	sbc	r23, r1
    566c:	01 96       	adiw	r24, 0x01	; 1
    566e:	f3 cf       	rjmp	.-26     	; 0x5656 <Endpoint_Write_Control_Stream_LE+0x56>
    5670:	21 e0       	ldi	r18, 0x01	; 1
    5672:	08 97       	sbiw	r24, 0x08	; 8
    5674:	09 f0       	breq	.+2      	; 0x5678 <Endpoint_Write_Control_Stream_LE+0x78>
    5676:	20 e0       	ldi	r18, 0x00	; 0
    5678:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    567c:	8e 77       	andi	r24, 0x7E	; 126
    567e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5682:	d1 cf       	rjmp	.-94     	; 0x5626 <Endpoint_Write_Control_Stream_LE+0x26>
    5684:	21 11       	cpse	r18, r1
    5686:	d2 cf       	rjmp	.-92     	; 0x562c <Endpoint_Write_Control_Stream_LE+0x2c>
    5688:	05 c0       	rjmp	.+10     	; 0x5694 <Endpoint_Write_Control_Stream_LE+0x94>
    568a:	8e b3       	in	r24, 0x1e	; 30
    568c:	88 23       	and	r24, r24
    568e:	51 f0       	breq	.+20     	; 0x56a4 <Endpoint_Write_Control_Stream_LE+0xa4>
    5690:	85 30       	cpi	r24, 0x05	; 5
    5692:	51 f0       	breq	.+20     	; 0x56a8 <Endpoint_Write_Control_Stream_LE+0xa8>
    5694:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5698:	82 ff       	sbrs	r24, 2
    569a:	f7 cf       	rjmp	.-18     	; 0x568a <Endpoint_Write_Control_Stream_LE+0x8a>
    569c:	80 e0       	ldi	r24, 0x00	; 0
    569e:	08 95       	ret
    56a0:	81 e0       	ldi	r24, 0x01	; 1
    56a2:	08 95       	ret
    56a4:	82 e0       	ldi	r24, 0x02	; 2
    56a6:	08 95       	ret
    56a8:	83 e0       	ldi	r24, 0x03	; 3
    56aa:	08 95       	ret

000056ac <Endpoint_Read_Control_Stream_LE>:
    56ac:	61 15       	cp	r22, r1
    56ae:	71 05       	cpc	r23, r1
    56b0:	29 f4       	brne	.+10     	; 0x56bc <Endpoint_Read_Control_Stream_LE+0x10>
    56b2:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    56b6:	2b 77       	andi	r18, 0x7B	; 123
    56b8:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    56bc:	fc 01       	movw	r30, r24
    56be:	61 15       	cp	r22, r1
    56c0:	71 05       	cpc	r23, r1
    56c2:	21 f1       	breq	.+72     	; 0x570c <Endpoint_Read_Control_Stream_LE+0x60>
    56c4:	8e b3       	in	r24, 0x1e	; 30
    56c6:	88 23       	and	r24, r24
    56c8:	49 f1       	breq	.+82     	; 0x571c <Endpoint_Read_Control_Stream_LE+0x70>
    56ca:	85 30       	cpi	r24, 0x05	; 5
    56cc:	49 f1       	breq	.+82     	; 0x5720 <Endpoint_Read_Control_Stream_LE+0x74>
    56ce:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    56d2:	83 fd       	sbrc	r24, 3
    56d4:	21 c0       	rjmp	.+66     	; 0x5718 <Endpoint_Read_Control_Stream_LE+0x6c>
    56d6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    56da:	82 ff       	sbrs	r24, 2
    56dc:	f0 cf       	rjmp	.-32     	; 0x56be <Endpoint_Read_Control_Stream_LE+0x12>
    56de:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    56e2:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    56e6:	89 2b       	or	r24, r25
    56e8:	31 f0       	breq	.+12     	; 0x56f6 <Endpoint_Read_Control_Stream_LE+0x4a>
    56ea:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    56ee:	81 93       	st	Z+, r24
    56f0:	61 50       	subi	r22, 0x01	; 1
    56f2:	71 09       	sbc	r23, r1
    56f4:	a1 f7       	brne	.-24     	; 0x56de <Endpoint_Read_Control_Stream_LE+0x32>
    56f6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    56fa:	8b 77       	andi	r24, 0x7B	; 123
    56fc:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5700:	de cf       	rjmp	.-68     	; 0x56be <Endpoint_Read_Control_Stream_LE+0x12>
    5702:	8e b3       	in	r24, 0x1e	; 30
    5704:	88 23       	and	r24, r24
    5706:	51 f0       	breq	.+20     	; 0x571c <Endpoint_Read_Control_Stream_LE+0x70>
    5708:	85 30       	cpi	r24, 0x05	; 5
    570a:	51 f0       	breq	.+20     	; 0x5720 <Endpoint_Read_Control_Stream_LE+0x74>
    570c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5710:	80 ff       	sbrs	r24, 0
    5712:	f7 cf       	rjmp	.-18     	; 0x5702 <Endpoint_Read_Control_Stream_LE+0x56>
    5714:	80 e0       	ldi	r24, 0x00	; 0
    5716:	08 95       	ret
    5718:	81 e0       	ldi	r24, 0x01	; 1
    571a:	08 95       	ret
    571c:	82 e0       	ldi	r24, 0x02	; 2
    571e:	08 95       	ret
    5720:	83 e0       	ldi	r24, 0x03	; 3
    5722:	08 95       	ret

00005724 <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    5724:	20 91 95 0d 	lds	r18, 0x0D95	; 0x800d95 <USB_ControlRequest+0x6>
    5728:	30 91 96 0d 	lds	r19, 0x0D96	; 0x800d96 <USB_ControlRequest+0x7>
    572c:	26 17       	cp	r18, r22
    572e:	37 07       	cpc	r19, r23
    5730:	48 f0       	brcs	.+18     	; 0x5744 <Endpoint_Write_Control_PStream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    5732:	61 15       	cp	r22, r1
    5734:	71 05       	cpc	r23, r1
    5736:	39 f4       	brne	.+14     	; 0x5746 <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5738:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    573c:	2e 77       	andi	r18, 0x7E	; 126
    573e:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5742:	01 c0       	rjmp	.+2      	; 0x5746 <Endpoint_Write_Control_PStream_LE+0x22>
    5744:	b9 01       	movw	r22, r18
    5746:	fc 01       	movw	r30, r24
    5748:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    574a:	61 15       	cp	r22, r1
    574c:	71 05       	cpc	r23, r1
    574e:	69 f1       	breq	.+90     	; 0x57aa <Endpoint_Write_Control_PStream_LE+0x86>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    5750:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    5752:	88 23       	and	r24, r24
    5754:	d1 f1       	breq	.+116    	; 0x57ca <Endpoint_Write_Control_PStream_LE+0xa6>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    5756:	85 30       	cpi	r24, 0x05	; 5
    5758:	d1 f1       	breq	.+116    	; 0x57ce <Endpoint_Write_Control_PStream_LE+0xaa>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    575a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    575e:	83 fd       	sbrc	r24, 3
    5760:	32 c0       	rjmp	.+100    	; 0x57c6 <Endpoint_Write_Control_PStream_LE+0xa2>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5762:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    5766:	82 fd       	sbrc	r24, 2
    5768:	28 c0       	rjmp	.+80     	; 0x57ba <Endpoint_Write_Control_PStream_LE+0x96>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    576a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  break;

		if (Endpoint_IsINReady())
    576e:	80 ff       	sbrs	r24, 0
    5770:	ec cf       	rjmp	.-40     	; 0x574a <Endpoint_Write_Control_PStream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    5772:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    5776:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    577a:	61 15       	cp	r22, r1
    577c:	71 05       	cpc	r23, r1
    577e:	59 f0       	breq	.+22     	; 0x5796 <Endpoint_Write_Control_PStream_LE+0x72>
    5780:	88 30       	cpi	r24, 0x08	; 8
    5782:	91 05       	cpc	r25, r1
    5784:	40 f4       	brcc	.+16     	; 0x5796 <Endpoint_Write_Control_PStream_LE+0x72>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    5786:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5788:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    578c:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    578e:	61 50       	subi	r22, 0x01	; 1
    5790:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    5792:	01 96       	adiw	r24, 0x01	; 1
    5794:	f2 cf       	rjmp	.-28     	; 0x577a <Endpoint_Write_Control_PStream_LE+0x56>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    5796:	21 e0       	ldi	r18, 0x01	; 1
    5798:	08 97       	sbiw	r24, 0x08	; 8
    579a:	09 f0       	breq	.+2      	; 0x579e <Endpoint_Write_Control_PStream_LE+0x7a>
    579c:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    579e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    57a2:	8e 77       	andi	r24, 0x7E	; 126
    57a4:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    57a8:	d0 cf       	rjmp	.-96     	; 0x574a <Endpoint_Write_Control_PStream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    57aa:	21 11       	cpse	r18, r1
    57ac:	d1 cf       	rjmp	.-94     	; 0x5750 <Endpoint_Write_Control_PStream_LE+0x2c>
    57ae:	05 c0       	rjmp	.+10     	; 0x57ba <Endpoint_Write_Control_PStream_LE+0x96>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    57b0:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    57b2:	88 23       	and	r24, r24
    57b4:	51 f0       	breq	.+20     	; 0x57ca <Endpoint_Write_Control_PStream_LE+0xa6>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    57b6:	85 30       	cpi	r24, 0x05	; 5
    57b8:	51 f0       	breq	.+20     	; 0x57ce <Endpoint_Write_Control_PStream_LE+0xaa>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    57ba:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    57be:	82 ff       	sbrs	r24, 2
    57c0:	f7 cf       	rjmp	.-18     	; 0x57b0 <Endpoint_Write_Control_PStream_LE+0x8c>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    57c2:	80 e0       	ldi	r24, 0x00	; 0
    57c4:	08 95       	ret
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    57c6:	81 e0       	ldi	r24, 0x01	; 1
    57c8:	08 95       	ret
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    57ca:	82 e0       	ldi	r24, 0x02	; 2
    57cc:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    57ce:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    57d0:	08 95       	ret

000057d2 <Pipe_Discard_Stream>:
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    57d2:	ef 92       	push	r14
    57d4:	ff 92       	push	r15
    57d6:	0f 93       	push	r16
    57d8:	1f 93       	push	r17
    57da:	cf 93       	push	r28
    57dc:	df 93       	push	r29
    57de:	ec 01       	movw	r28, r24
    57e0:	8b 01       	movw	r16, r22
    57e2:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    57e6:	8f 7c       	andi	r24, 0xCF	; 207
    57e8:	80 61       	ori	r24, 0x10	; 16
    57ea:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    57ee:	37 db       	rcall	.-2450   	; 0x4e5e <Pipe_WaitUntilReady>
    57f0:	81 11       	cpse	r24, r1
    57f2:	2d c0       	rjmp	.+90     	; 0x584e <Pipe_Discard_Stream+0x7c>
    57f4:	01 15       	cp	r16, r1
    57f6:	11 05       	cpc	r17, r1
    57f8:	29 f0       	breq	.+10     	; 0x5804 <Pipe_Discard_Stream+0x32>
    57fa:	f8 01       	movw	r30, r16
    57fc:	80 81       	ld	r24, Z
    57fe:	91 81       	ldd	r25, Z+1	; 0x01
    5800:	c8 1b       	sub	r28, r24
    5802:	d9 0b       	sbc	r29, r25
    5804:	e1 2c       	mov	r14, r1
    5806:	f1 2c       	mov	r15, r1
    5808:	20 97       	sbiw	r28, 0x00	; 0
    580a:	01 f1       	breq	.+64     	; 0x584c <Pipe_Discard_Stream+0x7a>
    580c:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5810:	85 fd       	sbrc	r24, 5
    5812:	15 c0       	rjmp	.+42     	; 0x583e <Pipe_Discard_Stream+0x6c>
    5814:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5818:	8e 77       	andi	r24, 0x7E	; 126
    581a:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    581e:	01 15       	cp	r16, r1
    5820:	11 05       	cpc	r17, r1
    5822:	49 f0       	breq	.+18     	; 0x5836 <Pipe_Discard_Stream+0x64>
    5824:	f8 01       	movw	r30, r16
    5826:	80 81       	ld	r24, Z
    5828:	91 81       	ldd	r25, Z+1	; 0x01
    582a:	e8 0e       	add	r14, r24
    582c:	f9 1e       	adc	r15, r25
    582e:	f1 82       	std	Z+1, r15	; 0x01
    5830:	e0 82       	st	Z, r14
    5832:	84 e0       	ldi	r24, 0x04	; 4
    5834:	0c c0       	rjmp	.+24     	; 0x584e <Pipe_Discard_Stream+0x7c>
    5836:	13 db       	rcall	.-2522   	; 0x4e5e <Pipe_WaitUntilReady>
    5838:	88 23       	and	r24, r24
    583a:	31 f3       	breq	.-52     	; 0x5808 <Pipe_Discard_Stream+0x36>
    583c:	08 c0       	rjmp	.+16     	; 0x584e <Pipe_Discard_Stream+0x7c>
    583e:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <__TEXT_REGION_LENGTH__+0x7e00af>
    5842:	21 97       	sbiw	r28, 0x01	; 1
    5844:	ff ef       	ldi	r31, 0xFF	; 255
    5846:	ef 1a       	sub	r14, r31
    5848:	ff 0a       	sbc	r15, r31
    584a:	de cf       	rjmp	.-68     	; 0x5808 <Pipe_Discard_Stream+0x36>
    584c:	80 e0       	ldi	r24, 0x00	; 0
    584e:	df 91       	pop	r29
    5850:	cf 91       	pop	r28
    5852:	1f 91       	pop	r17
    5854:	0f 91       	pop	r16
    5856:	ff 90       	pop	r15
    5858:	ef 90       	pop	r14
    585a:	08 95       	ret

0000585c <Pipe_Write_Stream_LE>:
    585c:	cf 92       	push	r12
    585e:	df 92       	push	r13
    5860:	ef 92       	push	r14
    5862:	ff 92       	push	r15
    5864:	0f 93       	push	r16
    5866:	1f 93       	push	r17
    5868:	cf 93       	push	r28
    586a:	df 93       	push	r29
    586c:	ec 01       	movw	r28, r24
    586e:	8b 01       	movw	r16, r22
    5870:	7a 01       	movw	r14, r20
    5872:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    5876:	8f 7c       	andi	r24, 0xCF	; 207
    5878:	80 62       	ori	r24, 0x20	; 32
    587a:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    587e:	ef da       	rcall	.-2594   	; 0x4e5e <Pipe_WaitUntilReady>
    5880:	81 11       	cpse	r24, r1
    5882:	32 c0       	rjmp	.+100    	; 0x58e8 <Pipe_Write_Stream_LE+0x8c>
    5884:	e1 14       	cp	r14, r1
    5886:	f1 04       	cpc	r15, r1
    5888:	39 f0       	breq	.+14     	; 0x5898 <Pipe_Write_Stream_LE+0x3c>
    588a:	f7 01       	movw	r30, r14
    588c:	80 81       	ld	r24, Z
    588e:	91 81       	ldd	r25, Z+1	; 0x01
    5890:	08 1b       	sub	r16, r24
    5892:	19 0b       	sbc	r17, r25
    5894:	c8 0f       	add	r28, r24
    5896:	d9 1f       	adc	r29, r25
    5898:	c1 2c       	mov	r12, r1
    589a:	d1 2c       	mov	r13, r1
    589c:	01 15       	cp	r16, r1
    589e:	11 05       	cpc	r17, r1
    58a0:	11 f1       	breq	.+68     	; 0x58e6 <Pipe_Write_Stream_LE+0x8a>
    58a2:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    58a6:	85 fd       	sbrc	r24, 5
    58a8:	15 c0       	rjmp	.+42     	; 0x58d4 <Pipe_Write_Stream_LE+0x78>
    58aa:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    58ae:	8b 77       	andi	r24, 0x7B	; 123
    58b0:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    58b4:	e1 14       	cp	r14, r1
    58b6:	f1 04       	cpc	r15, r1
    58b8:	49 f0       	breq	.+18     	; 0x58cc <Pipe_Write_Stream_LE+0x70>
    58ba:	f7 01       	movw	r30, r14
    58bc:	80 81       	ld	r24, Z
    58be:	91 81       	ldd	r25, Z+1	; 0x01
    58c0:	c8 0e       	add	r12, r24
    58c2:	d9 1e       	adc	r13, r25
    58c4:	d1 82       	std	Z+1, r13	; 0x01
    58c6:	c0 82       	st	Z, r12
    58c8:	84 e0       	ldi	r24, 0x04	; 4
    58ca:	0e c0       	rjmp	.+28     	; 0x58e8 <Pipe_Write_Stream_LE+0x8c>
    58cc:	c8 da       	rcall	.-2672   	; 0x4e5e <Pipe_WaitUntilReady>
    58ce:	88 23       	and	r24, r24
    58d0:	29 f3       	breq	.-54     	; 0x589c <Pipe_Write_Stream_LE+0x40>
    58d2:	0a c0       	rjmp	.+20     	; 0x58e8 <Pipe_Write_Stream_LE+0x8c>
    58d4:	89 91       	ld	r24, Y+
    58d6:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <__TEXT_REGION_LENGTH__+0x7e00af>
    58da:	01 50       	subi	r16, 0x01	; 1
    58dc:	11 09       	sbc	r17, r1
    58de:	ff ef       	ldi	r31, 0xFF	; 255
    58e0:	cf 1a       	sub	r12, r31
    58e2:	df 0a       	sbc	r13, r31
    58e4:	db cf       	rjmp	.-74     	; 0x589c <Pipe_Write_Stream_LE+0x40>
    58e6:	80 e0       	ldi	r24, 0x00	; 0
    58e8:	df 91       	pop	r29
    58ea:	cf 91       	pop	r28
    58ec:	1f 91       	pop	r17
    58ee:	0f 91       	pop	r16
    58f0:	ff 90       	pop	r15
    58f2:	ef 90       	pop	r14
    58f4:	df 90       	pop	r13
    58f6:	cf 90       	pop	r12
    58f8:	08 95       	ret

000058fa <Pipe_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    58fa:	cf 92       	push	r12
    58fc:	df 92       	push	r13
    58fe:	ef 92       	push	r14
    5900:	ff 92       	push	r15
    5902:	0f 93       	push	r16
    5904:	1f 93       	push	r17
    5906:	cf 93       	push	r28
    5908:	df 93       	push	r29
    590a:	ec 01       	movw	r28, r24
    590c:	8b 01       	movw	r16, r22
    590e:	7a 01       	movw	r14, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5910:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    5914:	8f 7c       	andi	r24, 0xCF	; 207
    5916:	80 61       	ori	r24, 0x10	; 16
    5918:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    591c:	a0 da       	rcall	.-2752   	; 0x4e5e <Pipe_WaitUntilReady>
    591e:	81 11       	cpse	r24, r1
    5920:	32 c0       	rjmp	.+100    	; 0x5986 <Pipe_Read_Stream_LE+0x8c>
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5922:	e1 14       	cp	r14, r1
    5924:	f1 04       	cpc	r15, r1
    5926:	39 f0       	breq	.+14     	; 0x5936 <Pipe_Read_Stream_LE+0x3c>
	{
		Length -= *BytesProcessed;
    5928:	f7 01       	movw	r30, r14
    592a:	80 81       	ld	r24, Z
    592c:	91 81       	ldd	r25, Z+1	; 0x01
    592e:	08 1b       	sub	r16, r24
    5930:	19 0b       	sbc	r17, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    5932:	c8 0f       	add	r28, r24
    5934:	d9 1f       	adc	r29, r25

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5936:	c1 2c       	mov	r12, r1
    5938:	d1 2c       	mov	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}
	
	while (Length)
    593a:	01 15       	cp	r16, r1
    593c:	11 05       	cpc	r17, r1
    593e:	11 f1       	breq	.+68     	; 0x5984 <Pipe_Read_Stream_LE+0x8a>
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5940:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5944:	85 fd       	sbrc	r24, 5
    5946:	15 c0       	rjmp	.+42     	; 0x5972 <Pipe_Read_Stream_LE+0x78>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5948:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    594c:	8e 77       	andi	r24, 0x7E	; 126
    594e:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    5952:	e1 14       	cp	r14, r1
    5954:	f1 04       	cpc	r15, r1
    5956:	49 f0       	breq	.+18     	; 0x596a <Pipe_Read_Stream_LE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    5958:	f7 01       	movw	r30, r14
    595a:	80 81       	ld	r24, Z
    595c:	91 81       	ldd	r25, Z+1	; 0x01
    595e:	c8 0e       	add	r12, r24
    5960:	d9 1e       	adc	r13, r25
    5962:	d1 82       	std	Z+1, r13	; 0x01
    5964:	c0 82       	st	Z, r12
				return PIPE_RWSTREAM_IncompleteTransfer;
    5966:	84 e0       	ldi	r24, 0x04	; 4
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5968:	0e c0       	rjmp	.+28     	; 0x5986 <Pipe_Read_Stream_LE+0x8c>
    596a:	79 da       	rcall	.-2830   	; 0x4e5e <Pipe_WaitUntilReady>
    596c:	88 23       	and	r24, r24
    596e:	29 f3       	breq	.-54     	; 0x593a <Pipe_Read_Stream_LE+0x40>
    5970:	0a c0       	rjmp	.+20     	; 0x5986 <Pipe_Read_Stream_LE+0x8c>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    5972:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <__TEXT_REGION_LENGTH__+0x7e00af>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5976:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    5978:	01 50       	subi	r16, 0x01	; 1
    597a:	11 09       	sbc	r17, r1
			BytesInTransfer++;
    597c:	ff ef       	ldi	r31, 0xFF	; 255
    597e:	cf 1a       	sub	r12, r31
    5980:	df 0a       	sbc	r13, r31
    5982:	db cf       	rjmp	.-74     	; 0x593a <Pipe_Read_Stream_LE+0x40>
		}
	}

	return PIPE_RWSTREAM_NoError;
    5984:	80 e0       	ldi	r24, 0x00	; 0
}
    5986:	df 91       	pop	r29
    5988:	cf 91       	pop	r28
    598a:	1f 91       	pop	r17
    598c:	0f 91       	pop	r16
    598e:	ff 90       	pop	r15
    5990:	ef 90       	pop	r14
    5992:	df 90       	pop	r13
    5994:	cf 90       	pop	r12
    5996:	08 95       	ret

00005998 <USB_GetNextDescriptor>:
{
	USB_GetNextDescriptorOfType(BytesRem, CurrConfigLoc, AfterType);

	if (*BytesRem)
	  USB_GetNextDescriptorOfType(BytesRem, CurrConfigLoc, Type);
}
    5998:	cf 93       	push	r28
    599a:	df 93       	push	r29
    599c:	dc 01       	movw	r26, r24
    599e:	eb 01       	movw	r28, r22
    59a0:	e8 81       	ld	r30, Y
    59a2:	f9 81       	ldd	r31, Y+1	; 0x01
    59a4:	20 81       	ld	r18, Z
    59a6:	8d 91       	ld	r24, X+
    59a8:	9c 91       	ld	r25, X
    59aa:	11 97       	sbiw	r26, 0x01	; 1
    59ac:	30 e0       	ldi	r19, 0x00	; 0
    59ae:	82 17       	cp	r24, r18
    59b0:	93 07       	cpc	r25, r19
    59b2:	08 f4       	brcc	.+2      	; 0x59b6 <USB_GetNextDescriptor+0x1e>
    59b4:	9c 01       	movw	r18, r24
    59b6:	e2 0f       	add	r30, r18
    59b8:	f3 1f       	adc	r31, r19
    59ba:	eb 01       	movw	r28, r22
    59bc:	f9 83       	std	Y+1, r31	; 0x01
    59be:	e8 83       	st	Y, r30
    59c0:	8d 91       	ld	r24, X+
    59c2:	9c 91       	ld	r25, X
    59c4:	11 97       	sbiw	r26, 0x01	; 1
    59c6:	82 1b       	sub	r24, r18
    59c8:	93 0b       	sbc	r25, r19
    59ca:	8d 93       	st	X+, r24
    59cc:	9c 93       	st	X, r25
    59ce:	df 91       	pop	r29
    59d0:	cf 91       	pop	r28
    59d2:	08 95       	ret

000059d4 <USB_Host_GetDeviceConfigDescriptor>:
    59d4:	cf 92       	push	r12
    59d6:	df 92       	push	r13
    59d8:	ef 92       	push	r14
    59da:	ff 92       	push	r15
    59dc:	0f 93       	push	r16
    59de:	1f 93       	push	r17
    59e0:	cf 93       	push	r28
    59e2:	df 93       	push	r29
    59e4:	cd b7       	in	r28, 0x3d	; 61
    59e6:	de b7       	in	r29, 0x3e	; 62
    59e8:	29 97       	sbiw	r28, 0x09	; 9
    59ea:	0f b6       	in	r0, 0x3f	; 63
    59ec:	f8 94       	cli
    59ee:	de bf       	out	0x3e, r29	; 62
    59f0:	0f be       	out	0x3f, r0	; 63
    59f2:	cd bf       	out	0x3d, r28	; 61
    59f4:	6b 01       	movw	r12, r22
    59f6:	8a 01       	movw	r16, r20
    59f8:	79 01       	movw	r14, r18
    59fa:	90 e8       	ldi	r25, 0x80	; 128
    59fc:	90 93 8f 0d 	sts	0x0D8F, r25	; 0x800d8f <USB_ControlRequest>
    5a00:	96 e0       	ldi	r25, 0x06	; 6
    5a02:	90 93 90 0d 	sts	0x0D90, r25	; 0x800d90 <USB_ControlRequest+0x1>
    5a06:	90 e0       	ldi	r25, 0x00	; 0
    5a08:	01 97       	sbiw	r24, 0x01	; 1
    5a0a:	92 60       	ori	r25, 0x02	; 2
    5a0c:	90 93 92 0d 	sts	0x0D92, r25	; 0x800d92 <USB_ControlRequest+0x3>
    5a10:	80 93 91 0d 	sts	0x0D91, r24	; 0x800d91 <USB_ControlRequest+0x2>
    5a14:	10 92 94 0d 	sts	0x0D94, r1	; 0x800d94 <USB_ControlRequest+0x5>
    5a18:	10 92 93 0d 	sts	0x0D93, r1	; 0x800d93 <USB_ControlRequest+0x4>
    5a1c:	89 e0       	ldi	r24, 0x09	; 9
    5a1e:	90 e0       	ldi	r25, 0x00	; 0
    5a20:	90 93 96 0d 	sts	0x0D96, r25	; 0x800d96 <USB_ControlRequest+0x7>
    5a24:	80 93 95 0d 	sts	0x0D95, r24	; 0x800d95 <USB_ControlRequest+0x6>
    5a28:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
    5a2c:	ce 01       	movw	r24, r28
    5a2e:	01 96       	adiw	r24, 0x01	; 1
    5a30:	de d1       	rcall	.+956    	; 0x5dee <USB_Host_SendControlRequest>
    5a32:	81 11       	cpse	r24, r1
    5a34:	19 c0       	rjmp	.+50     	; 0x5a68 <USB_Host_GetDeviceConfigDescriptor+0x94>
    5a36:	8b 81       	ldd	r24, Y+3	; 0x03
    5a38:	9c 81       	ldd	r25, Y+4	; 0x04
    5a3a:	f6 01       	movw	r30, r12
    5a3c:	91 83       	std	Z+1, r25	; 0x01
    5a3e:	80 83       	st	Z, r24
    5a40:	e8 16       	cp	r14, r24
    5a42:	f9 06       	cpc	r15, r25
    5a44:	70 f0       	brcs	.+28     	; 0x5a62 <USB_Host_GetDeviceConfigDescriptor+0x8e>
    5a46:	90 93 96 0d 	sts	0x0D96, r25	; 0x800d96 <USB_ControlRequest+0x7>
    5a4a:	80 93 95 0d 	sts	0x0D95, r24	; 0x800d95 <USB_ControlRequest+0x6>
    5a4e:	c8 01       	movw	r24, r16
    5a50:	ce d1       	rcall	.+924    	; 0x5dee <USB_Host_SendControlRequest>
    5a52:	81 11       	cpse	r24, r1
    5a54:	09 c0       	rjmp	.+18     	; 0x5a68 <USB_Host_GetDeviceConfigDescriptor+0x94>
    5a56:	f8 01       	movw	r30, r16
    5a58:	81 81       	ldd	r24, Z+1	; 0x01
    5a5a:	82 30       	cpi	r24, 0x02	; 2
    5a5c:	21 f4       	brne	.+8      	; 0x5a66 <USB_Host_GetDeviceConfigDescriptor+0x92>
    5a5e:	80 e0       	ldi	r24, 0x00	; 0
    5a60:	03 c0       	rjmp	.+6      	; 0x5a68 <USB_Host_GetDeviceConfigDescriptor+0x94>
    5a62:	85 e0       	ldi	r24, 0x05	; 5
    5a64:	01 c0       	rjmp	.+2      	; 0x5a68 <USB_Host_GetDeviceConfigDescriptor+0x94>
    5a66:	86 e0       	ldi	r24, 0x06	; 6
    5a68:	29 96       	adiw	r28, 0x09	; 9
    5a6a:	0f b6       	in	r0, 0x3f	; 63
    5a6c:	f8 94       	cli
    5a6e:	de bf       	out	0x3e, r29	; 62
    5a70:	0f be       	out	0x3f, r0	; 63
    5a72:	cd bf       	out	0x3d, r28	; 61
    5a74:	df 91       	pop	r29
    5a76:	cf 91       	pop	r28
    5a78:	1f 91       	pop	r17
    5a7a:	0f 91       	pop	r16
    5a7c:	ff 90       	pop	r15
    5a7e:	ef 90       	pop	r14
    5a80:	df 90       	pop	r13
    5a82:	cf 90       	pop	r12
    5a84:	08 95       	ret

00005a86 <USB_GetNextDescriptorComp>:

uint8_t USB_GetNextDescriptorComp(uint16_t* const BytesRem,
                                  void** const CurrConfigLoc,
                                  ConfigComparatorPtr_t const ComparatorRoutine)
{
    5a86:	af 92       	push	r10
    5a88:	bf 92       	push	r11
    5a8a:	cf 92       	push	r12
    5a8c:	df 92       	push	r13
    5a8e:	ef 92       	push	r14
    5a90:	ff 92       	push	r15
    5a92:	0f 93       	push	r16
    5a94:	1f 93       	push	r17
    5a96:	cf 93       	push	r28
    5a98:	df 93       	push	r29
    5a9a:	8c 01       	movw	r16, r24
    5a9c:	eb 01       	movw	r28, r22
    5a9e:	6a 01       	movw	r12, r20
	uint8_t ErrorCode;

	while (*BytesRem)
    5aa0:	f8 01       	movw	r30, r16
    5aa2:	e0 80       	ld	r14, Z
    5aa4:	f1 80       	ldd	r15, Z+1	; 0x01
    5aa6:	e1 14       	cp	r14, r1
    5aa8:	f1 04       	cpc	r15, r1
    5aaa:	99 f0       	breq	.+38     	; 0x5ad2 <USB_GetNextDescriptorComp+0x4c>
	{
		uint8_t* PrevDescLoc  = *CurrConfigLoc;
    5aac:	a8 80       	ld	r10, Y
    5aae:	b9 80       	ldd	r11, Y+1	; 0x01
		uint16_t PrevBytesRem = *BytesRem;

		USB_GetNextDescriptor(BytesRem, CurrConfigLoc);
    5ab0:	be 01       	movw	r22, r28
    5ab2:	c8 01       	movw	r24, r16
    5ab4:	71 df       	rcall	.-286    	; 0x5998 <USB_GetNextDescriptor>

		if ((ErrorCode = ComparatorRoutine(*CurrConfigLoc)) != DESCRIPTOR_SEARCH_NotFound)
    5ab6:	88 81       	ld	r24, Y
    5ab8:	99 81       	ldd	r25, Y+1	; 0x01
    5aba:	f6 01       	movw	r30, r12
    5abc:	09 95       	icall
    5abe:	82 30       	cpi	r24, 0x02	; 2
    5ac0:	79 f3       	breq	.-34     	; 0x5aa0 <USB_GetNextDescriptorComp+0x1a>
		{
			if (ErrorCode == DESCRIPTOR_SEARCH_Fail)
    5ac2:	81 30       	cpi	r24, 0x01	; 1
    5ac4:	39 f4       	brne	.+14     	; 0x5ad4 <USB_GetNextDescriptorComp+0x4e>
			{
				*CurrConfigLoc = PrevDescLoc;
    5ac6:	b9 82       	std	Y+1, r11	; 0x01
    5ac8:	a8 82       	st	Y, r10
				*BytesRem      = PrevBytesRem;
    5aca:	f8 01       	movw	r30, r16
    5acc:	f1 82       	std	Z+1, r15	; 0x01
    5ace:	e0 82       	st	Z, r14
    5ad0:	01 c0       	rjmp	.+2      	; 0x5ad4 <USB_GetNextDescriptorComp+0x4e>

			return ErrorCode;
		}
	}

	return DESCRIPTOR_SEARCH_COMP_EndOfDescriptor;
    5ad2:	82 e0       	ldi	r24, 0x02	; 2
}
    5ad4:	df 91       	pop	r29
    5ad6:	cf 91       	pop	r28
    5ad8:	1f 91       	pop	r17
    5ada:	0f 91       	pop	r16
    5adc:	ff 90       	pop	r15
    5ade:	ef 90       	pop	r14
    5ae0:	df 90       	pop	r13
    5ae2:	cf 90       	pop	r12
    5ae4:	bf 90       	pop	r11
    5ae6:	af 90       	pop	r10
    5ae8:	08 95       	ret

00005aea <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    5aea:	0f 93       	push	r16
    5aec:	1f 93       	push	r17
    5aee:	cf 93       	push	r28
    5af0:	df 93       	push	r29
    5af2:	cd b7       	in	r28, 0x3d	; 61
    5af4:	de b7       	in	r29, 0x3e	; 62
    5af6:	aa 97       	sbiw	r28, 0x2a	; 42
    5af8:	0f b6       	in	r0, 0x3f	; 63
    5afa:	f8 94       	cli
    5afc:	de bf       	out	0x3e, r29	; 62
    5afe:	0f be       	out	0x3f, r0	; 63
    5b00:	cd bf       	out	0x3d, r28	; 61
    5b02:	ef e8       	ldi	r30, 0x8F	; 143
    5b04:	fd e0       	ldi	r31, 0x0D	; 13
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    5b06:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    5b0a:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    5b0c:	2d e0       	ldi	r18, 0x0D	; 13
    5b0e:	e7 39       	cpi	r30, 0x97	; 151
    5b10:	f2 07       	cpc	r31, r18
    5b12:	c9 f7       	brne	.-14     	; 0x5b06 <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    5b14:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5b18:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsSETUPReceived())
    5b1c:	83 ff       	sbrs	r24, 3
    5b1e:	26 c1       	rjmp	.+588    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    5b20:	80 91 8f 0d 	lds	r24, 0x0D8F	; 0x800d8f <USB_ControlRequest>

		switch (USB_ControlRequest.bRequest)
    5b24:	90 91 90 0d 	lds	r25, 0x0D90	; 0x800d90 <USB_ControlRequest+0x1>
    5b28:	49 2f       	mov	r20, r25
    5b2a:	50 e0       	ldi	r21, 0x00	; 0
    5b2c:	4a 30       	cpi	r20, 0x0A	; 10
    5b2e:	51 05       	cpc	r21, r1
    5b30:	08 f0       	brcs	.+2      	; 0x5b34 <USB_Device_ProcessControlRequest+0x4a>
    5b32:	1c c1       	rjmp	.+568    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
    5b34:	fa 01       	movw	r30, r20
    5b36:	e2 5a       	subi	r30, 0xA2	; 162
    5b38:	ff 4f       	sbci	r31, 0xFF	; 255
    5b3a:	0c 94 da 39 	jmp	0x73b4	; 0x73b4 <__tablejump2__>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5b3e:	80 38       	cpi	r24, 0x80	; 128
    5b40:	81 f0       	breq	.+32     	; 0x5b62 <USB_Device_ProcessControlRequest+0x78>
    5b42:	82 38       	cpi	r24, 0x82	; 130
    5b44:	09 f0       	breq	.+2      	; 0x5b48 <USB_Device_ProcessControlRequest+0x5e>
    5b46:	12 c1       	rjmp	.+548    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    5b48:	80 91 93 0d 	lds	r24, 0x0D93	; 0x800d93 <USB_ControlRequest+0x4>
    5b4c:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    5b4e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    5b52:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>

			CurrentStatus = Endpoint_IsStalled();
    5b56:	85 fb       	bst	r24, 5
    5b58:	88 27       	eor	r24, r24
    5b5a:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    5b5c:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    5b60:	06 c0       	rjmp	.+12     	; 0x5b6e <USB_Device_ProcessControlRequest+0x84>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    5b62:	80 91 8b 0d 	lds	r24, 0x0D8B	; 0x800d8b <USB_Device_CurrentlySelfPowered>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    5b66:	90 91 8c 0d 	lds	r25, 0x0D8C	; 0x800d8c <USB_Device_RemoteWakeupEnabled>
    5b6a:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    5b6c:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5b6e:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5b72:	97 7f       	andi	r25, 0xF7	; 247
    5b74:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    5b78:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
				UEDATX = (Data >> 8);
    5b7c:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    5b80:	cb c0       	rjmp	.+406    	; 0x5d18 <USB_Device_ProcessControlRequest+0x22e>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5b82:	28 2f       	mov	r18, r24
    5b84:	2d 7f       	andi	r18, 0xFD	; 253
    5b86:	09 f0       	breq	.+2      	; 0x5b8a <USB_Device_ProcessControlRequest+0xa0>
    5b88:	f1 c0       	rjmp	.+482    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    5b8a:	88 23       	and	r24, r24
    5b8c:	19 f0       	breq	.+6      	; 0x5b94 <USB_Device_ProcessControlRequest+0xaa>
    5b8e:	82 30       	cpi	r24, 0x02	; 2
    5b90:	79 f0       	breq	.+30     	; 0x5bb0 <USB_Device_ProcessControlRequest+0xc6>
    5b92:	ec c0       	rjmp	.+472    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    5b94:	20 91 91 0d 	lds	r18, 0x0D91	; 0x800d91 <USB_ControlRequest+0x2>
    5b98:	30 91 92 0d 	lds	r19, 0x0D92	; 0x800d92 <USB_ControlRequest+0x3>
    5b9c:	21 30       	cpi	r18, 0x01	; 1
    5b9e:	09 f0       	breq	.+2      	; 0x5ba2 <USB_Device_ProcessControlRequest+0xb8>
    5ba0:	e5 c0       	rjmp	.+458    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    5ba2:	81 e0       	ldi	r24, 0x01	; 1
    5ba4:	93 30       	cpi	r25, 0x03	; 3
    5ba6:	09 f0       	breq	.+2      	; 0x5baa <USB_Device_ProcessControlRequest+0xc0>
    5ba8:	80 e0       	ldi	r24, 0x00	; 0
    5baa:	80 93 8c 0d 	sts	0x0D8C, r24	; 0x800d8c <USB_Device_RemoteWakeupEnabled>
    5bae:	2d c0       	rjmp	.+90     	; 0x5c0a <USB_Device_ProcessControlRequest+0x120>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    5bb0:	20 91 91 0d 	lds	r18, 0x0D91	; 0x800d91 <USB_ControlRequest+0x2>
    5bb4:	30 91 92 0d 	lds	r19, 0x0D92	; 0x800d92 <USB_ControlRequest+0x3>
    5bb8:	21 11       	cpse	r18, r1
    5bba:	27 c0       	rjmp	.+78     	; 0x5c0a <USB_Device_ProcessControlRequest+0x120>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    5bbc:	80 91 93 0d 	lds	r24, 0x0D93	; 0x800d93 <USB_ControlRequest+0x4>
    5bc0:	87 70       	andi	r24, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    5bc2:	09 f4       	brne	.+2      	; 0x5bc6 <USB_Device_ProcessControlRequest+0xdc>
    5bc4:	d3 c0       	rjmp	.+422    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    5bc6:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    5bca:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    5bce:	20 ff       	sbrs	r18, 0
    5bd0:	1c c0       	rjmp	.+56     	; 0x5c0a <USB_Device_ProcessControlRequest+0x120>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    5bd2:	93 30       	cpi	r25, 0x03	; 3
    5bd4:	21 f4       	brne	.+8      	; 0x5bde <USB_Device_ProcessControlRequest+0xf4>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    5bd6:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    5bda:	80 62       	ori	r24, 0x20	; 32
    5bdc:	14 c0       	rjmp	.+40     	; 0x5c06 <USB_Device_ProcessControlRequest+0x11c>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    5bde:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    5be2:	90 61       	ori	r25, 0x10	; 16
    5be4:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    5be8:	21 e0       	ldi	r18, 0x01	; 1
    5bea:	30 e0       	ldi	r19, 0x00	; 0
    5bec:	a9 01       	movw	r20, r18
    5bee:	02 c0       	rjmp	.+4      	; 0x5bf4 <USB_Device_ProcessControlRequest+0x10a>
    5bf0:	44 0f       	add	r20, r20
    5bf2:	55 1f       	adc	r21, r21
    5bf4:	8a 95       	dec	r24
    5bf6:	e2 f7       	brpl	.-8      	; 0x5bf0 <USB_Device_ProcessControlRequest+0x106>
    5bf8:	40 93 ea 00 	sts	0x00EA, r20	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>
				UERST = 0;
    5bfc:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    5c00:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    5c04:	88 60       	ori	r24, 0x08	; 8
    5c06:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    5c0a:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5c0e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5c12:	87 7f       	andi	r24, 0xF7	; 247
    5c14:	84 c0       	rjmp	.+264    	; 0x5d1e <USB_Device_ProcessControlRequest+0x234>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    5c16:	81 11       	cpse	r24, r1
    5c18:	a9 c0       	rjmp	.+338    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    5c1a:	10 91 91 0d 	lds	r17, 0x0D91	; 0x800d91 <USB_ControlRequest+0x2>
    5c1e:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    5c20:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    5c22:	f8 94       	cli
    5c24:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5c28:	87 7f       	andi	r24, 0xF7	; 247
    5c2a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    5c2e:	0e 94 90 24 	call	0x4920	; 0x4920 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5c32:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	while (!(Endpoint_IsINReady()));
    5c36:	80 ff       	sbrs	r24, 0
    5c38:	fc cf       	rjmp	.-8      	; 0x5c32 <USB_Device_ProcessControlRequest+0x148>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    5c3a:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
    5c3e:	80 78       	andi	r24, 0x80	; 128
    5c40:	81 2b       	or	r24, r17

				UDADDR = Temp;
    5c42:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
				UDADDR = Temp | (1 << ADDEN);
    5c46:	80 68       	ori	r24, 0x80	; 128
    5c48:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    5c4c:	11 11       	cpse	r17, r1
    5c4e:	02 c0       	rjmp	.+4      	; 0x5c54 <USB_Device_ProcessControlRequest+0x16a>
    5c50:	82 e0       	ldi	r24, 0x02	; 2
    5c52:	01 c0       	rjmp	.+2      	; 0x5c56 <USB_Device_ProcessControlRequest+0x16c>
    5c54:	83 e0       	ldi	r24, 0x03	; 3
    5c56:	8e bb       	out	0x1e, r24	; 30
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    5c58:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    5c5a:	88 c0       	rjmp	.+272    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5c5c:	80 58       	subi	r24, 0x80	; 128
    5c5e:	82 30       	cpi	r24, 0x02	; 2
    5c60:	08 f0       	brcs	.+2      	; 0x5c64 <USB_Device_ProcessControlRequest+0x17a>
    5c62:	84 c0       	rjmp	.+264    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    5c64:	80 91 91 0d 	lds	r24, 0x0D91	; 0x800d91 <USB_ControlRequest+0x2>
    5c68:	90 91 92 0d 	lds	r25, 0x0D92	; 0x800d92 <USB_ControlRequest+0x3>
    5c6c:	8c 3d       	cpi	r24, 0xDC	; 220
    5c6e:	53 e0       	ldi	r21, 0x03	; 3
    5c70:	95 07       	cpc	r25, r21
    5c72:	71 f5       	brne	.+92     	; 0x5cd0 <USB_Device_ProcessControlRequest+0x1e6>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    5c74:	83 e0       	ldi	r24, 0x03	; 3
    5c76:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    5c78:	8a e2       	ldi	r24, 0x2A	; 42
    5c7a:	89 83       	std	Y+1, r24	; 0x01
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    5c7c:	4f b7       	in	r20, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    5c7e:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    5c80:	de 01       	movw	r26, r28
    5c82:	13 96       	adiw	r26, 0x03	; 3
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    5c84:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    5c86:	3e e0       	ldi	r19, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    5c88:	51 e2       	ldi	r21, 0x21	; 33
    5c8a:	e3 2f       	mov	r30, r19
    5c8c:	f0 e0       	ldi	r31, 0x00	; 0
    5c8e:	50 93 57 00 	sts	0x0057, r21	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    5c92:	e4 91       	lpm	r30, Z

					if (SerialCharNum & 0x01)
    5c94:	20 ff       	sbrs	r18, 0
    5c96:	03 c0       	rjmp	.+6      	; 0x5c9e <USB_Device_ProcessControlRequest+0x1b4>
					{
						SerialByte >>= 4;
    5c98:	e2 95       	swap	r30
    5c9a:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    5c9c:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    5c9e:	ef 70       	andi	r30, 0x0F	; 15
    5ca0:	8e 2f       	mov	r24, r30
    5ca2:	90 e0       	ldi	r25, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    5ca4:	ea 30       	cpi	r30, 0x0A	; 10
    5ca6:	10 f0       	brcs	.+4      	; 0x5cac <USB_Device_ProcessControlRequest+0x1c2>
    5ca8:	c7 96       	adiw	r24, 0x37	; 55
    5caa:	01 c0       	rjmp	.+2      	; 0x5cae <USB_Device_ProcessControlRequest+0x1c4>
    5cac:	c0 96       	adiw	r24, 0x30	; 48
    5cae:	8d 93       	st	X+, r24
    5cb0:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    5cb2:	2f 5f       	subi	r18, 0xFF	; 255
    5cb4:	24 31       	cpi	r18, 0x14	; 20
    5cb6:	49 f7       	brne	.-46     	; 0x5c8a <USB_Device_ProcessControlRequest+0x1a0>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    5cb8:	4f bf       	out	0x3f, r20	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5cba:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5cbe:	87 7f       	andi	r24, 0xF7	; 247
    5cc0:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    5cc4:	6a e2       	ldi	r22, 0x2A	; 42
    5cc6:	70 e0       	ldi	r23, 0x00	; 0
    5cc8:	ce 01       	movw	r24, r28
    5cca:	01 96       	adiw	r24, 0x01	; 1
    5ccc:	99 dc       	rcall	.-1742   	; 0x5600 <Endpoint_Write_Control_Stream_LE>
    5cce:	13 c0       	rjmp	.+38     	; 0x5cf6 <USB_Device_ProcessControlRequest+0x20c>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    5cd0:	ae 01       	movw	r20, r28
    5cd2:	4f 5f       	subi	r20, 0xFF	; 255
    5cd4:	5f 4f       	sbci	r21, 0xFF	; 255
    5cd6:	60 91 93 0d 	lds	r22, 0x0D93	; 0x800d93 <USB_ControlRequest+0x4>
    5cda:	0e 94 86 02 	call	0x50c	; 0x50c <CALLBACK_USB_GetDescriptor>
    5cde:	bc 01       	movw	r22, r24
    5ce0:	89 2b       	or	r24, r25
    5ce2:	09 f4       	brne	.+2      	; 0x5ce6 <USB_Device_ProcessControlRequest+0x1fc>
    5ce4:	43 c0       	rjmp	.+134    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
    5ce6:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5cea:	97 7f       	andi	r25, 0xF7	; 247
    5cec:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    5cf0:	89 81       	ldd	r24, Y+1	; 0x01
    5cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    5cf4:	17 dd       	rcall	.-1490   	; 0x5724 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5cf6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5cfa:	8b 77       	andi	r24, 0x7B	; 123
    5cfc:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5d00:	35 c0       	rjmp	.+106    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    5d02:	80 38       	cpi	r24, 0x80	; 128
    5d04:	99 f5       	brne	.+102    	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5d06:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5d0a:	87 7f       	andi	r24, 0xF7	; 247
    5d0c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    5d10:	80 91 8a 0d 	lds	r24, 0x0D8A	; 0x800d8a <USB_Device_ConfigurationNumber>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5d14:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5d18:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5d1c:	8e 77       	andi	r24, 0x7E	; 126
    5d1e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    5d22:	0e 94 90 24 	call	0x4920	; 0x4920 <Endpoint_ClearStatusStage>
    5d26:	22 c0       	rjmp	.+68     	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    5d28:	81 11       	cpse	r24, r1
    5d2a:	20 c0       	rjmp	.+64     	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    5d2c:	80 91 91 0d 	lds	r24, 0x0D91	; 0x800d91 <USB_ControlRequest+0x2>
    5d30:	90 91 92 0d 	lds	r25, 0x0D92	; 0x800d92 <USB_ControlRequest+0x3>
    5d34:	99 27       	eor	r25, r25
    5d36:	02 97       	sbiw	r24, 0x02	; 2
    5d38:	cc f4       	brge	.+50     	; 0x5d6c <USB_Device_ProcessControlRequest+0x282>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5d3a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5d3e:	87 7f       	andi	r24, 0xF7	; 247
    5d40:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    5d44:	80 91 91 0d 	lds	r24, 0x0D91	; 0x800d91 <USB_ControlRequest+0x2>
    5d48:	80 93 8a 0d 	sts	0x0D8A, r24	; 0x800d8a <USB_Device_ConfigurationNumber>

	Endpoint_ClearStatusStage();
    5d4c:	0e 94 90 24 	call	0x4920	; 0x4920 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    5d50:	80 91 8a 0d 	lds	r24, 0x0D8A	; 0x800d8a <USB_Device_ConfigurationNumber>
    5d54:	81 11       	cpse	r24, r1
    5d56:	06 c0       	rjmp	.+12     	; 0x5d64 <USB_Device_ProcessControlRequest+0x27a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    5d58:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    5d5c:	87 fd       	sbrc	r24, 7
    5d5e:	02 c0       	rjmp	.+4      	; 0x5d64 <USB_Device_ProcessControlRequest+0x27a>
    5d60:	81 e0       	ldi	r24, 0x01	; 1
    5d62:	01 c0       	rjmp	.+2      	; 0x5d66 <USB_Device_ProcessControlRequest+0x27c>
    5d64:	84 e0       	ldi	r24, 0x04	; 4
    5d66:	8e bb       	out	0x1e, r24	; 30

	EVENT_USB_Device_ConfigurationChanged();
    5d68:	0e 94 ce 02 	call	0x59c	; 0x59c <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5d6c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    5d70:	83 ff       	sbrs	r24, 3
    5d72:	0a c0       	rjmp	.+20     	; 0x5d88 <USB_Device_ProcessControlRequest+0x29e>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    5d74:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    5d78:	80 62       	ori	r24, 0x20	; 32
    5d7a:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5d7e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    5d82:	87 7f       	andi	r24, 0xF7	; 247
    5d84:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    5d88:	aa 96       	adiw	r28, 0x2a	; 42
    5d8a:	0f b6       	in	r0, 0x3f	; 63
    5d8c:	f8 94       	cli
    5d8e:	de bf       	out	0x3e, r29	; 62
    5d90:	0f be       	out	0x3f, r0	; 63
    5d92:	cd bf       	out	0x3d, r28	; 61
    5d94:	df 91       	pop	r29
    5d96:	cf 91       	pop	r28
    5d98:	1f 91       	pop	r17
    5d9a:	0f 91       	pop	r16
    5d9c:	08 95       	ret

00005d9e <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    5d9e:	08 95       	ret

00005da0 <USB_Host_WaitForIOS>:

	return ReturnStatus;
}

static uint8_t USB_Host_WaitForIOS(const uint8_t WaitType)
{
    5da0:	1f 93       	push	r17
    5da2:	cf 93       	push	r28
    5da4:	df 93       	push	r29
    5da6:	18 2f       	mov	r17, r24
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    5da8:	c9 ee       	ldi	r28, 0xE9	; 233
    5daa:	d3 e0       	ldi	r29, 0x03	; 3
    5dac:	11 11       	cpse	r17, r1
    5dae:	0d c0       	rjmp	.+26     	; 0x5dca <USB_Host_WaitForIOS+0x2a>
			 *  \return Boolean \c true if the current pipe is ready for a SETUP packet, \c false otherwise.
			 */
			static inline bool Pipe_IsSETUPSent(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsSETUPSent(void)
			{
				return ((UPINTX & (1 << TXSTPI)) ? true : false);
    5db0:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5db4:	83 fd       	sbrc	r24, 3
    5db6:	16 c0       	rjmp	.+44     	; 0x5de4 <USB_Host_WaitForIOS+0x44>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
	{
		uint8_t ErrorCode;

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5db8:	81 e0       	ldi	r24, 0x01	; 1
    5dba:	0e 94 30 25 	call	0x4a60	; 0x4a60 <USB_Host_WaitMS>
    5dbe:	81 11       	cpse	r24, r1
    5dc0:	12 c0       	rjmp	.+36     	; 0x5de6 <USB_Host_WaitForIOS+0x46>
    5dc2:	21 97       	sbiw	r28, 0x01	; 1
		  return ErrorCode;

		if (!(TimeoutCounter--))
    5dc4:	99 f7       	brne	.-26     	; 0x5dac <USB_Host_WaitForIOS+0xc>
		  return HOST_SENDCONTROL_SoftwareTimeOut;
    5dc6:	84 e0       	ldi	r24, 0x04	; 4
    5dc8:	0e c0       	rjmp	.+28     	; 0x5de6 <USB_Host_WaitForIOS+0x46>
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    5dca:	11 30       	cpi	r17, 0x01	; 1
    5dcc:	29 f4       	brne	.+10     	; 0x5dd8 <USB_Host_WaitForIOS+0x38>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    5dce:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
    5dd2:	80 ff       	sbrs	r24, 0
    5dd4:	f1 cf       	rjmp	.-30     	; 0x5db8 <USB_Host_WaitForIOS+0x18>
    5dd6:	06 c0       	rjmp	.+12     	; 0x5de4 <USB_Host_WaitForIOS+0x44>
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    5dd8:	12 30       	cpi	r17, 0x02	; 2
    5dda:	71 f7       	brne	.-36     	; 0x5db8 <USB_Host_WaitForIOS+0x18>
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    5ddc:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
    5de0:	82 ff       	sbrs	r24, 2
    5de2:	ea cf       	rjmp	.-44     	; 0x5db8 <USB_Host_WaitForIOS+0x18>

		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
	}

	return HOST_SENDCONTROL_Successful;
    5de4:	80 e0       	ldi	r24, 0x00	; 0
}
    5de6:	df 91       	pop	r29
    5de8:	cf 91       	pop	r28
    5dea:	1f 91       	pop	r17
    5dec:	08 95       	ret

00005dee <USB_Host_SendControlRequest>:
#include "HostStandardReq.h"

uint8_t USB_Host_ConfigurationNumber;

uint8_t USB_Host_SendControlRequest(void* const BufferPtr)
{
    5dee:	ff 92       	push	r15
    5df0:	0f 93       	push	r16
    5df2:	1f 93       	push	r17
    5df4:	cf 93       	push	r28
    5df6:	df 93       	push	r29
    5df8:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    5dfa:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    5dfe:	81 70       	andi	r24, 0x01	; 1
    5e00:	f8 2e       	mov	r15, r24
	uint8_t* DataStream   = (uint8_t*)BufferPtr;
	bool     BusSuspended = USB_Host_IsBusSuspended();
	uint8_t  ReturnStatus = HOST_SENDCONTROL_Successful;
	uint16_t DataLen      = USB_ControlRequest.wLength;
    5e02:	00 91 95 0d 	lds	r16, 0x0D95	; 0x800d95 <USB_ControlRequest+0x6>
    5e06:	10 91 96 0d 	lds	r17, 0x0D96	; 0x800d96 <USB_ControlRequest+0x7>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    5e0a:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    5e0e:	81 60       	ori	r24, 0x01	; 1
    5e10:	80 93 9e 00 	sts	0x009E, r24	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>

	USB_Host_ResumeBus();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5e14:	81 e0       	ldi	r24, 0x01	; 1
    5e16:	0e 94 30 25 	call	0x4a60	; 0x4a60 <USB_Host_WaitMS>
    5e1a:	81 11       	cpse	r24, r1
    5e1c:	cb c0       	rjmp	.+406    	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5e1e:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    5e22:	8f 7c       	andi	r24, 0xCF	; 207
    5e24:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    5e28:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <__TEXT_REGION_LENGTH__+0x7e00f5>
				UPINTX &= ~(1 << PERRI);
    5e2c:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5e30:	8f 7e       	andi	r24, 0xEF	; 239
    5e32:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5e36:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5e3a:	8f 7b       	andi	r24, 0xBF	; 191
    5e3c:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5e40:	ef e8       	ldi	r30, 0x8F	; 143
    5e42:	fd e0       	ldi	r31, 0x0D	; 13
    5e44:	87 e9       	ldi	r24, 0x97	; 151
    5e46:	9d e0       	ldi	r25, 0x0D	; 13
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
	#else
	uint8_t* HeaderStream = (uint8_t*)&USB_ControlRequest;

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
	  Pipe_Write_8(*(HeaderStream++));	
    5e48:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    5e4a:	20 93 af 00 	sts	0x00AF, r18	; 0x8000af <__TEXT_REGION_LENGTH__+0x7e00af>
	Pipe_Write_16_LE(USB_ControlRequest.wIndex);
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
	#else
	uint8_t* HeaderStream = (uint8_t*)&USB_ControlRequest;

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
    5e4e:	8e 17       	cp	r24, r30
    5e50:	9f 07       	cpc	r25, r31
    5e52:	d1 f7       	brne	.-12     	; 0x5e48 <USB_Host_SendControlRequest+0x5a>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearSETUP(void)
			{
				UPINTX &= ~((1 << TXSTPI) | (1 << FIFOCON));
    5e54:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5e58:	87 77       	andi	r24, 0x77	; 119
    5e5a:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
	  Pipe_Write_8(*(HeaderStream++));	
	#endif
	
	Pipe_ClearSETUP();

	if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_SetupSent)) != HOST_SENDCONTROL_Successful)
    5e5e:	80 e0       	ldi	r24, 0x00	; 0
    5e60:	9f df       	rcall	.-194    	; 0x5da0 <USB_Host_WaitForIOS>
    5e62:	81 11       	cpse	r24, r1
    5e64:	a7 c0       	rjmp	.+334    	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5e66:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5e6a:	80 64       	ori	r24, 0x40	; 64
    5e6c:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
	  goto End_Of_Control_Send;

	Pipe_Freeze();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5e70:	81 e0       	ldi	r24, 0x01	; 1
    5e72:	0e 94 30 25 	call	0x4a60	; 0x4a60 <USB_Host_WaitMS>
    5e76:	81 11       	cpse	r24, r1
    5e78:	9d c0       	rjmp	.+314    	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>
	  goto End_Of_Control_Send;

	if ((USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION) == REQDIR_DEVICETOHOST)
    5e7a:	80 91 8f 0d 	lds	r24, 0x0D8F	; 0x800d8f <USB_ControlRequest>
    5e7e:	87 ff       	sbrs	r24, 7
    5e80:	50 c0       	rjmp	.+160    	; 0x5f22 <USB_Host_SendControlRequest+0x134>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5e82:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    5e86:	8f 7c       	andi	r24, 0xCF	; 207
    5e88:	80 61       	ori	r24, 0x10	; 16
    5e8a:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
    5e8e:	20 97       	sbiw	r28, 0x00	; 0
    5e90:	09 f0       	breq	.+2      	; 0x5e94 <USB_Host_SendControlRequest+0xa6>
    5e92:	3a c0       	rjmp	.+116    	; 0x5f08 <USB_Host_SendControlRequest+0x11a>
    5e94:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    5e98:	8f 7c       	andi	r24, 0xCF	; 207
    5e9a:	80 62       	ori	r24, 0x20	; 32
    5e9c:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5ea0:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5ea4:	8f 7b       	andi	r24, 0xBF	; 191
    5ea6:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
		}

		Pipe_SetPipeToken(PIPE_TOKEN_OUT);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5eaa:	82 e0       	ldi	r24, 0x02	; 2
    5eac:	79 df       	rcall	.-270    	; 0x5da0 <USB_Host_WaitForIOS>
    5eae:	81 11       	cpse	r24, r1
    5eb0:	81 c0       	rjmp	.+258    	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5eb2:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5eb6:	8b 77       	andi	r24, 0x7B	; 123
    5eb8:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
		  goto End_Of_Control_Send;

		Pipe_ClearOUT();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5ebc:	82 e0       	ldi	r24, 0x02	; 2
    5ebe:	70 df       	rcall	.-288    	; 0x5da0 <USB_Host_WaitForIOS>
    5ec0:	79 c0       	rjmp	.+242    	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5ec2:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5ec6:	8f 7b       	andi	r24, 0xBF	; 191
    5ec8:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
		{
			while (DataLen)
			{
				Pipe_Unfreeze();

				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    5ecc:	81 e0       	ldi	r24, 0x01	; 1
    5ece:	68 df       	rcall	.-304    	; 0x5da0 <USB_Host_WaitForIOS>
    5ed0:	81 11       	cpse	r24, r1
    5ed2:	70 c0       	rjmp	.+224    	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    5ed4:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
    5ed8:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
				  goto End_Of_Control_Send;

				if (!(Pipe_BytesInPipe()))
    5edc:	89 2b       	or	r24, r25
    5ede:	11 f4       	brne	.+4      	; 0x5ee4 <USB_Host_SendControlRequest+0xf6>
				  DataLen = 0;
    5ee0:	00 e0       	ldi	r16, 0x00	; 0
    5ee2:	10 e0       	ldi	r17, 0x00	; 0
    5ee4:	fe 01       	movw	r30, r28
    5ee6:	ef 01       	movw	r28, r30
    5ee8:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
    5eec:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>

				while (Pipe_BytesInPipe() && DataLen)
    5ef0:	89 2b       	or	r24, r25
    5ef2:	71 f4       	brne	.+28     	; 0x5f10 <USB_Host_SendControlRequest+0x122>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5ef4:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5ef8:	80 64       	ori	r24, 0x40	; 64
    5efa:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5efe:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5f02:	8e 77       	andi	r24, 0x7E	; 126
    5f04:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
		{
			while (DataLen)
    5f08:	01 15       	cp	r16, r1
    5f0a:	11 05       	cpc	r17, r1
    5f0c:	d1 f6       	brne	.-76     	; 0x5ec2 <USB_Host_SendControlRequest+0xd4>
    5f0e:	c2 cf       	rjmp	.-124    	; 0x5e94 <USB_Host_SendControlRequest+0xa6>
				  goto End_Of_Control_Send;

				if (!(Pipe_BytesInPipe()))
				  DataLen = 0;

				while (Pipe_BytesInPipe() && DataLen)
    5f10:	01 15       	cp	r16, r1
    5f12:	11 05       	cpc	r17, r1
    5f14:	79 f3       	breq	.-34     	; 0x5ef4 <USB_Host_SendControlRequest+0x106>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    5f16:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <__TEXT_REGION_LENGTH__+0x7e00af>
				{
					*(DataStream++) = Pipe_Read_8();
    5f1a:	81 93       	st	Z+, r24
					DataLen--;
    5f1c:	01 50       	subi	r16, 0x01	; 1
    5f1e:	11 09       	sbc	r17, r1
    5f20:	e2 cf       	rjmp	.-60     	; 0x5ee6 <USB_Host_SendControlRequest+0xf8>
		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
		  goto End_Of_Control_Send;
	}
	else
	{
		if (DataStream != NULL)
    5f22:	20 97       	sbiw	r28, 0x00	; 0
    5f24:	99 f1       	breq	.+102    	; 0x5f8c <USB_Host_SendControlRequest+0x19e>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5f26:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    5f2a:	8f 7c       	andi	r24, 0xCF	; 207
    5f2c:	80 62       	ori	r24, 0x20	; 32
    5f2e:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5f32:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5f36:	8f 7b       	andi	r24, 0xBF	; 191
    5f38:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
		{
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
    5f3c:	82 e0       	ldi	r24, 0x02	; 2
    5f3e:	01 15       	cp	r16, r1
    5f40:	11 05       	cpc	r17, r1
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5f42:	e1 f0       	breq	.+56     	; 0x5f7c <USB_Host_SendControlRequest+0x18e>
    5f44:	2d df       	rcall	.-422    	; 0x5da0 <USB_Host_WaitForIOS>
    5f46:	81 11       	cpse	r24, r1
    5f48:	35 c0       	rjmp	.+106    	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    5f4a:	20 91 f6 00 	lds	r18, 0x00F6	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
    5f4e:	30 91 f7 00 	lds	r19, 0x00F7	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
				  goto End_Of_Control_Send;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
    5f52:	80 91 fe 01 	lds	r24, 0x01FE	; 0x8001fe <USB_Host_ControlPipeSize>
    5f56:	90 e0       	ldi	r25, 0x00	; 0
    5f58:	28 17       	cp	r18, r24
    5f5a:	39 07       	cpc	r19, r25
    5f5c:	48 f4       	brcc	.+18     	; 0x5f70 <USB_Host_SendControlRequest+0x182>
				{
					Pipe_Write_8(*(DataStream++));
    5f5e:	21 96       	adiw	r28, 0x01	; 1
    5f60:	fe 01       	movw	r30, r28
    5f62:	31 97       	sbiw	r30, 0x01	; 1
    5f64:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    5f66:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <__TEXT_REGION_LENGTH__+0x7e00af>
					DataLen--;
    5f6a:	01 50       	subi	r16, 0x01	; 1
    5f6c:	11 09       	sbc	r17, r1
			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
				  goto End_Of_Control_Send;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
    5f6e:	69 f7       	brne	.-38     	; 0x5f4a <USB_Host_SendControlRequest+0x15c>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5f70:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5f74:	8b 77       	andi	r24, 0x7B	; 123
    5f76:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
				}

				Pipe_ClearOUT();
			}

			if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5f7a:	e0 cf       	rjmp	.-64     	; 0x5f3c <USB_Host_SendControlRequest+0x14e>
    5f7c:	11 df       	rcall	.-478    	; 0x5da0 <USB_Host_WaitForIOS>
    5f7e:	81 11       	cpse	r24, r1
    5f80:	19 c0       	rjmp	.+50     	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5f82:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5f86:	80 64       	ori	r24, 0x40	; 64
    5f88:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5f8c:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
    5f90:	8f 7c       	andi	r24, 0xCF	; 207
    5f92:	80 61       	ori	r24, 0x10	; 16
    5f94:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5f98:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5f9c:	8f 7b       	andi	r24, 0xBF	; 191
    5f9e:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
		}

		Pipe_SetPipeToken(PIPE_TOKEN_IN);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    5fa2:	81 e0       	ldi	r24, 0x01	; 1
    5fa4:	fd de       	rcall	.-518    	; 0x5da0 <USB_Host_WaitForIOS>
    5fa6:	81 11       	cpse	r24, r1
    5fa8:	05 c0       	rjmp	.+10     	; 0x5fb4 <USB_Host_SendControlRequest+0x1c6>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5faa:	90 91 a6 00 	lds	r25, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    5fae:	9e 77       	andi	r25, 0x7E	; 126
    5fb0:	90 93 a6 00 	sts	0x00A6, r25	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5fb4:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    5fb8:	90 64       	ori	r25, 0x40	; 64
    5fba:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
	}

End_Of_Control_Send:
	Pipe_Freeze();

	if (BusSuspended)
    5fbe:	f1 10       	cpse	r15, r1
    5fc0:	05 c0       	rjmp	.+10     	; 0x5fcc <USB_Host_SendControlRequest+0x1de>
			 *        some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    5fc2:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
    5fc6:	9e 7f       	andi	r25, 0xFE	; 254
    5fc8:	90 93 9e 00 	sts	0x009E, r25	; 0x80009e <__TEXT_REGION_LENGTH__+0x7e009e>
			 *  \param[in] PipeNumber  Index of the pipe to reset.
			 */
			static inline void Pipe_ResetPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ResetPipe(const uint8_t PipeNumber)
			{
				UPRST = (1 << PipeNumber);
    5fcc:	91 e0       	ldi	r25, 0x01	; 1
    5fce:	90 93 a8 00 	sts	0x00A8, r25	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7e00a8>
				UPRST = 0;
    5fd2:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7e00a8>
	  USB_Host_SuspendBus();

	Pipe_ResetPipe(PIPE_CONTROLPIPE);

	return ReturnStatus;
}
    5fd6:	df 91       	pop	r29
    5fd8:	cf 91       	pop	r28
    5fda:	1f 91       	pop	r17
    5fdc:	0f 91       	pop	r16
    5fde:	ff 90       	pop	r15
    5fe0:	08 95       	ret

00005fe2 <USB_Host_SetDeviceConfiguration>:

	return HOST_SENDCONTROL_Successful;
}

uint8_t USB_Host_SetDeviceConfiguration(const uint8_t ConfigNumber)
{
    5fe2:	cf 93       	push	r28
    5fe4:	c8 2f       	mov	r28, r24
	uint8_t ErrorCode;

	USB_ControlRequest = (USB_Request_Header_t)
    5fe6:	10 92 8f 0d 	sts	0x0D8F, r1	; 0x800d8f <USB_ControlRequest>
    5fea:	89 e0       	ldi	r24, 0x09	; 9
    5fec:	80 93 90 0d 	sts	0x0D90, r24	; 0x800d90 <USB_ControlRequest+0x1>
    5ff0:	8c 2f       	mov	r24, r28
    5ff2:	90 e0       	ldi	r25, 0x00	; 0
    5ff4:	90 93 92 0d 	sts	0x0D92, r25	; 0x800d92 <USB_ControlRequest+0x3>
    5ff8:	80 93 91 0d 	sts	0x0D91, r24	; 0x800d91 <USB_ControlRequest+0x2>
    5ffc:	10 92 94 0d 	sts	0x0D94, r1	; 0x800d94 <USB_ControlRequest+0x5>
    6000:	10 92 93 0d 	sts	0x0D93, r1	; 0x800d93 <USB_ControlRequest+0x4>
    6004:	10 92 96 0d 	sts	0x0D96, r1	; 0x800d96 <USB_ControlRequest+0x7>
    6008:	10 92 95 0d 	sts	0x0D95, r1	; 0x800d95 <USB_ControlRequest+0x6>
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    600c:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
			.wLength       = 0,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);
	
	if ((ErrorCode = USB_Host_SendControlRequest(NULL)) == HOST_SENDCONTROL_Successful)
    6010:	80 e0       	ldi	r24, 0x00	; 0
    6012:	90 e0       	ldi	r25, 0x00	; 0
    6014:	ec de       	rcall	.-552    	; 0x5dee <USB_Host_SendControlRequest>
    6016:	81 11       	cpse	r24, r1
    6018:	09 c0       	rjmp	.+18     	; 0x602c <USB_Host_SetDeviceConfiguration+0x4a>
	{
		USB_Host_ConfigurationNumber = ConfigNumber;
    601a:	c0 93 8d 0d 	sts	0x0D8D, r28	; 0x800d8d <USB_Host_ConfigurationNumber>
		USB_HostState                = (ConfigNumber) ? HOST_STATE_Configured : HOST_STATE_Addressed;
    601e:	c1 11       	cpse	r28, r1
    6020:	02 c0       	rjmp	.+4      	; 0x6026 <USB_Host_SetDeviceConfiguration+0x44>
    6022:	9a e0       	ldi	r25, 0x0A	; 10
    6024:	01 c0       	rjmp	.+2      	; 0x6028 <USB_Host_SetDeviceConfiguration+0x46>
    6026:	9b e0       	ldi	r25, 0x0B	; 11
    6028:	90 93 97 0d 	sts	0x0D97, r25	; 0x800d97 <USB_HostState>
	}

	return ErrorCode;
}
    602c:	cf 91       	pop	r28
    602e:	08 95       	ret

00006030 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    6030:	cf 93       	push	r28
	#if defined(USB_HOST_ONLY)
		USB_HostTask();
	#elif defined(USB_DEVICE_ONLY)
		USB_DeviceTask();
	#else
		if (USB_CurrentMode == USB_MODE_Device)
    6032:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
    6036:	81 30       	cpi	r24, 0x01	; 1
    6038:	79 f4       	brne	.+30     	; 0x6058 <USB_USBTask+0x28>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    603a:	8e b3       	in	r24, 0x1e	; 30
    603c:	88 23       	and	r24, r24
    603e:	c9 f0       	breq	.+50     	; 0x6072 <USB_USBTask+0x42>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    6040:	c0 91 e9 00 	lds	r28, 0x00E9	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    6044:	c7 70       	andi	r28, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6046:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    604a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    604e:	83 fd       	sbrc	r24, 3
		  USB_Device_ProcessControlRequest();
    6050:	4c dd       	rcall	.-1384   	; 0x5aea <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6052:	c0 93 e9 00 	sts	0x00E9, r28	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    6056:	0d c0       	rjmp	.+26     	; 0x6072 <USB_USBTask+0x42>
	#elif defined(USB_DEVICE_ONLY)
		USB_DeviceTask();
	#else
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
    6058:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <USB_CurrentMode>
    605c:	82 30       	cpi	r24, 0x02	; 2
    605e:	49 f4       	brne	.+18     	; 0x6072 <USB_USBTask+0x42>
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return (UPNUM & PIPE_PIPENUM_MASK);
    6060:	c0 91 a7 00 	lds	r28, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
    6064:	c7 70       	andi	r28, 0x07	; 7
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    6066:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
{
	uint8_t PrevPipe = Pipe_GetCurrentPipe();

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	USB_Host_ProcessNextHostState();
    606a:	0e 94 81 25 	call	0x4b02	; 0x4b02 <USB_Host_ProcessNextHostState>
    606e:	c0 93 a7 00 	sts	0x00A7, r28	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    6072:	cf 91       	pop	r28
    6074:	08 95       	ret

00006076 <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorage.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6076:	cf 93       	push	r28
    6078:	df 93       	push	r29
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    607a:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	if (!(Endpoint_IsSETUPReceived()))
    607e:	23 ff       	sbrs	r18, 3
    6080:	36 c0       	rjmp	.+108    	; 0x60ee <MS_Device_ProcessControlRequest+0x78>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    6082:	fc 01       	movw	r30, r24
    6084:	20 81       	ld	r18, Z
    6086:	30 e0       	ldi	r19, 0x00	; 0
    6088:	40 91 93 0d 	lds	r20, 0x0D93	; 0x800d93 <USB_ControlRequest+0x4>
    608c:	50 91 94 0d 	lds	r21, 0x0D94	; 0x800d94 <USB_ControlRequest+0x5>
    6090:	42 17       	cp	r20, r18
    6092:	53 07       	cpc	r21, r19
    6094:	61 f5       	brne	.+88     	; 0x60ee <MS_Device_ProcessControlRequest+0x78>
	  return;

	switch (USB_ControlRequest.bRequest)
    6096:	20 91 90 0d 	lds	r18, 0x0D90	; 0x800d90 <USB_ControlRequest+0x1>
    609a:	2e 3f       	cpi	r18, 0xFE	; 254
    609c:	89 f0       	breq	.+34     	; 0x60c0 <MS_Device_ProcessControlRequest+0x4a>
    609e:	2f 3f       	cpi	r18, 0xFF	; 255
    60a0:	31 f5       	brne	.+76     	; 0x60ee <MS_Device_ProcessControlRequest+0x78>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    60a2:	20 91 8f 0d 	lds	r18, 0x0D8F	; 0x800d8f <USB_ControlRequest>
    60a6:	21 32       	cpi	r18, 0x21	; 33
    60a8:	11 f5       	brne	.+68     	; 0x60ee <MS_Device_ProcessControlRequest+0x78>
    60aa:	ec 01       	movw	r28, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    60ac:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    60b0:	87 7f       	andi	r24, 0xF7	; 247
    60b2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    60b6:	0e 94 90 24 	call	0x4920	; 0x4920 <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    60ba:	81 e0       	ldi	r24, 0x01	; 1
    60bc:	8e ab       	std	Y+54, r24	; 0x36
    60be:	17 c0       	rjmp	.+46     	; 0x60ee <MS_Device_ProcessControlRequest+0x78>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    60c0:	20 91 8f 0d 	lds	r18, 0x0D8F	; 0x800d8f <USB_ControlRequest>
    60c4:	21 3a       	cpi	r18, 0xA1	; 161
    60c6:	99 f4       	brne	.+38     	; 0x60ee <MS_Device_ProcessControlRequest+0x78>
    60c8:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    60cc:	27 7f       	andi	r18, 0xF7	; 247
    60ce:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			{
				Endpoint_ClearSETUP();
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    60d2:	fc 01       	movw	r30, r24
    60d4:	81 85       	ldd	r24, Z+9	; 0x09
    60d6:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    60d8:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    60dc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    60e0:	8e 77       	andi	r24, 0x7E	; 126
    60e2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    60e6:	df 91       	pop	r29
    60e8:	cf 91       	pop	r28
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    60ea:	0c 94 90 24 	jmp	0x4920	; 0x4920 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    60ee:	df 91       	pop	r29
    60f0:	cf 91       	pop	r28
    60f2:	08 95       	ret

000060f4 <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    60f4:	1f 93       	push	r17
    60f6:	cf 93       	push	r28
    60f8:	df 93       	push	r29
    60fa:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    60fc:	fc 01       	movw	r30, r24
    60fe:	3a 96       	adiw	r30, 0x0a	; 10
    6100:	8d e2       	ldi	r24, 0x2D	; 45
    6102:	df 01       	movw	r26, r30
    6104:	1d 92       	st	X+, r1
    6106:	8a 95       	dec	r24
    6108:	e9 f7       	brne	.-6      	; 0x6104 <MS_Device_ConfigureEndpoints+0x10>

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    610a:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == MSInterfaceInfo->Config.DataINEndpointNumber)
    610c:	89 81       	ldd	r24, Y+1	; 0x01
    610e:	81 13       	cpse	r24, r17
    6110:	05 c0       	rjmp	.+10     	; 0x611c <MS_Device_ConfigureEndpoints+0x28>
		{
			Size         = MSInterfaceInfo->Config.DataINEndpointSize;
    6112:	6a 81       	ldd	r22, Y+2	; 0x02
    6114:	7b 81       	ldd	r23, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = MSInterfaceInfo->Config.DataINEndpointDoubleBank;
    6116:	8c 81       	ldd	r24, Y+4	; 0x04
		bool     DoubleBanked;

		if (EndpointNum == MSInterfaceInfo->Config.DataINEndpointNumber)
		{
			Size         = MSInterfaceInfo->Config.DataINEndpointSize;
			Direction    = ENDPOINT_DIR_IN;
    6118:	90 e8       	ldi	r25, 0x80	; 128
    611a:	0c c0       	rjmp	.+24     	; 0x6134 <MS_Device_ConfigureEndpoints+0x40>
			Type         = EP_TYPE_BULK;
			DoubleBanked = MSInterfaceInfo->Config.DataINEndpointDoubleBank;
		}
		else if (EndpointNum == MSInterfaceInfo->Config.DataOUTEndpointNumber)
    611c:	8d 81       	ldd	r24, Y+5	; 0x05
    611e:	81 17       	cp	r24, r17
    6120:	29 f0       	breq	.+10     	; 0x612c <MS_Device_ConfigureEndpoints+0x38>

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    6122:	1f 5f       	subi	r17, 0xFF	; 255
    6124:	17 30       	cpi	r17, 0x07	; 7
    6126:	91 f7       	brne	.-28     	; 0x610c <MS_Device_ConfigureEndpoints+0x18>
		{
			return false;
		}
	}

	return true;
    6128:	81 e0       	ldi	r24, 0x01	; 1
    612a:	1e c0       	rjmp	.+60     	; 0x6168 <MS_Device_ConfigureEndpoints+0x74>
			Type         = EP_TYPE_BULK;
			DoubleBanked = MSInterfaceInfo->Config.DataINEndpointDoubleBank;
		}
		else if (EndpointNum == MSInterfaceInfo->Config.DataOUTEndpointNumber)
		{
			Size         = MSInterfaceInfo->Config.DataOUTEndpointSize;
    612c:	6e 81       	ldd	r22, Y+6	; 0x06
    612e:	7f 81       	ldd	r23, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = MSInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    6130:	88 85       	ldd	r24, Y+8	; 0x08
			DoubleBanked = MSInterfaceInfo->Config.DataINEndpointDoubleBank;
		}
		else if (EndpointNum == MSInterfaceInfo->Config.DataOUTEndpointNumber)
		{
			Size         = MSInterfaceInfo->Config.DataOUTEndpointSize;
			Direction    = ENDPOINT_DIR_OUT;
    6132:	90 e0       	ldi	r25, 0x00	; 0
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    6134:	81 11       	cpse	r24, r1
    6136:	84 e0       	ldi	r24, 0x04	; 4
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    6138:	28 e0       	ldi	r18, 0x08	; 8
    613a:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    613c:	40 e0       	ldi	r20, 0x00	; 0
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    613e:	26 17       	cp	r18, r22
    6140:	37 07       	cpc	r19, r23
    6142:	20 f4       	brcc	.+8      	; 0x614c <MS_Device_ConfigureEndpoints+0x58>
				{
					MaskVal++;
    6144:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    6146:	22 0f       	add	r18, r18
    6148:	33 1f       	adc	r19, r19
    614a:	f9 cf       	rjmp	.-14     	; 0x613e <MS_Device_ConfigureEndpoints+0x4a>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    614c:	42 95       	swap	r20
    614e:	40 7f       	andi	r20, 0xF0	; 240
    6150:	82 60       	ori	r24, 0x02	; 2
    6152:	48 2b       	or	r20, r24
    6154:	61 e0       	ldi	r22, 0x01	; 1
    6156:	91 11       	cpse	r25, r1
    6158:	01 c0       	rjmp	.+2      	; 0x615c <MS_Device_ConfigureEndpoints+0x68>
    615a:	60 e0       	ldi	r22, 0x00	; 0
    615c:	60 68       	ori	r22, 0x80	; 128
    615e:	81 2f       	mov	r24, r17
    6160:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <Endpoint_ConfigureEndpoint_Prv>
    6164:	81 11       	cpse	r24, r1
    6166:	dd cf       	rjmp	.-70     	; 0x6122 <MS_Device_ConfigureEndpoints+0x2e>
			return false;
		}
	}

	return true;
}
    6168:	df 91       	pop	r29
    616a:	cf 91       	pop	r28
    616c:	1f 91       	pop	r17
    616e:	08 95       	ret

00006170 <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6170:	ef 92       	push	r14
    6172:	ff 92       	push	r15
    6174:	0f 93       	push	r16
    6176:	1f 93       	push	r17
    6178:	cf 93       	push	r28
    617a:	df 93       	push	r29
    617c:	00 d0       	rcall	.+0      	; 0x617e <MS_Device_USBTask+0xe>
    617e:	cd b7       	in	r28, 0x3d	; 61
    6180:	de b7       	in	r29, 0x3e	; 62
	if (USB_DeviceState != DEVICE_STATE_Configured)
    6182:	2e b3       	in	r18, 0x1e	; 30
    6184:	24 30       	cpi	r18, 0x04	; 4
    6186:	09 f0       	breq	.+2      	; 0x618a <MS_Device_USBTask+0x1a>
    6188:	f7 c0       	rjmp	.+494    	; 0x6378 <MS_Device_USBTask+0x208>
    618a:	8c 01       	movw	r16, r24
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    618c:	fc 01       	movw	r30, r24
    618e:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6190:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    6194:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsReadWriteAllowed())
    6198:	85 ff       	sbrs	r24, 5
    619a:	b8 c0       	rjmp	.+368    	; 0x630c <MS_Device_USBTask+0x19c>

static bool MS_Device_ReadInCommandBlock(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    619c:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    619e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
	
	BytesProcessed = 0;
    61a2:	1a 82       	std	Y+2, r1	; 0x02
    61a4:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    61a6:	78 01       	movw	r14, r16
    61a8:	fa e0       	ldi	r31, 0x0A	; 10
    61aa:	ef 0e       	add	r14, r31
    61ac:	f1 1c       	adc	r15, r1
    61ae:	ae 01       	movw	r20, r28
    61b0:	4f 5f       	subi	r20, 0xFF	; 255
    61b2:	5f 4f       	sbci	r21, 0xFF	; 255
    61b4:	6f e0       	ldi	r22, 0x0F	; 15
    61b6:	70 e0       	ldi	r23, 0x00	; 0
    61b8:	c7 01       	movw	r24, r14
    61ba:	d9 d9       	rcall	.-3150   	; 0x556e <Endpoint_Read_Stream_LE>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    61bc:	f8 01       	movw	r30, r16
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
	
	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    61be:	85 30       	cpi	r24, 0x05	; 5
    61c0:	21 f4       	brne	.+8      	; 0x61ca <MS_Device_USBTask+0x5a>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    61c2:	86 a9       	ldd	r24, Z+54	; 0x36
    61c4:	88 23       	and	r24, r24
    61c6:	99 f3       	breq	.-26     	; 0x61ae <MS_Device_USBTask+0x3e>
    61c8:	a1 c0       	rjmp	.+322    	; 0x630c <MS_Device_USBTask+0x19c>
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    61ca:	82 85       	ldd	r24, Z+10	; 0x0a
    61cc:	93 85       	ldd	r25, Z+11	; 0x0b
    61ce:	a4 85       	ldd	r26, Z+12	; 0x0c
    61d0:	b5 85       	ldd	r27, Z+13	; 0x0d
    61d2:	85 35       	cpi	r24, 0x55	; 85
    61d4:	93 45       	sbci	r25, 0x53	; 83
    61d6:	a2 44       	sbci	r26, 0x42	; 66
    61d8:	b3 44       	sbci	r27, 0x43	; 67
    61da:	61 f4       	brne	.+24     	; 0x61f4 <MS_Device_USBTask+0x84>
    61dc:	f8 01       	movw	r30, r16
    61de:	97 89       	ldd	r25, Z+23	; 0x17
    61e0:	81 85       	ldd	r24, Z+9	; 0x09
    61e2:	98 17       	cp	r25, r24
    61e4:	38 f4       	brcc	.+14     	; 0x61f4 <MS_Device_USBTask+0x84>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
    61e6:	86 89       	ldd	r24, Z+22	; 0x16
    61e8:	8f 71       	andi	r24, 0x1F	; 31
    61ea:	21 f4       	brne	.+8      	; 0x61f4 <MS_Device_USBTask+0x84>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    61ec:	80 8d       	ldd	r24, Z+24	; 0x18
    61ee:	81 50       	subi	r24, 0x01	; 1
    61f0:	80 31       	cpi	r24, 0x10	; 16
    61f2:	78 f0       	brcs	.+30     	; 0x6212 <MS_Device_USBTask+0xa2>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    61f4:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    61f8:	80 62       	ori	r24, 0x20	; 32
    61fa:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength >  16))
	{
		Endpoint_StallTransaction();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    61fe:	f8 01       	movw	r30, r16
    6200:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6202:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6206:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    620a:	80 62       	ori	r24, 0x20	; 32
    620c:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    6210:	7d c0       	rjmp	.+250    	; 0x630c <MS_Device_USBTask+0x19c>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    6212:	1a 82       	std	Y+2, r1	; 0x02
    6214:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6216:	78 01       	movw	r14, r16
    6218:	f9 e1       	ldi	r31, 0x19	; 25
    621a:	ef 0e       	add	r14, r31
    621c:	f1 1c       	adc	r15, r1
    621e:	f8 01       	movw	r30, r16
    6220:	60 8d       	ldd	r22, Z+24	; 0x18
    6222:	70 e0       	ldi	r23, 0x00	; 0
    6224:	ae 01       	movw	r20, r28
    6226:	4f 5f       	subi	r20, 0xFF	; 255
    6228:	5f 4f       	sbci	r21, 0xFF	; 255
    622a:	c7 01       	movw	r24, r14
    622c:	a0 d9       	rcall	.-3264   	; 0x556e <Endpoint_Read_Stream_LE>
    622e:	85 30       	cpi	r24, 0x05	; 5
    6230:	29 f4       	brne	.+10     	; 0x623c <MS_Device_USBTask+0xcc>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    6232:	f8 01       	movw	r30, r16
    6234:	86 a9       	ldd	r24, Z+54	; 0x36
    6236:	88 23       	and	r24, r24
    6238:	91 f3       	breq	.-28     	; 0x621e <MS_Device_USBTask+0xae>
    623a:	68 c0       	rjmp	.+208    	; 0x630c <MS_Device_USBTask+0x19c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    623c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    6240:	8b 77       	andi	r24, 0x7B	; 123
    6242:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsReadWriteAllowed())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    6246:	f8 01       	movw	r30, r16
    6248:	86 89       	ldd	r24, Z+22	; 0x16
    624a:	87 ff       	sbrs	r24, 7
    624c:	03 c0       	rjmp	.+6      	; 0x6254 <MS_Device_USBTask+0xe4>
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    624e:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6250:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    6254:	c8 01       	movw	r24, r16
    6256:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <CALLBACK_MS_Device_SCSICommandReceived>

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    625a:	91 e0       	ldi	r25, 0x01	; 1
    625c:	98 27       	eor	r25, r24
    625e:	f8 01       	movw	r30, r16
    6260:	95 ab       	std	Z+53, r25	; 0x35
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    6262:	45 e5       	ldi	r20, 0x55	; 85
    6264:	53 e5       	ldi	r21, 0x53	; 83
    6266:	62 e4       	ldi	r22, 0x42	; 66
    6268:	73 e5       	ldi	r23, 0x53	; 83
    626a:	41 a7       	std	Z+41, r20	; 0x29
    626c:	52 a7       	std	Z+42, r21	; 0x2a
    626e:	63 a7       	std	Z+43, r22	; 0x2b
    6270:	74 a7       	std	Z+44, r23	; 0x2c
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    6272:	46 85       	ldd	r20, Z+14	; 0x0e
    6274:	57 85       	ldd	r21, Z+15	; 0x0f
    6276:	60 89       	ldd	r22, Z+16	; 0x10
    6278:	71 89       	ldd	r23, Z+17	; 0x11
    627a:	45 a7       	std	Z+45, r20	; 0x2d
    627c:	56 a7       	std	Z+46, r21	; 0x2e
    627e:	67 a7       	std	Z+47, r22	; 0x2f
    6280:	70 ab       	std	Z+48, r23	; 0x30
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    6282:	42 89       	ldd	r20, Z+18	; 0x12
    6284:	53 89       	ldd	r21, Z+19	; 0x13
    6286:	64 89       	ldd	r22, Z+20	; 0x14
    6288:	75 89       	ldd	r23, Z+21	; 0x15
    628a:	41 ab       	std	Z+49, r20	; 0x31
    628c:	52 ab       	std	Z+50, r21	; 0x32
    628e:	63 ab       	std	Z+51, r22	; 0x33
    6290:	74 ab       	std	Z+52, r23	; 0x34

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    6292:	81 11       	cpse	r24, r1
    6294:	09 c0       	rjmp	.+18     	; 0x62a8 <MS_Device_USBTask+0x138>
    6296:	45 2b       	or	r20, r21
    6298:	46 2b       	or	r20, r22
    629a:	47 2b       	or	r20, r23
    629c:	29 f0       	breq	.+10     	; 0x62a8 <MS_Device_USBTask+0x138>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    629e:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    62a2:	80 62       	ori	r24, 0x20	; 32
    62a4:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
	return true;
}

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    62a8:	f8 01       	movw	r30, r16
    62aa:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    62ac:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    62b0:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    62b4:	f8 01       	movw	r30, r16

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);

	while (Endpoint_IsStalled())
    62b6:	85 ff       	sbrs	r24, 5
    62b8:	04 c0       	rjmp	.+8      	; 0x62c2 <MS_Device_USBTask+0x152>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    62ba:	86 a9       	ldd	r24, Z+54	; 0x36
    62bc:	88 23       	and	r24, r24
    62be:	c1 f3       	breq	.-16     	; 0x62b0 <MS_Device_USBTask+0x140>
    62c0:	25 c0       	rjmp	.+74     	; 0x630c <MS_Device_USBTask+0x19c>
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    62c2:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    62c4:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    62c8:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>

	while (Endpoint_IsStalled())
    62cc:	85 ff       	sbrs	r24, 5
    62ce:	05 c0       	rjmp	.+10     	; 0x62da <MS_Device_USBTask+0x16a>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    62d0:	f8 01       	movw	r30, r16
    62d2:	86 a9       	ldd	r24, Z+54	; 0x36
    62d4:	88 23       	and	r24, r24
    62d6:	c1 f3       	breq	.-16     	; 0x62c8 <MS_Device_USBTask+0x158>
    62d8:	19 c0       	rjmp	.+50     	; 0x630c <MS_Device_USBTask+0x19c>
		  return;
	}

	uint16_t BytesProcessed = 0;
    62da:	1a 82       	std	Y+2, r1	; 0x02
    62dc:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    62de:	78 01       	movw	r14, r16
    62e0:	f9 e2       	ldi	r31, 0x29	; 41
    62e2:	ef 0e       	add	r14, r31
    62e4:	f1 1c       	adc	r15, r1
    62e6:	ae 01       	movw	r20, r28
    62e8:	4f 5f       	subi	r20, 0xFF	; 255
    62ea:	5f 4f       	sbci	r21, 0xFF	; 255
    62ec:	6d e0       	ldi	r22, 0x0D	; 13
    62ee:	70 e0       	ldi	r23, 0x00	; 0
    62f0:	c7 01       	movw	r24, r14
    62f2:	a6 d8       	rcall	.-3764   	; 0x5440 <Endpoint_Write_Stream_LE>
    62f4:	85 30       	cpi	r24, 0x05	; 5
    62f6:	29 f4       	brne	.+10     	; 0x6302 <MS_Device_USBTask+0x192>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    62f8:	f8 01       	movw	r30, r16
    62fa:	86 a9       	ldd	r24, Z+54	; 0x36
    62fc:	88 23       	and	r24, r24
    62fe:	99 f3       	breq	.-26     	; 0x62e6 <MS_Device_USBTask+0x176>
    6300:	05 c0       	rjmp	.+10     	; 0x630c <MS_Device_USBTask+0x19c>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6302:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    6306:	8e 77       	andi	r24, 0x7E	; 126
    6308:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    630c:	f8 01       	movw	r30, r16
    630e:	86 a9       	ldd	r24, Z+54	; 0x36
    6310:	88 23       	and	r24, r24
    6312:	91 f1       	breq	.+100    	; 0x6378 <MS_Device_USBTask+0x208>
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    6314:	81 e0       	ldi	r24, 0x01	; 1
    6316:	90 e0       	ldi	r25, 0x00	; 0
    6318:	9c 01       	movw	r18, r24
    631a:	05 80       	ldd	r0, Z+5	; 0x05
    631c:	02 c0       	rjmp	.+4      	; 0x6322 <MS_Device_USBTask+0x1b2>
    631e:	22 0f       	add	r18, r18
    6320:	33 1f       	adc	r19, r19
    6322:	0a 94       	dec	r0
    6324:	e2 f7       	brpl	.-8      	; 0x631e <MS_Device_USBTask+0x1ae>
    6326:	20 93 ea 00 	sts	0x00EA, r18	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>
				UERST = 0;
    632a:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    632e:	01 80       	ldd	r0, Z+1	; 0x01
    6330:	02 c0       	rjmp	.+4      	; 0x6336 <MS_Device_USBTask+0x1c6>
    6332:	88 0f       	add	r24, r24
    6334:	99 1f       	adc	r25, r25
    6336:	0a 94       	dec	r0
    6338:	e2 f7       	brpl	.-8      	; 0x6332 <MS_Device_USBTask+0x1c2>
    633a:	80 93 ea 00 	sts	0x00EA, r24	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>
				UERST = 0;
    633e:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>
	{
		Endpoint_ResetEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
		Endpoint_ResetEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);

		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    6342:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6344:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6348:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    634c:	80 61       	ori	r24, 0x10	; 16
    634e:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6352:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    6356:	88 60       	ori	r24, 0x08	; 8
    6358:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    635c:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    635e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6362:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    6366:	80 61       	ori	r24, 0x10	; 16
    6368:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    636c:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    6370:	88 60       	ori	r24, 0x08	; 8
    6372:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    6376:	16 aa       	std	Z+54, r1	; 0x36
	}
}
    6378:	0f 90       	pop	r0
    637a:	0f 90       	pop	r0
    637c:	df 91       	pop	r29
    637e:	cf 91       	pop	r28
    6380:	1f 91       	pop	r17
    6382:	0f 91       	pop	r16
    6384:	ff 90       	pop	r15
    6386:	ef 90       	pop	r14
    6388:	08 95       	ret

0000638a <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    638a:	0f 93       	push	r16
    638c:	1f 93       	push	r17
    638e:	cf 93       	push	r28
    6390:	df 93       	push	r29
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6392:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	if (!(Endpoint_IsSETUPReceived()))
    6396:	23 ff       	sbrs	r18, 3
    6398:	65 c2       	rjmp	.+1226   	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    639a:	fc 01       	movw	r30, r24
    639c:	20 81       	ld	r18, Z
    639e:	30 e0       	ldi	r19, 0x00	; 0
    63a0:	40 91 93 0d 	lds	r20, 0x0D93	; 0x800d93 <USB_ControlRequest+0x4>
    63a4:	50 91 94 0d 	lds	r21, 0x0D94	; 0x800d94 <USB_ControlRequest+0x5>
    63a8:	42 17       	cp	r20, r18
    63aa:	53 07       	cpc	r21, r19
    63ac:	09 f0       	breq	.+2      	; 0x63b0 <RNDIS_Device_ProcessControlRequest+0x26>
    63ae:	5a c2       	rjmp	.+1204   	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
    63b0:	ec 01       	movw	r28, r24
	  return;

	switch (USB_ControlRequest.bRequest)
    63b2:	80 91 90 0d 	lds	r24, 0x0D90	; 0x800d90 <USB_ControlRequest+0x1>
    63b6:	88 23       	and	r24, r24
    63b8:	21 f0       	breq	.+8      	; 0x63c2 <RNDIS_Device_ProcessControlRequest+0x38>
    63ba:	81 30       	cpi	r24, 0x01	; 1
    63bc:	09 f4       	brne	.+2      	; 0x63c0 <RNDIS_Device_ProcessControlRequest+0x36>
    63be:	f3 c1       	rjmp	.+998    	; 0x67a6 <RNDIS_Device_ProcessControlRequest+0x41c>
    63c0:	51 c2       	rjmp	.+1186   	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    63c2:	80 91 8f 0d 	lds	r24, 0x0D8F	; 0x800d8f <USB_ControlRequest>
    63c6:	81 32       	cpi	r24, 0x21	; 33
    63c8:	09 f0       	breq	.+2      	; 0x63cc <RNDIS_Device_ProcessControlRequest+0x42>
    63ca:	4c c2       	rjmp	.+1176   	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    63cc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    63d0:	87 7f       	andi	r24, 0xF7	; 247
    63d2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    63d6:	60 91 95 0d 	lds	r22, 0x0D95	; 0x800d95 <USB_ControlRequest+0x6>
    63da:	70 91 96 0d 	lds	r23, 0x0D96	; 0x800d96 <USB_ControlRequest+0x7>
    63de:	cf 01       	movw	r24, r30
    63e0:	45 96       	adiw	r24, 0x15	; 21
    63e2:	64 d9       	rcall	.-3384   	; 0x56ac <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    63e4:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    63e8:	8e 77       	andi	r24, 0x7E	; 126
    63ea:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    63ee:	8d 89       	ldd	r24, Y+21	; 0x15
    63f0:	9e 89       	ldd	r25, Y+22	; 0x16
    63f2:	af 89       	ldd	r26, Y+23	; 0x17
    63f4:	b8 8d       	ldd	r27, Y+24	; 0x18
    63f6:	84 30       	cpi	r24, 0x04	; 4
    63f8:	91 05       	cpc	r25, r1
    63fa:	a1 05       	cpc	r26, r1
    63fc:	b1 05       	cpc	r27, r1
    63fe:	09 f4       	brne	.+2      	; 0x6402 <RNDIS_Device_ProcessControlRequest+0x78>
    6400:	87 c0       	rjmp	.+270    	; 0x6510 <RNDIS_Device_ProcessControlRequest+0x186>
    6402:	b0 f4       	brcc	.+44     	; 0x6430 <RNDIS_Device_ProcessControlRequest+0xa6>
    6404:	82 30       	cpi	r24, 0x02	; 2
    6406:	91 05       	cpc	r25, r1
    6408:	a1 05       	cpc	r26, r1
    640a:	b1 05       	cpc	r27, r1
    640c:	a1 f1       	breq	.+104    	; 0x6476 <RNDIS_Device_ProcessControlRequest+0xec>
    640e:	03 97       	sbiw	r24, 0x03	; 3
    6410:	a1 05       	cpc	r26, r1
    6412:	b1 05       	cpc	r27, r1
    6414:	09 f0       	breq	.+2      	; 0x6418 <RNDIS_Device_ProcessControlRequest+0x8e>
    6416:	26 c2       	rjmp	.+1100   	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    6418:	fe 01       	movw	r30, r28
    641a:	eb 56       	subi	r30, 0x6B	; 107
    641c:	ff 4f       	sbci	r31, 0xFF	; 255
    641e:	10 82       	st	Z, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    6420:	19 8e       	std	Y+25, r1	; 0x19
    6422:	1a 8e       	std	Y+26, r1	; 0x1a
    6424:	1b 8e       	std	Y+27, r1	; 0x1b
    6426:	1c 8e       	std	Y+28, r1	; 0x1c

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    6428:	ca 56       	subi	r28, 0x6A	; 106
    642a:	df 4f       	sbci	r29, 0xFF	; 255
    642c:	18 82       	st	Y, r1
    642e:	1a c2       	rjmp	.+1076   	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    6430:	86 30       	cpi	r24, 0x06	; 6
    6432:	91 05       	cpc	r25, r1
    6434:	a1 05       	cpc	r26, r1
    6436:	b1 05       	cpc	r27, r1
    6438:	09 f4       	brne	.+2      	; 0x643c <RNDIS_Device_ProcessControlRequest+0xb2>
    643a:	97 c1       	rjmp	.+814    	; 0x676a <RNDIS_Device_ProcessControlRequest+0x3e0>
    643c:	08 f4       	brcc	.+2      	; 0x6440 <RNDIS_Device_ProcessControlRequest+0xb6>
    643e:	4c c1       	rjmp	.+664    	; 0x66d8 <RNDIS_Device_ProcessControlRequest+0x34e>
    6440:	08 97       	sbiw	r24, 0x08	; 8
    6442:	a1 05       	cpc	r26, r1
    6444:	b1 05       	cpc	r27, r1
    6446:	09 f0       	breq	.+2      	; 0x644a <RNDIS_Device_ProcessControlRequest+0xc0>
    6448:	0d c2       	rjmp	.+1050   	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    644a:	fe 01       	movw	r30, r28
    644c:	eb 56       	subi	r30, 0x6B	; 107
    644e:	ff 4f       	sbci	r31, 0xFF	; 255
    6450:	81 e0       	ldi	r24, 0x01	; 1
    6452:	80 83       	st	Z, r24
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    6454:	88 e0       	ldi	r24, 0x08	; 8
    6456:	90 e0       	ldi	r25, 0x00	; 0
    6458:	a0 e0       	ldi	r26, 0x00	; 0
    645a:	b0 e8       	ldi	r27, 0x80	; 128
    645c:	8d 8b       	std	Y+21, r24	; 0x15
    645e:	9e 8b       	std	Y+22, r25	; 0x16
    6460:	af 8b       	std	Y+23, r26	; 0x17
    6462:	b8 8f       	std	Y+24, r27	; 0x18
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    6464:	80 e1       	ldi	r24, 0x10	; 16
    6466:	90 e0       	ldi	r25, 0x00	; 0
    6468:	a0 e0       	ldi	r26, 0x00	; 0
    646a:	b0 e0       	ldi	r27, 0x00	; 0
    646c:	89 8f       	std	Y+25, r24	; 0x19
    646e:	9a 8f       	std	Y+26, r25	; 0x1a
    6470:	ab 8f       	std	Y+27, r26	; 0x1b
    6472:	bc 8f       	std	Y+28, r27	; 0x1c
    6474:	93 c1       	rjmp	.+806    	; 0x679c <RNDIS_Device_ProcessControlRequest+0x412>
	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6476:	fe 01       	movw	r30, r28
    6478:	eb 56       	subi	r30, 0x6B	; 107
    647a:	ff 4f       	sbci	r31, 0xFF	; 255
    647c:	21 e0       	ldi	r18, 0x01	; 1
    647e:	20 83       	st	Z, r18
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    6480:	82 e0       	ldi	r24, 0x02	; 2
    6482:	90 e0       	ldi	r25, 0x00	; 0
    6484:	a0 e0       	ldi	r26, 0x00	; 0
    6486:	b0 e8       	ldi	r27, 0x80	; 128
    6488:	8d 8b       	std	Y+21, r24	; 0x15
    648a:	9e 8b       	std	Y+22, r25	; 0x16
    648c:	af 8b       	std	Y+23, r26	; 0x17
    648e:	b8 8f       	std	Y+24, r27	; 0x18
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    6490:	84 e3       	ldi	r24, 0x34	; 52
    6492:	90 e0       	ldi	r25, 0x00	; 0
    6494:	a0 e0       	ldi	r26, 0x00	; 0
    6496:	b0 e0       	ldi	r27, 0x00	; 0
    6498:	89 8f       	std	Y+25, r24	; 0x19
    649a:	9a 8f       	std	Y+26, r25	; 0x1a
    649c:	ab 8f       	std	Y+27, r26	; 0x1b
    649e:	bc 8f       	std	Y+28, r27	; 0x1c
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    64a0:	19 a2       	std	Y+33, r1	; 0x21
    64a2:	1a a2       	std	Y+34, r1	; 0x22
    64a4:	1b a2       	std	Y+35, r1	; 0x23
    64a6:	1c a2       	std	Y+36, r1	; 0x24

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    64a8:	81 e0       	ldi	r24, 0x01	; 1
    64aa:	90 e0       	ldi	r25, 0x00	; 0
    64ac:	a0 e0       	ldi	r26, 0x00	; 0
    64ae:	b0 e0       	ldi	r27, 0x00	; 0
    64b0:	8d a3       	std	Y+37, r24	; 0x25
    64b2:	9e a3       	std	Y+38, r25	; 0x26
    64b4:	af a3       	std	Y+39, r26	; 0x27
    64b6:	b8 a7       	std	Y+40, r27	; 0x28
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    64b8:	19 a6       	std	Y+41, r1	; 0x29
    64ba:	1a a6       	std	Y+42, r1	; 0x2a
    64bc:	1b a6       	std	Y+43, r1	; 0x2b
    64be:	1c a6       	std	Y+44, r1	; 0x2c
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    64c0:	8d a7       	std	Y+45, r24	; 0x2d
    64c2:	9e a7       	std	Y+46, r25	; 0x2e
    64c4:	af a7       	std	Y+47, r26	; 0x2f
    64c6:	b8 ab       	std	Y+48, r27	; 0x30
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    64c8:	19 aa       	std	Y+49, r1	; 0x31
    64ca:	1a aa       	std	Y+50, r1	; 0x32
    64cc:	1b aa       	std	Y+51, r1	; 0x33
    64ce:	1c aa       	std	Y+52, r1	; 0x34
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    64d0:	8d ab       	std	Y+53, r24	; 0x35
    64d2:	9e ab       	std	Y+54, r25	; 0x36
    64d4:	af ab       	std	Y+55, r26	; 0x37
    64d6:	b8 af       	std	Y+56, r27	; 0x38
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    64d8:	88 e0       	ldi	r24, 0x08	; 8
    64da:	96 e0       	ldi	r25, 0x06	; 6
    64dc:	a0 e0       	ldi	r26, 0x00	; 0
    64de:	b0 e0       	ldi	r27, 0x00	; 0
    64e0:	89 af       	std	Y+57, r24	; 0x39
    64e2:	9a af       	std	Y+58, r25	; 0x3a
    64e4:	ab af       	std	Y+59, r26	; 0x3b
    64e6:	bc af       	std	Y+60, r27	; 0x3c
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    64e8:	e8 55       	subi	r30, 0x58	; 88
    64ea:	f1 09       	sbc	r31, r1
    64ec:	10 82       	st	Z, r1
    64ee:	11 82       	std	Z+1, r1	; 0x01
    64f0:	12 82       	std	Z+2, r1	; 0x02
    64f2:	13 82       	std	Z+3, r1	; 0x03
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    64f4:	34 96       	adiw	r30, 0x04	; 4
    64f6:	10 82       	st	Z, r1
    64f8:	11 82       	std	Z+1, r1	; 0x01
    64fa:	12 82       	std	Z+2, r1	; 0x02
    64fc:	13 82       	std	Z+3, r1	; 0x03
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    64fe:	34 96       	adiw	r30, 0x04	; 4
    6500:	10 82       	st	Z, r1
    6502:	11 82       	std	Z+1, r1	; 0x01
    6504:	12 82       	std	Z+2, r1	; 0x02
    6506:	13 82       	std	Z+3, r1	; 0x03

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    6508:	ca 56       	subi	r28, 0x6A	; 106
    650a:	df 4f       	sbci	r29, 0xFF	; 255
    650c:	28 83       	st	Y, r18
    650e:	aa c1       	rjmp	.+852    	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
			MessageHeader->MessageLength                = CPU_TO_LE32(0);

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6510:	81 e0       	ldi	r24, 0x01	; 1
    6512:	fe 01       	movw	r30, r28
    6514:	eb 56       	subi	r30, 0x6B	; 107
    6516:	ff 4f       	sbci	r31, 0xFF	; 255
    6518:	80 83       	st	Z, r24

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    651a:	49 a1       	ldd	r20, Y+33	; 0x21
    651c:	5a a1       	ldd	r21, Y+34	; 0x22
    651e:	6b a1       	ldd	r22, Y+35	; 0x23
    6520:	7c a1       	ldd	r23, Y+36	; 0x24

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    6522:	ce 01       	movw	r24, r28
    6524:	8d 96       	adiw	r24, 0x2d	; 45
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    6526:	04 e0       	ldi	r16, 0x04	; 4
    6528:	10 e0       	ldi	r17, 0x00	; 0
    652a:	20 e0       	ldi	r18, 0x00	; 0
    652c:	30 e8       	ldi	r19, 0x80	; 128
    652e:	0d 8b       	std	Y+21, r16	; 0x15
    6530:	1e 8b       	std	Y+22, r17	; 0x16
    6532:	2f 8b       	std	Y+23, r18	; 0x17
    6534:	38 8f       	std	Y+24, r19	; 0x18
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    6536:	4e 30       	cpi	r20, 0x0E	; 14
    6538:	f1 e0       	ldi	r31, 0x01	; 1
    653a:	5f 07       	cpc	r21, r31
    653c:	6f 07       	cpc	r22, r31
    653e:	71 05       	cpc	r23, r1
    6540:	09 f4       	brne	.+2      	; 0x6544 <RNDIS_Device_ProcessControlRequest+0x1ba>
    6542:	b6 c0       	rjmp	.+364    	; 0x66b0 <RNDIS_Device_ProcessControlRequest+0x326>
    6544:	08 f0       	brcs	.+2      	; 0x6548 <RNDIS_Device_ProcessControlRequest+0x1be>
    6546:	56 c0       	rjmp	.+172    	; 0x65f4 <RNDIS_Device_ProcessControlRequest+0x26a>
    6548:	46 30       	cpi	r20, 0x06	; 6
    654a:	e1 e0       	ldi	r30, 0x01	; 1
    654c:	5e 07       	cpc	r21, r30
    654e:	6e 07       	cpc	r22, r30
    6550:	71 05       	cpc	r23, r1
    6552:	09 f4       	brne	.+2      	; 0x6556 <RNDIS_Device_ProcessControlRequest+0x1cc>
    6554:	a3 c0       	rjmp	.+326    	; 0x669c <RNDIS_Device_ProcessControlRequest+0x312>
    6556:	e8 f4       	brcc	.+58     	; 0x6592 <RNDIS_Device_ProcessControlRequest+0x208>
    6558:	42 30       	cpi	r20, 0x02	; 2
    655a:	21 e0       	ldi	r18, 0x01	; 1
    655c:	52 07       	cpc	r21, r18
    655e:	62 07       	cpc	r22, r18
    6560:	71 05       	cpc	r23, r1
    6562:	09 f4       	brne	.+2      	; 0x6566 <RNDIS_Device_ProcessControlRequest+0x1dc>
    6564:	ad c0       	rjmp	.+346    	; 0x66c0 <RNDIS_Device_ProcessControlRequest+0x336>
    6566:	70 f4       	brcc	.+28     	; 0x6584 <RNDIS_Device_ProcessControlRequest+0x1fa>
    6568:	41 30       	cpi	r20, 0x01	; 1
    656a:	51 40       	sbci	r21, 0x01	; 1
    656c:	61 40       	sbci	r22, 0x01	; 1
    656e:	71 05       	cpc	r23, r1
    6570:	09 f0       	breq	.+2      	; 0x6574 <RNDIS_Device_ProcessControlRequest+0x1ea>
    6572:	60 c1       	rjmp	.+704    	; 0x6834 <RNDIS_Device_ProcessControlRequest+0x4aa>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    6574:	4c e6       	ldi	r20, 0x6C	; 108
    6576:	50 e0       	ldi	r21, 0x00	; 0
    6578:	6b ed       	ldi	r22, 0xDB	; 219
    657a:	73 e0       	ldi	r23, 0x03	; 3
    657c:	3d d7       	rcall	.+3706   	; 0x73f8 <memcpy_P>
	(void)QuerySize;

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    657e:	0c e6       	ldi	r16, 0x6C	; 108
    6580:	10 e0       	ldi	r17, 0x00	; 0
    6582:	3c c1       	rjmp	.+632    	; 0x67fc <RNDIS_Device_ProcessControlRequest+0x472>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    6584:	45 30       	cpi	r20, 0x05	; 5
    6586:	51 40       	sbci	r21, 0x01	; 1
    6588:	61 40       	sbci	r22, 0x01	; 1
    658a:	71 05       	cpc	r23, r1
    658c:	08 f4       	brcc	.+2      	; 0x6590 <RNDIS_Device_ProcessControlRequest+0x206>
    658e:	98 c0       	rjmp	.+304    	; 0x66c0 <RNDIS_Device_ProcessControlRequest+0x336>
    6590:	51 c1       	rjmp	.+674    	; 0x6834 <RNDIS_Device_ProcessControlRequest+0x4aa>
    6592:	4c 30       	cpi	r20, 0x0C	; 12
    6594:	e1 e0       	ldi	r30, 0x01	; 1
    6596:	5e 07       	cpc	r21, r30
    6598:	6e 07       	cpc	r22, r30
    659a:	71 05       	cpc	r23, r1
    659c:	90 f4       	brcc	.+36     	; 0x65c2 <RNDIS_Device_ProcessControlRequest+0x238>
    659e:	4a 30       	cpi	r20, 0x0A	; 10
    65a0:	f1 e0       	ldi	r31, 0x01	; 1
    65a2:	5f 07       	cpc	r21, r31
    65a4:	6f 07       	cpc	r22, r31
    65a6:	71 05       	cpc	r23, r1
    65a8:	08 f0       	brcs	.+2      	; 0x65ac <RNDIS_Device_ProcessControlRequest+0x222>
    65aa:	78 c0       	rjmp	.+240    	; 0x669c <RNDIS_Device_ProcessControlRequest+0x312>
    65ac:	47 30       	cpi	r20, 0x07	; 7
    65ae:	51 40       	sbci	r21, 0x01	; 1
    65b0:	61 40       	sbci	r22, 0x01	; 1
    65b2:	71 05       	cpc	r23, r1
    65b4:	09 f0       	breq	.+2      	; 0x65b8 <RNDIS_Device_ProcessControlRequest+0x22e>
    65b6:	3e c1       	rjmp	.+636    	; 0x6834 <RNDIS_Device_ProcessControlRequest+0x4aa>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    65b8:	80 ea       	ldi	r24, 0xA0	; 160
    65ba:	96 e8       	ldi	r25, 0x86	; 134
    65bc:	a1 e0       	ldi	r26, 0x01	; 1
    65be:	b0 e0       	ldi	r27, 0x00	; 0
    65c0:	84 c0       	rjmp	.+264    	; 0x66ca <RNDIS_Device_ProcessControlRequest+0x340>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    65c2:	4c 30       	cpi	r20, 0x0C	; 12
    65c4:	e1 e0       	ldi	r30, 0x01	; 1
    65c6:	5e 07       	cpc	r21, r30
    65c8:	6e 07       	cpc	r22, r30
    65ca:	71 05       	cpc	r23, r1
    65cc:	09 f4       	brne	.+2      	; 0x65d0 <RNDIS_Device_ProcessControlRequest+0x246>
    65ce:	61 c0       	rjmp	.+194    	; 0x6692 <RNDIS_Device_ProcessControlRequest+0x308>
    65d0:	4d 30       	cpi	r20, 0x0D	; 13
    65d2:	51 40       	sbci	r21, 0x01	; 1
    65d4:	61 40       	sbci	r22, 0x01	; 1
    65d6:	71 05       	cpc	r23, r1
    65d8:	09 f0       	breq	.+2      	; 0x65dc <RNDIS_Device_ProcessControlRequest+0x252>
    65da:	2c c1       	rjmp	.+600    	; 0x6834 <RNDIS_Device_ProcessControlRequest+0x4aa>

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    65dc:	6d 85       	ldd	r22, Y+13	; 0x0d
    65de:	7e 85       	ldd	r23, Y+14	; 0x0e
    65e0:	fb 01       	movw	r30, r22
    65e2:	01 90       	ld	r0, Z+
    65e4:	00 20       	and	r0, r0
    65e6:	e9 f7       	brne	.-6      	; 0x65e2 <RNDIS_Device_ProcessControlRequest+0x258>
    65e8:	8f 01       	movw	r16, r30
    65ea:	06 1b       	sub	r16, r22

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    65ec:	17 0b       	sbc	r17, r23
    65ee:	a8 01       	movw	r20, r16
    65f0:	33 d7       	rcall	.+3686   	; 0x7458 <memcpy>
    65f2:	04 c1       	rjmp	.+520    	; 0x67fc <RNDIS_Device_ProcessControlRequest+0x472>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    65f4:	46 30       	cpi	r20, 0x06	; 6
    65f6:	21 e0       	ldi	r18, 0x01	; 1
    65f8:	52 07       	cpc	r21, r18
    65fa:	22 e0       	ldi	r18, 0x02	; 2
    65fc:	62 07       	cpc	r22, r18
    65fe:	71 05       	cpc	r23, r1
    6600:	10 f5       	brcc	.+68     	; 0x6646 <RNDIS_Device_ProcessControlRequest+0x2bc>
    6602:	41 30       	cpi	r20, 0x01	; 1
    6604:	81 e0       	ldi	r24, 0x01	; 1
    6606:	58 07       	cpc	r21, r24
    6608:	82 e0       	ldi	r24, 0x02	; 2
    660a:	68 07       	cpc	r22, r24
    660c:	71 05       	cpc	r23, r1
    660e:	08 f0       	brcs	.+2      	; 0x6612 <RNDIS_Device_ProcessControlRequest+0x288>
    6610:	57 c0       	rjmp	.+174    	; 0x66c0 <RNDIS_Device_ProcessControlRequest+0x336>
    6612:	44 31       	cpi	r20, 0x14	; 20
    6614:	e1 e0       	ldi	r30, 0x01	; 1
    6616:	5e 07       	cpc	r21, r30
    6618:	6e 07       	cpc	r22, r30
    661a:	71 05       	cpc	r23, r1
    661c:	09 f4       	brne	.+2      	; 0x6620 <RNDIS_Device_ProcessControlRequest+0x296>
    661e:	50 c0       	rjmp	.+160    	; 0x66c0 <RNDIS_Device_ProcessControlRequest+0x336>
    6620:	42 30       	cpi	r20, 0x02	; 2
    6622:	f2 e0       	ldi	r31, 0x02	; 2
    6624:	5f 07       	cpc	r21, r31
    6626:	f1 e0       	ldi	r31, 0x01	; 1
    6628:	6f 07       	cpc	r22, r31
    662a:	71 05       	cpc	r23, r1
    662c:	09 f4       	brne	.+2      	; 0x6630 <RNDIS_Device_ProcessControlRequest+0x2a6>
    662e:	48 c0       	rjmp	.+144    	; 0x66c0 <RNDIS_Device_ProcessControlRequest+0x336>
    6630:	41 31       	cpi	r20, 0x11	; 17
    6632:	51 40       	sbci	r21, 0x01	; 1
    6634:	61 40       	sbci	r22, 0x01	; 1
    6636:	71 05       	cpc	r23, r1
    6638:	09 f0       	breq	.+2      	; 0x663c <RNDIS_Device_ProcessControlRequest+0x2b2>
    663a:	fc c0       	rjmp	.+504    	; 0x6834 <RNDIS_Device_ProcessControlRequest+0x4aa>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    663c:	8c e5       	ldi	r24, 0x5C	; 92
    663e:	96 e0       	ldi	r25, 0x06	; 6
    6640:	a0 e0       	ldi	r26, 0x00	; 0
    6642:	b0 e0       	ldi	r27, 0x00	; 0
    6644:	42 c0       	rjmp	.+132    	; 0x66ca <RNDIS_Device_ProcessControlRequest+0x340>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    6646:	44 30       	cpi	r20, 0x04	; 4
    6648:	e1 e0       	ldi	r30, 0x01	; 1
    664a:	5e 07       	cpc	r21, r30
    664c:	6e 07       	cpc	r22, r30
    664e:	7e 07       	cpc	r23, r30
    6650:	51 f1       	breq	.+84     	; 0x66a6 <RNDIS_Device_ProcessControlRequest+0x31c>
    6652:	a8 f4       	brcc	.+42     	; 0x667e <RNDIS_Device_ProcessControlRequest+0x2f4>
    6654:	41 50       	subi	r20, 0x01	; 1
    6656:	51 40       	sbci	r21, 0x01	; 1
    6658:	61 40       	sbci	r22, 0x01	; 1
    665a:	71 40       	sbci	r23, 0x01	; 1
    665c:	42 30       	cpi	r20, 0x02	; 2
    665e:	51 05       	cpc	r21, r1
    6660:	61 05       	cpc	r22, r1
    6662:	71 05       	cpc	r23, r1
    6664:	08 f0       	brcs	.+2      	; 0x6668 <RNDIS_Device_ProcessControlRequest+0x2de>
    6666:	e6 c0       	rjmp	.+460    	; 0x6834 <RNDIS_Device_ProcessControlRequest+0x4aa>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    6668:	26 e0       	ldi	r18, 0x06	; 6
    666a:	fe 01       	movw	r30, r28
    666c:	3f 96       	adiw	r30, 0x0f	; 15
    666e:	dc 01       	movw	r26, r24
    6670:	01 90       	ld	r0, Z+
    6672:	0d 92       	st	X+, r0
    6674:	2a 95       	dec	r18
    6676:	e1 f7       	brne	.-8      	; 0x6670 <RNDIS_Device_ProcessControlRequest+0x2e6>
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    6678:	06 e0       	ldi	r16, 0x06	; 6
    667a:	10 e0       	ldi	r17, 0x00	; 0
    667c:	bf c0       	rjmp	.+382    	; 0x67fc <RNDIS_Device_ProcessControlRequest+0x472>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    667e:	41 50       	subi	r20, 0x01	; 1
    6680:	51 40       	sbci	r21, 0x01	; 1
    6682:	62 40       	sbci	r22, 0x02	; 2
    6684:	71 40       	sbci	r23, 0x01	; 1
    6686:	43 30       	cpi	r20, 0x03	; 3
    6688:	51 05       	cpc	r21, r1
    668a:	61 05       	cpc	r22, r1
    668c:	71 05       	cpc	r23, r1
    668e:	c0 f0       	brcs	.+48     	; 0x66c0 <RNDIS_Device_ProcessControlRequest+0x336>
    6690:	d1 c0       	rjmp	.+418    	; 0x6834 <RNDIS_Device_ProcessControlRequest+0x4aa>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    6692:	8f ef       	ldi	r24, 0xFF	; 255
    6694:	9f ef       	ldi	r25, 0xFF	; 255
    6696:	af ef       	ldi	r26, 0xFF	; 255
    6698:	b0 e0       	ldi	r27, 0x00	; 0
    669a:	17 c0       	rjmp	.+46     	; 0x66ca <RNDIS_Device_ProcessControlRequest+0x340>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    669c:	8c ed       	ldi	r24, 0xDC	; 220
    669e:	95 e0       	ldi	r25, 0x05	; 5
    66a0:	a0 e0       	ldi	r26, 0x00	; 0
    66a2:	b0 e0       	ldi	r27, 0x00	; 0
    66a4:	12 c0       	rjmp	.+36     	; 0x66ca <RNDIS_Device_ProcessControlRequest+0x340>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    66a6:	81 e0       	ldi	r24, 0x01	; 1
    66a8:	90 e0       	ldi	r25, 0x00	; 0
    66aa:	a0 e0       	ldi	r26, 0x00	; 0
    66ac:	b0 e0       	ldi	r27, 0x00	; 0
    66ae:	0d c0       	rjmp	.+26     	; 0x66ca <RNDIS_Device_ProcessControlRequest+0x340>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    66b0:	fe 01       	movw	r30, r28
    66b2:	e9 56       	subi	r30, 0x69	; 105
    66b4:	ff 4f       	sbci	r31, 0xFF	; 255
    66b6:	80 81       	ld	r24, Z
    66b8:	91 81       	ldd	r25, Z+1	; 0x01
    66ba:	a2 81       	ldd	r26, Z+2	; 0x02
    66bc:	b3 81       	ldd	r27, Z+3	; 0x03
    66be:	05 c0       	rjmp	.+10     	; 0x66ca <RNDIS_Device_ProcessControlRequest+0x340>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    66c0:	1d a6       	std	Y+45, r1	; 0x2d
    66c2:	1e a6       	std	Y+46, r1	; 0x2e
    66c4:	1f a6       	std	Y+47, r1	; 0x2f
    66c6:	18 aa       	std	Y+48, r1	; 0x30
    66c8:	04 c0       	rjmp	.+8      	; 0x66d2 <RNDIS_Device_ProcessControlRequest+0x348>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    66ca:	8d a7       	std	Y+45, r24	; 0x2d
    66cc:	9e a7       	std	Y+46, r25	; 0x2e
    66ce:	af a7       	std	Y+47, r26	; 0x2f
    66d0:	b8 ab       	std	Y+48, r27	; 0x30
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    66d2:	04 e0       	ldi	r16, 0x04	; 4
    66d4:	10 e0       	ldi	r17, 0x00	; 0
    66d6:	92 c0       	rjmp	.+292    	; 0x67fc <RNDIS_Device_ProcessControlRequest+0x472>
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    66d8:	81 e0       	ldi	r24, 0x01	; 1
    66da:	fe 01       	movw	r30, r28
    66dc:	eb 56       	subi	r30, 0x6B	; 107
    66de:	ff 4f       	sbci	r31, 0xFF	; 255
    66e0:	80 83       	st	Z, r24

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    66e2:	89 a1       	ldd	r24, Y+33	; 0x21
    66e4:	9a a1       	ldd	r25, Y+34	; 0x22
    66e6:	ab a1       	ldd	r26, Y+35	; 0x23
    66e8:	bc a1       	ldd	r27, Y+36	; 0x24

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    66ea:	45 e0       	ldi	r20, 0x05	; 5
    66ec:	50 e0       	ldi	r21, 0x00	; 0
    66ee:	60 e0       	ldi	r22, 0x00	; 0
    66f0:	70 e8       	ldi	r23, 0x80	; 128
    66f2:	4d 8b       	std	Y+21, r20	; 0x15
    66f4:	5e 8b       	std	Y+22, r21	; 0x16
    66f6:	6f 8b       	std	Y+23, r22	; 0x17
    66f8:	78 8f       	std	Y+24, r23	; 0x18
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    66fa:	40 e1       	ldi	r20, 0x10	; 16
    66fc:	50 e0       	ldi	r21, 0x00	; 0
    66fe:	60 e0       	ldi	r22, 0x00	; 0
    6700:	70 e0       	ldi	r23, 0x00	; 0
    6702:	49 8f       	std	Y+25, r20	; 0x19
    6704:	5a 8f       	std	Y+26, r21	; 0x1a
    6706:	6b 8f       	std	Y+27, r22	; 0x1b
    6708:	7c 8f       	std	Y+28, r23	; 0x1c
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    670a:	8e 30       	cpi	r24, 0x0E	; 14
    670c:	21 e0       	ldi	r18, 0x01	; 1
    670e:	92 07       	cpc	r25, r18
    6710:	a2 07       	cpc	r26, r18
    6712:	b1 05       	cpc	r27, r1
    6714:	51 f0       	breq	.+20     	; 0x672a <RNDIS_Device_ProcessControlRequest+0x3a0>
    6716:	83 30       	cpi	r24, 0x03	; 3
    6718:	91 40       	sbci	r25, 0x01	; 1
    671a:	a1 40       	sbci	r26, 0x01	; 1
    671c:	b1 40       	sbci	r27, 0x01	; 1
    671e:	e9 f0       	breq	.+58     	; 0x675a <RNDIS_Device_ProcessControlRequest+0x3d0>
			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    6720:	8b eb       	ldi	r24, 0xBB	; 187
    6722:	90 e0       	ldi	r25, 0x00	; 0
    6724:	a0 e0       	ldi	r26, 0x00	; 0
    6726:	b0 ec       	ldi	r27, 0xC0	; 192
    6728:	1b c0       	rjmp	.+54     	; 0x6760 <RNDIS_Device_ProcessControlRequest+0x3d6>

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
    672a:	89 a5       	ldd	r24, Y+41	; 0x29
    672c:	9a a5       	ldd	r25, Y+42	; 0x2a
    672e:	ab a5       	ldd	r26, Y+43	; 0x2b
    6730:	bc a5       	ldd	r27, Y+44	; 0x2c
    6732:	08 96       	adiw	r24, 0x08	; 8
    6734:	a1 1d       	adc	r26, r1
    6736:	b1 1d       	adc	r27, r1
	(void)SetSize;

	switch (OId)
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    6738:	fe 01       	movw	r30, r28
    673a:	e8 0f       	add	r30, r24
    673c:	f9 1f       	adc	r31, r25
    673e:	85 89       	ldd	r24, Z+21	; 0x15
    6740:	96 89       	ldd	r25, Z+22	; 0x16
    6742:	a7 89       	ldd	r26, Z+23	; 0x17
    6744:	b0 8d       	ldd	r27, Z+24	; 0x18
    6746:	fe 01       	movw	r30, r28
    6748:	e9 56       	subi	r30, 0x69	; 105
    674a:	ff 4f       	sbci	r31, 0xFF	; 255
    674c:	80 83       	st	Z, r24
    674e:	91 83       	std	Z+1, r25	; 0x01
    6750:	a2 83       	std	Z+2, r26	; 0x02
    6752:	b3 83       	std	Z+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState   = le32_to_cpu((RNDISInterfaceInfo->State.CurrPacketFilter) ?
    6754:	82 e0       	ldi	r24, 0x02	; 2
    6756:	31 97       	sbiw	r30, 0x01	; 1
    6758:	80 83       	st	Z, r24
			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    675a:	80 e0       	ldi	r24, 0x00	; 0
    675c:	90 e0       	ldi	r25, 0x00	; 0
    675e:	dc 01       	movw	r26, r24
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    6760:	89 a3       	std	Y+33, r24	; 0x21
    6762:	9a a3       	std	Y+34, r25	; 0x22
    6764:	ab a3       	std	Y+35, r26	; 0x23
    6766:	bc a3       	std	Y+36, r27	; 0x24
    6768:	7d c0       	rjmp	.+250    	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    676a:	fe 01       	movw	r30, r28
    676c:	eb 56       	subi	r30, 0x6B	; 107
    676e:	ff 4f       	sbci	r31, 0xFF	; 255
    6770:	81 e0       	ldi	r24, 0x01	; 1
    6772:	80 83       	st	Z, r24

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    6774:	86 e0       	ldi	r24, 0x06	; 6
    6776:	90 e0       	ldi	r25, 0x00	; 0
    6778:	a0 e0       	ldi	r26, 0x00	; 0
    677a:	b0 e8       	ldi	r27, 0x80	; 128
    677c:	8d 8b       	std	Y+21, r24	; 0x15
    677e:	9e 8b       	std	Y+22, r25	; 0x16
    6780:	af 8b       	std	Y+23, r26	; 0x17
    6782:	b8 8f       	std	Y+24, r27	; 0x18
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    6784:	80 e1       	ldi	r24, 0x10	; 16
    6786:	90 e0       	ldi	r25, 0x00	; 0
    6788:	a0 e0       	ldi	r26, 0x00	; 0
    678a:	b0 e0       	ldi	r27, 0x00	; 0
    678c:	89 8f       	std	Y+25, r24	; 0x19
    678e:	9a 8f       	std	Y+26, r25	; 0x1a
    6790:	ab 8f       	std	Y+27, r26	; 0x1b
    6792:	bc 8f       	std	Y+28, r27	; 0x1c
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    6794:	1d 8e       	std	Y+29, r1	; 0x1d
    6796:	1e 8e       	std	Y+30, r1	; 0x1e
    6798:	1f 8e       	std	Y+31, r1	; 0x1f
    679a:	18 a2       	std	Y+32, r1	; 0x20
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    679c:	19 a2       	std	Y+33, r1	; 0x21
    679e:	1a a2       	std	Y+34, r1	; 0x22
    67a0:	1b a2       	std	Y+35, r1	; 0x23
    67a2:	1c a2       	std	Y+36, r1	; 0x24
    67a4:	5f c0       	rjmp	.+190    	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    67a6:	80 91 8f 0d 	lds	r24, 0x0D8F	; 0x800d8f <USB_ControlRequest>
    67aa:	81 3a       	cpi	r24, 0xA1	; 161
    67ac:	09 f0       	breq	.+2      	; 0x67b0 <RNDIS_Device_ProcessControlRequest+0x426>
    67ae:	5a c0       	rjmp	.+180    	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

				if (!(MessageHeader->MessageLength))
    67b0:	81 8d       	ldd	r24, Z+25	; 0x19
    67b2:	92 8d       	ldd	r25, Z+26	; 0x1a
    67b4:	a3 8d       	ldd	r26, Z+27	; 0x1b
    67b6:	b4 8d       	ldd	r27, Z+28	; 0x1c
    67b8:	89 2b       	or	r24, r25
    67ba:	8a 2b       	or	r24, r26
    67bc:	8b 2b       	or	r24, r27
    67be:	49 f4       	brne	.+18     	; 0x67d2 <RNDIS_Device_ProcessControlRequest+0x448>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    67c0:	15 8a       	std	Z+21, r1	; 0x15
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    67c2:	81 e0       	ldi	r24, 0x01	; 1
    67c4:	90 e0       	ldi	r25, 0x00	; 0
    67c6:	a0 e0       	ldi	r26, 0x00	; 0
    67c8:	b0 e0       	ldi	r27, 0x00	; 0
    67ca:	81 8f       	std	Z+25, r24	; 0x19
    67cc:	92 8f       	std	Z+26, r25	; 0x1a
    67ce:	a3 8f       	std	Z+27, r26	; 0x1b
    67d0:	b4 8f       	std	Z+28, r27	; 0x1c
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    67d2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    67d6:	87 7f       	andi	r24, 0xF7	; 247
    67d8:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    67dc:	69 8d       	ldd	r22, Y+25	; 0x19
    67de:	7a 8d       	ldd	r23, Y+26	; 0x1a
    67e0:	ce 01       	movw	r24, r28
    67e2:	45 96       	adiw	r24, 0x15	; 21
    67e4:	0e 94 00 2b 	call	0x5600	; 0x5600 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    67e8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    67ec:	8b 77       	andi	r24, 0x7B	; 123
    67ee:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    67f2:	19 8e       	std	Y+25, r1	; 0x19
    67f4:	1a 8e       	std	Y+26, r1	; 0x1a
    67f6:	1b 8e       	std	Y+27, r1	; 0x1b
    67f8:	1c 8e       	std	Y+28, r1	; 0x1c
    67fa:	34 c0       	rjmp	.+104    	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
			
			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    67fc:	19 a2       	std	Y+33, r1	; 0x21
    67fe:	1a a2       	std	Y+34, r1	; 0x22
    6800:	1b a2       	std	Y+35, r1	; 0x23
    6802:	1c a2       	std	Y+36, r1	; 0x24
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    6804:	c8 01       	movw	r24, r16
    6806:	48 96       	adiw	r24, 0x18	; 24
    6808:	a0 e0       	ldi	r26, 0x00	; 0
    680a:	b0 e0       	ldi	r27, 0x00	; 0
    680c:	89 8f       	std	Y+25, r24	; 0x19
    680e:	9a 8f       	std	Y+26, r25	; 0x1a
    6810:	ab 8f       	std	Y+27, r26	; 0x1b
    6812:	bc 8f       	std	Y+28, r27	; 0x1c

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    6814:	a8 01       	movw	r20, r16
    6816:	60 e0       	ldi	r22, 0x00	; 0
    6818:	70 e0       	ldi	r23, 0x00	; 0
    681a:	4d a3       	std	Y+37, r20	; 0x25
    681c:	5e a3       	std	Y+38, r21	; 0x26
    681e:	6f a3       	std	Y+39, r22	; 0x27
    6820:	78 a7       	std	Y+40, r23	; 0x28
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    6822:	80 e1       	ldi	r24, 0x10	; 16
    6824:	90 e0       	ldi	r25, 0x00	; 0
    6826:	a0 e0       	ldi	r26, 0x00	; 0
    6828:	b0 e0       	ldi	r27, 0x00	; 0
    682a:	89 a7       	std	Y+41, r24	; 0x29
    682c:	9a a7       	std	Y+42, r25	; 0x2a
    682e:	ab a7       	std	Y+43, r26	; 0x2b
    6830:	bc a7       	std	Y+44, r27	; 0x2c
    6832:	18 c0       	rjmp	.+48     	; 0x6864 <RNDIS_Device_ProcessControlRequest+0x4da>
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    6834:	8b eb       	ldi	r24, 0xBB	; 187
    6836:	90 e0       	ldi	r25, 0x00	; 0
    6838:	a0 e0       	ldi	r26, 0x00	; 0
    683a:	b0 ec       	ldi	r27, 0xC0	; 192
    683c:	89 a3       	std	Y+33, r24	; 0x21
    683e:	9a a3       	std	Y+34, r25	; 0x22
    6840:	ab a3       	std	Y+35, r26	; 0x23
    6842:	bc a3       	std	Y+36, r27	; 0x24
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    6844:	88 e1       	ldi	r24, 0x18	; 24
    6846:	90 e0       	ldi	r25, 0x00	; 0
    6848:	a0 e0       	ldi	r26, 0x00	; 0
    684a:	b0 e0       	ldi	r27, 0x00	; 0
    684c:	89 8f       	std	Y+25, r24	; 0x19
    684e:	9a 8f       	std	Y+26, r25	; 0x1a
    6850:	ab 8f       	std	Y+27, r26	; 0x1b
    6852:	bc 8f       	std	Y+28, r27	; 0x1c

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    6854:	1d a2       	std	Y+37, r1	; 0x25
    6856:	1e a2       	std	Y+38, r1	; 0x26
    6858:	1f a2       	std	Y+39, r1	; 0x27
    685a:	18 a6       	std	Y+40, r1	; 0x28
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    685c:	19 a6       	std	Y+41, r1	; 0x29
    685e:	1a a6       	std	Y+42, r1	; 0x2a
    6860:	1b a6       	std	Y+43, r1	; 0x2b
    6862:	1c a6       	std	Y+44, r1	; 0x2c
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    6864:	df 91       	pop	r29
    6866:	cf 91       	pop	r28
    6868:	1f 91       	pop	r17
    686a:	0f 91       	pop	r16
    686c:	08 95       	ret

0000686e <RNDIS_Device_ConfigureEndpoints>:

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    686e:	1f 93       	push	r17
    6870:	cf 93       	push	r28
    6872:	df 93       	push	r29
    6874:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    6876:	fc 01       	movw	r30, r24
    6878:	75 96       	adiw	r30, 0x15	; 21
    687a:	86 e8       	ldi	r24, 0x86	; 134
    687c:	df 01       	movw	r26, r30
    687e:	1d 92       	st	X+, r1
    6880:	8a 95       	dec	r24
    6882:	e9 f7       	brne	.-6      	; 0x687e <RNDIS_Device_ConfigureEndpoints+0x10>

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    6884:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
    6886:	89 81       	ldd	r24, Y+1	; 0x01
    6888:	81 13       	cpse	r24, r17
    688a:	05 c0       	rjmp	.+10     	; 0x6896 <RNDIS_Device_ConfigureEndpoints+0x28>
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
    688c:	ea 81       	ldd	r30, Y+2	; 0x02
    688e:	fb 81       	ldd	r31, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
    6890:	9c 81       	ldd	r25, Y+4	; 0x04
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
			Direction    = ENDPOINT_DIR_IN;
    6892:	20 e8       	ldi	r18, 0x80	; 128
    6894:	07 c0       	rjmp	.+14     	; 0x68a4 <RNDIS_Device_ConfigureEndpoints+0x36>
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
    6896:	8d 81       	ldd	r24, Y+5	; 0x05
    6898:	81 13       	cpse	r24, r17
    689a:	06 c0       	rjmp	.+12     	; 0x68a8 <RNDIS_Device_ConfigureEndpoints+0x3a>
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
    689c:	ee 81       	ldd	r30, Y+6	; 0x06
    689e:	ff 81       	ldd	r31, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    68a0:	98 85       	ldd	r25, Y+8	; 0x08
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
			Direction    = ENDPOINT_DIR_OUT;
    68a2:	20 e0       	ldi	r18, 0x00	; 0
			Type         = EP_TYPE_BULK;
    68a4:	82 e0       	ldi	r24, 0x02	; 2
    68a6:	0d c0       	rjmp	.+26     	; 0x68c2 <RNDIS_Device_ConfigureEndpoints+0x54>
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
    68a8:	89 85       	ldd	r24, Y+9	; 0x09
    68aa:	81 17       	cp	r24, r17
    68ac:	29 f0       	breq	.+10     	; 0x68b8 <RNDIS_Device_ConfigureEndpoints+0x4a>

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    68ae:	1f 5f       	subi	r17, 0xFF	; 255
    68b0:	17 30       	cpi	r17, 0x07	; 7
    68b2:	49 f7       	brne	.-46     	; 0x6886 <RNDIS_Device_ConfigureEndpoints+0x18>
		{
			return false;
		}
	}

	return true;
    68b4:	81 e0       	ldi	r24, 0x01	; 1
    68b6:	23 c0       	rjmp	.+70     	; 0x68fe <RNDIS_Device_ConfigureEndpoints+0x90>
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
    68b8:	ea 85       	ldd	r30, Y+10	; 0x0a
    68ba:	fb 85       	ldd	r31, Y+11	; 0x0b
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_INTERRUPT;
			DoubleBanked = RNDISInterfaceInfo->Config.NotificationEndpointDoubleBank;
    68bc:	9c 85       	ldd	r25, Y+12	; 0x0c
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
			Direction    = ENDPOINT_DIR_IN;
    68be:	20 e8       	ldi	r18, 0x80	; 128
			Type         = EP_TYPE_INTERRUPT;
    68c0:	83 e0       	ldi	r24, 0x03	; 3
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    68c2:	91 11       	cpse	r25, r1
    68c4:	94 e0       	ldi	r25, 0x04	; 4
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    68c6:	68 e0       	ldi	r22, 0x08	; 8
    68c8:	70 e0       	ldi	r23, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    68ca:	40 e0       	ldi	r20, 0x00	; 0
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    68cc:	6e 17       	cp	r22, r30
    68ce:	7f 07       	cpc	r23, r31
    68d0:	20 f4       	brcc	.+8      	; 0x68da <RNDIS_Device_ConfigureEndpoints+0x6c>
				{
					MaskVal++;
    68d2:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    68d4:	66 0f       	add	r22, r22
    68d6:	77 1f       	adc	r23, r23
    68d8:	f9 cf       	rjmp	.-14     	; 0x68cc <RNDIS_Device_ConfigureEndpoints+0x5e>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    68da:	42 95       	swap	r20
    68dc:	40 7f       	andi	r20, 0xF0	; 240
    68de:	92 60       	ori	r25, 0x02	; 2
    68e0:	49 2b       	or	r20, r25
    68e2:	b0 e4       	ldi	r27, 0x40	; 64
    68e4:	8b 9f       	mul	r24, r27
    68e6:	c0 01       	movw	r24, r0
    68e8:	11 24       	eor	r1, r1
    68ea:	61 e0       	ldi	r22, 0x01	; 1
    68ec:	21 11       	cpse	r18, r1
    68ee:	01 c0       	rjmp	.+2      	; 0x68f2 <RNDIS_Device_ConfigureEndpoints+0x84>
    68f0:	60 e0       	ldi	r22, 0x00	; 0
    68f2:	68 2b       	or	r22, r24
    68f4:	81 2f       	mov	r24, r17
    68f6:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <Endpoint_ConfigureEndpoint_Prv>
    68fa:	81 11       	cpse	r24, r1
    68fc:	d8 cf       	rjmp	.-80     	; 0x68ae <RNDIS_Device_ConfigureEndpoints+0x40>
			return false;
		}
	}

	return true;
}
    68fe:	df 91       	pop	r29
    6900:	cf 91       	pop	r28
    6902:	1f 91       	pop	r17
    6904:	08 95       	ret

00006906 <RNDIS_Device_USBTask>:

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    6906:	0f 93       	push	r16
    6908:	1f 93       	push	r17
    690a:	cf 93       	push	r28
    690c:	df 93       	push	r29
    690e:	cd b7       	in	r28, 0x3d	; 61
    6910:	de b7       	in	r29, 0x3e	; 62
    6912:	28 97       	sbiw	r28, 0x08	; 8
    6914:	0f b6       	in	r0, 0x3f	; 63
    6916:	f8 94       	cli
    6918:	de bf       	out	0x3e, r29	; 62
    691a:	0f be       	out	0x3f, r0	; 63
    691c:	cd bf       	out	0x3d, r28	; 61
	if (USB_DeviceState != DEVICE_STATE_Configured)
    691e:	2e b3       	in	r18, 0x1e	; 30
    6920:	24 30       	cpi	r18, 0x04	; 4
    6922:	39 f5       	brne	.+78     	; 0x6972 <RNDIS_Device_USBTask+0x6c>
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpointNumber);
    6924:	fc 01       	movw	r30, r24
    6926:	21 85       	ldd	r18, Z+9	; 0x09
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6928:	20 93 e9 00 	sts	0x00E9, r18	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    692c:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    6930:	20 ff       	sbrs	r18, 0
    6932:	1f c0       	rjmp	.+62     	; 0x6972 <RNDIS_Device_USBTask+0x6c>
    6934:	8c 01       	movw	r16, r24
    6936:	0b 56       	subi	r16, 0x6B	; 107
    6938:	1f 4f       	sbci	r17, 0xFF	; 255
    693a:	f8 01       	movw	r30, r16
    693c:	80 81       	ld	r24, Z
    693e:	88 23       	and	r24, r24
    6940:	c1 f0       	breq	.+48     	; 0x6972 <RNDIS_Device_USBTask+0x6c>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    6942:	88 e0       	ldi	r24, 0x08	; 8
    6944:	ec e6       	ldi	r30, 0x6C	; 108
    6946:	f2 e0       	ldi	r31, 0x02	; 2
    6948:	de 01       	movw	r26, r28
    694a:	11 96       	adiw	r26, 0x01	; 1
    694c:	01 90       	ld	r0, Z+
    694e:	0d 92       	st	X+, r0
    6950:	8a 95       	dec	r24
    6952:	e1 f7       	brne	.-8      	; 0x694c <RNDIS_Device_USBTask+0x46>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    6954:	40 e0       	ldi	r20, 0x00	; 0
    6956:	50 e0       	ldi	r21, 0x00	; 0
    6958:	68 e0       	ldi	r22, 0x08	; 8
    695a:	70 e0       	ldi	r23, 0x00	; 0
    695c:	ce 01       	movw	r24, r28
    695e:	01 96       	adiw	r24, 0x01	; 1
    6960:	0e 94 20 2a 	call	0x5440	; 0x5440 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6964:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    6968:	8e 77       	andi	r24, 0x7E	; 126
    696a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    696e:	f8 01       	movw	r30, r16
    6970:	10 82       	st	Z, r1
	}
}
    6972:	28 96       	adiw	r28, 0x08	; 8
    6974:	0f b6       	in	r0, 0x3f	; 63
    6976:	f8 94       	cli
    6978:	de bf       	out	0x3e, r29	; 62
    697a:	0f be       	out	0x3f, r0	; 63
    697c:	cd bf       	out	0x3d, r28	; 61
    697e:	df 91       	pop	r29
    6980:	cf 91       	pop	r28
    6982:	1f 91       	pop	r17
    6984:	0f 91       	pop	r16
    6986:	08 95       	ret

00006988 <RNDIS_Device_IsPacketReceived>:
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6988:	2e b3       	in	r18, 0x1e	; 30
    698a:	24 30       	cpi	r18, 0x04	; 4
    698c:	81 f4       	brne	.+32     	; 0x69ae <RNDIS_Device_IsPacketReceived+0x26>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    698e:	fc 01       	movw	r30, r24
    6990:	ea 56       	subi	r30, 0x6A	; 106
    6992:	ff 4f       	sbci	r31, 0xFF	; 255
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6994:	20 81       	ld	r18, Z
    6996:	22 30       	cpi	r18, 0x02	; 2
    6998:	51 f4       	brne	.+20     	; 0x69ae <RNDIS_Device_IsPacketReceived+0x26>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    699a:	fc 01       	movw	r30, r24
    699c:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    699e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    69a2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    69a6:	82 fb       	bst	r24, 2
    69a8:	88 27       	eor	r24, r24
    69aa:	80 f9       	bld	r24, 0
	return Endpoint_IsOUTReceived();
    69ac:	08 95       	ret
bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    69ae:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
	return Endpoint_IsOUTReceived();
}
    69b0:	08 95       	ret

000069b2 <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    69b2:	ef 92       	push	r14
    69b4:	ff 92       	push	r15
    69b6:	0f 93       	push	r16
    69b8:	1f 93       	push	r17
    69ba:	cf 93       	push	r28
    69bc:	df 93       	push	r29
    69be:	cd b7       	in	r28, 0x3d	; 61
    69c0:	de b7       	in	r29, 0x3e	; 62
    69c2:	ac 97       	sbiw	r28, 0x2c	; 44
    69c4:	0f b6       	in	r0, 0x3f	; 63
    69c6:	f8 94       	cli
    69c8:	de bf       	out	0x3e, r29	; 62
    69ca:	0f be       	out	0x3f, r0	; 63
    69cc:	cd bf       	out	0x3d, r28	; 61
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    69ce:	2e b3       	in	r18, 0x1e	; 30
    69d0:	24 30       	cpi	r18, 0x04	; 4
    69d2:	e9 f5       	brne	.+122    	; 0x6a4e <RNDIS_Device_ReadPacket+0x9c>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    69d4:	fc 01       	movw	r30, r24
    69d6:	ea 56       	subi	r30, 0x6A	; 106
    69d8:	ff 4f       	sbci	r31, 0xFF	; 255

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    69da:	20 81       	ld	r18, Z
    69dc:	22 30       	cpi	r18, 0x02	; 2
    69de:	b9 f5       	brne	.+110    	; 0x6a4e <RNDIS_Device_ReadPacket+0x9c>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    69e0:	fc 01       	movw	r30, r24
    69e2:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    69e4:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
	
	*PacketLength = 0;
    69e8:	fa 01       	movw	r30, r20
    69ea:	11 82       	std	Z+1, r1	; 0x01
    69ec:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    69ee:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (!(Endpoint_IsOUTReceived()))
    69f2:	89 2f       	mov	r24, r25
    69f4:	84 70       	andi	r24, 0x04	; 4
    69f6:	92 ff       	sbrs	r25, 2
    69f8:	2b c0       	rjmp	.+86     	; 0x6a50 <RNDIS_Device_ReadPacket+0x9e>
    69fa:	8a 01       	movw	r16, r20
    69fc:	7b 01       	movw	r14, r22
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;	
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    69fe:	40 e0       	ldi	r20, 0x00	; 0
    6a00:	50 e0       	ldi	r21, 0x00	; 0
    6a02:	6c e2       	ldi	r22, 0x2C	; 44
    6a04:	70 e0       	ldi	r23, 0x00	; 0
    6a06:	ce 01       	movw	r24, r28
    6a08:	01 96       	adiw	r24, 0x01	; 1
    6a0a:	0e 94 b7 2a 	call	0x556e	; 0x556e <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    6a0e:	6d 85       	ldd	r22, Y+13	; 0x0d
    6a10:	7e 85       	ldd	r23, Y+14	; 0x0e
    6a12:	8f 85       	ldd	r24, Y+15	; 0x0f
    6a14:	98 89       	ldd	r25, Y+16	; 0x10
    6a16:	6d 3d       	cpi	r22, 0xDD	; 221
    6a18:	f5 e0       	ldi	r31, 0x05	; 5
    6a1a:	7f 07       	cpc	r23, r31
    6a1c:	81 05       	cpc	r24, r1
    6a1e:	91 05       	cpc	r25, r1
    6a20:	38 f0       	brcs	.+14     	; 0x6a30 <RNDIS_Device_ReadPacket+0x7e>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6a22:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    6a26:	80 62       	ori	r24, 0x20	; 32
    6a28:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    6a2c:	80 e8       	ldi	r24, 0x80	; 128
    6a2e:	10 c0       	rjmp	.+32     	; 0x6a50 <RNDIS_Device_ReadPacket+0x9e>
	}
	
	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    6a30:	f8 01       	movw	r30, r16
    6a32:	71 83       	std	Z+1, r23	; 0x01
    6a34:	60 83       	st	Z, r22

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    6a36:	40 e0       	ldi	r20, 0x00	; 0
    6a38:	50 e0       	ldi	r21, 0x00	; 0
    6a3a:	c7 01       	movw	r24, r14
    6a3c:	0e 94 b7 2a 	call	0x556e	; 0x556e <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6a40:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    6a44:	8b 77       	andi	r24, 0x7B	; 123
    6a46:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearOUT();
	
	return ENDPOINT_RWSTREAM_NoError;
    6a4a:	80 e0       	ldi	r24, 0x00	; 0
    6a4c:	01 c0       	rjmp	.+2      	; 0x6a50 <RNDIS_Device_ReadPacket+0x9e>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    6a4e:	82 e0       	ldi	r24, 0x02	; 2

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();
	
	return ENDPOINT_RWSTREAM_NoError;
}
    6a50:	ac 96       	adiw	r28, 0x2c	; 44
    6a52:	0f b6       	in	r0, 0x3f	; 63
    6a54:	f8 94       	cli
    6a56:	de bf       	out	0x3e, r29	; 62
    6a58:	0f be       	out	0x3f, r0	; 63
    6a5a:	cd bf       	out	0x3d, r28	; 61
    6a5c:	df 91       	pop	r29
    6a5e:	cf 91       	pop	r28
    6a60:	1f 91       	pop	r17
    6a62:	0f 91       	pop	r16
    6a64:	ff 90       	pop	r15
    6a66:	ef 90       	pop	r14
    6a68:	08 95       	ret

00006a6a <RNDIS_Device_SendPacket>:

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    6a6a:	ef 92       	push	r14
    6a6c:	ff 92       	push	r15
    6a6e:	0f 93       	push	r16
    6a70:	1f 93       	push	r17
    6a72:	cf 93       	push	r28
    6a74:	df 93       	push	r29
    6a76:	cd b7       	in	r28, 0x3d	; 61
    6a78:	de b7       	in	r29, 0x3e	; 62
    6a7a:	ac 97       	sbiw	r28, 0x2c	; 44
    6a7c:	0f b6       	in	r0, 0x3f	; 63
    6a7e:	f8 94       	cli
    6a80:	de bf       	out	0x3e, r29	; 62
    6a82:	0f be       	out	0x3f, r0	; 63
    6a84:	cd bf       	out	0x3d, r28	; 61
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6a86:	2e b3       	in	r18, 0x1e	; 30
    6a88:	24 30       	cpi	r18, 0x04	; 4
    6a8a:	09 f0       	breq	.+2      	; 0x6a8e <RNDIS_Device_SendPacket+0x24>
    6a8c:	4b c0       	rjmp	.+150    	; 0x6b24 <RNDIS_Device_SendPacket+0xba>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    6a8e:	fc 01       	movw	r30, r24
    6a90:	ea 56       	subi	r30, 0x6A	; 106
    6a92:	ff 4f       	sbci	r31, 0xFF	; 255
                                void* Buffer,
                                const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6a94:	20 81       	ld	r18, Z
    6a96:	22 30       	cpi	r18, 0x02	; 2
    6a98:	09 f0       	breq	.+2      	; 0x6a9c <RNDIS_Device_SendPacket+0x32>
    6a9a:	44 c0       	rjmp	.+136    	; 0x6b24 <RNDIS_Device_SendPacket+0xba>
    6a9c:	8a 01       	movw	r16, r20
    6a9e:	7b 01       	movw	r14, r22
    6aa0:	fc 01       	movw	r30, r24
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpointNumber);
    6aa2:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6aa4:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    6aa8:	0e 94 ad 24 	call	0x495a	; 0x495a <Endpoint_WaitUntilReady>
    6aac:	81 11       	cpse	r24, r1
    6aae:	3b c0       	rjmp	.+118    	; 0x6b26 <RNDIS_Device_SendPacket+0xbc>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    6ab0:	ce 01       	movw	r24, r28
    6ab2:	01 96       	adiw	r24, 0x01	; 1
    6ab4:	2c e2       	ldi	r18, 0x2C	; 44
    6ab6:	fc 01       	movw	r30, r24
    6ab8:	11 92       	st	Z+, r1
    6aba:	2a 95       	dec	r18
    6abc:	e9 f7       	brne	.-6      	; 0x6ab8 <RNDIS_Device_SendPacket+0x4e>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    6abe:	41 e0       	ldi	r20, 0x01	; 1
    6ac0:	50 e0       	ldi	r21, 0x00	; 0
    6ac2:	60 e0       	ldi	r22, 0x00	; 0
    6ac4:	70 e0       	ldi	r23, 0x00	; 0
    6ac6:	49 83       	std	Y+1, r20	; 0x01
    6ac8:	5a 83       	std	Y+2, r21	; 0x02
    6aca:	6b 83       	std	Y+3, r22	; 0x03
    6acc:	7c 83       	std	Y+4, r23	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    6ace:	a8 01       	movw	r20, r16
    6ad0:	44 5d       	subi	r20, 0xD4	; 212
    6ad2:	5f 4f       	sbci	r21, 0xFF	; 255
    6ad4:	60 e0       	ldi	r22, 0x00	; 0
    6ad6:	70 e0       	ldi	r23, 0x00	; 0
    6ad8:	4d 83       	std	Y+5, r20	; 0x05
    6ada:	5e 83       	std	Y+6, r21	; 0x06
    6adc:	6f 83       	std	Y+7, r22	; 0x07
    6ade:	78 87       	std	Y+8, r23	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    6ae0:	44 e2       	ldi	r20, 0x24	; 36
    6ae2:	50 e0       	ldi	r21, 0x00	; 0
    6ae4:	60 e0       	ldi	r22, 0x00	; 0
    6ae6:	70 e0       	ldi	r23, 0x00	; 0
    6ae8:	49 87       	std	Y+9, r20	; 0x09
    6aea:	5a 87       	std	Y+10, r21	; 0x0a
    6aec:	6b 87       	std	Y+11, r22	; 0x0b
    6aee:	7c 87       	std	Y+12, r23	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    6af0:	a8 01       	movw	r20, r16
    6af2:	60 e0       	ldi	r22, 0x00	; 0
    6af4:	70 e0       	ldi	r23, 0x00	; 0
    6af6:	4d 87       	std	Y+13, r20	; 0x0d
    6af8:	5e 87       	std	Y+14, r21	; 0x0e
    6afa:	6f 87       	std	Y+15, r22	; 0x0f
    6afc:	78 8b       	std	Y+16, r23	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    6afe:	40 e0       	ldi	r20, 0x00	; 0
    6b00:	50 e0       	ldi	r21, 0x00	; 0
    6b02:	6c e2       	ldi	r22, 0x2C	; 44
    6b04:	70 e0       	ldi	r23, 0x00	; 0
    6b06:	0e 94 20 2a 	call	0x5440	; 0x5440 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    6b0a:	40 e0       	ldi	r20, 0x00	; 0
    6b0c:	50 e0       	ldi	r21, 0x00	; 0
    6b0e:	b8 01       	movw	r22, r16
    6b10:	c7 01       	movw	r24, r14
    6b12:	0e 94 20 2a 	call	0x5440	; 0x5440 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6b16:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    6b1a:	8e 77       	andi	r24, 0x7E	; 126
    6b1c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    6b20:	80 e0       	ldi	r24, 0x00	; 0
    6b22:	01 c0       	rjmp	.+2      	; 0x6b26 <RNDIS_Device_SendPacket+0xbc>
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    6b24:	82 e0       	ldi	r24, 0x02	; 2
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    6b26:	ac 96       	adiw	r28, 0x2c	; 44
    6b28:	0f b6       	in	r0, 0x3f	; 63
    6b2a:	f8 94       	cli
    6b2c:	de bf       	out	0x3e, r29	; 62
    6b2e:	0f be       	out	0x3f, r0	; 63
    6b30:	cd bf       	out	0x3d, r28	; 61
    6b32:	df 91       	pop	r29
    6b34:	cf 91       	pop	r28
    6b36:	1f 91       	pop	r17
    6b38:	0f 91       	pop	r16
    6b3a:	ff 90       	pop	r15
    6b3c:	ef 90       	pop	r14
    6b3e:	08 95       	ret

00006b40 <DCOMP_RNDIS_Host_NextRNDISControlInterface>:
	{
		return ErrorCode;
	}

	return HOST_SENDCONTROL_Successful;
}
    6b40:	fc 01       	movw	r30, r24
    6b42:	81 81       	ldd	r24, Z+1	; 0x01
    6b44:	84 30       	cpi	r24, 0x04	; 4
    6b46:	59 f4       	brne	.+22     	; 0x6b5e <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    6b48:	85 81       	ldd	r24, Z+5	; 0x05
    6b4a:	82 30       	cpi	r24, 0x02	; 2
    6b4c:	41 f4       	brne	.+16     	; 0x6b5e <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    6b4e:	86 81       	ldd	r24, Z+6	; 0x06
    6b50:	82 30       	cpi	r24, 0x02	; 2
    6b52:	29 f4       	brne	.+10     	; 0x6b5e <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    6b54:	97 81       	ldd	r25, Z+7	; 0x07
    6b56:	9f 3f       	cpi	r25, 0xFF	; 255
    6b58:	19 f4       	brne	.+6      	; 0x6b60 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x20>
    6b5a:	80 e0       	ldi	r24, 0x00	; 0
    6b5c:	08 95       	ret
    6b5e:	82 e0       	ldi	r24, 0x02	; 2
    6b60:	08 95       	ret

00006b62 <DCOMP_RNDIS_Host_NextRNDISDataInterface>:
    6b62:	fc 01       	movw	r30, r24
    6b64:	81 81       	ldd	r24, Z+1	; 0x01
    6b66:	84 30       	cpi	r24, 0x04	; 4
    6b68:	51 f4       	brne	.+20     	; 0x6b7e <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1c>
    6b6a:	85 81       	ldd	r24, Z+5	; 0x05
    6b6c:	8a 30       	cpi	r24, 0x0A	; 10
    6b6e:	39 f4       	brne	.+14     	; 0x6b7e <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1c>
    6b70:	86 81       	ldd	r24, Z+6	; 0x06
    6b72:	81 11       	cpse	r24, r1
    6b74:	04 c0       	rjmp	.+8      	; 0x6b7e <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1c>
    6b76:	87 81       	ldd	r24, Z+7	; 0x07
    6b78:	81 11       	cpse	r24, r1
    6b7a:	01 c0       	rjmp	.+2      	; 0x6b7e <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1c>
    6b7c:	08 95       	ret
    6b7e:	82 e0       	ldi	r24, 0x02	; 2
    6b80:	08 95       	ret

00006b82 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint>:
    6b82:	fc 01       	movw	r30, r24
    6b84:	21 81       	ldd	r18, Z+1	; 0x01
    6b86:	25 30       	cpi	r18, 0x05	; 5
    6b88:	61 f4       	brne	.+24     	; 0x6ba2 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x20>
    6b8a:	23 81       	ldd	r18, Z+3	; 0x03
    6b8c:	23 70       	andi	r18, 0x03	; 3
    6b8e:	22 50       	subi	r18, 0x02	; 2
    6b90:	22 30       	cpi	r18, 0x02	; 2
    6b92:	28 f4       	brcc	.+10     	; 0x6b9e <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x1c>
    6b94:	82 81       	ldd	r24, Z+2	; 0x02
    6b96:	0e 94 0d 27 	call	0x4e1a	; 0x4e1a <Pipe_IsEndpointBound>
    6b9a:	88 23       	and	r24, r24
    6b9c:	31 f0       	breq	.+12     	; 0x6baa <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x28>
    6b9e:	82 e0       	ldi	r24, 0x02	; 2
    6ba0:	08 95       	ret
    6ba2:	24 30       	cpi	r18, 0x04	; 4
    6ba4:	e1 f7       	brne	.-8      	; 0x6b9e <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x1c>
    6ba6:	81 e0       	ldi	r24, 0x01	; 1
    6ba8:	08 95       	ret
    6baa:	80 e0       	ldi	r24, 0x00	; 0
    6bac:	08 95       	ret

00006bae <RNDIS_SendEncapsulatedCommand>:
    6bae:	fc 01       	movw	r30, r24
    6bb0:	83 85       	ldd	r24, Z+11	; 0x0b
    6bb2:	90 e0       	ldi	r25, 0x00	; 0
    6bb4:	ef e8       	ldi	r30, 0x8F	; 143
    6bb6:	fd e0       	ldi	r31, 0x0D	; 13
    6bb8:	21 e2       	ldi	r18, 0x21	; 33
    6bba:	20 83       	st	Z, r18
    6bbc:	11 82       	std	Z+1, r1	; 0x01
    6bbe:	13 82       	std	Z+3, r1	; 0x03
    6bc0:	12 82       	std	Z+2, r1	; 0x02
    6bc2:	95 83       	std	Z+5, r25	; 0x05
    6bc4:	84 83       	std	Z+4, r24	; 0x04
    6bc6:	57 83       	std	Z+7, r21	; 0x07
    6bc8:	46 83       	std	Z+6, r20	; 0x06
    6bca:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
    6bce:	cb 01       	movw	r24, r22
    6bd0:	0e c9       	rjmp	.-3556   	; 0x5dee <USB_Host_SendControlRequest>

00006bd2 <RNDIS_GetEncapsulatedResponse>:
    6bd2:	fc 01       	movw	r30, r24
    6bd4:	83 85       	ldd	r24, Z+11	; 0x0b
    6bd6:	90 e0       	ldi	r25, 0x00	; 0
    6bd8:	ef e8       	ldi	r30, 0x8F	; 143
    6bda:	fd e0       	ldi	r31, 0x0D	; 13
    6bdc:	21 ea       	ldi	r18, 0xA1	; 161
    6bde:	20 83       	st	Z, r18
    6be0:	21 e0       	ldi	r18, 0x01	; 1
    6be2:	21 83       	std	Z+1, r18	; 0x01
    6be4:	13 82       	std	Z+3, r1	; 0x03
    6be6:	12 82       	std	Z+2, r1	; 0x02
    6be8:	95 83       	std	Z+5, r25	; 0x05
    6bea:	84 83       	std	Z+4, r24	; 0x04
    6bec:	57 83       	std	Z+7, r21	; 0x07
    6bee:	46 83       	std	Z+6, r20	; 0x06
    6bf0:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
    6bf4:	cb 01       	movw	r24, r22
    6bf6:	fb c8       	rjmp	.-3594   	; 0x5dee <USB_Host_SendControlRequest>

00006bf8 <RNDIS_Host_ConfigurePipes>:
    6bf8:	3f 92       	push	r3
    6bfa:	4f 92       	push	r4
    6bfc:	5f 92       	push	r5
    6bfe:	6f 92       	push	r6
    6c00:	7f 92       	push	r7
    6c02:	8f 92       	push	r8
    6c04:	9f 92       	push	r9
    6c06:	af 92       	push	r10
    6c08:	bf 92       	push	r11
    6c0a:	cf 92       	push	r12
    6c0c:	df 92       	push	r13
    6c0e:	ef 92       	push	r14
    6c10:	ff 92       	push	r15
    6c12:	0f 93       	push	r16
    6c14:	1f 93       	push	r17
    6c16:	cf 93       	push	r28
    6c18:	df 93       	push	r29
    6c1a:	00 d0       	rcall	.+0      	; 0x6c1c <RNDIS_Host_ConfigurePipes+0x24>
    6c1c:	00 d0       	rcall	.+0      	; 0x6c1e <RNDIS_Host_ConfigurePipes+0x26>
    6c1e:	cd b7       	in	r28, 0x3d	; 61
    6c20:	de b7       	in	r29, 0x3e	; 62
    6c22:	7a 83       	std	Y+2, r23	; 0x02
    6c24:	69 83       	std	Y+1, r22	; 0x01
    6c26:	5c 83       	std	Y+4, r21	; 0x04
    6c28:	4b 83       	std	Y+3, r20	; 0x03
    6c2a:	fc 01       	movw	r30, r24
    6c2c:	3a 96       	adiw	r30, 0x0a	; 10
    6c2e:	20 e1       	ldi	r18, 0x10	; 16
    6c30:	df 01       	movw	r26, r30
    6c32:	1d 92       	st	X+, r1
    6c34:	2a 95       	dec	r18
    6c36:	e9 f7       	brne	.-6      	; 0x6c32 <RNDIS_Host_ConfigurePipes+0x3a>
    6c38:	6b 80       	ldd	r6, Y+3	; 0x03
    6c3a:	7c 80       	ldd	r7, Y+4	; 0x04
    6c3c:	f3 01       	movw	r30, r6
    6c3e:	11 81       	ldd	r17, Z+1	; 0x01
    6c40:	12 30       	cpi	r17, 0x02	; 2
    6c42:	09 f0       	breq	.+2      	; 0x6c46 <RNDIS_Host_ConfigurePipes+0x4e>
    6c44:	ac c0       	rjmp	.+344    	; 0x6d9e <RNDIS_Host_ConfigurePipes+0x1a6>
    6c46:	6c 01       	movw	r12, r24
    6c48:	a1 2c       	mov	r10, r1
    6c4a:	b1 2c       	mov	r11, r1
    6c4c:	81 2c       	mov	r8, r1
    6c4e:	91 2c       	mov	r9, r1
    6c50:	41 2c       	mov	r4, r1
    6c52:	51 2c       	mov	r5, r1
    6c54:	41 14       	cp	r4, r1
    6c56:	51 04       	cpc	r5, r1
    6c58:	09 f0       	breq	.+2      	; 0x6c5c <RNDIS_Host_ConfigurePipes+0x64>
    6c5a:	41 c0       	rjmp	.+130    	; 0x6cde <RNDIS_Host_ConfigurePipes+0xe6>
    6c5c:	61 14       	cp	r6, r1
    6c5e:	71 04       	cpc	r7, r1
    6c60:	39 f4       	brne	.+14     	; 0x6c70 <RNDIS_Host_ConfigurePipes+0x78>
    6c62:	a1 14       	cp	r10, r1
    6c64:	b1 04       	cpc	r11, r1
    6c66:	81 f4       	brne	.+32     	; 0x6c88 <RNDIS_Host_ConfigurePipes+0x90>
    6c68:	1b c0       	rjmp	.+54     	; 0x6ca0 <RNDIS_Host_ConfigurePipes+0xa8>
    6c6a:	61 14       	cp	r6, r1
    6c6c:	71 04       	cpc	r7, r1
    6c6e:	c1 f0       	breq	.+48     	; 0x6ca0 <RNDIS_Host_ConfigurePipes+0xa8>
    6c70:	41 ec       	ldi	r20, 0xC1	; 193
    6c72:	55 e3       	ldi	r21, 0x35	; 53
    6c74:	be 01       	movw	r22, r28
    6c76:	6d 5f       	subi	r22, 0xFD	; 253
    6c78:	7f 4f       	sbci	r23, 0xFF	; 255
    6c7a:	ce 01       	movw	r24, r28
    6c7c:	01 96       	adiw	r24, 0x01	; 1
    6c7e:	0e 94 43 2d 	call	0x5a86	; 0x5a86 <USB_GetNextDescriptorComp>
    6c82:	81 11       	cpse	r24, r1
    6c84:	ee cf       	rjmp	.-36     	; 0x6c62 <RNDIS_Host_ConfigurePipes+0x6a>
    6c86:	1c c0       	rjmp	.+56     	; 0x6cc0 <RNDIS_Host_ConfigurePipes+0xc8>
    6c88:	41 eb       	ldi	r20, 0xB1	; 177
    6c8a:	55 e3       	ldi	r21, 0x35	; 53
    6c8c:	be 01       	movw	r22, r28
    6c8e:	6d 5f       	subi	r22, 0xFD	; 253
    6c90:	7f 4f       	sbci	r23, 0xFF	; 255
    6c92:	ce 01       	movw	r24, r28
    6c94:	01 96       	adiw	r24, 0x01	; 1
    6c96:	0e 94 43 2d 	call	0x5a86	; 0x5a86 <USB_GetNextDescriptorComp>
    6c9a:	81 11       	cpse	r24, r1
    6c9c:	83 c0       	rjmp	.+262    	; 0x6da4 <RNDIS_Host_ConfigurePipes+0x1ac>
    6c9e:	d6 cf       	rjmp	.-84     	; 0x6c4c <RNDIS_Host_ConfigurePipes+0x54>
    6ca0:	40 ea       	ldi	r20, 0xA0	; 160
    6ca2:	55 e3       	ldi	r21, 0x35	; 53
    6ca4:	be 01       	movw	r22, r28
    6ca6:	6d 5f       	subi	r22, 0xFD	; 253
    6ca8:	7f 4f       	sbci	r23, 0xFF	; 255
    6caa:	ce 01       	movw	r24, r28
    6cac:	01 96       	adiw	r24, 0x01	; 1
    6cae:	0e 94 43 2d 	call	0x5a86	; 0x5a86 <USB_GetNextDescriptorComp>
    6cb2:	81 11       	cpse	r24, r1
    6cb4:	77 c0       	rjmp	.+238    	; 0x6da4 <RNDIS_Host_ConfigurePipes+0x1ac>
    6cb6:	6b 80       	ldd	r6, Y+3	; 0x03
    6cb8:	7c 80       	ldd	r7, Y+4	; 0x04
    6cba:	a1 2c       	mov	r10, r1
    6cbc:	b1 2c       	mov	r11, r1
    6cbe:	ca cf       	rjmp	.-108    	; 0x6c54 <RNDIS_Host_ConfigurePipes+0x5c>
    6cc0:	eb 81       	ldd	r30, Y+3	; 0x03
    6cc2:	fc 81       	ldd	r31, Y+4	; 0x04
    6cc4:	82 81       	ldd	r24, Z+2	; 0x02
    6cc6:	87 ff       	sbrs	r24, 7
    6cc8:	06 c0       	rjmp	.+12     	; 0x6cd6 <RNDIS_Host_ConfigurePipes+0xde>
    6cca:	83 81       	ldd	r24, Z+3	; 0x03
    6ccc:	83 70       	andi	r24, 0x03	; 3
    6cce:	83 30       	cpi	r24, 0x03	; 3
    6cd0:	21 f0       	breq	.+8      	; 0x6cda <RNDIS_Host_ConfigurePipes+0xe2>
    6cd2:	2f 01       	movw	r4, r30
    6cd4:	bf cf       	rjmp	.-130    	; 0x6c54 <RNDIS_Host_ConfigurePipes+0x5c>
    6cd6:	4f 01       	movw	r8, r30
    6cd8:	bd cf       	rjmp	.-134    	; 0x6c54 <RNDIS_Host_ConfigurePipes+0x5c>
    6cda:	5f 01       	movw	r10, r30
    6cdc:	bb cf       	rjmp	.-138    	; 0x6c54 <RNDIS_Host_ConfigurePipes+0x5c>
    6cde:	81 14       	cp	r8, r1
    6ce0:	91 04       	cpc	r9, r1
    6ce2:	09 f4       	brne	.+2      	; 0x6ce6 <RNDIS_Host_ConfigurePipes+0xee>
    6ce4:	bb cf       	rjmp	.-138    	; 0x6c5c <RNDIS_Host_ConfigurePipes+0x64>
    6ce6:	a1 14       	cp	r10, r1
    6ce8:	b1 04       	cpc	r11, r1
    6cea:	09 f4       	brne	.+2      	; 0x6cee <RNDIS_Host_ConfigurePipes+0xf6>
    6cec:	be cf       	rjmp	.-132    	; 0x6c6a <RNDIS_Host_ConfigurePipes+0x72>
    6cee:	ff 24       	eor	r15, r15
    6cf0:	f3 94       	inc	r15
    6cf2:	d6 01       	movw	r26, r12
    6cf4:	8c 91       	ld	r24, X
    6cf6:	8f 11       	cpse	r24, r15
    6cf8:	0e c0       	rjmp	.+28     	; 0x6d16 <RNDIS_Host_ConfigurePipes+0x11e>
    6cfa:	f2 01       	movw	r30, r4
    6cfc:	04 81       	ldd	r16, Z+4	; 0x04
    6cfe:	15 81       	ldd	r17, Z+5	; 0x05
    6d00:	22 81       	ldd	r18, Z+2	; 0x02
    6d02:	11 96       	adiw	r26, 0x01	; 1
    6d04:	8c 91       	ld	r24, X
    6d06:	11 97       	sbiw	r26, 0x01	; 1
    6d08:	1d 96       	adiw	r26, 0x0d	; 13
    6d0a:	1c 93       	st	X, r17
    6d0c:	0e 93       	st	-X, r16
    6d0e:	1c 97       	sbiw	r26, 0x0c	; 12
    6d10:	31 2c       	mov	r3, r1
    6d12:	40 e1       	ldi	r20, 0x10	; 16
    6d14:	13 c0       	rjmp	.+38     	; 0x6d3c <RNDIS_Host_ConfigurePipes+0x144>
    6d16:	d6 01       	movw	r26, r12
    6d18:	12 96       	adiw	r26, 0x02	; 2
    6d1a:	8c 91       	ld	r24, X
    6d1c:	12 97       	sbiw	r26, 0x02	; 2
    6d1e:	8f 11       	cpse	r24, r15
    6d20:	0f c0       	rjmp	.+30     	; 0x6d40 <RNDIS_Host_ConfigurePipes+0x148>
    6d22:	f4 01       	movw	r30, r8
    6d24:	04 81       	ldd	r16, Z+4	; 0x04
    6d26:	15 81       	ldd	r17, Z+5	; 0x05
    6d28:	22 81       	ldd	r18, Z+2	; 0x02
    6d2a:	13 96       	adiw	r26, 0x03	; 3
    6d2c:	8c 91       	ld	r24, X
    6d2e:	13 97       	sbiw	r26, 0x03	; 3
    6d30:	1f 96       	adiw	r26, 0x0f	; 15
    6d32:	1c 93       	st	X, r17
    6d34:	0e 93       	st	-X, r16
    6d36:	1e 97       	sbiw	r26, 0x0e	; 14
    6d38:	31 2c       	mov	r3, r1
    6d3a:	40 e2       	ldi	r20, 0x20	; 32
    6d3c:	62 e0       	ldi	r22, 0x02	; 2
    6d3e:	14 c0       	rjmp	.+40     	; 0x6d68 <RNDIS_Host_ConfigurePipes+0x170>
    6d40:	d6 01       	movw	r26, r12
    6d42:	14 96       	adiw	r26, 0x04	; 4
    6d44:	8c 91       	ld	r24, X
    6d46:	14 97       	sbiw	r26, 0x04	; 4
    6d48:	8f 11       	cpse	r24, r15
    6d4a:	1c c0       	rjmp	.+56     	; 0x6d84 <RNDIS_Host_ConfigurePipes+0x18c>
    6d4c:	f5 01       	movw	r30, r10
    6d4e:	04 81       	ldd	r16, Z+4	; 0x04
    6d50:	15 81       	ldd	r17, Z+5	; 0x05
    6d52:	22 81       	ldd	r18, Z+2	; 0x02
    6d54:	15 96       	adiw	r26, 0x05	; 5
    6d56:	8c 91       	ld	r24, X
    6d58:	15 97       	sbiw	r26, 0x05	; 5
    6d5a:	36 80       	ldd	r3, Z+6	; 0x06
    6d5c:	51 96       	adiw	r26, 0x11	; 17
    6d5e:	1c 93       	st	X, r17
    6d60:	0e 93       	st	-X, r16
    6d62:	50 97       	sbiw	r26, 0x10	; 16
    6d64:	40 e1       	ldi	r20, 0x10	; 16
    6d66:	63 e0       	ldi	r22, 0x03	; 3
    6d68:	81 11       	cpse	r24, r1
    6d6a:	02 c0       	rjmp	.+4      	; 0x6d70 <RNDIS_Host_ConfigurePipes+0x178>
    6d6c:	e1 2c       	mov	r14, r1
    6d6e:	02 c0       	rjmp	.+4      	; 0x6d74 <RNDIS_Host_ConfigurePipes+0x17c>
    6d70:	84 e0       	ldi	r24, 0x04	; 4
    6d72:	e8 2e       	mov	r14, r24
    6d74:	8f 2d       	mov	r24, r15
    6d76:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <Pipe_ConfigurePipe>
    6d7a:	88 23       	and	r24, r24
    6d7c:	91 f0       	breq	.+36     	; 0x6da2 <RNDIS_Host_ConfigurePipes+0x1aa>
    6d7e:	31 10       	cpse	r3, r1
    6d80:	30 92 ad 00 	sts	0x00AD, r3	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7e00ad>
    6d84:	f3 94       	inc	r15
    6d86:	f7 e0       	ldi	r31, 0x07	; 7
    6d88:	ff 12       	cpse	r15, r31
    6d8a:	b3 cf       	rjmp	.-154    	; 0x6cf2 <RNDIS_Host_ConfigurePipes+0xfa>
    6d8c:	d3 01       	movw	r26, r6
    6d8e:	12 96       	adiw	r26, 0x02	; 2
    6d90:	8c 91       	ld	r24, X
    6d92:	f6 01       	movw	r30, r12
    6d94:	83 87       	std	Z+11, r24	; 0x0b
    6d96:	81 e0       	ldi	r24, 0x01	; 1
    6d98:	82 87       	std	Z+10, r24	; 0x0a
    6d9a:	10 e0       	ldi	r17, 0x00	; 0
    6d9c:	03 c0       	rjmp	.+6      	; 0x6da4 <RNDIS_Host_ConfigurePipes+0x1ac>
    6d9e:	11 e0       	ldi	r17, 0x01	; 1
    6da0:	01 c0       	rjmp	.+2      	; 0x6da4 <RNDIS_Host_ConfigurePipes+0x1ac>
    6da2:	13 e0       	ldi	r17, 0x03	; 3
    6da4:	81 2f       	mov	r24, r17
    6da6:	0f 90       	pop	r0
    6da8:	0f 90       	pop	r0
    6daa:	0f 90       	pop	r0
    6dac:	0f 90       	pop	r0
    6dae:	df 91       	pop	r29
    6db0:	cf 91       	pop	r28
    6db2:	1f 91       	pop	r17
    6db4:	0f 91       	pop	r16
    6db6:	ff 90       	pop	r15
    6db8:	ef 90       	pop	r14
    6dba:	df 90       	pop	r13
    6dbc:	cf 90       	pop	r12
    6dbe:	bf 90       	pop	r11
    6dc0:	af 90       	pop	r10
    6dc2:	9f 90       	pop	r9
    6dc4:	8f 90       	pop	r8
    6dc6:	7f 90       	pop	r7
    6dc8:	6f 90       	pop	r6
    6dca:	5f 90       	pop	r5
    6dcc:	4f 90       	pop	r4
    6dce:	3f 90       	pop	r3
    6dd0:	08 95       	ret

00006dd2 <RNDIS_Host_InitializeDevice>:

uint8_t RNDIS_Host_InitializeDevice(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    6dd2:	0f 93       	push	r16
    6dd4:	1f 93       	push	r17
    6dd6:	cf 93       	push	r28
    6dd8:	df 93       	push	r29
    6dda:	cd b7       	in	r28, 0x3d	; 61
    6ddc:	de b7       	in	r29, 0x3e	; 62
    6dde:	cc 54       	subi	r28, 0x4C	; 76
    6de0:	d1 09       	sbc	r29, r1
    6de2:	0f b6       	in	r0, 0x3f	; 63
    6de4:	f8 94       	cli
    6de6:	de bf       	out	0x3e, r29	; 62
    6de8:	0f be       	out	0x3f, r0	; 63
    6dea:	cd bf       	out	0x3d, r28	; 61
    6dec:	8c 01       	movw	r16, r24
	uint8_t ErrorCode;

	RNDIS_Initialize_Message_t  InitMessage;
	RNDIS_Initialize_Complete_t InitMessageResponse;

	InitMessage.MessageType     = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_MSG);
    6dee:	82 e0       	ldi	r24, 0x02	; 2
    6df0:	90 e0       	ldi	r25, 0x00	; 0
    6df2:	a0 e0       	ldi	r26, 0x00	; 0
    6df4:	b0 e0       	ldi	r27, 0x00	; 0
    6df6:	8d ab       	std	Y+53, r24	; 0x35
    6df8:	9e ab       	std	Y+54, r25	; 0x36
    6dfa:	af ab       	std	Y+55, r26	; 0x37
    6dfc:	b8 af       	std	Y+56, r27	; 0x38
	InitMessage.MessageLength   = CPU_TO_LE32(sizeof(RNDIS_Initialize_Message_t));
    6dfe:	88 e1       	ldi	r24, 0x18	; 24
    6e00:	90 e0       	ldi	r25, 0x00	; 0
    6e02:	a0 e0       	ldi	r26, 0x00	; 0
    6e04:	b0 e0       	ldi	r27, 0x00	; 0
    6e06:	89 af       	std	Y+57, r24	; 0x39
    6e08:	9a af       	std	Y+58, r25	; 0x3a
    6e0a:	ab af       	std	Y+59, r26	; 0x3b
    6e0c:	bc af       	std	Y+60, r27	; 0x3c
	InitMessage.RequestId       = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    6e0e:	f8 01       	movw	r30, r16
    6e10:	86 89       	ldd	r24, Z+22	; 0x16
    6e12:	97 89       	ldd	r25, Z+23	; 0x17
    6e14:	a0 8d       	ldd	r26, Z+24	; 0x18
    6e16:	b1 8d       	ldd	r27, Z+25	; 0x19
    6e18:	ac 01       	movw	r20, r24
    6e1a:	bd 01       	movw	r22, r26
    6e1c:	4f 5f       	subi	r20, 0xFF	; 255
    6e1e:	5f 4f       	sbci	r21, 0xFF	; 255
    6e20:	6f 4f       	sbci	r22, 0xFF	; 255
    6e22:	7f 4f       	sbci	r23, 0xFF	; 255
    6e24:	46 8b       	std	Z+22, r20	; 0x16
    6e26:	57 8b       	std	Z+23, r21	; 0x17
    6e28:	60 8f       	std	Z+24, r22	; 0x18
    6e2a:	71 8f       	std	Z+25, r23	; 0x19
    6e2c:	21 96       	adiw	r28, 0x01	; 1
    6e2e:	8c af       	std	Y+60, r24	; 0x3c
    6e30:	9d af       	std	Y+61, r25	; 0x3d
    6e32:	ae af       	std	Y+62, r26	; 0x3e
    6e34:	bf af       	std	Y+63, r27	; 0x3f
    6e36:	21 97       	sbiw	r28, 0x01	; 1

	InitMessage.MajorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    6e38:	81 e0       	ldi	r24, 0x01	; 1
    6e3a:	90 e0       	ldi	r25, 0x00	; 0
    6e3c:	a0 e0       	ldi	r26, 0x00	; 0
    6e3e:	b0 e0       	ldi	r27, 0x00	; 0
    6e40:	25 96       	adiw	r28, 0x05	; 5
    6e42:	8c af       	std	Y+60, r24	; 0x3c
    6e44:	9d af       	std	Y+61, r25	; 0x3d
    6e46:	ae af       	std	Y+62, r26	; 0x3e
    6e48:	bf af       	std	Y+63, r27	; 0x3f
    6e4a:	25 97       	sbiw	r28, 0x05	; 5
	InitMessage.MinorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    6e4c:	29 96       	adiw	r28, 0x09	; 9
    6e4e:	1c ae       	std	Y+60, r1	; 0x3c
    6e50:	1d ae       	std	Y+61, r1	; 0x3d
    6e52:	1e ae       	std	Y+62, r1	; 0x3e
    6e54:	1f ae       	std	Y+63, r1	; 0x3f
    6e56:	29 97       	sbiw	r28, 0x09	; 9
	InitMessage.MaxTransferSize = cpu_to_le32(RNDISInterfaceInfo->Config.HostMaxPacketSize);
    6e58:	86 81       	ldd	r24, Z+6	; 0x06
    6e5a:	97 81       	ldd	r25, Z+7	; 0x07
    6e5c:	a0 85       	ldd	r26, Z+8	; 0x08
    6e5e:	b1 85       	ldd	r27, Z+9	; 0x09
    6e60:	2d 96       	adiw	r28, 0x0d	; 13
    6e62:	8c af       	std	Y+60, r24	; 0x3c
    6e64:	9d af       	std	Y+61, r25	; 0x3d
    6e66:	ae af       	std	Y+62, r26	; 0x3e
    6e68:	bf af       	std	Y+63, r27	; 0x3f
    6e6a:	2d 97       	sbiw	r28, 0x0d	; 13

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &InitMessage,
    6e6c:	48 e1       	ldi	r20, 0x18	; 24
    6e6e:	50 e0       	ldi	r21, 0x00	; 0
    6e70:	be 01       	movw	r22, r28
    6e72:	6b 5c       	subi	r22, 0xCB	; 203
    6e74:	7f 4f       	sbci	r23, 0xFF	; 255
    6e76:	c8 01       	movw	r24, r16
    6e78:	9a de       	rcall	.-716    	; 0x6bae <RNDIS_SendEncapsulatedCommand>
    6e7a:	81 11       	cpse	r24, r1
    6e7c:	1d c0       	rjmp	.+58     	; 0x6eb8 <RNDIS_Host_InitializeDevice+0xe6>
	                                               sizeof(RNDIS_Initialize_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &InitMessageResponse,
    6e7e:	44 e3       	ldi	r20, 0x34	; 52
    6e80:	50 e0       	ldi	r21, 0x00	; 0
    6e82:	be 01       	movw	r22, r28
    6e84:	6f 5f       	subi	r22, 0xFF	; 255
    6e86:	7f 4f       	sbci	r23, 0xFF	; 255
    6e88:	c8 01       	movw	r24, r16
    6e8a:	a3 de       	rcall	.-698    	; 0x6bd2 <RNDIS_GetEncapsulatedResponse>
    6e8c:	81 11       	cpse	r24, r1
    6e8e:	14 c0       	rjmp	.+40     	; 0x6eb8 <RNDIS_Host_InitializeDevice+0xe6>
	                                               sizeof(RNDIS_Initialize_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    6e90:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e92:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e94:	af 85       	ldd	r26, Y+15	; 0x0f
    6e96:	b8 89       	ldd	r27, Y+16	; 0x10
    6e98:	89 2b       	or	r24, r25
    6e9a:	8a 2b       	or	r24, r26
    6e9c:	8b 2b       	or	r24, r27
    6e9e:	59 f4       	brne	.+22     	; 0x6eb6 <RNDIS_Host_InitializeDevice+0xe4>
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);
    6ea0:	8d a1       	ldd	r24, Y+37	; 0x25
    6ea2:	9e a1       	ldd	r25, Y+38	; 0x26
    6ea4:	af a1       	ldd	r26, Y+39	; 0x27
    6ea6:	b8 a5       	ldd	r27, Y+40	; 0x28
    6ea8:	f8 01       	movw	r30, r16
    6eaa:	82 8b       	std	Z+18, r24	; 0x12
    6eac:	93 8b       	std	Z+19, r25	; 0x13
    6eae:	a4 8b       	std	Z+20, r26	; 0x14
    6eb0:	b5 8b       	std	Z+21, r27	; 0x15

	return HOST_SENDCONTROL_Successful;
    6eb2:	80 e0       	ldi	r24, 0x00	; 0
    6eb4:	01 c0       	rjmp	.+2      	; 0x6eb8 <RNDIS_Host_InitializeDevice+0xe6>
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    6eb6:	80 e8       	ldi	r24, 0x80	; 128

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);

	return HOST_SENDCONTROL_Successful;
}
    6eb8:	c4 5b       	subi	r28, 0xB4	; 180
    6eba:	df 4f       	sbci	r29, 0xFF	; 255
    6ebc:	0f b6       	in	r0, 0x3f	; 63
    6ebe:	f8 94       	cli
    6ec0:	de bf       	out	0x3e, r29	; 62
    6ec2:	0f be       	out	0x3f, r0	; 63
    6ec4:	cd bf       	out	0x3d, r28	; 61
    6ec6:	df 91       	pop	r29
    6ec8:	cf 91       	pop	r28
    6eca:	1f 91       	pop	r17
    6ecc:	0f 91       	pop	r16
    6ece:	08 95       	ret

00006ed0 <RNDIS_Host_SetRNDISProperty>:

uint8_t RNDIS_Host_SetRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                    const uint32_t Oid,
                                    void* Buffer,
                                    const uint16_t Length)
{
    6ed0:	4f 92       	push	r4
    6ed2:	5f 92       	push	r5
    6ed4:	6f 92       	push	r6
    6ed6:	7f 92       	push	r7
    6ed8:	8f 92       	push	r8
    6eda:	9f 92       	push	r9
    6edc:	af 92       	push	r10
    6ede:	bf 92       	push	r11
    6ee0:	cf 92       	push	r12
    6ee2:	df 92       	push	r13
    6ee4:	ef 92       	push	r14
    6ee6:	ff 92       	push	r15
    6ee8:	0f 93       	push	r16
    6eea:	1f 93       	push	r17
    6eec:	cf 93       	push	r28
    6eee:	df 93       	push	r29
    6ef0:	cd b7       	in	r28, 0x3d	; 61
    6ef2:	de b7       	in	r29, 0x3e	; 62
    6ef4:	60 97       	sbiw	r28, 0x10	; 16
    6ef6:	0f b6       	in	r0, 0x3f	; 63
    6ef8:	f8 94       	cli
    6efa:	de bf       	out	0x3e, r29	; 62
    6efc:	0f be       	out	0x3f, r0	; 63
    6efe:	cd bf       	out	0x3d, r28	; 61
    6f00:	6c 01       	movw	r12, r24

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	return HOST_SENDCONTROL_Successful;
}
    6f02:	ad b6       	in	r10, 0x3d	; 61
    6f04:	be b6       	in	r11, 0x3e	; 62

	struct
	{
		RNDIS_Set_Message_t SetMessage;
		uint8_t             ContiguousBuffer[Length];
	} SetMessageData;
    6f06:	48 01       	movw	r8, r16
    6f08:	8c e1       	ldi	r24, 0x1C	; 28
    6f0a:	88 0e       	add	r8, r24
    6f0c:	91 1c       	adc	r9, r1
    6f0e:	ed b7       	in	r30, 0x3d	; 61
    6f10:	fe b7       	in	r31, 0x3e	; 62
    6f12:	e8 19       	sub	r30, r8
    6f14:	f9 09       	sbc	r31, r9
    6f16:	0f b6       	in	r0, 0x3f	; 63
    6f18:	f8 94       	cli
    6f1a:	fe bf       	out	0x3e, r31	; 62
    6f1c:	0f be       	out	0x3f, r0	; 63
    6f1e:	ed bf       	out	0x3d, r30	; 61
    6f20:	8d b7       	in	r24, 0x3d	; 61
    6f22:	9e b7       	in	r25, 0x3e	; 62
    6f24:	01 96       	adiw	r24, 0x01	; 1
    6f26:	7c 01       	movw	r14, r24

	RNDIS_Set_Complete_t SetMessageResponse;

	SetMessageData.SetMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_SET_MSG);
    6f28:	85 e0       	ldi	r24, 0x05	; 5
    6f2a:	90 e0       	ldi	r25, 0x00	; 0
    6f2c:	a0 e0       	ldi	r26, 0x00	; 0
    6f2e:	b0 e0       	ldi	r27, 0x00	; 0
    6f30:	81 83       	std	Z+1, r24	; 0x01
    6f32:	92 83       	std	Z+2, r25	; 0x02
    6f34:	a3 83       	std	Z+3, r26	; 0x03
    6f36:	b4 83       	std	Z+4, r27	; 0x04
	SetMessageData.SetMessage.MessageLength  = cpu_to_le32(sizeof(RNDIS_Set_Message_t) + Length);
    6f38:	c4 01       	movw	r24, r8
    6f3a:	a0 e0       	ldi	r26, 0x00	; 0
    6f3c:	b0 e0       	ldi	r27, 0x00	; 0
    6f3e:	f7 01       	movw	r30, r14
    6f40:	84 83       	std	Z+4, r24	; 0x04
    6f42:	95 83       	std	Z+5, r25	; 0x05
    6f44:	a6 83       	std	Z+6, r26	; 0x06
    6f46:	b7 83       	std	Z+7, r27	; 0x07
	SetMessageData.SetMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    6f48:	f6 01       	movw	r30, r12
    6f4a:	86 89       	ldd	r24, Z+22	; 0x16
    6f4c:	97 89       	ldd	r25, Z+23	; 0x17
    6f4e:	a0 8d       	ldd	r26, Z+24	; 0x18
    6f50:	b1 8d       	ldd	r27, Z+25	; 0x19
    6f52:	2c 01       	movw	r4, r24
    6f54:	3d 01       	movw	r6, r26
    6f56:	ff ef       	ldi	r31, 0xFF	; 255
    6f58:	4f 1a       	sub	r4, r31
    6f5a:	5f 0a       	sbc	r5, r31
    6f5c:	6f 0a       	sbc	r6, r31
    6f5e:	7f 0a       	sbc	r7, r31
    6f60:	f6 01       	movw	r30, r12
    6f62:	46 8a       	std	Z+22, r4	; 0x16
    6f64:	57 8a       	std	Z+23, r5	; 0x17
    6f66:	60 8e       	std	Z+24, r6	; 0x18
    6f68:	71 8e       	std	Z+25, r7	; 0x19
    6f6a:	f7 01       	movw	r30, r14
    6f6c:	80 87       	std	Z+8, r24	; 0x08
    6f6e:	91 87       	std	Z+9, r25	; 0x09
    6f70:	a2 87       	std	Z+10, r26	; 0x0a
    6f72:	b3 87       	std	Z+11, r27	; 0x0b

	SetMessageData.SetMessage.Oid            = cpu_to_le32(Oid);
    6f74:	44 87       	std	Z+12, r20	; 0x0c
    6f76:	55 87       	std	Z+13, r21	; 0x0d
    6f78:	66 87       	std	Z+14, r22	; 0x0e
    6f7a:	77 87       	std	Z+15, r23	; 0x0f
	SetMessageData.SetMessage.InformationBufferLength = cpu_to_le32(Length);
    6f7c:	c8 01       	movw	r24, r16
    6f7e:	a0 e0       	ldi	r26, 0x00	; 0
    6f80:	b0 e0       	ldi	r27, 0x00	; 0
    6f82:	80 8b       	std	Z+16, r24	; 0x10
    6f84:	91 8b       	std	Z+17, r25	; 0x11
    6f86:	a2 8b       	std	Z+18, r26	; 0x12
    6f88:	b3 8b       	std	Z+19, r27	; 0x13
	SetMessageData.SetMessage.InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Set_Message_t) - sizeof(RNDIS_Message_Header_t));
    6f8a:	84 e1       	ldi	r24, 0x14	; 20
    6f8c:	90 e0       	ldi	r25, 0x00	; 0
    6f8e:	a0 e0       	ldi	r26, 0x00	; 0
    6f90:	b0 e0       	ldi	r27, 0x00	; 0
    6f92:	84 8b       	std	Z+20, r24	; 0x14
    6f94:	95 8b       	std	Z+21, r25	; 0x15
    6f96:	a6 8b       	std	Z+22, r26	; 0x16
    6f98:	b7 8b       	std	Z+23, r27	; 0x17
	SetMessageData.SetMessage.DeviceVcHandle = CPU_TO_LE32(0);
    6f9a:	10 8e       	std	Z+24, r1	; 0x18
    6f9c:	11 8e       	std	Z+25, r1	; 0x19
    6f9e:	12 8e       	std	Z+26, r1	; 0x1a
    6fa0:	13 8e       	std	Z+27, r1	; 0x1b

	memcpy(&SetMessageData.ContiguousBuffer, Buffer, Length);
    6fa2:	8d b7       	in	r24, 0x3d	; 61
    6fa4:	9e b7       	in	r25, 0x3e	; 62
    6fa6:	4d 96       	adiw	r24, 0x1d	; 29
    6fa8:	a8 01       	movw	r20, r16
    6faa:	b9 01       	movw	r22, r18
    6fac:	55 d2       	rcall	.+1194   	; 0x7458 <memcpy>

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &SetMessageData,
    6fae:	a4 01       	movw	r20, r8
    6fb0:	b7 01       	movw	r22, r14
    6fb2:	c6 01       	movw	r24, r12
    6fb4:	fc dd       	rcall	.-1032   	; 0x6bae <RNDIS_SendEncapsulatedCommand>
    6fb6:	81 11       	cpse	r24, r1
    6fb8:	14 c0       	rjmp	.+40     	; 0x6fe2 <RNDIS_Host_SetRNDISProperty+0x112>
	                                               SetMessageData.SetMessage.MessageLength)) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &SetMessageResponse,
    6fba:	40 e1       	ldi	r20, 0x10	; 16
    6fbc:	50 e0       	ldi	r21, 0x00	; 0
    6fbe:	be 01       	movw	r22, r28
    6fc0:	6f 5f       	subi	r22, 0xFF	; 255
    6fc2:	7f 4f       	sbci	r23, 0xFF	; 255
    6fc4:	c6 01       	movw	r24, r12
    6fc6:	05 de       	rcall	.-1014   	; 0x6bd2 <RNDIS_GetEncapsulatedResponse>
    6fc8:	81 11       	cpse	r24, r1
    6fca:	0b c0       	rjmp	.+22     	; 0x6fe2 <RNDIS_Host_SetRNDISProperty+0x112>
	                                               sizeof(RNDIS_Set_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    6fcc:	8d 85       	ldd	r24, Y+13	; 0x0d
    6fce:	9e 85       	ldd	r25, Y+14	; 0x0e
    6fd0:	af 85       	ldd	r26, Y+15	; 0x0f
    6fd2:	b8 89       	ldd	r27, Y+16	; 0x10
    6fd4:	89 2b       	or	r24, r25
    6fd6:	8a 2b       	or	r24, r26
    6fd8:	8b 2b       	or	r24, r27
    6fda:	11 f4       	brne	.+4      	; 0x6fe0 <RNDIS_Host_SetRNDISProperty+0x110>
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	return HOST_SENDCONTROL_Successful;
    6fdc:	80 e0       	ldi	r24, 0x00	; 0
    6fde:	01 c0       	rjmp	.+2      	; 0x6fe2 <RNDIS_Host_SetRNDISProperty+0x112>
	{
		return ErrorCode;
	}

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    6fe0:	80 e8       	ldi	r24, 0x80	; 128

	return HOST_SENDCONTROL_Successful;
}
    6fe2:	0f b6       	in	r0, 0x3f	; 63
    6fe4:	f8 94       	cli
    6fe6:	be be       	out	0x3e, r11	; 62
    6fe8:	0f be       	out	0x3f, r0	; 63
    6fea:	ad be       	out	0x3d, r10	; 61
    6fec:	60 96       	adiw	r28, 0x10	; 16
    6fee:	0f b6       	in	r0, 0x3f	; 63
    6ff0:	f8 94       	cli
    6ff2:	de bf       	out	0x3e, r29	; 62
    6ff4:	0f be       	out	0x3f, r0	; 63
    6ff6:	cd bf       	out	0x3d, r28	; 61
    6ff8:	df 91       	pop	r29
    6ffa:	cf 91       	pop	r28
    6ffc:	1f 91       	pop	r17
    6ffe:	0f 91       	pop	r16
    7000:	ff 90       	pop	r15
    7002:	ef 90       	pop	r14
    7004:	df 90       	pop	r13
    7006:	cf 90       	pop	r12
    7008:	bf 90       	pop	r11
    700a:	af 90       	pop	r10
    700c:	9f 90       	pop	r9
    700e:	8f 90       	pop	r8
    7010:	7f 90       	pop	r7
    7012:	6f 90       	pop	r6
    7014:	5f 90       	pop	r5
    7016:	4f 90       	pop	r4
    7018:	08 95       	ret

0000701a <RNDIS_Host_QueryRNDISProperty>:

uint8_t RNDIS_Host_QueryRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                      const uint32_t Oid,
                                      void* Buffer,
                                      const uint16_t MaxLength)
{
    701a:	2f 92       	push	r2
    701c:	3f 92       	push	r3
    701e:	4f 92       	push	r4
    7020:	5f 92       	push	r5
    7022:	6f 92       	push	r6
    7024:	7f 92       	push	r7
    7026:	8f 92       	push	r8
    7028:	9f 92       	push	r9
    702a:	af 92       	push	r10
    702c:	bf 92       	push	r11
    702e:	cf 92       	push	r12
    7030:	df 92       	push	r13
    7032:	ef 92       	push	r14
    7034:	ff 92       	push	r15
    7036:	0f 93       	push	r16
    7038:	1f 93       	push	r17
    703a:	cf 93       	push	r28
    703c:	df 93       	push	r29
    703e:	cd b7       	in	r28, 0x3d	; 61
    7040:	de b7       	in	r29, 0x3e	; 62
    7042:	6c 97       	sbiw	r28, 0x1c	; 28
    7044:	0f b6       	in	r0, 0x3f	; 63
    7046:	f8 94       	cli
    7048:	de bf       	out	0x3e, r29	; 62
    704a:	0f be       	out	0x3f, r0	; 63
    704c:	cd bf       	out	0x3d, r28	; 61
    704e:	6c 01       	movw	r12, r24
    7050:	49 01       	movw	r8, r18
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    7052:	6d b6       	in	r6, 0x3d	; 61
    7054:	7e b6       	in	r7, 0x3e	; 62

	struct
	{
		RNDIS_Query_Complete_t QueryMessageResponse;
		uint8_t                ContiguousBuffer[MaxLength];
	} QueryMessageResponseData;
    7056:	58 01       	movw	r10, r16
    7058:	28 e1       	ldi	r18, 0x18	; 24
    705a:	a2 0e       	add	r10, r18
    705c:	b1 1c       	adc	r11, r1
    705e:	8d b7       	in	r24, 0x3d	; 61
    7060:	9e b7       	in	r25, 0x3e	; 62
    7062:	8a 19       	sub	r24, r10
    7064:	9b 09       	sbc	r25, r11
    7066:	0f b6       	in	r0, 0x3f	; 63
    7068:	f8 94       	cli
    706a:	9e bf       	out	0x3e, r25	; 62
    706c:	0f be       	out	0x3f, r0	; 63
    706e:	8d bf       	out	0x3d, r24	; 61
    7070:	ed b7       	in	r30, 0x3d	; 61
    7072:	fe b7       	in	r31, 0x3e	; 62
    7074:	31 96       	adiw	r30, 0x01	; 1
    7076:	7f 01       	movw	r14, r30

	QueryMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_QUERY_MSG);
    7078:	84 e0       	ldi	r24, 0x04	; 4
    707a:	90 e0       	ldi	r25, 0x00	; 0
    707c:	a0 e0       	ldi	r26, 0x00	; 0
    707e:	b0 e0       	ldi	r27, 0x00	; 0
    7080:	89 83       	std	Y+1, r24	; 0x01
    7082:	9a 83       	std	Y+2, r25	; 0x02
    7084:	ab 83       	std	Y+3, r26	; 0x03
    7086:	bc 83       	std	Y+4, r27	; 0x04
	QueryMessage.MessageLength  = CPU_TO_LE32(sizeof(RNDIS_Query_Message_t));
    7088:	8c e1       	ldi	r24, 0x1C	; 28
    708a:	90 e0       	ldi	r25, 0x00	; 0
    708c:	a0 e0       	ldi	r26, 0x00	; 0
    708e:	b0 e0       	ldi	r27, 0x00	; 0
    7090:	8d 83       	std	Y+5, r24	; 0x05
    7092:	9e 83       	std	Y+6, r25	; 0x06
    7094:	af 83       	std	Y+7, r26	; 0x07
    7096:	b8 87       	std	Y+8, r27	; 0x08
	QueryMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    7098:	f6 01       	movw	r30, r12
    709a:	86 89       	ldd	r24, Z+22	; 0x16
    709c:	97 89       	ldd	r25, Z+23	; 0x17
    709e:	a0 8d       	ldd	r26, Z+24	; 0x18
    70a0:	b1 8d       	ldd	r27, Z+25	; 0x19
    70a2:	1c 01       	movw	r2, r24
    70a4:	2d 01       	movw	r4, r26
    70a6:	ff ef       	ldi	r31, 0xFF	; 255
    70a8:	2f 1a       	sub	r2, r31
    70aa:	3f 0a       	sbc	r3, r31
    70ac:	4f 0a       	sbc	r4, r31
    70ae:	5f 0a       	sbc	r5, r31
    70b0:	f6 01       	movw	r30, r12
    70b2:	26 8a       	std	Z+22, r2	; 0x16
    70b4:	37 8a       	std	Z+23, r3	; 0x17
    70b6:	40 8e       	std	Z+24, r4	; 0x18
    70b8:	51 8e       	std	Z+25, r5	; 0x19
    70ba:	89 87       	std	Y+9, r24	; 0x09
    70bc:	9a 87       	std	Y+10, r25	; 0x0a
    70be:	ab 87       	std	Y+11, r26	; 0x0b
    70c0:	bc 87       	std	Y+12, r27	; 0x0c

	QueryMessage.Oid            = cpu_to_le32(Oid);
    70c2:	4d 87       	std	Y+13, r20	; 0x0d
    70c4:	5e 87       	std	Y+14, r21	; 0x0e
    70c6:	6f 87       	std	Y+15, r22	; 0x0f
    70c8:	78 8b       	std	Y+16, r23	; 0x10
	QueryMessage.InformationBufferLength = CPU_TO_LE32(0);
    70ca:	19 8a       	std	Y+17, r1	; 0x11
    70cc:	1a 8a       	std	Y+18, r1	; 0x12
    70ce:	1b 8a       	std	Y+19, r1	; 0x13
    70d0:	1c 8a       	std	Y+20, r1	; 0x14
	QueryMessage.InformationBufferOffset = CPU_TO_LE32(0);
    70d2:	1d 8a       	std	Y+21, r1	; 0x15
    70d4:	1e 8a       	std	Y+22, r1	; 0x16
    70d6:	1f 8a       	std	Y+23, r1	; 0x17
    70d8:	18 8e       	std	Y+24, r1	; 0x18
	QueryMessage.DeviceVcHandle = CPU_TO_LE32(0);
    70da:	19 8e       	std	Y+25, r1	; 0x19
    70dc:	1a 8e       	std	Y+26, r1	; 0x1a
    70de:	1b 8e       	std	Y+27, r1	; 0x1b
    70e0:	1c 8e       	std	Y+28, r1	; 0x1c

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &QueryMessage,
    70e2:	4c e1       	ldi	r20, 0x1C	; 28
    70e4:	50 e0       	ldi	r21, 0x00	; 0
    70e6:	be 01       	movw	r22, r28
    70e8:	6f 5f       	subi	r22, 0xFF	; 255
    70ea:	7f 4f       	sbci	r23, 0xFF	; 255
    70ec:	c6 01       	movw	r24, r12
    70ee:	5f dd       	rcall	.-1346   	; 0x6bae <RNDIS_SendEncapsulatedCommand>
    70f0:	81 11       	cpse	r24, r1
    70f2:	18 c0       	rjmp	.+48     	; 0x7124 <RNDIS_Host_QueryRNDISProperty+0x10a>
	                                               sizeof(RNDIS_Query_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &QueryMessageResponseData,
    70f4:	a5 01       	movw	r20, r10
    70f6:	b7 01       	movw	r22, r14
    70f8:	c6 01       	movw	r24, r12
    70fa:	6b dd       	rcall	.-1322   	; 0x6bd2 <RNDIS_GetEncapsulatedResponse>
    70fc:	81 11       	cpse	r24, r1
    70fe:	12 c0       	rjmp	.+36     	; 0x7124 <RNDIS_Host_QueryRNDISProperty+0x10a>
	                                               sizeof(QueryMessageResponseData))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    7100:	f7 01       	movw	r30, r14
    7102:	84 85       	ldd	r24, Z+12	; 0x0c
    7104:	95 85       	ldd	r25, Z+13	; 0x0d
    7106:	a6 85       	ldd	r26, Z+14	; 0x0e
    7108:	b7 85       	ldd	r27, Z+15	; 0x0f
    710a:	89 2b       	or	r24, r25
    710c:	8a 2b       	or	r24, r26
    710e:	8b 2b       	or	r24, r27
    7110:	41 f4       	brne	.+16     	; 0x7122 <RNDIS_Host_QueryRNDISProperty+0x108>
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);
    7112:	b7 01       	movw	r22, r14
    7114:	68 5e       	subi	r22, 0xE8	; 232
    7116:	7f 4f       	sbci	r23, 0xFF	; 255
    7118:	a8 01       	movw	r20, r16
    711a:	c4 01       	movw	r24, r8
    711c:	9d d1       	rcall	.+826    	; 0x7458 <memcpy>

	return HOST_SENDCONTROL_Successful;
    711e:	80 e0       	ldi	r24, 0x00	; 0
    7120:	01 c0       	rjmp	.+2      	; 0x7124 <RNDIS_Host_QueryRNDISProperty+0x10a>
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    7122:	80 e8       	ldi	r24, 0x80	; 128

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    7124:	0f b6       	in	r0, 0x3f	; 63
    7126:	f8 94       	cli
    7128:	7e be       	out	0x3e, r7	; 62
    712a:	0f be       	out	0x3f, r0	; 63
    712c:	6d be       	out	0x3d, r6	; 61
    712e:	6c 96       	adiw	r28, 0x1c	; 28
    7130:	0f b6       	in	r0, 0x3f	; 63
    7132:	f8 94       	cli
    7134:	de bf       	out	0x3e, r29	; 62
    7136:	0f be       	out	0x3f, r0	; 63
    7138:	cd bf       	out	0x3d, r28	; 61
    713a:	df 91       	pop	r29
    713c:	cf 91       	pop	r28
    713e:	1f 91       	pop	r17
    7140:	0f 91       	pop	r16
    7142:	ff 90       	pop	r15
    7144:	ef 90       	pop	r14
    7146:	df 90       	pop	r13
    7148:	cf 90       	pop	r12
    714a:	bf 90       	pop	r11
    714c:	af 90       	pop	r10
    714e:	9f 90       	pop	r9
    7150:	8f 90       	pop	r8
    7152:	7f 90       	pop	r7
    7154:	6f 90       	pop	r6
    7156:	5f 90       	pop	r5
    7158:	4f 90       	pop	r4
    715a:	3f 90       	pop	r3
    715c:	2f 90       	pop	r2
    715e:	08 95       	ret

00007160 <RNDIS_Host_IsPacketReceived>:

bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    7160:	fc 01       	movw	r30, r24
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    7162:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <USB_HostState>
    7166:	8b 30       	cpi	r24, 0x0B	; 11
    7168:	a1 f4       	brne	.+40     	; 0x7192 <RNDIS_Host_IsPacketReceived+0x32>
    716a:	82 85       	ldd	r24, Z+10	; 0x0a
    716c:	88 23       	and	r24, r24
    716e:	91 f0       	breq	.+36     	; 0x7194 <RNDIS_Host_IsPacketReceived+0x34>
	  return false;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipeNumber);
    7170:	80 81       	ld	r24, Z
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    7172:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    7176:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    717a:	8f 7b       	andi	r24, 0xBF	; 191
    717c:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    7180:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    7184:	81 70       	andi	r24, 0x01	; 1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7186:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    718a:	90 64       	ori	r25, 0x40	; 64
    718c:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>

	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
    7190:	08 95       	ret
bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return false;
    7192:	80 e0       	ldi	r24, 0x00	; 0
	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
}
    7194:	08 95       	ret

00007196 <RNDIS_Host_ReadPacket>:

uint8_t RNDIS_Host_ReadPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              uint16_t* const PacketLength)
{
    7196:	ef 92       	push	r14
    7198:	ff 92       	push	r15
    719a:	0f 93       	push	r16
    719c:	1f 93       	push	r17
    719e:	cf 93       	push	r28
    71a0:	df 93       	push	r29
    71a2:	cd b7       	in	r28, 0x3d	; 61
    71a4:	de b7       	in	r29, 0x3e	; 62
    71a6:	ac 97       	sbiw	r28, 0x2c	; 44
    71a8:	0f b6       	in	r0, 0x3f	; 63
    71aa:	f8 94       	cli
    71ac:	de bf       	out	0x3e, r29	; 62
    71ae:	0f be       	out	0x3f, r0	; 63
    71b0:	cd bf       	out	0x3d, r28	; 61
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    71b2:	20 91 97 0d 	lds	r18, 0x0D97	; 0x800d97 <USB_HostState>
    71b6:	2b 30       	cpi	r18, 0x0B	; 11
    71b8:	09 f0       	breq	.+2      	; 0x71bc <RNDIS_Host_ReadPacket+0x26>
    71ba:	57 c0       	rjmp	.+174    	; 0x726a <RNDIS_Host_ReadPacket+0xd4>
    71bc:	fc 01       	movw	r30, r24
    71be:	22 85       	ldd	r18, Z+10	; 0x0a
    71c0:	22 23       	and	r18, r18
    71c2:	09 f4       	brne	.+2      	; 0x71c6 <RNDIS_Host_ReadPacket+0x30>
    71c4:	52 c0       	rjmp	.+164    	; 0x726a <RNDIS_Host_ReadPacket+0xd4>
	  return PIPE_READYWAIT_DeviceDisconnected;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipeNumber);
    71c6:	80 81       	ld	r24, Z
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    71c8:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    71cc:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    71d0:	9f 7b       	andi	r25, 0xBF	; 191
    71d2:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    71d6:	90 91 a6 00 	lds	r25, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
	Pipe_Unfreeze();

	if (!(Pipe_IsReadWriteAllowed()))
    71da:	89 2f       	mov	r24, r25
    71dc:	80 72       	andi	r24, 0x20	; 32
    71de:	95 fd       	sbrc	r25, 5
    71e0:	12 c0       	rjmp	.+36     	; 0x7206 <RNDIS_Host_ReadPacket+0x70>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    71e2:	90 91 a6 00 	lds	r25, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
	{
		if (Pipe_IsINReceived())
    71e6:	90 ff       	sbrs	r25, 0
    71e8:	05 c0       	rjmp	.+10     	; 0x71f4 <RNDIS_Host_ReadPacket+0x5e>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    71ea:	90 91 a6 00 	lds	r25, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    71ee:	9e 77       	andi	r25, 0x7E	; 126
    71f0:	90 93 a6 00 	sts	0x00A6, r25	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
		  Pipe_ClearIN();

		*PacketLength = 0;
    71f4:	fa 01       	movw	r30, r20
    71f6:	11 82       	std	Z+1, r1	; 0x01
    71f8:	10 82       	st	Z, r1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    71fa:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    71fe:	90 64       	ori	r25, 0x40	; 64
    7200:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
		Pipe_Freeze();
		return PIPE_RWSTREAM_NoError;
    7204:	33 c0       	rjmp	.+102    	; 0x726c <RNDIS_Host_ReadPacket+0xd6>
    7206:	8a 01       	movw	r16, r20
    7208:	7b 01       	movw	r14, r22
	}

	RNDIS_Packet_Message_t DeviceMessage;

	if ((ErrorCode = Pipe_Read_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    720a:	40 e0       	ldi	r20, 0x00	; 0
    720c:	50 e0       	ldi	r21, 0x00	; 0
    720e:	6c e2       	ldi	r22, 0x2C	; 44
    7210:	70 e0       	ldi	r23, 0x00	; 0
    7212:	ce 01       	movw	r24, r28
    7214:	01 96       	adiw	r24, 0x01	; 1
    7216:	0e 94 7d 2c 	call	0x58fa	; 0x58fa <Pipe_Read_Stream_LE>
    721a:	81 11       	cpse	r24, r1
    721c:	27 c0       	rjmp	.+78     	; 0x726c <RNDIS_Host_ReadPacket+0xd6>
	                                     NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	*PacketLength = (uint16_t)le32_to_cpu(DeviceMessage.DataLength);
    721e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7220:	9e 85       	ldd	r25, Y+14	; 0x0e
    7222:	f8 01       	movw	r30, r16
    7224:	91 83       	std	Z+1, r25	; 0x01
    7226:	80 83       	st	Z, r24

	Pipe_Discard_Stream(DeviceMessage.DataOffset -
    7228:	89 85       	ldd	r24, Y+9	; 0x09
    722a:	9a 85       	ldd	r25, Y+10	; 0x0a
    722c:	60 e0       	ldi	r22, 0x00	; 0
    722e:	70 e0       	ldi	r23, 0x00	; 0
    7230:	84 97       	sbiw	r24, 0x24	; 36
    7232:	0e 94 e9 2b 	call	0x57d2	; 0x57d2 <Pipe_Discard_Stream>
	                    (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t)),
	                    NULL);

	Pipe_Read_Stream_LE(Buffer, *PacketLength, NULL);
    7236:	f8 01       	movw	r30, r16
    7238:	60 81       	ld	r22, Z
    723a:	71 81       	ldd	r23, Z+1	; 0x01
    723c:	40 e0       	ldi	r20, 0x00	; 0
    723e:	50 e0       	ldi	r21, 0x00	; 0
    7240:	c7 01       	movw	r24, r14
    7242:	0e 94 7d 2c 	call	0x58fa	; 0x58fa <Pipe_Read_Stream_LE>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    7246:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
    724a:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>

	if (!(Pipe_BytesInPipe()))
    724e:	89 2b       	or	r24, r25
    7250:	29 f4       	brne	.+10     	; 0x725c <RNDIS_Host_ReadPacket+0xc6>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    7252:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    7256:	8e 77       	andi	r24, 0x7E	; 126
    7258:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    725c:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    7260:	80 64       	ori	r24, 0x40	; 64
    7262:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    7266:	80 e0       	ldi	r24, 0x00	; 0
    7268:	01 c0       	rjmp	.+2      	; 0x726c <RNDIS_Host_ReadPacket+0xd6>
                              uint16_t* const PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return PIPE_READYWAIT_DeviceDisconnected;
    726a:	82 e0       	ldi	r24, 0x02	; 2
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
}
    726c:	ac 96       	adiw	r28, 0x2c	; 44
    726e:	0f b6       	in	r0, 0x3f	; 63
    7270:	f8 94       	cli
    7272:	de bf       	out	0x3e, r29	; 62
    7274:	0f be       	out	0x3f, r0	; 63
    7276:	cd bf       	out	0x3d, r28	; 61
    7278:	df 91       	pop	r29
    727a:	cf 91       	pop	r28
    727c:	1f 91       	pop	r17
    727e:	0f 91       	pop	r16
    7280:	ff 90       	pop	r15
    7282:	ef 90       	pop	r14
    7284:	08 95       	ret

00007286 <RNDIS_Host_SendPacket>:

uint8_t RNDIS_Host_SendPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              const uint16_t PacketLength)
{
    7286:	ef 92       	push	r14
    7288:	ff 92       	push	r15
    728a:	0f 93       	push	r16
    728c:	1f 93       	push	r17
    728e:	cf 93       	push	r28
    7290:	df 93       	push	r29
    7292:	cd b7       	in	r28, 0x3d	; 61
    7294:	de b7       	in	r29, 0x3e	; 62
    7296:	ac 97       	sbiw	r28, 0x2c	; 44
    7298:	0f b6       	in	r0, 0x3f	; 63
    729a:	f8 94       	cli
    729c:	de bf       	out	0x3e, r29	; 62
    729e:	0f be       	out	0x3f, r0	; 63
    72a0:	cd bf       	out	0x3d, r28	; 61
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    72a2:	20 91 97 0d 	lds	r18, 0x0D97	; 0x800d97 <USB_HostState>
    72a6:	2b 30       	cpi	r18, 0x0B	; 11
    72a8:	09 f0       	breq	.+2      	; 0x72ac <RNDIS_Host_SendPacket+0x26>
    72aa:	54 c0       	rjmp	.+168    	; 0x7354 <RNDIS_Host_SendPacket+0xce>
    72ac:	dc 01       	movw	r26, r24
    72ae:	1a 96       	adiw	r26, 0x0a	; 10
    72b0:	2c 91       	ld	r18, X
    72b2:	22 23       	and	r18, r18
    72b4:	09 f4       	brne	.+2      	; 0x72b8 <RNDIS_Host_SendPacket+0x32>
    72b6:	4e c0       	rjmp	.+156    	; 0x7354 <RNDIS_Host_SendPacket+0xce>
    72b8:	8a 01       	movw	r16, r20
    72ba:	7b 01       	movw	r14, r22
	  return PIPE_READYWAIT_DeviceDisconnected;

	RNDIS_Packet_Message_t DeviceMessage;

	memset(&DeviceMessage, 0, sizeof(RNDIS_Packet_Message_t));
    72bc:	fe 01       	movw	r30, r28
    72be:	31 96       	adiw	r30, 0x01	; 1
    72c0:	2c e2       	ldi	r18, 0x2C	; 44
    72c2:	df 01       	movw	r26, r30
    72c4:	1d 92       	st	X+, r1
    72c6:	2a 95       	dec	r18
    72c8:	e9 f7       	brne	.-6      	; 0x72c4 <RNDIS_Host_SendPacket+0x3e>
	DeviceMessage.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    72ca:	41 e0       	ldi	r20, 0x01	; 1
    72cc:	50 e0       	ldi	r21, 0x00	; 0
    72ce:	60 e0       	ldi	r22, 0x00	; 0
    72d0:	70 e0       	ldi	r23, 0x00	; 0
    72d2:	49 83       	std	Y+1, r20	; 0x01
    72d4:	5a 83       	std	Y+2, r21	; 0x02
    72d6:	6b 83       	std	Y+3, r22	; 0x03
    72d8:	7c 83       	std	Y+4, r23	; 0x04
	DeviceMessage.MessageLength = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    72da:	a8 01       	movw	r20, r16
    72dc:	44 5d       	subi	r20, 0xD4	; 212
    72de:	5f 4f       	sbci	r21, 0xFF	; 255
    72e0:	60 e0       	ldi	r22, 0x00	; 0
    72e2:	70 e0       	ldi	r23, 0x00	; 0
    72e4:	4d 83       	std	Y+5, r20	; 0x05
    72e6:	5e 83       	std	Y+6, r21	; 0x06
    72e8:	6f 83       	std	Y+7, r22	; 0x07
    72ea:	78 87       	std	Y+8, r23	; 0x08
	DeviceMessage.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    72ec:	44 e2       	ldi	r20, 0x24	; 36
    72ee:	50 e0       	ldi	r21, 0x00	; 0
    72f0:	60 e0       	ldi	r22, 0x00	; 0
    72f2:	70 e0       	ldi	r23, 0x00	; 0
    72f4:	49 87       	std	Y+9, r20	; 0x09
    72f6:	5a 87       	std	Y+10, r21	; 0x0a
    72f8:	6b 87       	std	Y+11, r22	; 0x0b
    72fa:	7c 87       	std	Y+12, r23	; 0x0c
	DeviceMessage.DataLength    = cpu_to_le32(PacketLength);
    72fc:	a8 01       	movw	r20, r16
    72fe:	60 e0       	ldi	r22, 0x00	; 0
    7300:	70 e0       	ldi	r23, 0x00	; 0
    7302:	4d 87       	std	Y+13, r20	; 0x0d
    7304:	5e 87       	std	Y+14, r21	; 0x0e
    7306:	6f 87       	std	Y+15, r22	; 0x0f
    7308:	78 8b       	std	Y+16, r23	; 0x10

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataOUTPipeNumber);
    730a:	dc 01       	movw	r26, r24
    730c:	12 96       	adiw	r26, 0x02	; 2
    730e:	8c 91       	ld	r24, X
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    7310:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    7314:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    7318:	9f 7b       	andi	r25, 0xBF	; 191
    731a:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
	Pipe_Unfreeze();

	if ((ErrorCode = Pipe_Write_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    731e:	40 e0       	ldi	r20, 0x00	; 0
    7320:	50 e0       	ldi	r21, 0x00	; 0
    7322:	6c e2       	ldi	r22, 0x2C	; 44
    7324:	70 e0       	ldi	r23, 0x00	; 0
    7326:	cf 01       	movw	r24, r30
    7328:	0e 94 2e 2c 	call	0x585c	; 0x585c <Pipe_Write_Stream_LE>
    732c:	81 11       	cpse	r24, r1
    732e:	13 c0       	rjmp	.+38     	; 0x7356 <RNDIS_Host_SendPacket+0xd0>
	                                      NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	Pipe_Write_Stream_LE(Buffer, PacketLength, NULL);
    7330:	40 e0       	ldi	r20, 0x00	; 0
    7332:	50 e0       	ldi	r21, 0x00	; 0
    7334:	b8 01       	movw	r22, r16
    7336:	c7 01       	movw	r24, r14
    7338:	0e 94 2e 2c 	call	0x585c	; 0x585c <Pipe_Write_Stream_LE>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    733c:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>
    7340:	8b 77       	andi	r24, 0x7B	; 123
    7342:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7346:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
    734a:	80 64       	ori	r24, 0x40	; 64
    734c:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    7350:	80 e0       	ldi	r24, 0x00	; 0
    7352:	01 c0       	rjmp	.+2      	; 0x7356 <RNDIS_Host_SendPacket+0xd0>
                              const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return PIPE_READYWAIT_DeviceDisconnected;
    7354:	82 e0       	ldi	r24, 0x02	; 2
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
}
    7356:	ac 96       	adiw	r28, 0x2c	; 44
    7358:	0f b6       	in	r0, 0x3f	; 63
    735a:	f8 94       	cli
    735c:	de bf       	out	0x3e, r29	; 62
    735e:	0f be       	out	0x3f, r0	; 63
    7360:	cd bf       	out	0x3d, r28	; 61
    7362:	df 91       	pop	r29
    7364:	cf 91       	pop	r28
    7366:	1f 91       	pop	r17
    7368:	0f 91       	pop	r16
    736a:	ff 90       	pop	r15
    736c:	ef 90       	pop	r14
    736e:	08 95       	ret

00007370 <__udivmodsi4>:
    7370:	a1 e2       	ldi	r26, 0x21	; 33
    7372:	1a 2e       	mov	r1, r26
    7374:	aa 1b       	sub	r26, r26
    7376:	bb 1b       	sub	r27, r27
    7378:	fd 01       	movw	r30, r26
    737a:	0d c0       	rjmp	.+26     	; 0x7396 <__udivmodsi4_ep>

0000737c <__udivmodsi4_loop>:
    737c:	aa 1f       	adc	r26, r26
    737e:	bb 1f       	adc	r27, r27
    7380:	ee 1f       	adc	r30, r30
    7382:	ff 1f       	adc	r31, r31
    7384:	a2 17       	cp	r26, r18
    7386:	b3 07       	cpc	r27, r19
    7388:	e4 07       	cpc	r30, r20
    738a:	f5 07       	cpc	r31, r21
    738c:	20 f0       	brcs	.+8      	; 0x7396 <__udivmodsi4_ep>
    738e:	a2 1b       	sub	r26, r18
    7390:	b3 0b       	sbc	r27, r19
    7392:	e4 0b       	sbc	r30, r20
    7394:	f5 0b       	sbc	r31, r21

00007396 <__udivmodsi4_ep>:
    7396:	66 1f       	adc	r22, r22
    7398:	77 1f       	adc	r23, r23
    739a:	88 1f       	adc	r24, r24
    739c:	99 1f       	adc	r25, r25
    739e:	1a 94       	dec	r1
    73a0:	69 f7       	brne	.-38     	; 0x737c <__udivmodsi4_loop>
    73a2:	60 95       	com	r22
    73a4:	70 95       	com	r23
    73a6:	80 95       	com	r24
    73a8:	90 95       	com	r25
    73aa:	9b 01       	movw	r18, r22
    73ac:	ac 01       	movw	r20, r24
    73ae:	bd 01       	movw	r22, r26
    73b0:	cf 01       	movw	r24, r30
    73b2:	08 95       	ret

000073b4 <__tablejump2__>:
    73b4:	ee 0f       	add	r30, r30
    73b6:	ff 1f       	adc	r31, r31
    73b8:	00 24       	eor	r0, r0
    73ba:	00 1c       	adc	r0, r0
    73bc:	0b be       	out	0x3b, r0	; 59
    73be:	07 90       	elpm	r0, Z+
    73c0:	f6 91       	elpm	r31, Z
    73c2:	e0 2d       	mov	r30, r0
    73c4:	09 94       	ijmp

000073c6 <__umulhisi3>:
    73c6:	a2 9f       	mul	r26, r18
    73c8:	b0 01       	movw	r22, r0
    73ca:	b3 9f       	mul	r27, r19
    73cc:	c0 01       	movw	r24, r0
    73ce:	a3 9f       	mul	r26, r19
    73d0:	70 0d       	add	r23, r0
    73d2:	81 1d       	adc	r24, r1
    73d4:	11 24       	eor	r1, r1
    73d6:	91 1d       	adc	r25, r1
    73d8:	b2 9f       	mul	r27, r18
    73da:	70 0d       	add	r23, r0
    73dc:	81 1d       	adc	r24, r1
    73de:	11 24       	eor	r1, r1
    73e0:	91 1d       	adc	r25, r1
    73e2:	08 95       	ret

000073e4 <__muluhisi3>:
    73e4:	f0 df       	rcall	.-32     	; 0x73c6 <__umulhisi3>
    73e6:	a5 9f       	mul	r26, r21
    73e8:	90 0d       	add	r25, r0
    73ea:	b4 9f       	mul	r27, r20
    73ec:	90 0d       	add	r25, r0
    73ee:	a4 9f       	mul	r26, r20
    73f0:	80 0d       	add	r24, r0
    73f2:	91 1d       	adc	r25, r1
    73f4:	11 24       	eor	r1, r1
    73f6:	08 95       	ret

000073f8 <memcpy_P>:
    73f8:	fb 01       	movw	r30, r22
    73fa:	dc 01       	movw	r26, r24
    73fc:	02 c0       	rjmp	.+4      	; 0x7402 <memcpy_P+0xa>
    73fe:	05 90       	lpm	r0, Z+
    7400:	0d 92       	st	X+, r0
    7402:	41 50       	subi	r20, 0x01	; 1
    7404:	50 40       	sbci	r21, 0x00	; 0
    7406:	d8 f7       	brcc	.-10     	; 0x73fe <memcpy_P+0x6>
    7408:	08 95       	ret

0000740a <strcmp_P>:
    740a:	fb 01       	movw	r30, r22
    740c:	dc 01       	movw	r26, r24
    740e:	8d 91       	ld	r24, X+
    7410:	05 90       	lpm	r0, Z+
    7412:	80 19       	sub	r24, r0
    7414:	01 10       	cpse	r0, r1
    7416:	d9 f3       	breq	.-10     	; 0x740e <strcmp_P+0x4>
    7418:	99 0b       	sbc	r25, r25
    741a:	08 95       	ret

0000741c <strcpy_P>:
    741c:	fb 01       	movw	r30, r22
    741e:	dc 01       	movw	r26, r24
    7420:	05 90       	lpm	r0, Z+
    7422:	0d 92       	st	X+, r0
    7424:	00 20       	and	r0, r0
    7426:	e1 f7       	brne	.-8      	; 0x7420 <strcpy_P+0x4>
    7428:	08 95       	ret

0000742a <strlcpy_P>:
    742a:	dc 01       	movw	r26, r24
    742c:	fb 01       	movw	r30, r22
    742e:	41 50       	subi	r20, 0x01	; 1
    7430:	50 40       	sbci	r21, 0x00	; 0
    7432:	58 f0       	brcs	.+22     	; 0x744a <strlcpy_P+0x20>
    7434:	49 f0       	breq	.+18     	; 0x7448 <strlcpy_P+0x1e>
    7436:	05 90       	lpm	r0, Z+
    7438:	0d 92       	st	X+, r0
    743a:	00 20       	and	r0, r0
    743c:	c1 f7       	brne	.-16     	; 0x742e <strlcpy_P+0x4>
    743e:	e6 1b       	sub	r30, r22
    7440:	f7 0b       	sbc	r31, r23
    7442:	31 97       	sbiw	r30, 0x01	; 1
    7444:	cf 01       	movw	r24, r30
    7446:	08 95       	ret
    7448:	1c 92       	st	X, r1
    744a:	05 90       	lpm	r0, Z+
    744c:	00 20       	and	r0, r0
    744e:	e9 f7       	brne	.-6      	; 0x744a <strlcpy_P+0x20>
    7450:	f6 cf       	rjmp	.-20     	; 0x743e <strlcpy_P+0x14>

00007452 <strtok>:
    7452:	4b eb       	ldi	r20, 0xBB	; 187
    7454:	53 e0       	ldi	r21, 0x03	; 3
    7456:	3f c0       	rjmp	.+126    	; 0x74d6 <strtok_r>

00007458 <memcpy>:
    7458:	fb 01       	movw	r30, r22
    745a:	dc 01       	movw	r26, r24
    745c:	02 c0       	rjmp	.+4      	; 0x7462 <memcpy+0xa>
    745e:	01 90       	ld	r0, Z+
    7460:	0d 92       	st	X+, r0
    7462:	41 50       	subi	r20, 0x01	; 1
    7464:	50 40       	sbci	r21, 0x00	; 0
    7466:	d8 f7       	brcc	.-10     	; 0x745e <memcpy+0x6>
    7468:	08 95       	ret

0000746a <memset>:
    746a:	dc 01       	movw	r26, r24
    746c:	01 c0       	rjmp	.+2      	; 0x7470 <memset+0x6>
    746e:	6d 93       	st	X+, r22
    7470:	41 50       	subi	r20, 0x01	; 1
    7472:	50 40       	sbci	r21, 0x00	; 0
    7474:	e0 f7       	brcc	.-8      	; 0x746e <memset+0x4>
    7476:	08 95       	ret

00007478 <strchr>:
    7478:	fc 01       	movw	r30, r24
    747a:	81 91       	ld	r24, Z+
    747c:	86 17       	cp	r24, r22
    747e:	21 f0       	breq	.+8      	; 0x7488 <strchr+0x10>
    7480:	88 23       	and	r24, r24
    7482:	d9 f7       	brne	.-10     	; 0x747a <strchr+0x2>
    7484:	99 27       	eor	r25, r25
    7486:	08 95       	ret
    7488:	31 97       	sbiw	r30, 0x01	; 1
    748a:	cf 01       	movw	r24, r30
    748c:	08 95       	ret

0000748e <strcmp>:
    748e:	fb 01       	movw	r30, r22
    7490:	dc 01       	movw	r26, r24
    7492:	8d 91       	ld	r24, X+
    7494:	01 90       	ld	r0, Z+
    7496:	80 19       	sub	r24, r0
    7498:	01 10       	cpse	r0, r1
    749a:	d9 f3       	breq	.-10     	; 0x7492 <strcmp+0x4>
    749c:	99 0b       	sbc	r25, r25
    749e:	08 95       	ret

000074a0 <strcpy>:
    74a0:	fb 01       	movw	r30, r22
    74a2:	dc 01       	movw	r26, r24
    74a4:	01 90       	ld	r0, Z+
    74a6:	0d 92       	st	X+, r0
    74a8:	00 20       	and	r0, r0
    74aa:	e1 f7       	brne	.-8      	; 0x74a4 <strcpy+0x4>
    74ac:	08 95       	ret

000074ae <strlcpy>:
    74ae:	dc 01       	movw	r26, r24
    74b0:	fb 01       	movw	r30, r22
    74b2:	41 50       	subi	r20, 0x01	; 1
    74b4:	50 40       	sbci	r21, 0x00	; 0
    74b6:	58 f0       	brcs	.+22     	; 0x74ce <strlcpy+0x20>
    74b8:	49 f0       	breq	.+18     	; 0x74cc <strlcpy+0x1e>
    74ba:	01 90       	ld	r0, Z+
    74bc:	0d 92       	st	X+, r0
    74be:	00 20       	and	r0, r0
    74c0:	c1 f7       	brne	.-16     	; 0x74b2 <strlcpy+0x4>
    74c2:	e6 1b       	sub	r30, r22
    74c4:	f7 0b       	sbc	r31, r23
    74c6:	31 97       	sbiw	r30, 0x01	; 1
    74c8:	cf 01       	movw	r24, r30
    74ca:	08 95       	ret
    74cc:	1c 92       	st	X, r1
    74ce:	01 90       	ld	r0, Z+
    74d0:	00 20       	and	r0, r0
    74d2:	e9 f7       	brne	.-6      	; 0x74ce <strlcpy+0x20>
    74d4:	f6 cf       	rjmp	.-20     	; 0x74c2 <strlcpy+0x14>

000074d6 <strtok_r>:
    74d6:	fa 01       	movw	r30, r20
    74d8:	a1 91       	ld	r26, Z+
    74da:	b0 81       	ld	r27, Z
    74dc:	00 97       	sbiw	r24, 0x00	; 0
    74de:	19 f4       	brne	.+6      	; 0x74e6 <strtok_r+0x10>
    74e0:	10 97       	sbiw	r26, 0x00	; 0
    74e2:	e1 f0       	breq	.+56     	; 0x751c <strtok_r+0x46>
    74e4:	cd 01       	movw	r24, r26
    74e6:	dc 01       	movw	r26, r24
    74e8:	cd 01       	movw	r24, r26
    74ea:	0d 90       	ld	r0, X+
    74ec:	00 20       	and	r0, r0
    74ee:	11 f4       	brne	.+4      	; 0x74f4 <strtok_r+0x1e>
    74f0:	c0 01       	movw	r24, r0
    74f2:	13 c0       	rjmp	.+38     	; 0x751a <strtok_r+0x44>
    74f4:	fb 01       	movw	r30, r22
    74f6:	21 91       	ld	r18, Z+
    74f8:	22 23       	and	r18, r18
    74fa:	19 f0       	breq	.+6      	; 0x7502 <strtok_r+0x2c>
    74fc:	20 15       	cp	r18, r0
    74fe:	d9 f7       	brne	.-10     	; 0x74f6 <strtok_r+0x20>
    7500:	f3 cf       	rjmp	.-26     	; 0x74e8 <strtok_r+0x12>
    7502:	fb 01       	movw	r30, r22
    7504:	21 91       	ld	r18, Z+
    7506:	20 15       	cp	r18, r0
    7508:	19 f4       	brne	.+6      	; 0x7510 <strtok_r+0x3a>
    750a:	1e 92       	st	-X, r1
    750c:	11 96       	adiw	r26, 0x01	; 1
    750e:	06 c0       	rjmp	.+12     	; 0x751c <strtok_r+0x46>
    7510:	22 23       	and	r18, r18
    7512:	c1 f7       	brne	.-16     	; 0x7504 <strtok_r+0x2e>
    7514:	0d 90       	ld	r0, X+
    7516:	00 20       	and	r0, r0
    7518:	a1 f7       	brne	.-24     	; 0x7502 <strtok_r+0x2c>
    751a:	d0 01       	movw	r26, r0
    751c:	fa 01       	movw	r30, r20
    751e:	a1 93       	st	Z+, r26
    7520:	b0 83       	st	Z, r27
    7522:	08 95       	ret

00007524 <sprintf_P>:
    7524:	0f 93       	push	r16
    7526:	1f 93       	push	r17
    7528:	cf 93       	push	r28
    752a:	df 93       	push	r29
    752c:	cd b7       	in	r28, 0x3d	; 61
    752e:	de b7       	in	r29, 0x3e	; 62
    7530:	2e 97       	sbiw	r28, 0x0e	; 14
    7532:	0f b6       	in	r0, 0x3f	; 63
    7534:	f8 94       	cli
    7536:	de bf       	out	0x3e, r29	; 62
    7538:	0f be       	out	0x3f, r0	; 63
    753a:	cd bf       	out	0x3d, r28	; 61
    753c:	0d 89       	ldd	r16, Y+21	; 0x15
    753e:	1e 89       	ldd	r17, Y+22	; 0x16
    7540:	8e e0       	ldi	r24, 0x0E	; 14
    7542:	8c 83       	std	Y+4, r24	; 0x04
    7544:	1a 83       	std	Y+2, r17	; 0x02
    7546:	09 83       	std	Y+1, r16	; 0x01
    7548:	8f ef       	ldi	r24, 0xFF	; 255
    754a:	9f e7       	ldi	r25, 0x7F	; 127
    754c:	9e 83       	std	Y+6, r25	; 0x06
    754e:	8d 83       	std	Y+5, r24	; 0x05
    7550:	ae 01       	movw	r20, r28
    7552:	47 5e       	subi	r20, 0xE7	; 231
    7554:	5f 4f       	sbci	r21, 0xFF	; 255
    7556:	6f 89       	ldd	r22, Y+23	; 0x17
    7558:	78 8d       	ldd	r23, Y+24	; 0x18
    755a:	ce 01       	movw	r24, r28
    755c:	01 96       	adiw	r24, 0x01	; 1
    755e:	10 d0       	rcall	.+32     	; 0x7580 <vfprintf>
    7560:	ef 81       	ldd	r30, Y+7	; 0x07
    7562:	f8 85       	ldd	r31, Y+8	; 0x08
    7564:	e0 0f       	add	r30, r16
    7566:	f1 1f       	adc	r31, r17
    7568:	10 82       	st	Z, r1
    756a:	2e 96       	adiw	r28, 0x0e	; 14
    756c:	0f b6       	in	r0, 0x3f	; 63
    756e:	f8 94       	cli
    7570:	de bf       	out	0x3e, r29	; 62
    7572:	0f be       	out	0x3f, r0	; 63
    7574:	cd bf       	out	0x3d, r28	; 61
    7576:	df 91       	pop	r29
    7578:	cf 91       	pop	r28
    757a:	1f 91       	pop	r17
    757c:	0f 91       	pop	r16
    757e:	08 95       	ret

00007580 <vfprintf>:
    7580:	2f 92       	push	r2
    7582:	3f 92       	push	r3
    7584:	4f 92       	push	r4
    7586:	5f 92       	push	r5
    7588:	6f 92       	push	r6
    758a:	7f 92       	push	r7
    758c:	8f 92       	push	r8
    758e:	9f 92       	push	r9
    7590:	af 92       	push	r10
    7592:	bf 92       	push	r11
    7594:	cf 92       	push	r12
    7596:	df 92       	push	r13
    7598:	ef 92       	push	r14
    759a:	ff 92       	push	r15
    759c:	0f 93       	push	r16
    759e:	1f 93       	push	r17
    75a0:	cf 93       	push	r28
    75a2:	df 93       	push	r29
    75a4:	cd b7       	in	r28, 0x3d	; 61
    75a6:	de b7       	in	r29, 0x3e	; 62
    75a8:	2b 97       	sbiw	r28, 0x0b	; 11
    75aa:	0f b6       	in	r0, 0x3f	; 63
    75ac:	f8 94       	cli
    75ae:	de bf       	out	0x3e, r29	; 62
    75b0:	0f be       	out	0x3f, r0	; 63
    75b2:	cd bf       	out	0x3d, r28	; 61
    75b4:	6c 01       	movw	r12, r24
    75b6:	7b 01       	movw	r14, r22
    75b8:	8a 01       	movw	r16, r20
    75ba:	fc 01       	movw	r30, r24
    75bc:	17 82       	std	Z+7, r1	; 0x07
    75be:	16 82       	std	Z+6, r1	; 0x06
    75c0:	83 81       	ldd	r24, Z+3	; 0x03
    75c2:	81 ff       	sbrs	r24, 1
    75c4:	bf c1       	rjmp	.+894    	; 0x7944 <vfprintf+0x3c4>
    75c6:	ce 01       	movw	r24, r28
    75c8:	01 96       	adiw	r24, 0x01	; 1
    75ca:	3c 01       	movw	r6, r24
    75cc:	f6 01       	movw	r30, r12
    75ce:	93 81       	ldd	r25, Z+3	; 0x03
    75d0:	f7 01       	movw	r30, r14
    75d2:	93 fd       	sbrc	r25, 3
    75d4:	85 91       	lpm	r24, Z+
    75d6:	93 ff       	sbrs	r25, 3
    75d8:	81 91       	ld	r24, Z+
    75da:	7f 01       	movw	r14, r30
    75dc:	88 23       	and	r24, r24
    75de:	09 f4       	brne	.+2      	; 0x75e2 <vfprintf+0x62>
    75e0:	ad c1       	rjmp	.+858    	; 0x793c <vfprintf+0x3bc>
    75e2:	85 32       	cpi	r24, 0x25	; 37
    75e4:	39 f4       	brne	.+14     	; 0x75f4 <vfprintf+0x74>
    75e6:	93 fd       	sbrc	r25, 3
    75e8:	85 91       	lpm	r24, Z+
    75ea:	93 ff       	sbrs	r25, 3
    75ec:	81 91       	ld	r24, Z+
    75ee:	7f 01       	movw	r14, r30
    75f0:	85 32       	cpi	r24, 0x25	; 37
    75f2:	21 f4       	brne	.+8      	; 0x75fc <vfprintf+0x7c>
    75f4:	b6 01       	movw	r22, r12
    75f6:	90 e0       	ldi	r25, 0x00	; 0
    75f8:	d6 d1       	rcall	.+940    	; 0x79a6 <fputc>
    75fa:	e8 cf       	rjmp	.-48     	; 0x75cc <vfprintf+0x4c>
    75fc:	91 2c       	mov	r9, r1
    75fe:	21 2c       	mov	r2, r1
    7600:	31 2c       	mov	r3, r1
    7602:	ff e1       	ldi	r31, 0x1F	; 31
    7604:	f3 15       	cp	r31, r3
    7606:	d8 f0       	brcs	.+54     	; 0x763e <vfprintf+0xbe>
    7608:	8b 32       	cpi	r24, 0x2B	; 43
    760a:	79 f0       	breq	.+30     	; 0x762a <vfprintf+0xaa>
    760c:	38 f4       	brcc	.+14     	; 0x761c <vfprintf+0x9c>
    760e:	80 32       	cpi	r24, 0x20	; 32
    7610:	79 f0       	breq	.+30     	; 0x7630 <vfprintf+0xb0>
    7612:	83 32       	cpi	r24, 0x23	; 35
    7614:	a1 f4       	brne	.+40     	; 0x763e <vfprintf+0xbe>
    7616:	23 2d       	mov	r18, r3
    7618:	20 61       	ori	r18, 0x10	; 16
    761a:	1d c0       	rjmp	.+58     	; 0x7656 <vfprintf+0xd6>
    761c:	8d 32       	cpi	r24, 0x2D	; 45
    761e:	61 f0       	breq	.+24     	; 0x7638 <vfprintf+0xb8>
    7620:	80 33       	cpi	r24, 0x30	; 48
    7622:	69 f4       	brne	.+26     	; 0x763e <vfprintf+0xbe>
    7624:	23 2d       	mov	r18, r3
    7626:	21 60       	ori	r18, 0x01	; 1
    7628:	16 c0       	rjmp	.+44     	; 0x7656 <vfprintf+0xd6>
    762a:	83 2d       	mov	r24, r3
    762c:	82 60       	ori	r24, 0x02	; 2
    762e:	38 2e       	mov	r3, r24
    7630:	e3 2d       	mov	r30, r3
    7632:	e4 60       	ori	r30, 0x04	; 4
    7634:	3e 2e       	mov	r3, r30
    7636:	2a c0       	rjmp	.+84     	; 0x768c <vfprintf+0x10c>
    7638:	f3 2d       	mov	r31, r3
    763a:	f8 60       	ori	r31, 0x08	; 8
    763c:	1d c0       	rjmp	.+58     	; 0x7678 <vfprintf+0xf8>
    763e:	37 fc       	sbrc	r3, 7
    7640:	2d c0       	rjmp	.+90     	; 0x769c <vfprintf+0x11c>
    7642:	20 ed       	ldi	r18, 0xD0	; 208
    7644:	28 0f       	add	r18, r24
    7646:	2a 30       	cpi	r18, 0x0A	; 10
    7648:	40 f0       	brcs	.+16     	; 0x765a <vfprintf+0xda>
    764a:	8e 32       	cpi	r24, 0x2E	; 46
    764c:	b9 f4       	brne	.+46     	; 0x767c <vfprintf+0xfc>
    764e:	36 fc       	sbrc	r3, 6
    7650:	75 c1       	rjmp	.+746    	; 0x793c <vfprintf+0x3bc>
    7652:	23 2d       	mov	r18, r3
    7654:	20 64       	ori	r18, 0x40	; 64
    7656:	32 2e       	mov	r3, r18
    7658:	19 c0       	rjmp	.+50     	; 0x768c <vfprintf+0x10c>
    765a:	36 fe       	sbrs	r3, 6
    765c:	06 c0       	rjmp	.+12     	; 0x766a <vfprintf+0xea>
    765e:	8a e0       	ldi	r24, 0x0A	; 10
    7660:	98 9e       	mul	r9, r24
    7662:	20 0d       	add	r18, r0
    7664:	11 24       	eor	r1, r1
    7666:	92 2e       	mov	r9, r18
    7668:	11 c0       	rjmp	.+34     	; 0x768c <vfprintf+0x10c>
    766a:	ea e0       	ldi	r30, 0x0A	; 10
    766c:	2e 9e       	mul	r2, r30
    766e:	20 0d       	add	r18, r0
    7670:	11 24       	eor	r1, r1
    7672:	22 2e       	mov	r2, r18
    7674:	f3 2d       	mov	r31, r3
    7676:	f0 62       	ori	r31, 0x20	; 32
    7678:	3f 2e       	mov	r3, r31
    767a:	08 c0       	rjmp	.+16     	; 0x768c <vfprintf+0x10c>
    767c:	8c 36       	cpi	r24, 0x6C	; 108
    767e:	21 f4       	brne	.+8      	; 0x7688 <vfprintf+0x108>
    7680:	83 2d       	mov	r24, r3
    7682:	80 68       	ori	r24, 0x80	; 128
    7684:	38 2e       	mov	r3, r24
    7686:	02 c0       	rjmp	.+4      	; 0x768c <vfprintf+0x10c>
    7688:	88 36       	cpi	r24, 0x68	; 104
    768a:	41 f4       	brne	.+16     	; 0x769c <vfprintf+0x11c>
    768c:	f7 01       	movw	r30, r14
    768e:	93 fd       	sbrc	r25, 3
    7690:	85 91       	lpm	r24, Z+
    7692:	93 ff       	sbrs	r25, 3
    7694:	81 91       	ld	r24, Z+
    7696:	7f 01       	movw	r14, r30
    7698:	81 11       	cpse	r24, r1
    769a:	b3 cf       	rjmp	.-154    	; 0x7602 <vfprintf+0x82>
    769c:	98 2f       	mov	r25, r24
    769e:	9f 7d       	andi	r25, 0xDF	; 223
    76a0:	95 54       	subi	r25, 0x45	; 69
    76a2:	93 30       	cpi	r25, 0x03	; 3
    76a4:	28 f4       	brcc	.+10     	; 0x76b0 <vfprintf+0x130>
    76a6:	0c 5f       	subi	r16, 0xFC	; 252
    76a8:	1f 4f       	sbci	r17, 0xFF	; 255
    76aa:	9f e3       	ldi	r25, 0x3F	; 63
    76ac:	99 83       	std	Y+1, r25	; 0x01
    76ae:	0d c0       	rjmp	.+26     	; 0x76ca <vfprintf+0x14a>
    76b0:	83 36       	cpi	r24, 0x63	; 99
    76b2:	31 f0       	breq	.+12     	; 0x76c0 <vfprintf+0x140>
    76b4:	83 37       	cpi	r24, 0x73	; 115
    76b6:	71 f0       	breq	.+28     	; 0x76d4 <vfprintf+0x154>
    76b8:	83 35       	cpi	r24, 0x53	; 83
    76ba:	09 f0       	breq	.+2      	; 0x76be <vfprintf+0x13e>
    76bc:	55 c0       	rjmp	.+170    	; 0x7768 <vfprintf+0x1e8>
    76be:	20 c0       	rjmp	.+64     	; 0x7700 <vfprintf+0x180>
    76c0:	f8 01       	movw	r30, r16
    76c2:	80 81       	ld	r24, Z
    76c4:	89 83       	std	Y+1, r24	; 0x01
    76c6:	0e 5f       	subi	r16, 0xFE	; 254
    76c8:	1f 4f       	sbci	r17, 0xFF	; 255
    76ca:	88 24       	eor	r8, r8
    76cc:	83 94       	inc	r8
    76ce:	91 2c       	mov	r9, r1
    76d0:	53 01       	movw	r10, r6
    76d2:	12 c0       	rjmp	.+36     	; 0x76f8 <vfprintf+0x178>
    76d4:	28 01       	movw	r4, r16
    76d6:	f2 e0       	ldi	r31, 0x02	; 2
    76d8:	4f 0e       	add	r4, r31
    76da:	51 1c       	adc	r5, r1
    76dc:	f8 01       	movw	r30, r16
    76de:	a0 80       	ld	r10, Z
    76e0:	b1 80       	ldd	r11, Z+1	; 0x01
    76e2:	36 fe       	sbrs	r3, 6
    76e4:	03 c0       	rjmp	.+6      	; 0x76ec <vfprintf+0x16c>
    76e6:	69 2d       	mov	r22, r9
    76e8:	70 e0       	ldi	r23, 0x00	; 0
    76ea:	02 c0       	rjmp	.+4      	; 0x76f0 <vfprintf+0x170>
    76ec:	6f ef       	ldi	r22, 0xFF	; 255
    76ee:	7f ef       	ldi	r23, 0xFF	; 255
    76f0:	c5 01       	movw	r24, r10
    76f2:	4e d1       	rcall	.+668    	; 0x7990 <strnlen>
    76f4:	4c 01       	movw	r8, r24
    76f6:	82 01       	movw	r16, r4
    76f8:	f3 2d       	mov	r31, r3
    76fa:	ff 77       	andi	r31, 0x7F	; 127
    76fc:	3f 2e       	mov	r3, r31
    76fe:	15 c0       	rjmp	.+42     	; 0x772a <vfprintf+0x1aa>
    7700:	28 01       	movw	r4, r16
    7702:	22 e0       	ldi	r18, 0x02	; 2
    7704:	42 0e       	add	r4, r18
    7706:	51 1c       	adc	r5, r1
    7708:	f8 01       	movw	r30, r16
    770a:	a0 80       	ld	r10, Z
    770c:	b1 80       	ldd	r11, Z+1	; 0x01
    770e:	36 fe       	sbrs	r3, 6
    7710:	03 c0       	rjmp	.+6      	; 0x7718 <vfprintf+0x198>
    7712:	69 2d       	mov	r22, r9
    7714:	70 e0       	ldi	r23, 0x00	; 0
    7716:	02 c0       	rjmp	.+4      	; 0x771c <vfprintf+0x19c>
    7718:	6f ef       	ldi	r22, 0xFF	; 255
    771a:	7f ef       	ldi	r23, 0xFF	; 255
    771c:	c5 01       	movw	r24, r10
    771e:	2d d1       	rcall	.+602    	; 0x797a <strnlen_P>
    7720:	4c 01       	movw	r8, r24
    7722:	f3 2d       	mov	r31, r3
    7724:	f0 68       	ori	r31, 0x80	; 128
    7726:	3f 2e       	mov	r3, r31
    7728:	82 01       	movw	r16, r4
    772a:	33 fc       	sbrc	r3, 3
    772c:	19 c0       	rjmp	.+50     	; 0x7760 <vfprintf+0x1e0>
    772e:	82 2d       	mov	r24, r2
    7730:	90 e0       	ldi	r25, 0x00	; 0
    7732:	88 16       	cp	r8, r24
    7734:	99 06       	cpc	r9, r25
    7736:	a0 f4       	brcc	.+40     	; 0x7760 <vfprintf+0x1e0>
    7738:	b6 01       	movw	r22, r12
    773a:	80 e2       	ldi	r24, 0x20	; 32
    773c:	90 e0       	ldi	r25, 0x00	; 0
    773e:	33 d1       	rcall	.+614    	; 0x79a6 <fputc>
    7740:	2a 94       	dec	r2
    7742:	f5 cf       	rjmp	.-22     	; 0x772e <vfprintf+0x1ae>
    7744:	f5 01       	movw	r30, r10
    7746:	37 fc       	sbrc	r3, 7
    7748:	85 91       	lpm	r24, Z+
    774a:	37 fe       	sbrs	r3, 7
    774c:	81 91       	ld	r24, Z+
    774e:	5f 01       	movw	r10, r30
    7750:	b6 01       	movw	r22, r12
    7752:	90 e0       	ldi	r25, 0x00	; 0
    7754:	28 d1       	rcall	.+592    	; 0x79a6 <fputc>
    7756:	21 10       	cpse	r2, r1
    7758:	2a 94       	dec	r2
    775a:	21 e0       	ldi	r18, 0x01	; 1
    775c:	82 1a       	sub	r8, r18
    775e:	91 08       	sbc	r9, r1
    7760:	81 14       	cp	r8, r1
    7762:	91 04       	cpc	r9, r1
    7764:	79 f7       	brne	.-34     	; 0x7744 <vfprintf+0x1c4>
    7766:	e1 c0       	rjmp	.+450    	; 0x792a <vfprintf+0x3aa>
    7768:	84 36       	cpi	r24, 0x64	; 100
    776a:	11 f0       	breq	.+4      	; 0x7770 <vfprintf+0x1f0>
    776c:	89 36       	cpi	r24, 0x69	; 105
    776e:	39 f5       	brne	.+78     	; 0x77be <vfprintf+0x23e>
    7770:	f8 01       	movw	r30, r16
    7772:	37 fe       	sbrs	r3, 7
    7774:	07 c0       	rjmp	.+14     	; 0x7784 <vfprintf+0x204>
    7776:	60 81       	ld	r22, Z
    7778:	71 81       	ldd	r23, Z+1	; 0x01
    777a:	82 81       	ldd	r24, Z+2	; 0x02
    777c:	93 81       	ldd	r25, Z+3	; 0x03
    777e:	0c 5f       	subi	r16, 0xFC	; 252
    7780:	1f 4f       	sbci	r17, 0xFF	; 255
    7782:	08 c0       	rjmp	.+16     	; 0x7794 <vfprintf+0x214>
    7784:	60 81       	ld	r22, Z
    7786:	71 81       	ldd	r23, Z+1	; 0x01
    7788:	07 2e       	mov	r0, r23
    778a:	00 0c       	add	r0, r0
    778c:	88 0b       	sbc	r24, r24
    778e:	99 0b       	sbc	r25, r25
    7790:	0e 5f       	subi	r16, 0xFE	; 254
    7792:	1f 4f       	sbci	r17, 0xFF	; 255
    7794:	f3 2d       	mov	r31, r3
    7796:	ff 76       	andi	r31, 0x6F	; 111
    7798:	3f 2e       	mov	r3, r31
    779a:	97 ff       	sbrs	r25, 7
    779c:	09 c0       	rjmp	.+18     	; 0x77b0 <vfprintf+0x230>
    779e:	90 95       	com	r25
    77a0:	80 95       	com	r24
    77a2:	70 95       	com	r23
    77a4:	61 95       	neg	r22
    77a6:	7f 4f       	sbci	r23, 0xFF	; 255
    77a8:	8f 4f       	sbci	r24, 0xFF	; 255
    77aa:	9f 4f       	sbci	r25, 0xFF	; 255
    77ac:	f0 68       	ori	r31, 0x80	; 128
    77ae:	3f 2e       	mov	r3, r31
    77b0:	2a e0       	ldi	r18, 0x0A	; 10
    77b2:	30 e0       	ldi	r19, 0x00	; 0
    77b4:	a3 01       	movw	r20, r6
    77b6:	33 d1       	rcall	.+614    	; 0x7a1e <__ultoa_invert>
    77b8:	88 2e       	mov	r8, r24
    77ba:	86 18       	sub	r8, r6
    77bc:	44 c0       	rjmp	.+136    	; 0x7846 <vfprintf+0x2c6>
    77be:	85 37       	cpi	r24, 0x75	; 117
    77c0:	31 f4       	brne	.+12     	; 0x77ce <vfprintf+0x24e>
    77c2:	23 2d       	mov	r18, r3
    77c4:	2f 7e       	andi	r18, 0xEF	; 239
    77c6:	b2 2e       	mov	r11, r18
    77c8:	2a e0       	ldi	r18, 0x0A	; 10
    77ca:	30 e0       	ldi	r19, 0x00	; 0
    77cc:	25 c0       	rjmp	.+74     	; 0x7818 <vfprintf+0x298>
    77ce:	93 2d       	mov	r25, r3
    77d0:	99 7f       	andi	r25, 0xF9	; 249
    77d2:	b9 2e       	mov	r11, r25
    77d4:	8f 36       	cpi	r24, 0x6F	; 111
    77d6:	c1 f0       	breq	.+48     	; 0x7808 <vfprintf+0x288>
    77d8:	18 f4       	brcc	.+6      	; 0x77e0 <vfprintf+0x260>
    77da:	88 35       	cpi	r24, 0x58	; 88
    77dc:	79 f0       	breq	.+30     	; 0x77fc <vfprintf+0x27c>
    77de:	ae c0       	rjmp	.+348    	; 0x793c <vfprintf+0x3bc>
    77e0:	80 37       	cpi	r24, 0x70	; 112
    77e2:	19 f0       	breq	.+6      	; 0x77ea <vfprintf+0x26a>
    77e4:	88 37       	cpi	r24, 0x78	; 120
    77e6:	21 f0       	breq	.+8      	; 0x77f0 <vfprintf+0x270>
    77e8:	a9 c0       	rjmp	.+338    	; 0x793c <vfprintf+0x3bc>
    77ea:	e9 2f       	mov	r30, r25
    77ec:	e0 61       	ori	r30, 0x10	; 16
    77ee:	be 2e       	mov	r11, r30
    77f0:	b4 fe       	sbrs	r11, 4
    77f2:	0d c0       	rjmp	.+26     	; 0x780e <vfprintf+0x28e>
    77f4:	fb 2d       	mov	r31, r11
    77f6:	f4 60       	ori	r31, 0x04	; 4
    77f8:	bf 2e       	mov	r11, r31
    77fa:	09 c0       	rjmp	.+18     	; 0x780e <vfprintf+0x28e>
    77fc:	34 fe       	sbrs	r3, 4
    77fe:	0a c0       	rjmp	.+20     	; 0x7814 <vfprintf+0x294>
    7800:	29 2f       	mov	r18, r25
    7802:	26 60       	ori	r18, 0x06	; 6
    7804:	b2 2e       	mov	r11, r18
    7806:	06 c0       	rjmp	.+12     	; 0x7814 <vfprintf+0x294>
    7808:	28 e0       	ldi	r18, 0x08	; 8
    780a:	30 e0       	ldi	r19, 0x00	; 0
    780c:	05 c0       	rjmp	.+10     	; 0x7818 <vfprintf+0x298>
    780e:	20 e1       	ldi	r18, 0x10	; 16
    7810:	30 e0       	ldi	r19, 0x00	; 0
    7812:	02 c0       	rjmp	.+4      	; 0x7818 <vfprintf+0x298>
    7814:	20 e1       	ldi	r18, 0x10	; 16
    7816:	32 e0       	ldi	r19, 0x02	; 2
    7818:	f8 01       	movw	r30, r16
    781a:	b7 fe       	sbrs	r11, 7
    781c:	07 c0       	rjmp	.+14     	; 0x782c <vfprintf+0x2ac>
    781e:	60 81       	ld	r22, Z
    7820:	71 81       	ldd	r23, Z+1	; 0x01
    7822:	82 81       	ldd	r24, Z+2	; 0x02
    7824:	93 81       	ldd	r25, Z+3	; 0x03
    7826:	0c 5f       	subi	r16, 0xFC	; 252
    7828:	1f 4f       	sbci	r17, 0xFF	; 255
    782a:	06 c0       	rjmp	.+12     	; 0x7838 <vfprintf+0x2b8>
    782c:	60 81       	ld	r22, Z
    782e:	71 81       	ldd	r23, Z+1	; 0x01
    7830:	80 e0       	ldi	r24, 0x00	; 0
    7832:	90 e0       	ldi	r25, 0x00	; 0
    7834:	0e 5f       	subi	r16, 0xFE	; 254
    7836:	1f 4f       	sbci	r17, 0xFF	; 255
    7838:	a3 01       	movw	r20, r6
    783a:	f1 d0       	rcall	.+482    	; 0x7a1e <__ultoa_invert>
    783c:	88 2e       	mov	r8, r24
    783e:	86 18       	sub	r8, r6
    7840:	fb 2d       	mov	r31, r11
    7842:	ff 77       	andi	r31, 0x7F	; 127
    7844:	3f 2e       	mov	r3, r31
    7846:	36 fe       	sbrs	r3, 6
    7848:	0d c0       	rjmp	.+26     	; 0x7864 <vfprintf+0x2e4>
    784a:	23 2d       	mov	r18, r3
    784c:	2e 7f       	andi	r18, 0xFE	; 254
    784e:	a2 2e       	mov	r10, r18
    7850:	89 14       	cp	r8, r9
    7852:	58 f4       	brcc	.+22     	; 0x786a <vfprintf+0x2ea>
    7854:	34 fe       	sbrs	r3, 4
    7856:	0b c0       	rjmp	.+22     	; 0x786e <vfprintf+0x2ee>
    7858:	32 fc       	sbrc	r3, 2
    785a:	09 c0       	rjmp	.+18     	; 0x786e <vfprintf+0x2ee>
    785c:	83 2d       	mov	r24, r3
    785e:	8e 7e       	andi	r24, 0xEE	; 238
    7860:	a8 2e       	mov	r10, r24
    7862:	05 c0       	rjmp	.+10     	; 0x786e <vfprintf+0x2ee>
    7864:	b8 2c       	mov	r11, r8
    7866:	a3 2c       	mov	r10, r3
    7868:	03 c0       	rjmp	.+6      	; 0x7870 <vfprintf+0x2f0>
    786a:	b8 2c       	mov	r11, r8
    786c:	01 c0       	rjmp	.+2      	; 0x7870 <vfprintf+0x2f0>
    786e:	b9 2c       	mov	r11, r9
    7870:	a4 fe       	sbrs	r10, 4
    7872:	0f c0       	rjmp	.+30     	; 0x7892 <vfprintf+0x312>
    7874:	fe 01       	movw	r30, r28
    7876:	e8 0d       	add	r30, r8
    7878:	f1 1d       	adc	r31, r1
    787a:	80 81       	ld	r24, Z
    787c:	80 33       	cpi	r24, 0x30	; 48
    787e:	21 f4       	brne	.+8      	; 0x7888 <vfprintf+0x308>
    7880:	9a 2d       	mov	r25, r10
    7882:	99 7e       	andi	r25, 0xE9	; 233
    7884:	a9 2e       	mov	r10, r25
    7886:	09 c0       	rjmp	.+18     	; 0x789a <vfprintf+0x31a>
    7888:	a2 fe       	sbrs	r10, 2
    788a:	06 c0       	rjmp	.+12     	; 0x7898 <vfprintf+0x318>
    788c:	b3 94       	inc	r11
    788e:	b3 94       	inc	r11
    7890:	04 c0       	rjmp	.+8      	; 0x789a <vfprintf+0x31a>
    7892:	8a 2d       	mov	r24, r10
    7894:	86 78       	andi	r24, 0x86	; 134
    7896:	09 f0       	breq	.+2      	; 0x789a <vfprintf+0x31a>
    7898:	b3 94       	inc	r11
    789a:	a3 fc       	sbrc	r10, 3
    789c:	10 c0       	rjmp	.+32     	; 0x78be <vfprintf+0x33e>
    789e:	a0 fe       	sbrs	r10, 0
    78a0:	06 c0       	rjmp	.+12     	; 0x78ae <vfprintf+0x32e>
    78a2:	b2 14       	cp	r11, r2
    78a4:	80 f4       	brcc	.+32     	; 0x78c6 <vfprintf+0x346>
    78a6:	28 0c       	add	r2, r8
    78a8:	92 2c       	mov	r9, r2
    78aa:	9b 18       	sub	r9, r11
    78ac:	0d c0       	rjmp	.+26     	; 0x78c8 <vfprintf+0x348>
    78ae:	b2 14       	cp	r11, r2
    78b0:	58 f4       	brcc	.+22     	; 0x78c8 <vfprintf+0x348>
    78b2:	b6 01       	movw	r22, r12
    78b4:	80 e2       	ldi	r24, 0x20	; 32
    78b6:	90 e0       	ldi	r25, 0x00	; 0
    78b8:	76 d0       	rcall	.+236    	; 0x79a6 <fputc>
    78ba:	b3 94       	inc	r11
    78bc:	f8 cf       	rjmp	.-16     	; 0x78ae <vfprintf+0x32e>
    78be:	b2 14       	cp	r11, r2
    78c0:	18 f4       	brcc	.+6      	; 0x78c8 <vfprintf+0x348>
    78c2:	2b 18       	sub	r2, r11
    78c4:	02 c0       	rjmp	.+4      	; 0x78ca <vfprintf+0x34a>
    78c6:	98 2c       	mov	r9, r8
    78c8:	21 2c       	mov	r2, r1
    78ca:	a4 fe       	sbrs	r10, 4
    78cc:	0f c0       	rjmp	.+30     	; 0x78ec <vfprintf+0x36c>
    78ce:	b6 01       	movw	r22, r12
    78d0:	80 e3       	ldi	r24, 0x30	; 48
    78d2:	90 e0       	ldi	r25, 0x00	; 0
    78d4:	68 d0       	rcall	.+208    	; 0x79a6 <fputc>
    78d6:	a2 fe       	sbrs	r10, 2
    78d8:	16 c0       	rjmp	.+44     	; 0x7906 <vfprintf+0x386>
    78da:	a1 fc       	sbrc	r10, 1
    78dc:	03 c0       	rjmp	.+6      	; 0x78e4 <vfprintf+0x364>
    78de:	88 e7       	ldi	r24, 0x78	; 120
    78e0:	90 e0       	ldi	r25, 0x00	; 0
    78e2:	02 c0       	rjmp	.+4      	; 0x78e8 <vfprintf+0x368>
    78e4:	88 e5       	ldi	r24, 0x58	; 88
    78e6:	90 e0       	ldi	r25, 0x00	; 0
    78e8:	b6 01       	movw	r22, r12
    78ea:	0c c0       	rjmp	.+24     	; 0x7904 <vfprintf+0x384>
    78ec:	8a 2d       	mov	r24, r10
    78ee:	86 78       	andi	r24, 0x86	; 134
    78f0:	51 f0       	breq	.+20     	; 0x7906 <vfprintf+0x386>
    78f2:	a1 fe       	sbrs	r10, 1
    78f4:	02 c0       	rjmp	.+4      	; 0x78fa <vfprintf+0x37a>
    78f6:	8b e2       	ldi	r24, 0x2B	; 43
    78f8:	01 c0       	rjmp	.+2      	; 0x78fc <vfprintf+0x37c>
    78fa:	80 e2       	ldi	r24, 0x20	; 32
    78fc:	a7 fc       	sbrc	r10, 7
    78fe:	8d e2       	ldi	r24, 0x2D	; 45
    7900:	b6 01       	movw	r22, r12
    7902:	90 e0       	ldi	r25, 0x00	; 0
    7904:	50 d0       	rcall	.+160    	; 0x79a6 <fputc>
    7906:	89 14       	cp	r8, r9
    7908:	30 f4       	brcc	.+12     	; 0x7916 <vfprintf+0x396>
    790a:	b6 01       	movw	r22, r12
    790c:	80 e3       	ldi	r24, 0x30	; 48
    790e:	90 e0       	ldi	r25, 0x00	; 0
    7910:	4a d0       	rcall	.+148    	; 0x79a6 <fputc>
    7912:	9a 94       	dec	r9
    7914:	f8 cf       	rjmp	.-16     	; 0x7906 <vfprintf+0x386>
    7916:	8a 94       	dec	r8
    7918:	f3 01       	movw	r30, r6
    791a:	e8 0d       	add	r30, r8
    791c:	f1 1d       	adc	r31, r1
    791e:	80 81       	ld	r24, Z
    7920:	b6 01       	movw	r22, r12
    7922:	90 e0       	ldi	r25, 0x00	; 0
    7924:	40 d0       	rcall	.+128    	; 0x79a6 <fputc>
    7926:	81 10       	cpse	r8, r1
    7928:	f6 cf       	rjmp	.-20     	; 0x7916 <vfprintf+0x396>
    792a:	22 20       	and	r2, r2
    792c:	09 f4       	brne	.+2      	; 0x7930 <vfprintf+0x3b0>
    792e:	4e ce       	rjmp	.-868    	; 0x75cc <vfprintf+0x4c>
    7930:	b6 01       	movw	r22, r12
    7932:	80 e2       	ldi	r24, 0x20	; 32
    7934:	90 e0       	ldi	r25, 0x00	; 0
    7936:	37 d0       	rcall	.+110    	; 0x79a6 <fputc>
    7938:	2a 94       	dec	r2
    793a:	f7 cf       	rjmp	.-18     	; 0x792a <vfprintf+0x3aa>
    793c:	f6 01       	movw	r30, r12
    793e:	86 81       	ldd	r24, Z+6	; 0x06
    7940:	97 81       	ldd	r25, Z+7	; 0x07
    7942:	02 c0       	rjmp	.+4      	; 0x7948 <vfprintf+0x3c8>
    7944:	8f ef       	ldi	r24, 0xFF	; 255
    7946:	9f ef       	ldi	r25, 0xFF	; 255
    7948:	2b 96       	adiw	r28, 0x0b	; 11
    794a:	0f b6       	in	r0, 0x3f	; 63
    794c:	f8 94       	cli
    794e:	de bf       	out	0x3e, r29	; 62
    7950:	0f be       	out	0x3f, r0	; 63
    7952:	cd bf       	out	0x3d, r28	; 61
    7954:	df 91       	pop	r29
    7956:	cf 91       	pop	r28
    7958:	1f 91       	pop	r17
    795a:	0f 91       	pop	r16
    795c:	ff 90       	pop	r15
    795e:	ef 90       	pop	r14
    7960:	df 90       	pop	r13
    7962:	cf 90       	pop	r12
    7964:	bf 90       	pop	r11
    7966:	af 90       	pop	r10
    7968:	9f 90       	pop	r9
    796a:	8f 90       	pop	r8
    796c:	7f 90       	pop	r7
    796e:	6f 90       	pop	r6
    7970:	5f 90       	pop	r5
    7972:	4f 90       	pop	r4
    7974:	3f 90       	pop	r3
    7976:	2f 90       	pop	r2
    7978:	08 95       	ret

0000797a <strnlen_P>:
    797a:	fc 01       	movw	r30, r24
    797c:	05 90       	lpm	r0, Z+
    797e:	61 50       	subi	r22, 0x01	; 1
    7980:	70 40       	sbci	r23, 0x00	; 0
    7982:	01 10       	cpse	r0, r1
    7984:	d8 f7       	brcc	.-10     	; 0x797c <strnlen_P+0x2>
    7986:	80 95       	com	r24
    7988:	90 95       	com	r25
    798a:	8e 0f       	add	r24, r30
    798c:	9f 1f       	adc	r25, r31
    798e:	08 95       	ret

00007990 <strnlen>:
    7990:	fc 01       	movw	r30, r24
    7992:	61 50       	subi	r22, 0x01	; 1
    7994:	70 40       	sbci	r23, 0x00	; 0
    7996:	01 90       	ld	r0, Z+
    7998:	01 10       	cpse	r0, r1
    799a:	d8 f7       	brcc	.-10     	; 0x7992 <strnlen+0x2>
    799c:	80 95       	com	r24
    799e:	90 95       	com	r25
    79a0:	8e 0f       	add	r24, r30
    79a2:	9f 1f       	adc	r25, r31
    79a4:	08 95       	ret

000079a6 <fputc>:
    79a6:	0f 93       	push	r16
    79a8:	1f 93       	push	r17
    79aa:	cf 93       	push	r28
    79ac:	df 93       	push	r29
    79ae:	fb 01       	movw	r30, r22
    79b0:	23 81       	ldd	r18, Z+3	; 0x03
    79b2:	21 fd       	sbrc	r18, 1
    79b4:	03 c0       	rjmp	.+6      	; 0x79bc <fputc+0x16>
    79b6:	8f ef       	ldi	r24, 0xFF	; 255
    79b8:	9f ef       	ldi	r25, 0xFF	; 255
    79ba:	2c c0       	rjmp	.+88     	; 0x7a14 <fputc+0x6e>
    79bc:	22 ff       	sbrs	r18, 2
    79be:	16 c0       	rjmp	.+44     	; 0x79ec <fputc+0x46>
    79c0:	46 81       	ldd	r20, Z+6	; 0x06
    79c2:	57 81       	ldd	r21, Z+7	; 0x07
    79c4:	24 81       	ldd	r18, Z+4	; 0x04
    79c6:	35 81       	ldd	r19, Z+5	; 0x05
    79c8:	42 17       	cp	r20, r18
    79ca:	53 07       	cpc	r21, r19
    79cc:	44 f4       	brge	.+16     	; 0x79de <fputc+0x38>
    79ce:	a0 81       	ld	r26, Z
    79d0:	b1 81       	ldd	r27, Z+1	; 0x01
    79d2:	9d 01       	movw	r18, r26
    79d4:	2f 5f       	subi	r18, 0xFF	; 255
    79d6:	3f 4f       	sbci	r19, 0xFF	; 255
    79d8:	31 83       	std	Z+1, r19	; 0x01
    79da:	20 83       	st	Z, r18
    79dc:	8c 93       	st	X, r24
    79de:	26 81       	ldd	r18, Z+6	; 0x06
    79e0:	37 81       	ldd	r19, Z+7	; 0x07
    79e2:	2f 5f       	subi	r18, 0xFF	; 255
    79e4:	3f 4f       	sbci	r19, 0xFF	; 255
    79e6:	37 83       	std	Z+7, r19	; 0x07
    79e8:	26 83       	std	Z+6, r18	; 0x06
    79ea:	14 c0       	rjmp	.+40     	; 0x7a14 <fputc+0x6e>
    79ec:	8b 01       	movw	r16, r22
    79ee:	ec 01       	movw	r28, r24
    79f0:	fb 01       	movw	r30, r22
    79f2:	00 84       	ldd	r0, Z+8	; 0x08
    79f4:	f1 85       	ldd	r31, Z+9	; 0x09
    79f6:	e0 2d       	mov	r30, r0
    79f8:	09 95       	icall
    79fa:	89 2b       	or	r24, r25
    79fc:	e1 f6       	brne	.-72     	; 0x79b6 <fputc+0x10>
    79fe:	d8 01       	movw	r26, r16
    7a00:	16 96       	adiw	r26, 0x06	; 6
    7a02:	8d 91       	ld	r24, X+
    7a04:	9c 91       	ld	r25, X
    7a06:	17 97       	sbiw	r26, 0x07	; 7
    7a08:	01 96       	adiw	r24, 0x01	; 1
    7a0a:	17 96       	adiw	r26, 0x07	; 7
    7a0c:	9c 93       	st	X, r25
    7a0e:	8e 93       	st	-X, r24
    7a10:	16 97       	sbiw	r26, 0x06	; 6
    7a12:	ce 01       	movw	r24, r28
    7a14:	df 91       	pop	r29
    7a16:	cf 91       	pop	r28
    7a18:	1f 91       	pop	r17
    7a1a:	0f 91       	pop	r16
    7a1c:	08 95       	ret

00007a1e <__ultoa_invert>:
    7a1e:	fa 01       	movw	r30, r20
    7a20:	aa 27       	eor	r26, r26
    7a22:	28 30       	cpi	r18, 0x08	; 8
    7a24:	51 f1       	breq	.+84     	; 0x7a7a <__ultoa_invert+0x5c>
    7a26:	20 31       	cpi	r18, 0x10	; 16
    7a28:	81 f1       	breq	.+96     	; 0x7a8a <__ultoa_invert+0x6c>
    7a2a:	e8 94       	clt
    7a2c:	6f 93       	push	r22
    7a2e:	6e 7f       	andi	r22, 0xFE	; 254
    7a30:	6e 5f       	subi	r22, 0xFE	; 254
    7a32:	7f 4f       	sbci	r23, 0xFF	; 255
    7a34:	8f 4f       	sbci	r24, 0xFF	; 255
    7a36:	9f 4f       	sbci	r25, 0xFF	; 255
    7a38:	af 4f       	sbci	r26, 0xFF	; 255
    7a3a:	b1 e0       	ldi	r27, 0x01	; 1
    7a3c:	3e d0       	rcall	.+124    	; 0x7aba <__ultoa_invert+0x9c>
    7a3e:	b4 e0       	ldi	r27, 0x04	; 4
    7a40:	3c d0       	rcall	.+120    	; 0x7aba <__ultoa_invert+0x9c>
    7a42:	67 0f       	add	r22, r23
    7a44:	78 1f       	adc	r23, r24
    7a46:	89 1f       	adc	r24, r25
    7a48:	9a 1f       	adc	r25, r26
    7a4a:	a1 1d       	adc	r26, r1
    7a4c:	68 0f       	add	r22, r24
    7a4e:	79 1f       	adc	r23, r25
    7a50:	8a 1f       	adc	r24, r26
    7a52:	91 1d       	adc	r25, r1
    7a54:	a1 1d       	adc	r26, r1
    7a56:	6a 0f       	add	r22, r26
    7a58:	71 1d       	adc	r23, r1
    7a5a:	81 1d       	adc	r24, r1
    7a5c:	91 1d       	adc	r25, r1
    7a5e:	a1 1d       	adc	r26, r1
    7a60:	20 d0       	rcall	.+64     	; 0x7aa2 <__ultoa_invert+0x84>
    7a62:	09 f4       	brne	.+2      	; 0x7a66 <__ultoa_invert+0x48>
    7a64:	68 94       	set
    7a66:	3f 91       	pop	r19
    7a68:	2a e0       	ldi	r18, 0x0A	; 10
    7a6a:	26 9f       	mul	r18, r22
    7a6c:	11 24       	eor	r1, r1
    7a6e:	30 19       	sub	r19, r0
    7a70:	30 5d       	subi	r19, 0xD0	; 208
    7a72:	31 93       	st	Z+, r19
    7a74:	de f6       	brtc	.-74     	; 0x7a2c <__ultoa_invert+0xe>
    7a76:	cf 01       	movw	r24, r30
    7a78:	08 95       	ret
    7a7a:	46 2f       	mov	r20, r22
    7a7c:	47 70       	andi	r20, 0x07	; 7
    7a7e:	40 5d       	subi	r20, 0xD0	; 208
    7a80:	41 93       	st	Z+, r20
    7a82:	b3 e0       	ldi	r27, 0x03	; 3
    7a84:	0f d0       	rcall	.+30     	; 0x7aa4 <__ultoa_invert+0x86>
    7a86:	c9 f7       	brne	.-14     	; 0x7a7a <__ultoa_invert+0x5c>
    7a88:	f6 cf       	rjmp	.-20     	; 0x7a76 <__ultoa_invert+0x58>
    7a8a:	46 2f       	mov	r20, r22
    7a8c:	4f 70       	andi	r20, 0x0F	; 15
    7a8e:	40 5d       	subi	r20, 0xD0	; 208
    7a90:	4a 33       	cpi	r20, 0x3A	; 58
    7a92:	18 f0       	brcs	.+6      	; 0x7a9a <__ultoa_invert+0x7c>
    7a94:	49 5d       	subi	r20, 0xD9	; 217
    7a96:	31 fd       	sbrc	r19, 1
    7a98:	40 52       	subi	r20, 0x20	; 32
    7a9a:	41 93       	st	Z+, r20
    7a9c:	02 d0       	rcall	.+4      	; 0x7aa2 <__ultoa_invert+0x84>
    7a9e:	a9 f7       	brne	.-22     	; 0x7a8a <__ultoa_invert+0x6c>
    7aa0:	ea cf       	rjmp	.-44     	; 0x7a76 <__ultoa_invert+0x58>
    7aa2:	b4 e0       	ldi	r27, 0x04	; 4
    7aa4:	a6 95       	lsr	r26
    7aa6:	97 95       	ror	r25
    7aa8:	87 95       	ror	r24
    7aaa:	77 95       	ror	r23
    7aac:	67 95       	ror	r22
    7aae:	ba 95       	dec	r27
    7ab0:	c9 f7       	brne	.-14     	; 0x7aa4 <__ultoa_invert+0x86>
    7ab2:	00 97       	sbiw	r24, 0x00	; 0
    7ab4:	61 05       	cpc	r22, r1
    7ab6:	71 05       	cpc	r23, r1
    7ab8:	08 95       	ret
    7aba:	9b 01       	movw	r18, r22
    7abc:	ac 01       	movw	r20, r24
    7abe:	0a 2e       	mov	r0, r26
    7ac0:	06 94       	lsr	r0
    7ac2:	57 95       	ror	r21
    7ac4:	47 95       	ror	r20
    7ac6:	37 95       	ror	r19
    7ac8:	27 95       	ror	r18
    7aca:	ba 95       	dec	r27
    7acc:	c9 f7       	brne	.-14     	; 0x7ac0 <__ultoa_invert+0xa2>
    7ace:	62 0f       	add	r22, r18
    7ad0:	73 1f       	adc	r23, r19
    7ad2:	84 1f       	adc	r24, r20
    7ad4:	95 1f       	adc	r25, r21
    7ad6:	a0 1d       	adc	r26, r0
    7ad8:	08 95       	ret

00007ada <_exit>:
    7ada:	f8 94       	cli

00007adc <__stop_program>:
    7adc:	ff cf       	rjmp	.-2      	; 0x7adc <__stop_program>
