   1               		.file	"ConfigDescriptor.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.DComp_NextStillImageInterface,"ax",@progbits
  12               	.global	DComp_NextStillImageInterface
  14               	DComp_NextStillImageInterface:
  15               	.LFB148:
  16               		.file 1 "ConfigDescriptor.c"
   1:ConfigDescriptor.c **** /*
   2:ConfigDescriptor.c ****              LUFA Library
   3:ConfigDescriptor.c ****      Copyright (C) Dean Camera, 2011.
   4:ConfigDescriptor.c **** 
   5:ConfigDescriptor.c ****   dean [at] fourwalledcubicle [dot] com
   6:ConfigDescriptor.c ****            www.lufa-lib.org
   7:ConfigDescriptor.c **** */
   8:ConfigDescriptor.c **** 
   9:ConfigDescriptor.c **** /*
  10:ConfigDescriptor.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:ConfigDescriptor.c **** 
  12:ConfigDescriptor.c ****   Permission to use, copy, modify, distribute, and sell this
  13:ConfigDescriptor.c ****   software and its documentation for any purpose is hereby granted
  14:ConfigDescriptor.c ****   without fee, provided that the above copyright notice appear in
  15:ConfigDescriptor.c ****   all copies and that both that the copyright notice and this
  16:ConfigDescriptor.c ****   permission notice and warranty disclaimer appear in supporting
  17:ConfigDescriptor.c ****   documentation, and that the name of the author not be used in
  18:ConfigDescriptor.c ****   advertising or publicity pertaining to distribution of the
  19:ConfigDescriptor.c ****   software without specific, written prior permission.
  20:ConfigDescriptor.c **** 
  21:ConfigDescriptor.c ****   The author disclaim all warranties with regard to this
  22:ConfigDescriptor.c ****   software, including all implied warranties of merchantability
  23:ConfigDescriptor.c ****   and fitness.  In no event shall the author be liable for any
  24:ConfigDescriptor.c ****   special, indirect or consequential damages or any damages
  25:ConfigDescriptor.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:ConfigDescriptor.c ****   in an action of contract, negligence or other tortious action,
  27:ConfigDescriptor.c ****   arising out of or in connection with the use or performance of
  28:ConfigDescriptor.c ****   this software.
  29:ConfigDescriptor.c **** */
  30:ConfigDescriptor.c **** 
  31:ConfigDescriptor.c **** /** \file
  32:ConfigDescriptor.c ****  *
  33:ConfigDescriptor.c ****  *  USB Device Configuration Descriptor processing routines, to determine the correct pipe configur
  34:ConfigDescriptor.c ****  *  needed to communication with an attached USB device. Descriptors are special  computer-readable
  35:ConfigDescriptor.c ****  *  which the host requests upon device enumeration, to determine the device's capabilities and fun
  36:ConfigDescriptor.c ****  */
  37:ConfigDescriptor.c **** 
  38:ConfigDescriptor.c **** #include "ConfigDescriptor.h"
  39:ConfigDescriptor.c **** 
  40:ConfigDescriptor.c **** /** Reads and processes an attached device's descriptors, to determine compatibility and pipe confi
  41:ConfigDescriptor.c ****  *  routine will read in the entire configuration descriptor, and configure the hosts pipes to corr
  42:ConfigDescriptor.c ****  *  with compatible devices.
  43:ConfigDescriptor.c ****  *
  44:ConfigDescriptor.c ****  *  This routine searches for a SI interface descriptor containing bulk IN and OUT data endpoints.
  45:ConfigDescriptor.c ****  *
  46:ConfigDescriptor.c ****  *  \return An error code from the \ref StillImageHost_GetConfigDescriptorDataCodes_t enum.
  47:ConfigDescriptor.c ****  */
  48:ConfigDescriptor.c **** uint8_t ProcessConfigurationDescriptor(void)
  49:ConfigDescriptor.c **** {
  50:ConfigDescriptor.c **** 	uint8_t  ConfigDescriptorData[512];
  51:ConfigDescriptor.c **** 	void*    CurrConfigLocation = ConfigDescriptorData;
  52:ConfigDescriptor.c **** 	uint16_t CurrConfigBytesRem;
  53:ConfigDescriptor.c **** 
  54:ConfigDescriptor.c **** 	USB_Descriptor_Interface_t* StillImageInterface = NULL;
  55:ConfigDescriptor.c **** 	USB_Descriptor_Endpoint_t*  DataINEndpoint      = NULL;
  56:ConfigDescriptor.c **** 	USB_Descriptor_Endpoint_t*  DataOUTEndpoint     = NULL;
  57:ConfigDescriptor.c **** 	USB_Descriptor_Endpoint_t*  EventsEndpoint      = NULL;
  58:ConfigDescriptor.c **** 
  59:ConfigDescriptor.c **** 	/* Retrieve the entire configuration descriptor into the allocated buffer */
  60:ConfigDescriptor.c **** 	switch (USB_Host_GetDeviceConfigDescriptor(1, &CurrConfigBytesRem, ConfigDescriptorData, sizeof(Co
  61:ConfigDescriptor.c **** 	{
  62:ConfigDescriptor.c **** 		case HOST_GETCONFIG_Successful:
  63:ConfigDescriptor.c **** 			break;
  64:ConfigDescriptor.c **** 		case HOST_GETCONFIG_InvalidData:
  65:ConfigDescriptor.c **** 			return InvalidConfigDataReturned;
  66:ConfigDescriptor.c **** 		case HOST_GETCONFIG_BuffOverflow:
  67:ConfigDescriptor.c **** 			return DescriptorTooLarge;
  68:ConfigDescriptor.c **** 		default:
  69:ConfigDescriptor.c **** 			return ControlError;
  70:ConfigDescriptor.c **** 	}
  71:ConfigDescriptor.c **** 
  72:ConfigDescriptor.c **** 	while (!(DataINEndpoint) || !(DataOUTEndpoint))
  73:ConfigDescriptor.c **** 	{
  74:ConfigDescriptor.c **** 		/* See if we've found a likely compatible interface, and if there is an endpoint within that inte
  75:ConfigDescriptor.c **** 		if (!(StillImageInterface) ||
  76:ConfigDescriptor.c **** 		    USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
  77:ConfigDescriptor.c **** 		                              DComp_NextStillImageInterfaceDataEndpoint) != DESCRIPTOR_SEARCH_COM
  78:ConfigDescriptor.c **** 		{
  79:ConfigDescriptor.c **** 			/* Get the next Still Image interface from the configuration descriptor */
  80:ConfigDescriptor.c **** 			if (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
  81:ConfigDescriptor.c **** 										  DComp_NextStillImageInterface) != DESCRIPTOR_SEARCH_COMP_Found)
  82:ConfigDescriptor.c **** 			{
  83:ConfigDescriptor.c **** 				/* Descriptor not found, error out */
  84:ConfigDescriptor.c **** 				return NoCompatibleInterfaceFound;
  85:ConfigDescriptor.c **** 			}
  86:ConfigDescriptor.c **** 
  87:ConfigDescriptor.c **** 			/* Save the interface in case we need to refer back to it later */
  88:ConfigDescriptor.c **** 			StillImageInterface = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_Interface_t);
  89:ConfigDescriptor.c **** 
  90:ConfigDescriptor.c **** 			/* Clear any found endpoints */
  91:ConfigDescriptor.c **** 			DataINEndpoint  = NULL;
  92:ConfigDescriptor.c **** 			DataOUTEndpoint = NULL;
  93:ConfigDescriptor.c **** 			EventsEndpoint  = NULL;
  94:ConfigDescriptor.c **** 
  95:ConfigDescriptor.c **** 			/* Skip the remainder of the loop as we have not found an endpoint yet */
  96:ConfigDescriptor.c **** 			continue;
  97:ConfigDescriptor.c **** 		}
  98:ConfigDescriptor.c **** 
  99:ConfigDescriptor.c **** 		/* Retrieve the endpoint address from the endpoint descriptor */
 100:ConfigDescriptor.c **** 		USB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_End
 101:ConfigDescriptor.c **** 
 102:ConfigDescriptor.c **** 		/* If the endpoint is a IN type endpoint */
 103:ConfigDescriptor.c **** 		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
 104:ConfigDescriptor.c **** 		{
 105:ConfigDescriptor.c **** 			/* Check if the found endpoint is a interrupt or bulk type descriptor */
 106:ConfigDescriptor.c **** 			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
 107:ConfigDescriptor.c **** 			  EventsEndpoint = EndpointData;
 108:ConfigDescriptor.c **** 			else
 109:ConfigDescriptor.c **** 			  DataINEndpoint = EndpointData;
 110:ConfigDescriptor.c **** 		}
 111:ConfigDescriptor.c **** 		else
 112:ConfigDescriptor.c **** 		{
 113:ConfigDescriptor.c **** 			DataOUTEndpoint = EndpointData;
 114:ConfigDescriptor.c **** 		}
 115:ConfigDescriptor.c **** 	}
 116:ConfigDescriptor.c **** 
 117:ConfigDescriptor.c **** 	/* Configure the Still Image data IN pipe */
 118:ConfigDescriptor.c **** 	Pipe_ConfigurePipe(SIMAGE_DATA_IN_PIPE, EP_TYPE_BULK, PIPE_TOKEN_IN,
 119:ConfigDescriptor.c **** 	                   DataINEndpoint->EndpointAddress, DataINEndpoint->EndpointSize, PIPE_BANK_SINGLE
 120:ConfigDescriptor.c **** 
 121:ConfigDescriptor.c **** 	/* Configure the Still Image data OUT pipe */
 122:ConfigDescriptor.c **** 	Pipe_ConfigurePipe(SIMAGE_DATA_OUT_PIPE, EP_TYPE_BULK, PIPE_TOKEN_OUT,
 123:ConfigDescriptor.c **** 					   DataOUTEndpoint->EndpointAddress, DataOUTEndpoint->EndpointSize, PIPE_BANK_SINGLE);
 124:ConfigDescriptor.c **** 
 125:ConfigDescriptor.c **** 	/* Configure the Still Image events pipe */
 126:ConfigDescriptor.c **** 	Pipe_ConfigurePipe(SIMAGE_EVENTS_PIPE, EP_TYPE_INTERRUPT, PIPE_TOKEN_IN,
 127:ConfigDescriptor.c **** 					   EventsEndpoint->EndpointAddress, EventsEndpoint->EndpointSize, PIPE_BANK_SINGLE);
 128:ConfigDescriptor.c **** 	Pipe_SetInterruptPeriod(EventsEndpoint->PollingIntervalMS);
 129:ConfigDescriptor.c **** 
 130:ConfigDescriptor.c **** 	/* Valid data found, return success */
 131:ConfigDescriptor.c **** 	return SuccessfulConfigRead;
 132:ConfigDescriptor.c **** }
 133:ConfigDescriptor.c **** 
 134:ConfigDescriptor.c **** /** Descriptor comparator function. This comparator function is can be called while processing an a
 135:ConfigDescriptor.c ****  *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort
 136:ConfigDescriptor.c ****  *  descriptor processing if an incompatible descriptor configuration is found.
 137:ConfigDescriptor.c ****  *
 138:ConfigDescriptor.c ****  *  This comparator searches for the next Interface descriptor of the correct Still Image Class, Su
 139:ConfigDescriptor.c ****  *
 140:ConfigDescriptor.c ****  *  \return A value from the DSEARCH_Return_ErrorCodes_t enum
 141:ConfigDescriptor.c ****  */
 142:ConfigDescriptor.c **** uint8_t DComp_NextStillImageInterface(void* CurrentDescriptor)
 143:ConfigDescriptor.c **** {
  17               		.loc 1 143 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  24 0000 FC01      		movw r30,r24
  25               	.LVL1:
 144:ConfigDescriptor.c **** 	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);
 145:ConfigDescriptor.c **** 
 146:ConfigDescriptor.c **** 	if (Header->Type == DTYPE_Interface)
  26               		.loc 1 146 0
  27 0002 8181      		ldd r24,Z+1
  28               	.LVL2:
  29 0004 8430      		cpi r24,lo8(4)
  30 0006 01F4      		brne .L6
  31               	.LVL3:
  32               	.LBB5:
 147:ConfigDescriptor.c **** 	{
 148:ConfigDescriptor.c **** 		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Interf
 149:ConfigDescriptor.c **** 
 150:ConfigDescriptor.c **** 		/* Check the descriptor class, subclass and protocol, break out if correct interface found */
 151:ConfigDescriptor.c **** 		if ((Interface->Class    == SI_CSCP_StillImageClass)    &&
  33               		.loc 1 151 0
  34 0008 8581      		ldd r24,Z+5
  35 000a 8630      		cpi r24,lo8(6)
  36 000c 01F4      		brne .L6
  37               		.loc 1 151 0 is_stmt 0 discriminator 1
  38 000e 8681      		ldd r24,Z+6
  39 0010 8130      		cpi r24,lo8(1)
  40 0012 01F4      		brne .L6
 152:ConfigDescriptor.c **** 		    (Interface->SubClass == SI_CSCP_StillImageSubclass) &&
  41               		.loc 1 152 0 is_stmt 1
  42 0014 8781      		ldd r24,Z+7
  43 0016 8130      		cpi r24,lo8(1)
  44 0018 01F4      		brne .L6
 153:ConfigDescriptor.c **** 		    (Interface->Protocol == SI_CSCP_BulkOnlyProtocol))
 154:ConfigDescriptor.c **** 		{
 155:ConfigDescriptor.c **** 			return DESCRIPTOR_SEARCH_Found;
  45               		.loc 1 155 0
  46 001a 80E0      		ldi r24,0
  47 001c 0895      		ret
  48               	.LVL4:
  49               	.L6:
  50               	.LBE5:
 156:ConfigDescriptor.c **** 		}
 157:ConfigDescriptor.c **** 	}
 158:ConfigDescriptor.c **** 
 159:ConfigDescriptor.c **** 	return DESCRIPTOR_SEARCH_NotFound;
  51               		.loc 1 159 0
  52 001e 82E0      		ldi r24,lo8(2)
 160:ConfigDescriptor.c **** }
  53               		.loc 1 160 0
  54 0020 0895      		ret
  55               		.cfi_endproc
  56               	.LFE148:
  58               		.section	.text.DComp_NextStillImageInterfaceDataEndpoint,"ax",@progbits
  59               	.global	DComp_NextStillImageInterfaceDataEndpoint
  61               	DComp_NextStillImageInterfaceDataEndpoint:
  62               	.LFB149:
 161:ConfigDescriptor.c **** 
 162:ConfigDescriptor.c **** /** Descriptor comparator function. This comparator function is can be called while processing an a
 163:ConfigDescriptor.c ****  *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort
 164:ConfigDescriptor.c ****  *  descriptor processing if an incompatible descriptor configuration is found.
 165:ConfigDescriptor.c ****  *
 166:ConfigDescriptor.c ****  *  This comparator searches for the next Interrupt or Bulk Endpoint descriptor of the current SI i
 167:ConfigDescriptor.c ****  *  search if another interface descriptor is found before the next endpoint.
 168:ConfigDescriptor.c ****  *
 169:ConfigDescriptor.c ****  *  \return A value from the DSEARCH_Return_ErrorCodes_t enum
 170:ConfigDescriptor.c ****  */
 171:ConfigDescriptor.c **** uint8_t DComp_NextStillImageInterfaceDataEndpoint(void* CurrentDescriptor)
 172:ConfigDescriptor.c **** {
  63               		.loc 1 172 0
  64               		.cfi_startproc
  65               	.LVL5:
  66               	/* prologue: function */
  67               	/* frame size = 0 */
  68               	/* stack size = 0 */
  69               	.L__stack_usage = 0
  70 0000 FC01      		movw r30,r24
  71               	.LVL6:
 173:ConfigDescriptor.c **** 	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);
 174:ConfigDescriptor.c **** 
 175:ConfigDescriptor.c **** 	if (Header->Type == DTYPE_Endpoint)
  72               		.loc 1 175 0
  73 0002 9181      		ldd r25,Z+1
  74 0004 9530      		cpi r25,lo8(5)
  75 0006 01F4      		brne .L9
  76               	.LVL7:
  77               	.LBB6:
 176:ConfigDescriptor.c **** 	{
 177:ConfigDescriptor.c **** 		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint
 178:ConfigDescriptor.c **** 
 179:ConfigDescriptor.c **** 		/* Check the endpoint type, break out if correct BULK or INTERRUPT type endpoint found */
 180:ConfigDescriptor.c **** 		if (((Endpoint->Attributes & EP_TYPE_MASK) == EP_TYPE_BULK) || 
  78               		.loc 1 180 0
  79 0008 8381      		ldd r24,Z+3
  80               	.LVL8:
  81 000a 8370      		andi r24,lo8(3)
  82 000c 90E0      		ldi r25,0
  83 000e 0297      		sbiw r24,2
  84 0010 0297      		sbiw r24,2
  85 0012 00F4      		brsh .L12
 181:ConfigDescriptor.c **** 		    ((Endpoint->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT))
 182:ConfigDescriptor.c **** 		{
 183:ConfigDescriptor.c **** 			return DESCRIPTOR_SEARCH_Found;
  86               		.loc 1 183 0
  87 0014 80E0      		ldi r24,0
  88 0016 0895      		ret
  89               	.LVL9:
  90               	.L9:
  91               	.LBE6:
 184:ConfigDescriptor.c **** 		}
 185:ConfigDescriptor.c **** 	}
 186:ConfigDescriptor.c **** 	else if (Header->Type == DTYPE_Interface)
  92               		.loc 1 186 0
  93 0018 9430      		cpi r25,lo8(4)
  94 001a 01F4      		brne .L12
 187:ConfigDescriptor.c **** 	{
 188:ConfigDescriptor.c **** 		return DESCRIPTOR_SEARCH_Fail;
  95               		.loc 1 188 0
  96 001c 81E0      		ldi r24,lo8(1)
  97               	.LVL10:
  98 001e 0895      		ret
  99               	.L12:
 189:ConfigDescriptor.c **** 	}
 190:ConfigDescriptor.c **** 
 191:ConfigDescriptor.c **** 	return DESCRIPTOR_SEARCH_NotFound;
 100               		.loc 1 191 0
 101 0020 82E0      		ldi r24,lo8(2)
 192:ConfigDescriptor.c **** }
 102               		.loc 1 192 0
 103 0022 0895      		ret
 104               		.cfi_endproc
 105               	.LFE149:
 107               		.section	.text.ProcessConfigurationDescriptor,"ax",@progbits
 108               	.global	ProcessConfigurationDescriptor
 110               	ProcessConfigurationDescriptor:
 111               	.LFB147:
  49:ConfigDescriptor.c **** 	uint8_t  ConfigDescriptorData[512];
 112               		.loc 1 49 0
 113               		.cfi_startproc
 114 0000 8F92      		push r8
 115               	.LCFI0:
 116               		.cfi_def_cfa_offset 3
 117               		.cfi_offset 8, -2
 118 0002 9F92      		push r9
 119               	.LCFI1:
 120               		.cfi_def_cfa_offset 4
 121               		.cfi_offset 9, -3
 122 0004 AF92      		push r10
 123               	.LCFI2:
 124               		.cfi_def_cfa_offset 5
 125               		.cfi_offset 10, -4
 126 0006 BF92      		push r11
 127               	.LCFI3:
 128               		.cfi_def_cfa_offset 6
 129               		.cfi_offset 11, -5
 130 0008 CF92      		push r12
 131               	.LCFI4:
 132               		.cfi_def_cfa_offset 7
 133               		.cfi_offset 12, -6
 134 000a DF92      		push r13
 135               	.LCFI5:
 136               		.cfi_def_cfa_offset 8
 137               		.cfi_offset 13, -7
 138 000c EF92      		push r14
 139               	.LCFI6:
 140               		.cfi_def_cfa_offset 9
 141               		.cfi_offset 14, -8
 142 000e FF92      		push r15
 143               	.LCFI7:
 144               		.cfi_def_cfa_offset 10
 145               		.cfi_offset 15, -9
 146 0010 0F93      		push r16
 147               	.LCFI8:
 148               		.cfi_def_cfa_offset 11
 149               		.cfi_offset 16, -10
 150 0012 1F93      		push r17
 151               	.LCFI9:
 152               		.cfi_def_cfa_offset 12
 153               		.cfi_offset 17, -11
 154 0014 CF93      		push r28
 155               	.LCFI10:
 156               		.cfi_def_cfa_offset 13
 157               		.cfi_offset 28, -12
 158 0016 DF93      		push r29
 159               	.LCFI11:
 160               		.cfi_def_cfa_offset 14
 161               		.cfi_offset 29, -13
 162 0018 CDB7      		in r28,__SP_L__
 163 001a DEB7      		in r29,__SP_H__
 164               	.LCFI12:
 165               		.cfi_def_cfa_register 28
 166 001c C450      		subi r28,4
 167 001e D240      		sbci r29,2
 168               	.LCFI13:
 169               		.cfi_def_cfa_offset 530
 170 0020 0FB6      		in __tmp_reg__,__SREG__
 171 0022 F894      		cli
 172 0024 DEBF      		out __SP_H__,r29
 173 0026 0FBE      		out __SREG__,__tmp_reg__
 174 0028 CDBF      		out __SP_L__,r28
 175               	/* prologue: function */
 176               	/* frame size = 516 */
 177               	/* stack size = 528 */
 178               	.L__stack_usage = 528
  51:ConfigDescriptor.c **** 	uint16_t CurrConfigBytesRem;
 179               		.loc 1 51 0
 180 002a AE01      		movw r20,r28
 181 002c 4F5F      		subi r20,-1
 182 002e 5F4F      		sbci r21,-1
 183 0030 CD5F      		subi r28,lo8(-515)
 184 0032 DD4F      		sbci r29,hi8(-515)
 185 0034 5983      		std Y+1,r21
 186 0036 4883      		st Y,r20
 187 0038 C350      		subi r28,lo8(515)
 188 003a D240      		sbci r29,hi8(515)
 189               	.LVL11:
  60:ConfigDescriptor.c **** 	{
 190               		.loc 1 60 0
 191 003c 20E0      		ldi r18,0
 192 003e 32E0      		ldi r19,lo8(2)
 193 0040 BE01      		movw r22,r28
 194 0042 6F5F      		subi r22,-1
 195 0044 7D4F      		sbci r23,-3
 196 0046 81E0      		ldi r24,lo8(1)
 197 0048 0E94 0000 		call USB_Host_GetDeviceConfigDescriptor
 198               	.LVL12:
 199 004c 8530      		cpi r24,lo8(5)
 200 004e 01F0      		breq .L15
 201 0050 8630      		cpi r24,lo8(6)
 202 0052 01F4      		brne .+2
 203 0054 00C0      		rjmp .L24
 204 0056 8823      		tst r24
 205 0058 01F0      		breq .L17
  69:ConfigDescriptor.c **** 	}
 206               		.loc 1 69 0
 207 005a FF24      		clr r15
 208 005c F394      		inc r15
 209 005e 00C0      		rjmp .L16
 210               	.L15:
  67:ConfigDescriptor.c **** 		default:
 211               		.loc 1 67 0
 212 0060 22E0      		ldi r18,lo8(2)
 213 0062 F22E      		mov r15,r18
 214 0064 00C0      		rjmp .L16
 215               	.LVL13:
 216               	.L38:
 217               	.LBB7:
  76:ConfigDescriptor.c **** 		                              DComp_NextStillImageInterfaceDataEndpoint) != DESCRIPTOR_SEARCH_COM
 218               		.loc 1 76 0 discriminator 1
 219 0066 40E0      		ldi r20,lo8(gs(DComp_NextStillImageInterfaceDataEndpoint))
 220 0068 50E0      		ldi r21,hi8(gs(DComp_NextStillImageInterfaceDataEndpoint))
 221 006a BE01      		movw r22,r28
 222 006c 6D5F      		subi r22,-3
 223 006e 7D4F      		sbci r23,-3
 224 0070 CE01      		movw r24,r28
 225 0072 8F5F      		subi r24,-1
 226 0074 9D4F      		sbci r25,-3
 227 0076 0E94 0000 		call USB_GetNextDescriptorComp
 228               	.LVL14:
 229 007a F82E      		mov r15,r24
  75:ConfigDescriptor.c **** 		    USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
 230               		.loc 1 75 0 discriminator 1
 231 007c 8111      		cpse r24,__zero_reg__
 232 007e 00C0      		rjmp .L17
 100:ConfigDescriptor.c **** 
 233               		.loc 1 100 0
 234 0080 CD5F      		subi r28,lo8(-515)
 235 0082 DD4F      		sbci r29,hi8(-515)
 236 0084 E881      		ld r30,Y
 237 0086 F981      		ldd r31,Y+1
 238 0088 C350      		subi r28,lo8(515)
 239 008a D240      		sbci r29,hi8(515)
 240               	.LVL15:
 103:ConfigDescriptor.c **** 		{
 241               		.loc 1 103 0
 242 008c 8281      		ldd r24,Z+2
 243 008e 87FF      		sbrs r24,7
 244 0090 00C0      		rjmp .L26
 106:ConfigDescriptor.c **** 			  EventsEndpoint = EndpointData;
 245               		.loc 1 106 0
 246 0092 8381      		ldd r24,Z+3
 247 0094 8370      		andi r24,lo8(3)
 248 0096 8330      		cpi r24,lo8(3)
 249 0098 01F0      		breq .L27
 109:ConfigDescriptor.c **** 		}
 250               		.loc 1 109 0
 251 009a 4F01      		movw r8,r30
 252               	.L22:
 253               	.LVL16:
 254               	.LBE7:
  72:ConfigDescriptor.c **** 	{
 255               		.loc 1 72 0
 256 009c 8114      		cp r8,__zero_reg__
 257 009e 9104      		cpc r9,__zero_reg__
 258 00a0 01F4      		brne .L37
 259               	.LVL17:
 260               	.L21:
 261               	.LBB8:
  75:ConfigDescriptor.c **** 		    USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
 262               		.loc 1 75 0
 263 00a2 0115      		cp r16,__zero_reg__
 264 00a4 1105      		cpc r17,__zero_reg__
 265 00a6 01F4      		brne .L38
 266               	.LVL18:
 267               	.L17:
  80:ConfigDescriptor.c **** 										  DComp_NextStillImageInterface) != DESCRIPTOR_SEARCH_COMP_Found)
 268               		.loc 1 80 0
 269 00a8 40E0      		ldi r20,lo8(gs(DComp_NextStillImageInterface))
 270 00aa 50E0      		ldi r21,hi8(gs(DComp_NextStillImageInterface))
 271 00ac BE01      		movw r22,r28
 272 00ae 6D5F      		subi r22,-3
 273 00b0 7D4F      		sbci r23,-3
 274 00b2 CE01      		movw r24,r28
 275 00b4 8F5F      		subi r24,-1
 276 00b6 9D4F      		sbci r25,-3
 277 00b8 0E94 0000 		call USB_GetNextDescriptorComp
 278               	.LVL19:
 279 00bc 8111      		cpse r24,__zero_reg__
 280 00be 00C0      		rjmp .L25
  88:ConfigDescriptor.c **** 
 281               		.loc 1 88 0
 282 00c0 CD5F      		subi r28,lo8(-515)
 283 00c2 DD4F      		sbci r29,hi8(-515)
 284 00c4 0881      		ld r16,Y
 285 00c6 1981      		ldd r17,Y+1
 286 00c8 C350      		subi r28,lo8(515)
 287 00ca D240      		sbci r29,hi8(515)
 288               	.LVL20:
  93:ConfigDescriptor.c **** 
 289               		.loc 1 93 0
 290 00cc C12C      		mov r12,__zero_reg__
 291 00ce D12C      		mov r13,__zero_reg__
  92:ConfigDescriptor.c **** 			EventsEndpoint  = NULL;
 292               		.loc 1 92 0
 293 00d0 A12C      		mov r10,__zero_reg__
 294 00d2 B12C      		mov r11,__zero_reg__
  91:ConfigDescriptor.c **** 			DataOUTEndpoint = NULL;
 295               		.loc 1 91 0
 296 00d4 812C      		mov r8,__zero_reg__
 297 00d6 912C      		mov r9,__zero_reg__
 298 00d8 00C0      		rjmp .L21
 299               	.LVL21:
 300               	.L26:
 113:ConfigDescriptor.c **** 		}
 301               		.loc 1 113 0
 302 00da 5F01      		movw r10,r30
 303 00dc 00C0      		rjmp .L22
 304               	.L27:
 107:ConfigDescriptor.c **** 			else
 305               		.loc 1 107 0
 306 00de 6F01      		movw r12,r30
 307 00e0 00C0      		rjmp .L22
 308               	.LVL22:
 309               	.L37:
 310               	.LBE8:
  72:ConfigDescriptor.c **** 	{
 311               		.loc 1 72 0 discriminator 1
 312 00e2 A114      		cp r10,__zero_reg__
 313 00e4 B104      		cpc r11,__zero_reg__
 314 00e6 01F0      		breq .L21
 118:ConfigDescriptor.c **** 	                   DataINEndpoint->EndpointAddress, DataINEndpoint->EndpointSize, PIPE_BANK_SINGLE
 315               		.loc 1 118 0
 316 00e8 F401      		movw r30,r8
 317               	.LVL23:
 318 00ea 0481      		ldd r16,Z+4
 319 00ec 1581      		ldd r17,Z+5
 320               	.LVL24:
 321 00ee E12C      		mov r14,__zero_reg__
 322 00f0 2281      		ldd r18,Z+2
 323 00f2 40E1      		ldi r20,lo8(16)
 324 00f4 62E0      		ldi r22,lo8(2)
 325 00f6 81E0      		ldi r24,lo8(1)
 326 00f8 0E94 0000 		call Pipe_ConfigurePipe
 327               	.LVL25:
 122:ConfigDescriptor.c **** 					   DataOUTEndpoint->EndpointAddress, DataOUTEndpoint->EndpointSize, PIPE_BANK_SINGLE);
 328               		.loc 1 122 0
 329 00fc F501      		movw r30,r10
 330 00fe 0481      		ldd r16,Z+4
 331 0100 1581      		ldd r17,Z+5
 332 0102 2281      		ldd r18,Z+2
 333 0104 40E2      		ldi r20,lo8(32)
 334 0106 62E0      		ldi r22,lo8(2)
 335 0108 82E0      		ldi r24,lo8(2)
 336 010a 0E94 0000 		call Pipe_ConfigurePipe
 337               	.LVL26:
 126:ConfigDescriptor.c **** 					   EventsEndpoint->EndpointAddress, EventsEndpoint->EndpointSize, PIPE_BANK_SINGLE);
 338               		.loc 1 126 0
 339 010e F601      		movw r30,r12
 340 0110 0481      		ldd r16,Z+4
 341 0112 1581      		ldd r17,Z+5
 342 0114 2281      		ldd r18,Z+2
 343 0116 40E1      		ldi r20,lo8(16)
 344 0118 63E0      		ldi r22,lo8(3)
 345 011a 83E0      		ldi r24,lo8(3)
 346 011c 0E94 0000 		call Pipe_ConfigurePipe
 347               	.LVL27:
 128:ConfigDescriptor.c **** 
 348               		.loc 1 128 0
 349 0120 F601      		movw r30,r12
 350 0122 8681      		ldd r24,Z+6
 351               	.LVL28:
 352               	.LBB9:
 353               	.LBB10:
 354               		.file 2 "../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h"
   1:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
   2:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****              LUFA Library
   3:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   5:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
   8:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   9:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
  10:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  12:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  21:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   this software.
  29:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
  30:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  31:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \file
  32:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief USB Pipe definitions for the AVR8 microcontrollers.
  33:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \copydetails Group_PipeManagement_AVR8
  34:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  35:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  38:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  39:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeRW
  40:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeRW_AVR8 Pipe Data Reading and Writing (AVR8)
  41:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe data read/write definitions for the Atmel AVR8 architecture.
  42:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  43:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to p
  44:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  45:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  46:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePrimitiveRW
  47:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePrimitiveRW_AVR8 Read/Write of Primitive Data Types (AVR8)
  48:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe primitive data read/write definitions for the Atmel AVR8 architecture.
  49:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  50:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  51:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  from and to pipes.
  52:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  53:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  54:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePacketManagement
  55:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePacketManagement_AVR8 Pipe Packet Management (AVR8)
  56:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe packet management definitions for the Atmel AVR8 architecture.
  57:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  58:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to packet management of pipes.
  59:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  60:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  61:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeControlReq
  62:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeControlReq_AVR8 Pipe Control Request Management (AVR8)
  63:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe control request management definitions for the Atmel AVR8 architecture.
  64:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  65:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Module for host mode request processing. This module allows for the transmission of standard, c
  66:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  vendor control requests to the default control endpoint of an attached device while in host mod
  67:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  68:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \see Chapter 9 of the USB 2.0 specification.
  69:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  70:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  71:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeManagement
  72:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeManagement_AVR8 Pipe Management (AVR8)
  73:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe management definitions for the Atmel AVR8 architecture.
  74:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  75:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  This module contains functions, macros and enums related to pipe management when in USB Host mo
  76:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  module contains the pipe management macros, as well as pipe interrupt and data send/receive fun
  77:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  for various data types.
  78:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  79:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  @{
  80:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  81:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  82:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #ifndef __PIPE_AVR8_H__
  83:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #define __PIPE_AVR8_H__
  84:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  85:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Includes: */
  86:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../../../../Common/Common.h"
  87:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../USBTask.h"
  88:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  89:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  90:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if defined(__cplusplus)
  91:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			extern "C" {
  92:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  93:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  94:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Preprocessor Checks: */
  95:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  96:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  97:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  98:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  99:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 100:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Macros: */
 101:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Error Flag Masks */
 102:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 103:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an overflow error occurred in the pipe o
 104:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_OVERFLOW         (1 << 6)
 105:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 106:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an underflow error occurred in the pipe 
 107:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_UNDERFLOW        (1 << 5)
 108:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 109:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a CRC error occurred in the pipe on the 
 110:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_CRC16            (1 << 4)
 111:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 112:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware timeout error occurred in the
 113:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_TIMEOUT          (1 << 3)
 114:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 115:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware PID error occurred in the pip
 116:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_PID              (1 << 2)
 117:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 118:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data PID error occurred in th
 119:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATAPID          (1 << 1)
 120:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 121:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data toggle error occurred in
 122:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATATGL          (1 << 0)
 123:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 124:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 125:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Token Masks */
 126:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 127:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a SETUP token (for CONTROL t
 128:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which will trigger a control request on the attached device when data is written to the pipe
 129:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 130:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_SETUP                (0 << PTOKEN0)
 131:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 132:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a IN token (for non-CONTROL 
 133:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from device to host.
 134:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 135:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_IN                   (1 << PTOKEN0)
 136:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 137:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a OUT token (for non-CONTROL
 138:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from host to device.
 139:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 140:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_OUT                  (2 << PTOKEN0)
 141:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 142:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			
 143:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Bank Mode Masks */
 144:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 145:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 146:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have one single bank, which requires less USB FIFO memory but results in slower trans
 147:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  only one USB device (the AVR or the attached device) can access the pipe's bank at the one t
 148:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 149:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_SINGLE                (0 << EPBK0)
 150:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 151:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 152:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have two banks, which requires more USB FIFO memory but results in faster transfers a
 153:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  USB device (the AVR or the attached device) can access one bank while the other accesses the
 154:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  bank.
 155:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 156:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_DOUBLE                (1 << EPBK0)
 157:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 158:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 159:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Default size of the default control pipe's bank, until altered by the Endpoint0Size value
 160:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  in the device descriptor of the attached device.
 161:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 162:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_CONTROLPIPE_DEFAULT_SIZE   64
 163:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 164:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Total number of pipes (including the default control pipe at address 0) which may be used in
 165:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the device. Different USB AVR models support different amounts of pipes, this value reflects
 166:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the maximum number of pipes for the currently selected AVR model.
 167:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 168:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOTAL_PIPES                7
 169:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 170:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Size in bytes of the largest pipe bank size possible in the device. Not all banks on each AV
 171:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  model supports the largest bank size possible on the device; different pipe numbers support
 172:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  different maximum bank sizes. This value reflects the largest possible bank of any pipe on t
 173:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected USB AVR model.
 174:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 175:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_MAX_SIZE                   256
 176:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 177:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Enums: */
 178:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enum for the possible error return codes of the \ref Pipe_WaitUntilReady() function.
 179:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 180:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 181:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 182:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			enum Pipe_WaitUntilReady_ErrorCodes_t
 183:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 184:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_NoError                 = 0, /**< Pipe ready for next packet, no error. */
 185:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_PipeStalled             = 1,	/**< The device stalled the pipe while waiting. */
 186:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host while wa
 187:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_Timeout                 = 3, /**< The device failed to accept or send the next p
 188:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   within the software timeout period set by the
 189:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   \ref USB_STREAM_TIMEOUT_MS macro.
 190:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             */
 191:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			};
 192:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 193:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Inline Functions: */
 194:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Indicates the number of bytes currently stored in the current pipes's selected bank.
 195:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 196:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \note The return width of this function may differ, depending on the maximum pipe bank size
 197:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *        of the selected AVR model.
 198:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 199:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 200:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 201:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
 202:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 203:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 204:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void)
 205:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 206:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return UPBCX;
 207:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 208:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 209:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Returns the pipe address of the currently selected pipe. This is typically used to save the
 210:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected pipe number so that it can be restored after another pipe has been manipu
 211:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 212:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Index of the currently selected pipe.
 213:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 214:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 215:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void)
 216:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 217:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPNUM & PIPE_PIPENUM_MASK);
 218:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 219:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 220:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Selects the given pipe number. Any pipe operations which do not require the pipe number to b
 221:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicated will operate on the currently selected pipe.
 222:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 223:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to select.
 224:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 225:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 226:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
 227:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPNUM = PipeNumber;
 229:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 230:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 231:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Resets the desired pipe, including the pipe banks and flags.
 232:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 233:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to reset.
 234:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 235:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 236:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber)
 237:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 238:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = (1 << PipeNumber);
 239:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = 0;
 240:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 241:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 242:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enables the currently selected pipe so that data can be sent and received through it to and 
 243:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  an attached device.
 244:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 245:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePi
 246:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 247:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
 248:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void)
 249:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 250:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << PEN);
 251:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 252:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 253:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Disables the currently selected pipe so that data cannot be sent and received through it to 
 254:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  from an attached device.
 255:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 256:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
 257:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void)
 258:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 259:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << PEN);
 260:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 261:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 262:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is enabled, but not necessarily configured.
 263:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 264:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 * \return Boolean \c true if the currently selected pipe is enabled, \c false otherwise.
 265:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 266:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 267:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void)
 268:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 269:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPCONX & (1 << PEN)) ? true : false);
 270:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 271:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 272:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Gets the current pipe token, indicating the pipe's data direction and type.
 273:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 274:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
 275:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 276:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 277:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void)
 278:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 279:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPCFG0X & (0x03 << PTOKEN0));
 280:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 281:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 282:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the token for the currently selected pipe to one of the tokens specified by the \c PIPE
 283:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  masks. This can be used on CONTROL type pipes, to allow for bidirectional transfer of data d
 284:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  control requests, or on regular pipes to allow for half-duplex bidirectional data transfer t
 285:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which have two endpoints of opposite direction sharing the same endpoint address within the 
 286:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 287:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
 288:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 289:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
 290:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token)
 291:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 292:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
 293:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 294:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 295:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
 296:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
 297:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void)
 298:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 299:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << INMODE);
 300:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 301:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 302:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to only allow the specified number of IN requests to 
 303:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  accepted by the pipe before it is automatically frozen.
 304:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 305:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] TotalINRequests  Total number of IN requests that the pipe may receive before fre
 306:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 307:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests) ATTR_ALWAYS_INLINE;
 308:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests)
 309:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 310:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << INMODE);
 311:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINRQX = TotalINRequests;
 312:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 313:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 314:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is configured.
 315:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 316:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
 317:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 318:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 319:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void)
 320:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 321:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPSTAX & (1 << CFGOK)) ? true : false);
 322:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 323:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 324:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Retrieves the endpoint address of the endpoint within the attached device that the currently
 325:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipe is bound to.
 326:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 327:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Endpoint address the currently selected pipe is bound to.
 328:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 329:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INL
 330:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
 331:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
 333:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 334:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 335:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 336:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the period between interrupts for an INTERRUPT type pipe to a specified number of milli
 337:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 338:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Milliseconds  Number of milliseconds between each pipe poll.
 339:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 340:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds) ATTR_ALWAYS_INLINE;
 341:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds)
 342:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 343:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG2X = Milliseconds;
 355               		.loc 2 343 0
 356 0124 8093 AD00 		sts 173,r24
 357               	.LVL29:
 358               	.LBE10:
 359               	.LBE9:
 131:ConfigDescriptor.c **** }
 360               		.loc 1 131 0
 361 0128 00C0      		rjmp .L16
 362               	.LVL30:
 363               	.L24:
  65:ConfigDescriptor.c **** 		case HOST_GETCONFIG_BuffOverflow:
 364               		.loc 1 65 0
 365 012a 93E0      		ldi r25,lo8(3)
 366 012c F92E      		mov r15,r25
 367 012e 00C0      		rjmp .L16
 368               	.LVL31:
 369               	.L25:
 370               	.LBB11:
  84:ConfigDescriptor.c **** 			}
 371               		.loc 1 84 0
 372 0130 84E0      		ldi r24,lo8(4)
 373 0132 F82E      		mov r15,r24
 374               	.L16:
 375               	.LBE11:
 132:ConfigDescriptor.c **** 
 376               		.loc 1 132 0
 377 0134 8F2D      		mov r24,r15
 378               	/* epilogue start */
 379 0136 CC5F      		subi r28,-4
 380 0138 DD4F      		sbci r29,-3
 381 013a 0FB6      		in __tmp_reg__,__SREG__
 382 013c F894      		cli
 383 013e DEBF      		out __SP_H__,r29
 384 0140 0FBE      		out __SREG__,__tmp_reg__
 385 0142 CDBF      		out __SP_L__,r28
 386 0144 DF91      		pop r29
 387 0146 CF91      		pop r28
 388 0148 1F91      		pop r17
 389 014a 0F91      		pop r16
 390 014c FF90      		pop r15
 391 014e EF90      		pop r14
 392 0150 DF90      		pop r13
 393 0152 CF90      		pop r12
 394 0154 BF90      		pop r11
 395 0156 AF90      		pop r10
 396 0158 9F90      		pop r9
 397 015a 8F90      		pop r8
 398 015c 0895      		ret
 399               		.cfi_endproc
 400               	.LFE147:
 402               		.text
 403               	.Letext0:
 404               		.file 3 "/usr/lib/avr/include/stdint.h"
 405               		.file 4 "../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../StdDescriptors.h"
 406               		.file 5 "../../../../LUFA/Drivers/USB/Core/ConfigDescriptor.h"
 407               		.file 6 "/usr/lib/avr/include/stdio.h"
 408               		.file 7 "../../../../LUFA/Drivers/USB/Class/Host/../Common/StillImage.h"
 409               		.file 8 "ConfigDescriptor.h"
 410               		.file 9 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
 411               		.file 10 "../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ConfigDescriptor.c
     /tmp/ccCao1f5.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccCao1f5.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccCao1f5.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccCao1f5.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccCao1f5.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccCao1f5.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccCao1f5.s:14     .text.DComp_NextStillImageInterface:0000000000000000 DComp_NextStillImageInterface
     /tmp/ccCao1f5.s:61     .text.DComp_NextStillImageInterfaceDataEndpoint:0000000000000000 DComp_NextStillImageInterfaceDataEndpoint
     /tmp/ccCao1f5.s:110    .text.ProcessConfigurationDescriptor:0000000000000000 ProcessConfigurationDescriptor

UNDEFINED SYMBOLS
USB_Host_GetDeviceConfigDescriptor
USB_GetNextDescriptorComp
Pipe_ConfigurePipe
