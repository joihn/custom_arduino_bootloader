   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB94:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 	  
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this 
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in 
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting 
  17:Descriptors.c ****   documentation, and that the name of the author not be used in 
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the 
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special 
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.  
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  41:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  42:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  43:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  44:Descriptors.c ****  *  more details on HID report descriptors.
  45:Descriptors.c ****  */
  46:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t HIDReport[] =
  47:Descriptors.c **** {
  48:Descriptors.c **** 	HID_RI_USAGE_PAGE(16, 0xFFDC), /* Vendor Page 0xDC */
  49:Descriptors.c **** 	HID_RI_USAGE(8, 0xFB), /* Vendor Usage 0xFB */
  50:Descriptors.c **** 	HID_RI_COLLECTION(8, 0x01), /* Vendor Usage 1 */
  51:Descriptors.c **** 	    HID_RI_USAGE(8, 0x02), /* Vendor Usage 2 */
  52:Descriptors.c **** 	    HID_RI_LOGICAL_MINIMUM(8, 0x00),
  53:Descriptors.c **** 	    HID_RI_LOGICAL_MAXIMUM(8, 0xFF),
  54:Descriptors.c **** 	    HID_RI_REPORT_SIZE(8, 0x08),
  55:Descriptors.c **** 	    HID_RI_REPORT_COUNT(16, (sizeof(uint16_t) + SPM_PAGESIZE)),		
  56:Descriptors.c **** 	    HID_RI_OUTPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE | HID_IOF_NON_VOLATILE),
  57:Descriptors.c **** 	HID_RI_END_COLLECTION(0),
  58:Descriptors.c **** };
  59:Descriptors.c **** 
  60:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  61:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  62:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  63:Descriptors.c ****  *  process begins.
  64:Descriptors.c ****  */
  65:Descriptors.c **** const USB_Descriptor_Device_t DeviceDescriptor =
  66:Descriptors.c **** {
  67:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  68:Descriptors.c **** 
  69:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  70:Descriptors.c **** 	.Class                  = USB_CSCP_NoDeviceClass,
  71:Descriptors.c **** 	.SubClass               = USB_CSCP_NoDeviceSubclass,
  72:Descriptors.c **** 	.Protocol               = USB_CSCP_NoDeviceProtocol,
  73:Descriptors.c **** 
  74:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  75:Descriptors.c **** 
  76:Descriptors.c **** 	.VendorID               = 0x03EB,
  77:Descriptors.c **** 	.ProductID              = 0x2067,
  78:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
  79:Descriptors.c **** 
  80:Descriptors.c **** 	.ManufacturerStrIndex   = NO_DESCRIPTOR,
  81:Descriptors.c **** 	.ProductStrIndex        = NO_DESCRIPTOR,
  82:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
  83:Descriptors.c **** 
  84:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  85:Descriptors.c **** };
  86:Descriptors.c **** 
  87:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
  88:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
  89:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
  90:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
  91:Descriptors.c ****  */
  92:Descriptors.c **** const USB_Descriptor_Configuration_t ConfigurationDescriptor =
  93:Descriptors.c **** {
  94:Descriptors.c **** 	.Config = 
  95:Descriptors.c **** 		{
  96:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
  97:Descriptors.c **** 
  98:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
  99:Descriptors.c **** 			.TotalInterfaces        = 1,
 100:Descriptors.c **** 				
 101:Descriptors.c **** 			.ConfigurationNumber    = 1,
 102:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 103:Descriptors.c **** 				
 104:Descriptors.c **** 			.ConfigAttributes       = USB_CONFIG_ATTR_BUSPOWERED,
 105:Descriptors.c **** 			
 106:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 107:Descriptors.c **** 		},
 108:Descriptors.c **** 		
 109:Descriptors.c **** 	.HID_Interface = 
 110:Descriptors.c **** 		{
 111:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 112:Descriptors.c **** 
 113:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 114:Descriptors.c **** 			.AlternateSetting       = 0x00,
 115:Descriptors.c **** 			
 116:Descriptors.c **** 			.TotalEndpoints         = 1,
 117:Descriptors.c **** 				
 118:Descriptors.c **** 			.Class                  = HID_CSCP_HIDClass,
 119:Descriptors.c **** 			.SubClass               = HID_CSCP_NonBootSubclass,
 120:Descriptors.c **** 			.Protocol               = HID_CSCP_NonBootProtocol,
 121:Descriptors.c **** 				
 122:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 123:Descriptors.c **** 		},
 124:Descriptors.c **** 
 125:Descriptors.c **** 	.HID_VendorHID = 
 126:Descriptors.c **** 		{  
 127:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_HID_t), .Type = HID_DTYPE_HID},
 128:Descriptors.c **** 			
 129:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 130:Descriptors.c **** 			.CountryCode            = 0x00,
 131:Descriptors.c **** 			.TotalReportDescriptors = 1,
 132:Descriptors.c **** 			.HIDReportType          = HID_DTYPE_Report,
 133:Descriptors.c **** 			.HIDReportLength        = sizeof(HIDReport)
 134:Descriptors.c **** 		},
 135:Descriptors.c **** 		
 136:Descriptors.c **** 	.HID_ReportINEndpoint = 
 137:Descriptors.c **** 		{
 138:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 139:Descriptors.c **** 
 140:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | HID_IN_EPNUM),
 141:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 142:Descriptors.c **** 			.EndpointSize           = HID_IN_EPSIZE,
 143:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 144:Descriptors.c **** 		},
 145:Descriptors.c **** };
 146:Descriptors.c **** 
 147:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 148:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 149:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 150:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 151:Descriptors.c ****  *  USB host.
 152:Descriptors.c ****  */
 153:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 154:Descriptors.c ****                                     const uint8_t wIndex,
 155:Descriptors.c ****                                     const void** const DescriptorAddress)
 156:Descriptors.c **** {
  17               		.loc 1 156 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 157:Descriptors.c **** 	const uint8_t DescriptorType   = (wValue >> 8);
 158:Descriptors.c **** 
 159:Descriptors.c **** 	const void* Address = NULL;
 160:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 161:Descriptors.c **** 	
 162:Descriptors.c **** 	/* If/Else If chain compiles slightly smaller than a switch case */
 163:Descriptors.c **** 	if (DescriptorType == DTYPE_Device)
  24               		.loc 1 163 0
  25 0000 9130      		cpi r25,lo8(1)
  26 0002 01F0      		breq .L3
 164:Descriptors.c **** 	{
 165:Descriptors.c **** 		Address = &DeviceDescriptor;
 166:Descriptors.c **** 		Size    = sizeof(USB_Descriptor_Device_t);	
 167:Descriptors.c **** 	}
 168:Descriptors.c **** 	else if (DescriptorType == DTYPE_Configuration)
  27               		.loc 1 168 0
  28 0004 9230      		cpi r25,lo8(2)
  29 0006 01F0      		breq .L4
 169:Descriptors.c **** 	{
 170:Descriptors.c **** 		Address = &ConfigurationDescriptor;
 171:Descriptors.c **** 		Size    = sizeof(USB_Descriptor_Configuration_t);	
 172:Descriptors.c **** 	}
 173:Descriptors.c **** 	else if (DescriptorType == HID_DTYPE_HID)
  30               		.loc 1 173 0
  31 0008 9132      		cpi r25,lo8(33)
  32 000a 01F0      		breq .L5
 174:Descriptors.c **** 	{
 175:Descriptors.c **** 		Address = &ConfigurationDescriptor.HID_VendorHID;
 176:Descriptors.c **** 		Size    = sizeof(USB_HID_Descriptor_HID_t);
 177:Descriptors.c **** 	}
 178:Descriptors.c **** 	else
 179:Descriptors.c **** 	{
 180:Descriptors.c **** 		Address = &HIDReport;
 181:Descriptors.c **** 		Size    = sizeof(HIDReport);
  33               		.loc 1 181 0
  34 000c 85E1      		ldi r24,lo8(21)
  35 000e 90E0      		ldi r25,0
  36               	.LVL1:
 180:Descriptors.c **** 		Size    = sizeof(HIDReport);
  37               		.loc 1 180 0
  38 0010 20E0      		ldi r18,lo8(HIDReport)
  39 0012 30E0      		ldi r19,hi8(HIDReport)
  40 0014 00C0      		rjmp .L2
  41               	.LVL2:
  42               	.L3:
 166:Descriptors.c **** 	}
  43               		.loc 1 166 0
  44 0016 82E1      		ldi r24,lo8(18)
  45 0018 90E0      		ldi r25,0
  46               	.LVL3:
 165:Descriptors.c **** 		Size    = sizeof(USB_Descriptor_Device_t);	
  47               		.loc 1 165 0
  48 001a 20E0      		ldi r18,lo8(DeviceDescriptor)
  49 001c 30E0      		ldi r19,hi8(DeviceDescriptor)
  50 001e 00C0      		rjmp .L2
  51               	.LVL4:
  52               	.L4:
 171:Descriptors.c **** 	}
  53               		.loc 1 171 0
  54 0020 82E2      		ldi r24,lo8(34)
  55 0022 90E0      		ldi r25,0
  56               	.LVL5:
 170:Descriptors.c **** 		Size    = sizeof(USB_Descriptor_Configuration_t);	
  57               		.loc 1 170 0
  58 0024 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  59 0026 30E0      		ldi r19,hi8(ConfigurationDescriptor)
  60 0028 00C0      		rjmp .L2
  61               	.LVL6:
  62               	.L5:
 176:Descriptors.c **** 	}
  63               		.loc 1 176 0
  64 002a 89E0      		ldi r24,lo8(9)
  65 002c 90E0      		ldi r25,0
  66               	.LVL7:
 175:Descriptors.c **** 		Size    = sizeof(USB_HID_Descriptor_HID_t);
  67               		.loc 1 175 0
  68 002e 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
  69 0030 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
  70               	.L2:
  71               	.LVL8:
 182:Descriptors.c **** 	}
 183:Descriptors.c **** 
 184:Descriptors.c **** 	*DescriptorAddress = Address;
  72               		.loc 1 184 0
  73 0032 FA01      		movw r30,r20
  74 0034 3183      		std Z+1,r19
  75 0036 2083      		st Z,r18
 185:Descriptors.c **** 	return Size;
 186:Descriptors.c **** }
  76               		.loc 1 186 0
  77 0038 0895      		ret
  78               		.cfi_endproc
  79               	.LFE94:
  81               	.global	ConfigurationDescriptor
  82               		.section	.rodata
  85               	ConfigurationDescriptor:
  86 0000 09        		.byte	9
  87 0001 02        		.byte	2
  88 0002 2200      		.word	34
  89 0004 01        		.byte	1
  90 0005 01        		.byte	1
  91 0006 00        		.byte	0
  92 0007 80        		.byte	-128
  93 0008 32        		.byte	50
  94 0009 09        		.byte	9
  95 000a 04        		.byte	4
  96 000b 00        		.byte	0
  97 000c 00        		.byte	0
  98 000d 01        		.byte	1
  99 000e 03        		.byte	3
 100 000f 00        		.byte	0
 101 0010 00        		.byte	0
 102 0011 00        		.byte	0
 103 0012 09        		.byte	9
 104 0013 21        		.byte	33
 105 0014 1101      		.word	273
 106 0016 00        		.byte	0
 107 0017 01        		.byte	1
 108 0018 22        		.byte	34
 109 0019 1500      		.word	21
 110 001b 07        		.byte	7
 111 001c 05        		.byte	5
 112 001d 81        		.byte	-127
 113 001e 03        		.byte	3
 114 001f 4000      		.word	64
 115 0021 01        		.byte	1
 116               	.global	DeviceDescriptor
 119               	DeviceDescriptor:
 120 0022 12        		.byte	18
 121 0023 01        		.byte	1
 122 0024 1001      		.word	272
 123 0026 00        		.byte	0
 124 0027 00        		.byte	0
 125 0028 00        		.byte	0
 126 0029 08        		.byte	8
 127 002a EB03      		.word	1003
 128 002c 6720      		.word	8295
 129 002e 0100      		.word	1
 130 0030 00        		.byte	0
 131 0031 00        		.byte	0
 132 0032 00        		.byte	0
 133 0033 01        		.byte	1
 134               	.global	HIDReport
 137               	HIDReport:
 138 0034 06        		.byte	6
 139 0035 DC        		.byte	-36
 140 0036 FF        		.byte	-1
 141 0037 09        		.byte	9
 142 0038 FB        		.byte	-5
 143 0039 A1        		.byte	-95
 144 003a 01        		.byte	1
 145 003b 09        		.byte	9
 146 003c 02        		.byte	2
 147 003d 15        		.byte	21
 148 003e 00        		.byte	0
 149 003f 25        		.byte	37
 150 0040 FF        		.byte	-1
 151 0041 75        		.byte	117
 152 0042 08        		.byte	8
 153 0043 96        		.byte	-106
 154 0044 02        		.byte	2
 155 0045 01        		.byte	1
 156 0046 91        		.byte	-111
 157 0047 02        		.byte	2
 158 0048 C0        		.byte	-64
 159               		.text
 160               	.Letext0:
 161               		.file 2 "/usr/lib/avr/include/stdint.h"
 162               		.file 3 "../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 163               		.file 4 "../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 164               		.file 5 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/cctVf37a.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cctVf37a.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cctVf37a.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cctVf37a.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cctVf37a.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cctVf37a.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cctVf37a.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/cctVf37a.s:137    .rodata:0000000000000034 HIDReport
     /tmp/cctVf37a.s:119    .rodata:0000000000000022 DeviceDescriptor
     /tmp/cctVf37a.s:85     .rodata:0000000000000000 ConfigurationDescriptor

UNDEFINED SYMBOLS
__do_copy_data
