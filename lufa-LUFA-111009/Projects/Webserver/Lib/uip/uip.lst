   1               		.file	"uip.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.chksum,"ax",@progbits
  13               	chksum:
  14               	.LFB7:
  15               		.file 1 "Lib/uip/uip.c"
   1:Lib/uip/uip.c **** #define DEBUG_PRINTF(...) /*printf(__VA_ARGS__)*/
   2:Lib/uip/uip.c **** 
   3:Lib/uip/uip.c **** /**
   4:Lib/uip/uip.c ****  * \addtogroup uip
   5:Lib/uip/uip.c ****  * @{
   6:Lib/uip/uip.c ****  */
   7:Lib/uip/uip.c **** 
   8:Lib/uip/uip.c **** /**
   9:Lib/uip/uip.c ****  * \file
  10:Lib/uip/uip.c ****  * The uIP TCP/IP stack code.
  11:Lib/uip/uip.c ****  * \author Adam Dunkels <adam@dunkels.com>
  12:Lib/uip/uip.c ****  */
  13:Lib/uip/uip.c **** 
  14:Lib/uip/uip.c **** /*
  15:Lib/uip/uip.c ****  * Copyright (c) 2001-2003, Adam Dunkels.
  16:Lib/uip/uip.c ****  * All rights reserved.
  17:Lib/uip/uip.c ****  *
  18:Lib/uip/uip.c ****  * Redistribution and use in source and binary forms, with or without
  19:Lib/uip/uip.c ****  * modification, are permitted provided that the following conditions
  20:Lib/uip/uip.c ****  * are met:
  21:Lib/uip/uip.c ****  * 1. Redistributions of source code must retain the above copyright
  22:Lib/uip/uip.c ****  *    notice, this list of conditions and the following disclaimer.
  23:Lib/uip/uip.c ****  * 2. Redistributions in binary form must reproduce the above copyright
  24:Lib/uip/uip.c ****  *    notice, this list of conditions and the following disclaimer in the
  25:Lib/uip/uip.c ****  *    documentation and/or other materials provided with the distribution.
  26:Lib/uip/uip.c ****  * 3. The name of the author may not be used to endorse or promote
  27:Lib/uip/uip.c ****  *    products derived from this software without specific prior
  28:Lib/uip/uip.c ****  *    written permission.
  29:Lib/uip/uip.c ****  *
  30:Lib/uip/uip.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  31:Lib/uip/uip.c ****  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  32:Lib/uip/uip.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  33:Lib/uip/uip.c ****  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  34:Lib/uip/uip.c ****  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  35:Lib/uip/uip.c ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  36:Lib/uip/uip.c ****  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  37:Lib/uip/uip.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  38:Lib/uip/uip.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  39:Lib/uip/uip.c ****  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  40:Lib/uip/uip.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  41:Lib/uip/uip.c ****  *
  42:Lib/uip/uip.c ****  * This file is part of the uIP TCP/IP stack.
  43:Lib/uip/uip.c ****  *
  44:Lib/uip/uip.c ****  * $Id: uip.c,v 1.15 2008/10/15 08:08:32 adamdunkels Exp $
  45:Lib/uip/uip.c ****  *
  46:Lib/uip/uip.c ****  */
  47:Lib/uip/uip.c **** 
  48:Lib/uip/uip.c **** /*
  49:Lib/uip/uip.c ****  * uIP is a small implementation of the IP, UDP and TCP protocols (as
  50:Lib/uip/uip.c ****  * well as some basic ICMP stuff). The implementation couples the IP,
  51:Lib/uip/uip.c ****  * UDP, TCP and the application layers very tightly. To keep the size
  52:Lib/uip/uip.c ****  * of the compiled code down, this code frequently uses the goto
  53:Lib/uip/uip.c ****  * statement. While it would be possible to break the uip_process()
  54:Lib/uip/uip.c ****  * function into many smaller functions, this would increase the code
  55:Lib/uip/uip.c ****  * size because of the overhead of parameter passing and the fact that
  56:Lib/uip/uip.c ****  * the optimiser would not be as efficient.
  57:Lib/uip/uip.c ****  *
  58:Lib/uip/uip.c ****  * The principle is that we have a small buffer, called the uip_buf,
  59:Lib/uip/uip.c ****  * in which the device driver puts an incoming packet. The TCP/IP
  60:Lib/uip/uip.c ****  * stack parses the headers in the packet, and calls the
  61:Lib/uip/uip.c ****  * application. If the remote host has sent data to the application,
  62:Lib/uip/uip.c ****  * this data is present in the uip_buf and the application read the
  63:Lib/uip/uip.c ****  * data from there. It is up to the application to put this data into
  64:Lib/uip/uip.c ****  * a byte stream if needed. The application will not be fed with data
  65:Lib/uip/uip.c ****  * that is out of sequence.
  66:Lib/uip/uip.c ****  *
  67:Lib/uip/uip.c ****  * If the application whishes to send data to the peer, it should put
  68:Lib/uip/uip.c ****  * its data into the uip_buf. The uip_appdata pointer points to the
  69:Lib/uip/uip.c ****  * first available byte. The TCP/IP stack will calculate the
  70:Lib/uip/uip.c ****  * checksums, and fill in the necessary header fields and finally send
  71:Lib/uip/uip.c ****  * the packet back to the peer.
  72:Lib/uip/uip.c **** */
  73:Lib/uip/uip.c **** 
  74:Lib/uip/uip.c **** #include "uip.h"
  75:Lib/uip/uip.c **** #include "uipopt.h"
  76:Lib/uip/uip.c **** #include "uip_arp.h"
  77:Lib/uip/uip.c **** 
  78:Lib/uip/uip.c **** #if !UIP_CONF_IPV6 /* If UIP_CONF_IPV6 is defined, we compile the
  79:Lib/uip/uip.c **** 		      uip6.c file instead of this one. Therefore
  80:Lib/uip/uip.c **** 		      this #ifndef removes the entire compilation
  81:Lib/uip/uip.c **** 		      output of the uip.c file */
  82:Lib/uip/uip.c **** 
  83:Lib/uip/uip.c **** 
  84:Lib/uip/uip.c **** #if UIP_CONF_IPV6
  85:Lib/uip/uip.c **** #include "net/uip-neighbor.h"
  86:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
  87:Lib/uip/uip.c **** 
  88:Lib/uip/uip.c **** #include <string.h>
  89:Lib/uip/uip.c **** 
  90:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
  91:Lib/uip/uip.c **** /* Variable definitions. */
  92:Lib/uip/uip.c **** 
  93:Lib/uip/uip.c **** 
  94:Lib/uip/uip.c **** /* The IP address of this host. If it is defined to be fixed (by
  95:Lib/uip/uip.c ****    setting UIP_FIXEDADDR to 1 in uipopt.h), the address is set
  96:Lib/uip/uip.c ****    here. Otherwise, the address */
  97:Lib/uip/uip.c **** #if UIP_FIXEDADDR > 0
  98:Lib/uip/uip.c **** const uip_ipaddr_t uip_hostaddr =
  99:Lib/uip/uip.c ****   { UIP_IPADDR0, UIP_IPADDR1, UIP_IPADDR2, UIP_IPADDR3 };
 100:Lib/uip/uip.c **** const uip_ipaddr_t uip_draddr =
 101:Lib/uip/uip.c ****   { UIP_DRIPADDR0, UIP_DRIPADDR1, UIP_DRIPADDR2, UIP_DRIPADDR3 };
 102:Lib/uip/uip.c **** const uip_ipaddr_t uip_netmask =
 103:Lib/uip/uip.c ****   { UIP_NETMASK0, UIP_NETMASK1, UIP_NETMASK2, UIP_NETMASK3 };
 104:Lib/uip/uip.c **** #else
 105:Lib/uip/uip.c **** uip_ipaddr_t uip_hostaddr, uip_draddr, uip_netmask;
 106:Lib/uip/uip.c **** #endif /* UIP_FIXEDADDR */
 107:Lib/uip/uip.c **** 
 108:Lib/uip/uip.c **** const uip_ipaddr_t uip_broadcast_addr =
 109:Lib/uip/uip.c **** #if UIP_CONF_IPV6
 110:Lib/uip/uip.c ****   { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 111:Lib/uip/uip.c ****       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } };
 112:Lib/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 113:Lib/uip/uip.c ****   { { 0xff, 0xff, 0xff, 0xff } };
 114:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 115:Lib/uip/uip.c **** const uip_ipaddr_t uip_all_zeroes_addr = { { 0x0, /* rest is 0 */ } };
 116:Lib/uip/uip.c **** 
 117:Lib/uip/uip.c **** #if UIP_FIXEDETHADDR
 118:Lib/uip/uip.c **** const struct uip_eth_addr uip_ethaddr = {{UIP_ETHADDR0,
 119:Lib/uip/uip.c **** 					  UIP_ETHADDR1,
 120:Lib/uip/uip.c **** 					  UIP_ETHADDR2,
 121:Lib/uip/uip.c **** 					  UIP_ETHADDR3,
 122:Lib/uip/uip.c **** 					  UIP_ETHADDR4,
 123:Lib/uip/uip.c **** 					  UIP_ETHADDR5}};
 124:Lib/uip/uip.c **** #else
 125:Lib/uip/uip.c **** struct uip_eth_addr uip_ethaddr = {{0,0,0,0,0,0}};
 126:Lib/uip/uip.c **** #endif
 127:Lib/uip/uip.c **** 
 128:Lib/uip/uip.c **** #ifndef UIP_CONF_EXTERNAL_BUFFER
 129:Lib/uip/uip.c **** u8_t uip_buf[UIP_BUFSIZE + 2];   /* The packet buffer that contains
 130:Lib/uip/uip.c **** 				    incoming packets. */
 131:Lib/uip/uip.c **** #endif /* UIP_CONF_EXTERNAL_BUFFER */
 132:Lib/uip/uip.c **** 
 133:Lib/uip/uip.c **** void *uip_appdata;               /* The uip_appdata pointer points to
 134:Lib/uip/uip.c **** 				    application data. */
 135:Lib/uip/uip.c **** void *uip_sappdata;              /* The uip_appdata pointer points to
 136:Lib/uip/uip.c **** 				    the application data which is to
 137:Lib/uip/uip.c **** 				    be sent. */
 138:Lib/uip/uip.c **** #if UIP_URGDATA > 0
 139:Lib/uip/uip.c **** void *uip_urgdata;               /* The uip_urgdata pointer points to
 140:Lib/uip/uip.c ****    				    urgent data (out-of-band data), if
 141:Lib/uip/uip.c ****    				    present. */
 142:Lib/uip/uip.c **** u16_t uip_urglen, uip_surglen;
 143:Lib/uip/uip.c **** #endif /* UIP_URGDATA > 0 */
 144:Lib/uip/uip.c **** 
 145:Lib/uip/uip.c **** u16_t uip_len, uip_slen;
 146:Lib/uip/uip.c ****                              /* The uip_len is either 8 or 16 bits,
 147:Lib/uip/uip.c **** 				depending on the maximum packet
 148:Lib/uip/uip.c **** 				size. */
 149:Lib/uip/uip.c **** 
 150:Lib/uip/uip.c **** u8_t uip_flags;     /* The uip_flags variable is used for
 151:Lib/uip/uip.c **** 				communication between the TCP/IP stack
 152:Lib/uip/uip.c **** 				and the application program. */
 153:Lib/uip/uip.c **** struct uip_conn *uip_conn;   /* uip_conn always points to the current
 154:Lib/uip/uip.c **** 				connection. */
 155:Lib/uip/uip.c **** 
 156:Lib/uip/uip.c **** struct uip_conn uip_conns[UIP_CONNS];
 157:Lib/uip/uip.c ****                              /* The uip_conns array holds all TCP
 158:Lib/uip/uip.c **** 				connections. */
 159:Lib/uip/uip.c **** u16_t uip_listenports[UIP_LISTENPORTS];
 160:Lib/uip/uip.c ****                              /* The uip_listenports list all currently
 161:Lib/uip/uip.c **** 				listening ports. */
 162:Lib/uip/uip.c **** #if UIP_UDP
 163:Lib/uip/uip.c **** struct uip_udp_conn *uip_udp_conn;
 164:Lib/uip/uip.c **** struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
 165:Lib/uip/uip.c **** #endif /* UIP_UDP */
 166:Lib/uip/uip.c **** 
 167:Lib/uip/uip.c **** static u16_t ipid;           /* Ths ipid variable is an increasing
 168:Lib/uip/uip.c **** 				number that is used for the IP ID
 169:Lib/uip/uip.c **** 				field. */
 170:Lib/uip/uip.c **** 
 171:Lib/uip/uip.c **** void uip_setipid(u16_t id) { ipid = id; }
 172:Lib/uip/uip.c **** 
 173:Lib/uip/uip.c **** static u8_t iss[4];          /* The iss variable is used for the TCP
 174:Lib/uip/uip.c **** 				initial sequence number. */
 175:Lib/uip/uip.c **** 
 176:Lib/uip/uip.c **** #if UIP_ACTIVE_OPEN
 177:Lib/uip/uip.c **** static u16_t lastport;       /* Keeps track of the last port used for
 178:Lib/uip/uip.c **** 				a new connection. */
 179:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 180:Lib/uip/uip.c **** 
 181:Lib/uip/uip.c **** /* Temporary variables. */
 182:Lib/uip/uip.c **** u8_t uip_acc32[4];
 183:Lib/uip/uip.c **** static u8_t c, opt;
 184:Lib/uip/uip.c **** static u16_t tmp16;
 185:Lib/uip/uip.c **** 
 186:Lib/uip/uip.c **** /* Structures and definitions. */
 187:Lib/uip/uip.c **** #define TCP_FIN 0x01
 188:Lib/uip/uip.c **** #define TCP_SYN 0x02
 189:Lib/uip/uip.c **** #define TCP_RST 0x04
 190:Lib/uip/uip.c **** #define TCP_PSH 0x08
 191:Lib/uip/uip.c **** #define TCP_ACK 0x10
 192:Lib/uip/uip.c **** #define TCP_URG 0x20
 193:Lib/uip/uip.c **** #define TCP_CTL 0x3f
 194:Lib/uip/uip.c **** 
 195:Lib/uip/uip.c **** #define TCP_OPT_END     0   /* End of TCP options list */
 196:Lib/uip/uip.c **** #define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
 197:Lib/uip/uip.c **** #define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
 198:Lib/uip/uip.c **** 
 199:Lib/uip/uip.c **** #define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
 200:Lib/uip/uip.c **** 
 201:Lib/uip/uip.c **** #define ICMP_ECHO_REPLY 0
 202:Lib/uip/uip.c **** #define ICMP_ECHO       8
 203:Lib/uip/uip.c **** 
 204:Lib/uip/uip.c **** #define ICMP_DEST_UNREACHABLE        3
 205:Lib/uip/uip.c **** #define ICMP_PORT_UNREACHABLE        3
 206:Lib/uip/uip.c **** 
 207:Lib/uip/uip.c **** #define ICMP6_ECHO_REPLY             129
 208:Lib/uip/uip.c **** #define ICMP6_ECHO                   128
 209:Lib/uip/uip.c **** #define ICMP6_NEIGHBOR_SOLICITATION  135
 210:Lib/uip/uip.c **** #define ICMP6_NEIGHBOR_ADVERTISEMENT 136
 211:Lib/uip/uip.c **** 
 212:Lib/uip/uip.c **** #define ICMP6_FLAG_S (1 << 6)
 213:Lib/uip/uip.c **** 
 214:Lib/uip/uip.c **** #define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
 215:Lib/uip/uip.c **** #define ICMP6_OPTION_TARGET_LINK_ADDRESS 2
 216:Lib/uip/uip.c **** 
 217:Lib/uip/uip.c **** 
 218:Lib/uip/uip.c **** /* Macros. */
 219:Lib/uip/uip.c **** #define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
 220:Lib/uip/uip.c **** #define FBUF ((struct uip_tcpip_hdr *)&uip_reassbuf[0])
 221:Lib/uip/uip.c **** #define ICMPBUF ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
 222:Lib/uip/uip.c **** #define UDPBUF ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
 223:Lib/uip/uip.c **** 
 224:Lib/uip/uip.c **** 
 225:Lib/uip/uip.c **** #if UIP_STATISTICS == 1
 226:Lib/uip/uip.c **** struct uip_stats uip_stat;
 227:Lib/uip/uip.c **** #define UIP_STAT(s) s
 228:Lib/uip/uip.c **** #else
 229:Lib/uip/uip.c **** #define UIP_STAT(s)
 230:Lib/uip/uip.c **** #endif /* UIP_STATISTICS == 1 */
 231:Lib/uip/uip.c **** 
 232:Lib/uip/uip.c **** #if UIP_LOGGING == 1
 233:Lib/uip/uip.c **** #include <stdio.h>
 234:Lib/uip/uip.c **** void uip_log(char *msg);
 235:Lib/uip/uip.c **** #define UIP_LOG(m) uip_log(m)
 236:Lib/uip/uip.c **** #else
 237:Lib/uip/uip.c **** #define UIP_LOG(m)
 238:Lib/uip/uip.c **** #endif /* UIP_LOGGING == 1 */
 239:Lib/uip/uip.c **** 
 240:Lib/uip/uip.c **** #if ! UIP_ARCH_ADD32
 241:Lib/uip/uip.c **** void
 242:Lib/uip/uip.c **** uip_add32(u8_t *op32, u16_t op16)
 243:Lib/uip/uip.c **** {
 244:Lib/uip/uip.c ****   uip_acc32[3] = op32[3] + (op16 & 0xff);
 245:Lib/uip/uip.c ****   uip_acc32[2] = op32[2] + (op16 >> 8);
 246:Lib/uip/uip.c ****   uip_acc32[1] = op32[1];
 247:Lib/uip/uip.c ****   uip_acc32[0] = op32[0];
 248:Lib/uip/uip.c **** 
 249:Lib/uip/uip.c ****   if(uip_acc32[2] < (op16 >> 8)) {
 250:Lib/uip/uip.c ****     ++uip_acc32[1];
 251:Lib/uip/uip.c ****     if(uip_acc32[1] == 0) {
 252:Lib/uip/uip.c ****       ++uip_acc32[0];
 253:Lib/uip/uip.c ****     }
 254:Lib/uip/uip.c ****   }
 255:Lib/uip/uip.c **** 
 256:Lib/uip/uip.c **** 
 257:Lib/uip/uip.c ****   if(uip_acc32[3] < (op16 & 0xff)) {
 258:Lib/uip/uip.c ****     ++uip_acc32[2];
 259:Lib/uip/uip.c ****     if(uip_acc32[2] == 0) {
 260:Lib/uip/uip.c ****       ++uip_acc32[1];
 261:Lib/uip/uip.c ****       if(uip_acc32[1] == 0) {
 262:Lib/uip/uip.c **** 	++uip_acc32[0];
 263:Lib/uip/uip.c ****       }
 264:Lib/uip/uip.c ****     }
 265:Lib/uip/uip.c ****   }
 266:Lib/uip/uip.c **** }
 267:Lib/uip/uip.c **** 
 268:Lib/uip/uip.c **** #endif /* UIP_ARCH_ADD32 */
 269:Lib/uip/uip.c **** 
 270:Lib/uip/uip.c **** #if ! UIP_ARCH_CHKSUM
 271:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 272:Lib/uip/uip.c **** static u16_t
 273:Lib/uip/uip.c **** chksum(u16_t sum, const u8_t *data, u16_t len)
 274:Lib/uip/uip.c **** {
  16               		.loc 1 274 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23 0000 FB01      		movw r30,r22
  24               	.LVL1:
 275:Lib/uip/uip.c ****   u16_t t;
 276:Lib/uip/uip.c ****   const u8_t *dataptr;
 277:Lib/uip/uip.c ****   const u8_t *last_byte;
 278:Lib/uip/uip.c **** 
 279:Lib/uip/uip.c ****   dataptr = data;
 280:Lib/uip/uip.c ****   last_byte = data + len - 1;
  25               		.loc 1 280 0
  26 0002 4150      		subi r20,1
  27 0004 5109      		sbc r21,__zero_reg__
  28               	.LVL2:
  29 0006 460F      		add r20,r22
  30 0008 571F      		adc r21,r23
  31               	.LVL3:
  32               	.L2:
 281:Lib/uip/uip.c **** 
 282:Lib/uip/uip.c ****   while(dataptr < last_byte) {	/* At least two more bytes */
  33               		.loc 1 282 0
  34 000a E417      		cp r30,r20
  35 000c F507      		cpc r31,r21
  36 000e 00F4      		brsh .L7
 283:Lib/uip/uip.c ****     t = (dataptr[0] << 8) + dataptr[1];
  37               		.loc 1 283 0
  38 0010 2081      		ld r18,Z
  39 0012 30E0      		ldi r19,0
  40 0014 322F      		mov r19,r18
  41 0016 2227      		clr r18
  42 0018 6181      		ldd r22,Z+1
  43 001a 260F      		add r18,r22
  44 001c 311D      		adc r19,__zero_reg__
  45               	.LVL4:
 284:Lib/uip/uip.c ****     sum += t;
  46               		.loc 1 284 0
  47 001e 820F      		add r24,r18
  48 0020 931F      		adc r25,r19
  49               	.LVL5:
 285:Lib/uip/uip.c ****     if(sum < t) {
  50               		.loc 1 285 0
  51 0022 8217      		cp r24,r18
  52 0024 9307      		cpc r25,r19
  53 0026 00F4      		brsh .L3
 286:Lib/uip/uip.c ****       sum++;		/* carry */
  54               		.loc 1 286 0
  55 0028 0196      		adiw r24,1
  56               	.LVL6:
  57               	.L3:
 287:Lib/uip/uip.c ****     }
 288:Lib/uip/uip.c ****     dataptr += 2;
  58               		.loc 1 288 0
  59 002a 3296      		adiw r30,2
  60               	.LVL7:
  61 002c 00C0      		rjmp .L2
  62               	.LVL8:
  63               	.L7:
 289:Lib/uip/uip.c ****   }
 290:Lib/uip/uip.c **** 
 291:Lib/uip/uip.c ****   if(dataptr == last_byte) {
  64               		.loc 1 291 0
  65 002e E417      		cp r30,r20
  66 0030 F507      		cpc r31,r21
  67 0032 01F4      		brne .L5
 292:Lib/uip/uip.c ****     t = (dataptr[0] << 8) + 0;
  68               		.loc 1 292 0
  69 0034 2081      		ld r18,Z
  70 0036 30E0      		ldi r19,0
  71 0038 322F      		mov r19,r18
  72 003a 2227      		clr r18
  73               	.LVL9:
 293:Lib/uip/uip.c ****     sum += t;
  74               		.loc 1 293 0
  75 003c 820F      		add r24,r18
  76 003e 931F      		adc r25,r19
  77               	.LVL10:
 294:Lib/uip/uip.c ****     if(sum < t) {
  78               		.loc 1 294 0
  79 0040 8217      		cp r24,r18
  80 0042 9307      		cpc r25,r19
  81 0044 00F4      		brsh .L5
 295:Lib/uip/uip.c ****       sum++;		/* carry */
  82               		.loc 1 295 0
  83 0046 0196      		adiw r24,1
  84               	.LVL11:
  85               	.L5:
 296:Lib/uip/uip.c ****     }
 297:Lib/uip/uip.c ****   }
 298:Lib/uip/uip.c **** 
 299:Lib/uip/uip.c ****   /* Return sum in host byte order. */
 300:Lib/uip/uip.c ****   return sum;
 301:Lib/uip/uip.c **** }
  86               		.loc 1 301 0
  87 0048 0895      		ret
  88               		.cfi_endproc
  89               	.LFE7:
  91               		.section	.text.uip_setipid,"ax",@progbits
  92               	.global	uip_setipid
  94               	uip_setipid:
  95               	.LFB5:
 171:Lib/uip/uip.c **** 
  96               		.loc 1 171 0
  97               		.cfi_startproc
  98               	.LVL12:
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 171:Lib/uip/uip.c **** 
 103               		.loc 1 171 0
 104 0000 9093 0000 		sts ipid+1,r25
 105 0004 8093 0000 		sts ipid,r24
 106 0008 0895      		ret
 107               		.cfi_endproc
 108               	.LFE5:
 110               		.section	.text.uip_add32,"ax",@progbits
 111               	.global	uip_add32
 113               	uip_add32:
 114               	.LFB6:
 243:Lib/uip/uip.c ****   uip_acc32[3] = op32[3] + (op16 & 0xff);
 115               		.loc 1 243 0
 116               		.cfi_startproc
 117               	.LVL13:
 118               	/* prologue: function */
 119               	/* frame size = 0 */
 120               	/* stack size = 0 */
 121               	.L__stack_usage = 0
 122 0000 FC01      		movw r30,r24
 244:Lib/uip/uip.c ****   uip_acc32[2] = op32[2] + (op16 >> 8);
 123               		.loc 1 244 0
 124 0002 2381      		ldd r18,Z+3
 125 0004 260F      		add r18,r22
 126 0006 2093 0000 		sts uip_acc32+3,r18
 245:Lib/uip/uip.c ****   uip_acc32[1] = op32[1];
 127               		.loc 1 245 0
 128 000a A72F      		mov r26,r23
 129 000c BB27      		clr r27
 130               	.LVL14:
 131 000e 9281      		ldd r25,Z+2
 132 0010 9A0F      		add r25,r26
 133 0012 9093 0000 		sts uip_acc32+2,r25
 246:Lib/uip/uip.c ****   uip_acc32[0] = op32[0];
 134               		.loc 1 246 0
 135 0016 3181      		ldd r19,Z+1
 136 0018 3093 0000 		sts uip_acc32+1,r19
 247:Lib/uip/uip.c **** 
 137               		.loc 1 247 0
 138 001c 4081      		ld r20,Z
 139 001e 4093 0000 		sts uip_acc32,r20
 249:Lib/uip/uip.c ****     ++uip_acc32[1];
 140               		.loc 1 249 0
 141 0022 E92F      		mov r30,r25
 142               	.LVL15:
 143 0024 F0E0      		ldi r31,0
 144 0026 EA17      		cp r30,r26
 145 0028 FB07      		cpc r31,r27
 146 002a 00F4      		brsh .L11
 250:Lib/uip/uip.c ****     if(uip_acc32[1] == 0) {
 147               		.loc 1 250 0
 148 002c 81E0      		ldi r24,lo8(1)
 149 002e 830F      		add r24,r19
 150 0030 8093 0000 		sts uip_acc32+1,r24
 251:Lib/uip/uip.c ****       ++uip_acc32[0];
 151               		.loc 1 251 0
 152 0034 8111      		cpse r24,__zero_reg__
 153 0036 00C0      		rjmp .L11
 252:Lib/uip/uip.c ****     }
 154               		.loc 1 252 0
 155 0038 4F5F      		subi r20,lo8(-(1))
 156 003a 4093 0000 		sts uip_acc32,r20
 157               	.L11:
 257:Lib/uip/uip.c ****     ++uip_acc32[2];
 158               		.loc 1 257 0
 159 003e 30E0      		ldi r19,0
 160 0040 7727      		clr r23
 161               	.LVL16:
 162 0042 2617      		cp r18,r22
 163 0044 3707      		cpc r19,r23
 164 0046 00F4      		brsh .L9
 258:Lib/uip/uip.c ****     if(uip_acc32[2] == 0) {
 165               		.loc 1 258 0
 166 0048 9F5F      		subi r25,lo8(-(1))
 167 004a 9093 0000 		sts uip_acc32+2,r25
 259:Lib/uip/uip.c ****       ++uip_acc32[1];
 168               		.loc 1 259 0
 169 004e 9111      		cpse r25,__zero_reg__
 170 0050 00C0      		rjmp .L9
 260:Lib/uip/uip.c ****       if(uip_acc32[1] == 0) {
 171               		.loc 1 260 0
 172 0052 8091 0000 		lds r24,uip_acc32+1
 173 0056 8F5F      		subi r24,lo8(-(1))
 174 0058 8093 0000 		sts uip_acc32+1,r24
 261:Lib/uip/uip.c **** 	++uip_acc32[0];
 175               		.loc 1 261 0
 176 005c 8111      		cpse r24,__zero_reg__
 177 005e 00C0      		rjmp .L9
 262:Lib/uip/uip.c ****       }
 178               		.loc 1 262 0
 179 0060 8091 0000 		lds r24,uip_acc32
 180 0064 8F5F      		subi r24,lo8(-(1))
 181 0066 8093 0000 		sts uip_acc32,r24
 182               	.L9:
 183 006a 0895      		ret
 184               		.cfi_endproc
 185               	.LFE6:
 187               		.section	.text.unlikely.uip_add_rcv_nxt,"ax",@progbits
 189               	uip_add_rcv_nxt:
 190               	.LFB17:
 302:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 303:Lib/uip/uip.c **** u16_t
 304:Lib/uip/uip.c **** uip_chksum(u16_t *data, u16_t len)
 305:Lib/uip/uip.c **** {
 306:Lib/uip/uip.c ****   return htons(chksum(0, (u8_t *)data, len));
 307:Lib/uip/uip.c **** }
 308:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 309:Lib/uip/uip.c **** #ifndef UIP_ARCH_IPCHKSUM
 310:Lib/uip/uip.c **** u16_t
 311:Lib/uip/uip.c **** uip_ipchksum(void)
 312:Lib/uip/uip.c **** {
 313:Lib/uip/uip.c ****   u16_t sum;
 314:Lib/uip/uip.c **** 
 315:Lib/uip/uip.c ****   sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
 316:Lib/uip/uip.c ****   DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
 317:Lib/uip/uip.c ****   return (sum == 0) ? 0xffff : htons(sum);
 318:Lib/uip/uip.c **** }
 319:Lib/uip/uip.c **** #endif
 320:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 321:Lib/uip/uip.c **** static u16_t
 322:Lib/uip/uip.c **** upper_layer_chksum(u8_t proto)
 323:Lib/uip/uip.c **** {
 324:Lib/uip/uip.c ****   u16_t upper_layer_len;
 325:Lib/uip/uip.c ****   u16_t sum;
 326:Lib/uip/uip.c **** 
 327:Lib/uip/uip.c **** #if UIP_CONF_IPV6
 328:Lib/uip/uip.c ****   upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
 329:Lib/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 330:Lib/uip/uip.c ****   upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
 331:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 332:Lib/uip/uip.c **** 
 333:Lib/uip/uip.c ****   /* First sum pseudoheader. */
 334:Lib/uip/uip.c **** 
 335:Lib/uip/uip.c ****   /* IP protocol and length fields. This addition cannot carry. */
 336:Lib/uip/uip.c ****   sum = upper_layer_len + proto;
 337:Lib/uip/uip.c ****   /* Sum IP source and destination addresses. */
 338:Lib/uip/uip.c ****   sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
 339:Lib/uip/uip.c **** 
 340:Lib/uip/uip.c ****   /* Sum TCP header and data. */
 341:Lib/uip/uip.c ****   sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
 342:Lib/uip/uip.c **** 	       upper_layer_len);
 343:Lib/uip/uip.c **** 
 344:Lib/uip/uip.c ****   return (sum == 0) ? 0xffff : htons(sum);
 345:Lib/uip/uip.c **** }
 346:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 347:Lib/uip/uip.c **** #if UIP_CONF_IPV6
 348:Lib/uip/uip.c **** u16_t
 349:Lib/uip/uip.c **** uip_icmp6chksum(void)
 350:Lib/uip/uip.c **** {
 351:Lib/uip/uip.c ****   return upper_layer_chksum(UIP_PROTO_ICMP6);
 352:Lib/uip/uip.c **** 
 353:Lib/uip/uip.c **** }
 354:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 355:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 356:Lib/uip/uip.c **** u16_t
 357:Lib/uip/uip.c **** uip_tcpchksum(void)
 358:Lib/uip/uip.c **** {
 359:Lib/uip/uip.c ****   return upper_layer_chksum(UIP_PROTO_TCP);
 360:Lib/uip/uip.c **** }
 361:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 362:Lib/uip/uip.c **** #if UIP_UDP_CHECKSUMS
 363:Lib/uip/uip.c **** u16_t
 364:Lib/uip/uip.c **** uip_udpchksum(void)
 365:Lib/uip/uip.c **** {
 366:Lib/uip/uip.c ****   return upper_layer_chksum(UIP_PROTO_UDP);
 367:Lib/uip/uip.c **** }
 368:Lib/uip/uip.c **** #endif /* UIP_UDP_CHECKSUMS */
 369:Lib/uip/uip.c **** #endif /* UIP_ARCH_CHKSUM */
 370:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 371:Lib/uip/uip.c **** void
 372:Lib/uip/uip.c **** uip_init(void)
 373:Lib/uip/uip.c **** {
 374:Lib/uip/uip.c ****   for(c = 0; c < UIP_LISTENPORTS; ++c) {
 375:Lib/uip/uip.c ****     uip_listenports[c] = 0;
 376:Lib/uip/uip.c ****   }
 377:Lib/uip/uip.c ****   for(c = 0; c < UIP_CONNS; ++c) {
 378:Lib/uip/uip.c ****     uip_conns[c].tcpstateflags = UIP_CLOSED;
 379:Lib/uip/uip.c ****   }
 380:Lib/uip/uip.c **** #if UIP_ACTIVE_OPEN
 381:Lib/uip/uip.c ****   lastport = 1024;
 382:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 383:Lib/uip/uip.c **** 
 384:Lib/uip/uip.c **** #if UIP_UDP
 385:Lib/uip/uip.c ****   for(c = 0; c < UIP_UDP_CONNS; ++c) {
 386:Lib/uip/uip.c ****     uip_udp_conns[c].lport = 0;
 387:Lib/uip/uip.c ****   }
 388:Lib/uip/uip.c **** #endif /* UIP_UDP */
 389:Lib/uip/uip.c **** 
 390:Lib/uip/uip.c **** 
 391:Lib/uip/uip.c ****   /* IPv4 initialization. */
 392:Lib/uip/uip.c **** #if UIP_FIXEDADDR == 0
 393:Lib/uip/uip.c ****   /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
 394:Lib/uip/uip.c **** #endif /* UIP_FIXEDADDR */
 395:Lib/uip/uip.c **** 
 396:Lib/uip/uip.c **** }
 397:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 398:Lib/uip/uip.c **** #if UIP_ACTIVE_OPEN
 399:Lib/uip/uip.c **** struct uip_conn *
 400:Lib/uip/uip.c **** uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
 401:Lib/uip/uip.c **** {
 402:Lib/uip/uip.c ****   register struct uip_conn *conn, *cconn;
 403:Lib/uip/uip.c **** 
 404:Lib/uip/uip.c ****   /* Find an unused local port. */
 405:Lib/uip/uip.c ****  again:
 406:Lib/uip/uip.c ****   ++lastport;
 407:Lib/uip/uip.c **** 
 408:Lib/uip/uip.c ****   if(lastport >= 32000) {
 409:Lib/uip/uip.c ****     lastport = 4096;
 410:Lib/uip/uip.c ****   }
 411:Lib/uip/uip.c **** 
 412:Lib/uip/uip.c ****   /* Check if this port is already in use, and if so try to find
 413:Lib/uip/uip.c ****      another one. */
 414:Lib/uip/uip.c ****   for(c = 0; c < UIP_CONNS; ++c) {
 415:Lib/uip/uip.c ****     conn = &uip_conns[c];
 416:Lib/uip/uip.c ****     if(conn->tcpstateflags != UIP_CLOSED &&
 417:Lib/uip/uip.c ****        conn->lport == htons(lastport)) {
 418:Lib/uip/uip.c ****       goto again;
 419:Lib/uip/uip.c ****     }
 420:Lib/uip/uip.c ****   }
 421:Lib/uip/uip.c **** 
 422:Lib/uip/uip.c ****   conn = 0;
 423:Lib/uip/uip.c ****   for(c = 0; c < UIP_CONNS; ++c) {
 424:Lib/uip/uip.c ****     cconn = &uip_conns[c];
 425:Lib/uip/uip.c ****     if(cconn->tcpstateflags == UIP_CLOSED) {
 426:Lib/uip/uip.c ****       conn = cconn;
 427:Lib/uip/uip.c ****       break;
 428:Lib/uip/uip.c ****     }
 429:Lib/uip/uip.c ****     if(cconn->tcpstateflags == UIP_TIME_WAIT) {
 430:Lib/uip/uip.c ****       if(conn == 0 ||
 431:Lib/uip/uip.c **** 	 cconn->timer > conn->timer) {
 432:Lib/uip/uip.c **** 	conn = cconn;
 433:Lib/uip/uip.c ****       }
 434:Lib/uip/uip.c ****     }
 435:Lib/uip/uip.c ****   }
 436:Lib/uip/uip.c **** 
 437:Lib/uip/uip.c ****   if(conn == 0) {
 438:Lib/uip/uip.c ****     return 0;
 439:Lib/uip/uip.c ****   }
 440:Lib/uip/uip.c **** 
 441:Lib/uip/uip.c ****   conn->tcpstateflags = UIP_SYN_SENT;
 442:Lib/uip/uip.c **** 
 443:Lib/uip/uip.c ****   conn->snd_nxt[0] = iss[0];
 444:Lib/uip/uip.c ****   conn->snd_nxt[1] = iss[1];
 445:Lib/uip/uip.c ****   conn->snd_nxt[2] = iss[2];
 446:Lib/uip/uip.c ****   conn->snd_nxt[3] = iss[3];
 447:Lib/uip/uip.c **** 
 448:Lib/uip/uip.c ****   conn->initialmss = conn->mss = UIP_TCP_MSS;
 449:Lib/uip/uip.c **** 
 450:Lib/uip/uip.c ****   conn->len = 1;   /* TCP length of the SYN is one. */
 451:Lib/uip/uip.c ****   conn->nrtx = 0;
 452:Lib/uip/uip.c ****   conn->timer = 1; /* Send the SYN next time around. */
 453:Lib/uip/uip.c ****   conn->rto = UIP_RTO;
 454:Lib/uip/uip.c ****   conn->sa = 0;
 455:Lib/uip/uip.c ****   conn->sv = 16;   /* Initial value of the RTT variance. */
 456:Lib/uip/uip.c ****   conn->lport = htons(lastport);
 457:Lib/uip/uip.c ****   conn->rport = rport;
 458:Lib/uip/uip.c ****   uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 459:Lib/uip/uip.c **** 
 460:Lib/uip/uip.c ****   return conn;
 461:Lib/uip/uip.c **** }
 462:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 463:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 464:Lib/uip/uip.c **** #if UIP_UDP
 465:Lib/uip/uip.c **** struct uip_udp_conn *
 466:Lib/uip/uip.c **** uip_udp_new(const uip_ipaddr_t *ripaddr, u16_t rport)
 467:Lib/uip/uip.c **** {
 468:Lib/uip/uip.c ****   register struct uip_udp_conn *conn;
 469:Lib/uip/uip.c **** 
 470:Lib/uip/uip.c ****   /* Find an unused local port. */
 471:Lib/uip/uip.c ****  again:
 472:Lib/uip/uip.c ****   ++lastport;
 473:Lib/uip/uip.c **** 
 474:Lib/uip/uip.c ****   if(lastport >= 32000) {
 475:Lib/uip/uip.c ****     lastport = 4096;
 476:Lib/uip/uip.c ****   }
 477:Lib/uip/uip.c **** 
 478:Lib/uip/uip.c ****   for(c = 0; c < UIP_UDP_CONNS; ++c) {
 479:Lib/uip/uip.c ****     if(uip_udp_conns[c].lport == htons(lastport)) {
 480:Lib/uip/uip.c ****       goto again;
 481:Lib/uip/uip.c ****     }
 482:Lib/uip/uip.c ****   }
 483:Lib/uip/uip.c **** 
 484:Lib/uip/uip.c **** 
 485:Lib/uip/uip.c ****   conn = 0;
 486:Lib/uip/uip.c ****   for(c = 0; c < UIP_UDP_CONNS; ++c) {
 487:Lib/uip/uip.c ****     if(uip_udp_conns[c].lport == 0) {
 488:Lib/uip/uip.c ****       conn = &uip_udp_conns[c];
 489:Lib/uip/uip.c ****       break;
 490:Lib/uip/uip.c ****     }
 491:Lib/uip/uip.c ****   }
 492:Lib/uip/uip.c **** 
 493:Lib/uip/uip.c ****   if(conn == 0) {
 494:Lib/uip/uip.c ****     return 0;
 495:Lib/uip/uip.c ****   }
 496:Lib/uip/uip.c **** 
 497:Lib/uip/uip.c ****   conn->lport = HTONS(lastport);
 498:Lib/uip/uip.c ****   conn->rport = rport;
 499:Lib/uip/uip.c ****   if(ripaddr == NULL) {
 500:Lib/uip/uip.c ****     memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
 501:Lib/uip/uip.c ****   } else {
 502:Lib/uip/uip.c ****     uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 503:Lib/uip/uip.c ****   }
 504:Lib/uip/uip.c ****   conn->ttl = UIP_TTL;
 505:Lib/uip/uip.c **** 
 506:Lib/uip/uip.c ****   return conn;
 507:Lib/uip/uip.c **** }
 508:Lib/uip/uip.c **** #endif /* UIP_UDP */
 509:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 510:Lib/uip/uip.c **** void
 511:Lib/uip/uip.c **** uip_unlisten(u16_t port)
 512:Lib/uip/uip.c **** {
 513:Lib/uip/uip.c ****   for(c = 0; c < UIP_LISTENPORTS; ++c) {
 514:Lib/uip/uip.c ****     if(uip_listenports[c] == port) {
 515:Lib/uip/uip.c ****       uip_listenports[c] = 0;
 516:Lib/uip/uip.c ****       return;
 517:Lib/uip/uip.c ****     }
 518:Lib/uip/uip.c ****   }
 519:Lib/uip/uip.c **** }
 520:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 521:Lib/uip/uip.c **** void
 522:Lib/uip/uip.c **** uip_listen(u16_t port)
 523:Lib/uip/uip.c **** {
 524:Lib/uip/uip.c ****   for(c = 0; c < UIP_LISTENPORTS; ++c) {
 525:Lib/uip/uip.c ****     if(uip_listenports[c] == 0) {
 526:Lib/uip/uip.c ****       uip_listenports[c] = port;
 527:Lib/uip/uip.c ****       return;
 528:Lib/uip/uip.c ****     }
 529:Lib/uip/uip.c ****   }
 530:Lib/uip/uip.c **** }
 531:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 532:Lib/uip/uip.c **** /* XXX: IP fragment reassembly: not well-tested. */
 533:Lib/uip/uip.c **** 
 534:Lib/uip/uip.c **** #if UIP_REASSEMBLY && !UIP_CONF_IPV6
 535:Lib/uip/uip.c **** #define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
 536:Lib/uip/uip.c **** static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
 537:Lib/uip/uip.c **** static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
 538:Lib/uip/uip.c **** static const u8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
 539:Lib/uip/uip.c **** 				    0x0f, 0x07, 0x03, 0x01};
 540:Lib/uip/uip.c **** static u16_t uip_reasslen;
 541:Lib/uip/uip.c **** static u8_t uip_reassflags;
 542:Lib/uip/uip.c **** #define UIP_REASS_FLAG_LASTFRAG 0x01
 543:Lib/uip/uip.c **** static u8_t uip_reasstmr;
 544:Lib/uip/uip.c **** 
 545:Lib/uip/uip.c **** #define IP_MF   0x20
 546:Lib/uip/uip.c **** 
 547:Lib/uip/uip.c **** static u8_t
 548:Lib/uip/uip.c **** uip_reass(void)
 549:Lib/uip/uip.c **** {
 550:Lib/uip/uip.c ****   u16_t offset, len;
 551:Lib/uip/uip.c ****   u16_t i;
 552:Lib/uip/uip.c **** 
 553:Lib/uip/uip.c ****   /* If ip_reasstmr is zero, no packet is present in the buffer, so we
 554:Lib/uip/uip.c ****      write the IP header of the fragment into the reassembly
 555:Lib/uip/uip.c ****      buffer. The timer is updated with the maximum age. */
 556:Lib/uip/uip.c ****   if(uip_reasstmr == 0) {
 557:Lib/uip/uip.c ****     memcpy(uip_reassbuf, &BUF->vhl, UIP_IPH_LEN);
 558:Lib/uip/uip.c ****     uip_reasstmr = UIP_REASS_MAXAGE;
 559:Lib/uip/uip.c ****     uip_reassflags = 0;
 560:Lib/uip/uip.c ****     /* Clear the bitmap. */
 561:Lib/uip/uip.c ****     memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
 562:Lib/uip/uip.c ****   }
 563:Lib/uip/uip.c **** 
 564:Lib/uip/uip.c ****   /* Check if the incoming fragment matches the one currently present
 565:Lib/uip/uip.c ****      in the reasembly buffer. If so, we proceed with copying the
 566:Lib/uip/uip.c ****      fragment into the buffer. */
 567:Lib/uip/uip.c ****   if(BUF->srcipaddr[0] == FBUF->srcipaddr[0] &&
 568:Lib/uip/uip.c ****      BUF->srcipaddr[1] == FBUF->srcipaddr[1] &&
 569:Lib/uip/uip.c ****      BUF->destipaddr[0] == FBUF->destipaddr[0] &&
 570:Lib/uip/uip.c ****      BUF->destipaddr[1] == FBUF->destipaddr[1] &&
 571:Lib/uip/uip.c ****      BUF->ipid[0] == FBUF->ipid[0] &&
 572:Lib/uip/uip.c ****      BUF->ipid[1] == FBUF->ipid[1]) {
 573:Lib/uip/uip.c **** 
 574:Lib/uip/uip.c ****     len = (BUF->len[0] << 8) + BUF->len[1] - (BUF->vhl & 0x0f) * 4;
 575:Lib/uip/uip.c ****     offset = (((BUF->ipoffset[0] & 0x3f) << 8) + BUF->ipoffset[1]) * 8;
 576:Lib/uip/uip.c **** 
 577:Lib/uip/uip.c ****     /* If the offset or the offset + fragment length overflows the
 578:Lib/uip/uip.c ****        reassembly buffer, we discard the entire packet. */
 579:Lib/uip/uip.c ****     if(offset > UIP_REASS_BUFSIZE ||
 580:Lib/uip/uip.c ****        offset + len > UIP_REASS_BUFSIZE) {
 581:Lib/uip/uip.c ****       uip_reasstmr = 0;
 582:Lib/uip/uip.c ****       goto nullreturn;
 583:Lib/uip/uip.c ****     }
 584:Lib/uip/uip.c **** 
 585:Lib/uip/uip.c ****     /* Copy the fragment into the reassembly buffer, at the right
 586:Lib/uip/uip.c ****        offset. */
 587:Lib/uip/uip.c ****     memcpy(&uip_reassbuf[UIP_IPH_LEN + offset],
 588:Lib/uip/uip.c **** 	   (char *)BUF + (int)((BUF->vhl & 0x0f) * 4),
 589:Lib/uip/uip.c **** 	   len);
 590:Lib/uip/uip.c **** 
 591:Lib/uip/uip.c ****     /* Update the bitmap. */
 592:Lib/uip/uip.c ****     if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
 593:Lib/uip/uip.c ****       /* If the two endpoints are in the same byte, we only update
 594:Lib/uip/uip.c **** 	 that byte. */
 595:Lib/uip/uip.c **** 
 596:Lib/uip/uip.c ****       uip_reassbitmap[offset / (8 * 8)] |=
 597:Lib/uip/uip.c **** 	     bitmap_bits[(offset / 8 ) & 7] &
 598:Lib/uip/uip.c **** 	     ~bitmap_bits[((offset + len) / 8 ) & 7];
 599:Lib/uip/uip.c ****     } else {
 600:Lib/uip/uip.c ****       /* If the two endpoints are in different bytes, we update the
 601:Lib/uip/uip.c **** 	 bytes in the endpoints and fill the stuff in-between with
 602:Lib/uip/uip.c **** 	 0xff. */
 603:Lib/uip/uip.c ****       uip_reassbitmap[offset / (8 * 8)] |=
 604:Lib/uip/uip.c **** 	bitmap_bits[(offset / 8 ) & 7];
 605:Lib/uip/uip.c ****       for(i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
 606:Lib/uip/uip.c **** 	uip_reassbitmap[i] = 0xff;
 607:Lib/uip/uip.c ****       }
 608:Lib/uip/uip.c ****       uip_reassbitmap[(offset + len) / (8 * 8)] |=
 609:Lib/uip/uip.c **** 	~bitmap_bits[((offset + len) / 8 ) & 7];
 610:Lib/uip/uip.c ****     }
 611:Lib/uip/uip.c **** 
 612:Lib/uip/uip.c ****     /* If this fragment has the More Fragments flag set to zero, we
 613:Lib/uip/uip.c ****        know that this is the last fragment, so we can calculate the
 614:Lib/uip/uip.c ****        size of the entire packet. We also set the
 615:Lib/uip/uip.c ****        IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
 616:Lib/uip/uip.c ****        the final fragment. */
 617:Lib/uip/uip.c **** 
 618:Lib/uip/uip.c ****     if((BUF->ipoffset[0] & IP_MF) == 0) {
 619:Lib/uip/uip.c ****       uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
 620:Lib/uip/uip.c ****       uip_reasslen = offset + len;
 621:Lib/uip/uip.c ****     }
 622:Lib/uip/uip.c **** 
 623:Lib/uip/uip.c ****     /* Finally, we check if we have a full packet in the buffer. We do
 624:Lib/uip/uip.c ****        this by checking if we have the last fragment and if all bits
 625:Lib/uip/uip.c ****        in the bitmap are set. */
 626:Lib/uip/uip.c ****     if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
 627:Lib/uip/uip.c ****       /* Check all bytes up to and including all but the last byte in
 628:Lib/uip/uip.c **** 	 the bitmap. */
 629:Lib/uip/uip.c ****       for(i = 0; i < uip_reasslen / (8 * 8) - 1; ++i) {
 630:Lib/uip/uip.c **** 	if(uip_reassbitmap[i] != 0xff) {
 631:Lib/uip/uip.c **** 	  goto nullreturn;
 632:Lib/uip/uip.c **** 	}
 633:Lib/uip/uip.c ****       }
 634:Lib/uip/uip.c ****       /* Check the last byte in the bitmap. It should contain just the
 635:Lib/uip/uip.c **** 	 right amount of bits. */
 636:Lib/uip/uip.c ****       if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
 637:Lib/uip/uip.c **** 	 (u8_t)~bitmap_bits[uip_reasslen / 8 & 7]) {
 638:Lib/uip/uip.c **** 	goto nullreturn;
 639:Lib/uip/uip.c ****       }
 640:Lib/uip/uip.c **** 
 641:Lib/uip/uip.c ****       /* If we have come this far, we have a full packet in the
 642:Lib/uip/uip.c **** 	 buffer, so we allocate a pbuf and copy the packet into it. We
 643:Lib/uip/uip.c **** 	 also reset the timer. */
 644:Lib/uip/uip.c ****       uip_reasstmr = 0;
 645:Lib/uip/uip.c ****       memcpy(BUF, FBUF, uip_reasslen);
 646:Lib/uip/uip.c **** 
 647:Lib/uip/uip.c ****       /* Pretend to be a "normal" (i.e., not fragmented) IP packet
 648:Lib/uip/uip.c **** 	 from now on. */
 649:Lib/uip/uip.c ****       BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
 650:Lib/uip/uip.c ****       BUF->len[0] = uip_reasslen >> 8;
 651:Lib/uip/uip.c ****       BUF->len[1] = uip_reasslen & 0xff;
 652:Lib/uip/uip.c ****       BUF->ipchksum = 0;
 653:Lib/uip/uip.c ****       BUF->ipchksum = ~(uip_ipchksum());
 654:Lib/uip/uip.c **** 
 655:Lib/uip/uip.c ****       return uip_reasslen;
 656:Lib/uip/uip.c ****     }
 657:Lib/uip/uip.c ****   }
 658:Lib/uip/uip.c **** 
 659:Lib/uip/uip.c ****  nullreturn:
 660:Lib/uip/uip.c ****   return 0;
 661:Lib/uip/uip.c **** }
 662:Lib/uip/uip.c **** #endif /* UIP_REASSEMBLY */
 663:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 664:Lib/uip/uip.c **** static void
 665:Lib/uip/uip.c **** uip_add_rcv_nxt(u16_t n)
 666:Lib/uip/uip.c **** {
 191               		.loc 1 666 0
 192               		.cfi_startproc
 193               	.LVL17:
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
 667:Lib/uip/uip.c ****   uip_add32(uip_conn->rcv_nxt, n);
 198               		.loc 1 667 0
 199 0000 2091 0000 		lds r18,uip_conn
 200 0004 3091 0000 		lds r19,uip_conn+1
 201 0008 BC01      		movw r22,r24
 202 000a C901      		movw r24,r18
 203               	.LVL18:
 204 000c 0896      		adiw r24,8
 205 000e 0E94 0000 		call uip_add32
 206               	.LVL19:
 668:Lib/uip/uip.c ****   uip_conn->rcv_nxt[0] = uip_acc32[0];
 207               		.loc 1 668 0
 208 0012 E091 0000 		lds r30,uip_conn
 209 0016 F091 0000 		lds r31,uip_conn+1
 210 001a A0E0      		ldi r26,lo8(uip_acc32)
 211 001c B0E0      		ldi r27,hi8(uip_acc32)
 212 001e 8C91      		ld r24,X
 213 0020 8087      		std Z+8,r24
 669:Lib/uip/uip.c ****   uip_conn->rcv_nxt[1] = uip_acc32[1];
 214               		.loc 1 669 0
 215 0022 1196      		adiw r26,1
 216 0024 8C91      		ld r24,X
 217 0026 1197      		sbiw r26,1
 218 0028 8187      		std Z+9,r24
 670:Lib/uip/uip.c ****   uip_conn->rcv_nxt[2] = uip_acc32[2];
 219               		.loc 1 670 0
 220 002a 1296      		adiw r26,2
 221 002c 8C91      		ld r24,X
 222 002e 1297      		sbiw r26,2
 223 0030 8287      		std Z+10,r24
 671:Lib/uip/uip.c ****   uip_conn->rcv_nxt[3] = uip_acc32[3];
 224               		.loc 1 671 0
 225 0032 1396      		adiw r26,3
 226 0034 8C91      		ld r24,X
 227 0036 8387      		std Z+11,r24
 228 0038 0895      		ret
 229               		.cfi_endproc
 230               	.LFE17:
 232               		.section	.text.uip_chksum,"ax",@progbits
 233               	.global	uip_chksum
 235               	uip_chksum:
 236               	.LFB8:
 305:Lib/uip/uip.c ****   return htons(chksum(0, (u8_t *)data, len));
 237               		.loc 1 305 0
 238               		.cfi_startproc
 239               	.LVL20:
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
 244 0000 AB01      		movw r20,r22
 306:Lib/uip/uip.c **** }
 245               		.loc 1 306 0
 246 0002 BC01      		movw r22,r24
 247               	.LVL21:
 248 0004 80E0      		ldi r24,0
 249 0006 90E0      		ldi r25,0
 250               	.LVL22:
 251 0008 0E94 0000 		call chksum
 252               	.LVL23:
 307:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 253               		.loc 1 307 0
 254 000c 9827      		eor r25,r24
 255 000e 8927      		eor r24,r25
 256 0010 9827      		eor r25,r24
 257 0012 0895      		ret
 258               		.cfi_endproc
 259               	.LFE8:
 261               		.section	.text.uip_ipchksum,"ax",@progbits
 262               	.global	uip_ipchksum
 264               	uip_ipchksum:
 265               	.LFB9:
 312:Lib/uip/uip.c ****   u16_t sum;
 266               		.loc 1 312 0
 267               		.cfi_startproc
 268               	/* prologue: function */
 269               	/* frame size = 0 */
 270               	/* stack size = 0 */
 271               	.L__stack_usage = 0
 315:Lib/uip/uip.c ****   DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
 272               		.loc 1 315 0
 273 0000 44E1      		ldi r20,lo8(20)
 274 0002 50E0      		ldi r21,0
 275 0004 60E0      		ldi r22,lo8(uip_buf+14)
 276 0006 70E0      		ldi r23,hi8(uip_buf+14)
 277 0008 80E0      		ldi r24,0
 278 000a 90E0      		ldi r25,0
 279 000c 0E94 0000 		call chksum
 280               	.LVL24:
 317:Lib/uip/uip.c **** }
 281               		.loc 1 317 0
 282 0010 0097      		sbiw r24,0
 283 0012 01F0      		breq .L20
 284               	.LVL25:
 285               	.LBB6:
 286               	.LBB7:
 672:Lib/uip/uip.c **** }
 673:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 674:Lib/uip/uip.c **** void
 675:Lib/uip/uip.c **** uip_process(u8_t flag)
 676:Lib/uip/uip.c **** {
 677:Lib/uip/uip.c ****   register struct uip_conn *uip_connr = uip_conn;
 678:Lib/uip/uip.c **** 
 679:Lib/uip/uip.c **** #if UIP_UDP
 680:Lib/uip/uip.c ****   if(flag == UIP_UDP_SEND_CONN) {
 681:Lib/uip/uip.c ****     goto udp_send;
 682:Lib/uip/uip.c ****   }
 683:Lib/uip/uip.c **** #endif /* UIP_UDP */
 684:Lib/uip/uip.c **** 
 685:Lib/uip/uip.c ****   uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
 686:Lib/uip/uip.c **** 
 687:Lib/uip/uip.c ****   /* Check if we were invoked because of a poll request for a
 688:Lib/uip/uip.c ****      particular connection. */
 689:Lib/uip/uip.c ****   if(flag == UIP_POLL_REQUEST) {
 690:Lib/uip/uip.c ****     if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
 691:Lib/uip/uip.c ****        !uip_outstanding(uip_connr)) {
 692:Lib/uip/uip.c **** 	uip_len = uip_slen = 0;
 693:Lib/uip/uip.c **** 	uip_flags = UIP_POLL;
 694:Lib/uip/uip.c **** 	UIP_APPCALL();
 695:Lib/uip/uip.c **** 	goto appsend;
 696:Lib/uip/uip.c ****     }
 697:Lib/uip/uip.c ****     goto drop;
 698:Lib/uip/uip.c **** 
 699:Lib/uip/uip.c ****     /* Check if we were invoked because of the periodic timer firing. */
 700:Lib/uip/uip.c ****   } else if(flag == UIP_TIMER) {
 701:Lib/uip/uip.c **** #if UIP_REASSEMBLY
 702:Lib/uip/uip.c ****     if(uip_reasstmr != 0) {
 703:Lib/uip/uip.c ****       --uip_reasstmr;
 704:Lib/uip/uip.c ****     }
 705:Lib/uip/uip.c **** #endif /* UIP_REASSEMBLY */
 706:Lib/uip/uip.c ****     /* Increase the initial sequence number. */
 707:Lib/uip/uip.c ****     if(++iss[3] == 0) {
 708:Lib/uip/uip.c ****       if(++iss[2] == 0) {
 709:Lib/uip/uip.c **** 	if(++iss[1] == 0) {
 710:Lib/uip/uip.c **** 	  ++iss[0];
 711:Lib/uip/uip.c **** 	}
 712:Lib/uip/uip.c ****       }
 713:Lib/uip/uip.c ****     }
 714:Lib/uip/uip.c **** 
 715:Lib/uip/uip.c ****     /* Reset the length variables. */
 716:Lib/uip/uip.c ****     uip_len = 0;
 717:Lib/uip/uip.c ****     uip_slen = 0;
 718:Lib/uip/uip.c **** 
 719:Lib/uip/uip.c ****     /* Check if the connection is in a state in which we simply wait
 720:Lib/uip/uip.c ****        for the connection to time out. If so, we increase the
 721:Lib/uip/uip.c ****        connection's timer and remove the connection if it times
 722:Lib/uip/uip.c ****        out. */
 723:Lib/uip/uip.c ****     if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
 724:Lib/uip/uip.c ****        uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
 725:Lib/uip/uip.c ****       ++(uip_connr->timer);
 726:Lib/uip/uip.c ****       if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 727:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_CLOSED;
 728:Lib/uip/uip.c ****       }
 729:Lib/uip/uip.c ****     } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
 730:Lib/uip/uip.c ****       /* If the connection has outstanding data, we increase the
 731:Lib/uip/uip.c **** 	 connection's timer and see if it has reached the RTO value
 732:Lib/uip/uip.c **** 	 in which case we retransmit. */
 733:Lib/uip/uip.c ****       if(uip_outstanding(uip_connr)) {
 734:Lib/uip/uip.c **** 	if(uip_connr->timer-- == 0) {
 735:Lib/uip/uip.c **** 	  if(uip_connr->nrtx == UIP_MAXRTX ||
 736:Lib/uip/uip.c **** 	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
 737:Lib/uip/uip.c **** 	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
 738:Lib/uip/uip.c **** 	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
 739:Lib/uip/uip.c **** 	    uip_connr->tcpstateflags = UIP_CLOSED;
 740:Lib/uip/uip.c **** 
 741:Lib/uip/uip.c **** 	    /* We call UIP_APPCALL() with uip_flags set to
 742:Lib/uip/uip.c **** 	       UIP_TIMEDOUT to inform the application that the
 743:Lib/uip/uip.c **** 	       connection has timed out. */
 744:Lib/uip/uip.c **** 	    uip_flags = UIP_TIMEDOUT;
 745:Lib/uip/uip.c **** 	    UIP_APPCALL();
 746:Lib/uip/uip.c **** 
 747:Lib/uip/uip.c **** 	    /* We also send a reset packet to the remote host. */
 748:Lib/uip/uip.c **** 	    BUF->flags = TCP_RST | TCP_ACK;
 749:Lib/uip/uip.c **** 	    goto tcp_send_nodata;
 750:Lib/uip/uip.c **** 	  }
 751:Lib/uip/uip.c **** 
 752:Lib/uip/uip.c **** 	  /* Exponential back-off. */
 753:Lib/uip/uip.c **** 	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
 754:Lib/uip/uip.c **** 					 4:
 755:Lib/uip/uip.c **** 					 uip_connr->nrtx);
 756:Lib/uip/uip.c **** 	  ++(uip_connr->nrtx);
 757:Lib/uip/uip.c **** 
 758:Lib/uip/uip.c **** 	  /* Ok, so we need to retransmit. We do this differently
 759:Lib/uip/uip.c **** 	     depending on which state we are in. In ESTABLISHED, we
 760:Lib/uip/uip.c **** 	     call upon the application so that it may prepare the
 761:Lib/uip/uip.c **** 	     data for the retransmit. In SYN_RCVD, we resend the
 762:Lib/uip/uip.c **** 	     SYNACK that we sent earlier and in LAST_ACK we have to
 763:Lib/uip/uip.c **** 	     retransmit our FINACK. */
 764:Lib/uip/uip.c **** 	  UIP_STAT(++uip_stat.tcp.rexmit);
 765:Lib/uip/uip.c **** 	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
 766:Lib/uip/uip.c **** 	  case UIP_SYN_RCVD:
 767:Lib/uip/uip.c **** 	    /* In the SYN_RCVD state, we should retransmit our
 768:Lib/uip/uip.c ****                SYNACK. */
 769:Lib/uip/uip.c **** 	    goto tcp_send_synack;
 770:Lib/uip/uip.c **** 
 771:Lib/uip/uip.c **** #if UIP_ACTIVE_OPEN
 772:Lib/uip/uip.c **** 	  case UIP_SYN_SENT:
 773:Lib/uip/uip.c **** 	    /* In the SYN_SENT state, we retransmit out SYN. */
 774:Lib/uip/uip.c **** 	    BUF->flags = 0;
 775:Lib/uip/uip.c **** 	    goto tcp_send_syn;
 776:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 777:Lib/uip/uip.c **** 
 778:Lib/uip/uip.c **** 	  case UIP_ESTABLISHED:
 779:Lib/uip/uip.c **** 	    /* In the ESTABLISHED state, we call upon the application
 780:Lib/uip/uip.c ****                to do the actual retransmit after which we jump into
 781:Lib/uip/uip.c ****                the code for sending out the packet (the apprexmit
 782:Lib/uip/uip.c ****                label). */
 783:Lib/uip/uip.c **** 	    uip_flags = UIP_REXMIT;
 784:Lib/uip/uip.c **** 	    UIP_APPCALL();
 785:Lib/uip/uip.c **** 	    goto apprexmit;
 786:Lib/uip/uip.c **** 
 787:Lib/uip/uip.c **** 	  case UIP_FIN_WAIT_1:
 788:Lib/uip/uip.c **** 	  case UIP_CLOSING:
 789:Lib/uip/uip.c **** 	  case UIP_LAST_ACK:
 790:Lib/uip/uip.c **** 	    /* In all these states we should retransmit a FINACK. */
 791:Lib/uip/uip.c **** 	    goto tcp_send_finack;
 792:Lib/uip/uip.c **** 
 793:Lib/uip/uip.c **** 	  }
 794:Lib/uip/uip.c **** 	}
 795:Lib/uip/uip.c ****       } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
 796:Lib/uip/uip.c **** 	/* If there was no need for a retransmission, we poll the
 797:Lib/uip/uip.c ****            application for new data. */
 798:Lib/uip/uip.c **** 	uip_len = uip_slen = 0;
 799:Lib/uip/uip.c **** 	uip_flags = UIP_POLL;
 800:Lib/uip/uip.c **** 	UIP_APPCALL();
 801:Lib/uip/uip.c **** 	goto appsend;
 802:Lib/uip/uip.c ****       }
 803:Lib/uip/uip.c ****     }
 804:Lib/uip/uip.c ****     goto drop;
 805:Lib/uip/uip.c ****   }
 806:Lib/uip/uip.c **** #if UIP_UDP
 807:Lib/uip/uip.c ****   if(flag == UIP_UDP_TIMER) {
 808:Lib/uip/uip.c ****     if(uip_udp_conn->lport != 0) {
 809:Lib/uip/uip.c ****       uip_conn = NULL;
 810:Lib/uip/uip.c ****       uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 811:Lib/uip/uip.c ****       uip_len = uip_slen = 0;
 812:Lib/uip/uip.c ****       uip_flags = UIP_POLL;
 813:Lib/uip/uip.c ****       UIP_UDP_APPCALL();
 814:Lib/uip/uip.c ****       goto udp_send;
 815:Lib/uip/uip.c ****     } else {
 816:Lib/uip/uip.c ****       goto drop;
 817:Lib/uip/uip.c ****     }
 818:Lib/uip/uip.c ****   }
 819:Lib/uip/uip.c **** #endif
 820:Lib/uip/uip.c **** 
 821:Lib/uip/uip.c ****   /* This is where the input processing starts. */
 822:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.ip.recv);
 823:Lib/uip/uip.c **** 
 824:Lib/uip/uip.c ****   /* Start of IP input header processing code. */
 825:Lib/uip/uip.c **** 
 826:Lib/uip/uip.c **** #if UIP_CONF_IPV6
 827:Lib/uip/uip.c ****   /* Check validity of the IP header. */
 828:Lib/uip/uip.c ****   if((BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
 829:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.drop);
 830:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.vhlerr);
 831:Lib/uip/uip.c ****     UIP_LOG("ipv6: invalid version.");
 832:Lib/uip/uip.c ****     goto drop;
 833:Lib/uip/uip.c ****   }
 834:Lib/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 835:Lib/uip/uip.c ****   /* Check validity of the IP header. */
 836:Lib/uip/uip.c ****   if(BUF->vhl != 0x45)  { /* IP version and header length. */
 837:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.drop);
 838:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.vhlerr);
 839:Lib/uip/uip.c ****     UIP_LOG("ip: invalid version or header length.");
 840:Lib/uip/uip.c ****     goto drop;
 841:Lib/uip/uip.c ****   }
 842:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 843:Lib/uip/uip.c **** 
 844:Lib/uip/uip.c ****   /* Check the size of the packet. If the size reported to us in
 845:Lib/uip/uip.c ****      uip_len is smaller the size reported in the IP header, we assume
 846:Lib/uip/uip.c ****      that the packet has been corrupted in transit. If the size of
 847:Lib/uip/uip.c ****      uip_len is larger than the size reported in the IP packet header,
 848:Lib/uip/uip.c ****      the packet has been padded and we set uip_len to the correct
 849:Lib/uip/uip.c ****      value.. */
 850:Lib/uip/uip.c **** 
 851:Lib/uip/uip.c ****   if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
 852:Lib/uip/uip.c ****     uip_len = (BUF->len[0] << 8) + BUF->len[1];
 853:Lib/uip/uip.c **** #if UIP_CONF_IPV6
 854:Lib/uip/uip.c ****     uip_len += 40; /* The length reported in the IPv6 header is the
 855:Lib/uip/uip.c **** 		      length of the payload that follows the
 856:Lib/uip/uip.c **** 		      header. However, uIP uses the uip_len variable
 857:Lib/uip/uip.c **** 		      for holding the size of the entire packet,
 858:Lib/uip/uip.c **** 		      including the IP header. For IPv4 this is not a
 859:Lib/uip/uip.c **** 		      problem as the length field in the IPv4 header
 860:Lib/uip/uip.c **** 		      contains the length of the entire packet. But
 861:Lib/uip/uip.c **** 		      for IPv6 we need to add the size of the IPv6
 862:Lib/uip/uip.c **** 		      header (40 bytes). */
 863:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 864:Lib/uip/uip.c ****   } else {
 865:Lib/uip/uip.c ****     UIP_LOG("ip: packet shorter than reported in IP header.");
 866:Lib/uip/uip.c ****     goto drop;
 867:Lib/uip/uip.c ****   }
 868:Lib/uip/uip.c **** 
 869:Lib/uip/uip.c **** #if !UIP_CONF_IPV6
 870:Lib/uip/uip.c ****   /* Check the fragment flag. */
 871:Lib/uip/uip.c ****   if((BUF->ipoffset[0] & 0x3f) != 0 ||
 872:Lib/uip/uip.c ****      BUF->ipoffset[1] != 0) {
 873:Lib/uip/uip.c **** #if UIP_REASSEMBLY
 874:Lib/uip/uip.c ****     uip_len = uip_reass();
 875:Lib/uip/uip.c ****     if(uip_len == 0) {
 876:Lib/uip/uip.c ****       goto drop;
 877:Lib/uip/uip.c ****     }
 878:Lib/uip/uip.c **** #else /* UIP_REASSEMBLY */
 879:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.drop);
 880:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.fragerr);
 881:Lib/uip/uip.c ****     UIP_LOG("ip: fragment dropped.");
 882:Lib/uip/uip.c ****     goto drop;
 883:Lib/uip/uip.c **** #endif /* UIP_REASSEMBLY */
 884:Lib/uip/uip.c ****   }
 885:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 886:Lib/uip/uip.c **** 
 887:Lib/uip/uip.c ****   if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
 888:Lib/uip/uip.c ****     /* If we are configured to use ping IP address configuration and
 889:Lib/uip/uip.c ****        hasn't been assigned an IP address yet, we accept all ICMP
 890:Lib/uip/uip.c ****        packets. */
 891:Lib/uip/uip.c **** #if UIP_PINGADDRCONF && !UIP_CONF_IPV6
 892:Lib/uip/uip.c ****     if(BUF->proto == UIP_PROTO_ICMP) {
 893:Lib/uip/uip.c ****       UIP_LOG("ip: possible ping config packet received.");
 894:Lib/uip/uip.c ****       goto icmp_input;
 895:Lib/uip/uip.c ****     } else {
 896:Lib/uip/uip.c ****       UIP_LOG("ip: packet dropped since no address assigned.");
 897:Lib/uip/uip.c ****       goto drop;
 898:Lib/uip/uip.c ****     }
 899:Lib/uip/uip.c **** #endif /* UIP_PINGADDRCONF */
 900:Lib/uip/uip.c **** 
 901:Lib/uip/uip.c ****   } else {
 902:Lib/uip/uip.c ****     /* If IP broadcast support is configured, we check for a broadcast
 903:Lib/uip/uip.c ****        UDP packet, which may be destined to us. */
 904:Lib/uip/uip.c **** #if UIP_BROADCAST
 905:Lib/uip/uip.c ****     DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
 906:Lib/uip/uip.c ****     if(BUF->proto == UIP_PROTO_UDP &&
 907:Lib/uip/uip.c ****        uip_ipaddr_cmp(&BUF->destipaddr, &uip_broadcast_addr))
 908:Lib/uip/uip.c **** 	{
 909:Lib/uip/uip.c **** 		if (uip_ipaddr_cmp(&BUF->srcipaddr, &uip_all_zeroes_addr))
 910:Lib/uip/uip.c **** 		  uip_ipaddr_copy(&BUF->srcipaddr, &uip_broadcast_addr);
 911:Lib/uip/uip.c **** 
 912:Lib/uip/uip.c **** 		goto udp_input;
 913:Lib/uip/uip.c ****     }
 914:Lib/uip/uip.c **** #endif /* UIP_BROADCAST */
 915:Lib/uip/uip.c **** 
 916:Lib/uip/uip.c ****     /* Check if the packet is destined for our IP address. */
 917:Lib/uip/uip.c **** #if !UIP_CONF_IPV6
 918:Lib/uip/uip.c ****     if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
 919:Lib/uip/uip.c ****       UIP_STAT(++uip_stat.ip.drop);
 920:Lib/uip/uip.c ****       goto drop;
 921:Lib/uip/uip.c ****     }
 922:Lib/uip/uip.c **** #else /* UIP_CONF_IPV6 */
 923:Lib/uip/uip.c ****     /* For IPv6, packet reception is a little trickier as we need to
 924:Lib/uip/uip.c ****        make sure that we listen to certain multicast addresses (all
 925:Lib/uip/uip.c ****        hosts multicast address, and the solicited-node multicast
 926:Lib/uip/uip.c ****        address) as well. However, we will cheat here and accept all
 927:Lib/uip/uip.c ****        multicast packets that are sent to the ff02::/16 addresses. */
 928:Lib/uip/uip.c ****     if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr) &&
 929:Lib/uip/uip.c ****        BUF->destipaddr.u16[0] != HTONS(0xff02)) {
 930:Lib/uip/uip.c ****       UIP_STAT(++uip_stat.ip.drop);
 931:Lib/uip/uip.c ****       goto drop;
 932:Lib/uip/uip.c ****     }
 933:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 934:Lib/uip/uip.c ****   }
 935:Lib/uip/uip.c **** 
 936:Lib/uip/uip.c **** #if !UIP_CONF_IPV6
 937:Lib/uip/uip.c ****   if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
 938:Lib/uip/uip.c **** 				    checksum. */
 939:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.drop);
 940:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.chkerr);
 941:Lib/uip/uip.c ****     UIP_LOG("ip: bad checksum.");
 942:Lib/uip/uip.c ****     goto drop;
 943:Lib/uip/uip.c ****   }
 944:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 945:Lib/uip/uip.c **** 
 946:Lib/uip/uip.c ****   if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
 947:Lib/uip/uip.c **** 				       proceed with TCP input
 948:Lib/uip/uip.c **** 				       processing. */
 949:Lib/uip/uip.c ****     goto tcp_input;
 950:Lib/uip/uip.c ****   }
 951:Lib/uip/uip.c **** 
 952:Lib/uip/uip.c **** #if UIP_UDP
 953:Lib/uip/uip.c ****   if(BUF->proto == UIP_PROTO_UDP) {
 954:Lib/uip/uip.c ****     goto udp_input;
 955:Lib/uip/uip.c ****   }
 956:Lib/uip/uip.c **** #endif /* UIP_UDP */
 957:Lib/uip/uip.c **** 
 958:Lib/uip/uip.c **** #if !UIP_CONF_IPV6
 959:Lib/uip/uip.c ****   /* ICMPv4 processing code follows. */
 960:Lib/uip/uip.c ****   if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
 961:Lib/uip/uip.c **** 					here. */
 962:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.drop);
 963:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.protoerr);
 964:Lib/uip/uip.c ****     UIP_LOG("ip: neither tcp nor icmp.");
 965:Lib/uip/uip.c ****     goto drop;
 966:Lib/uip/uip.c ****   }
 967:Lib/uip/uip.c **** 
 968:Lib/uip/uip.c **** #if UIP_PINGADDRCONF
 969:Lib/uip/uip.c ****  icmp_input:
 970:Lib/uip/uip.c **** #endif /* UIP_PINGADDRCONF */
 971:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.icmp.recv);
 972:Lib/uip/uip.c **** 
 973:Lib/uip/uip.c ****   /* ICMP echo (i.e., ping) processing. This is simple, we only change
 974:Lib/uip/uip.c ****      the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
 975:Lib/uip/uip.c ****      checksum before we return the packet. */
 976:Lib/uip/uip.c ****   if(ICMPBUF->type != ICMP_ECHO) {
 977:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.icmp.drop);
 978:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.icmp.typeerr);
 979:Lib/uip/uip.c ****     UIP_LOG("icmp: not icmp echo.");
 980:Lib/uip/uip.c ****     goto drop;
 981:Lib/uip/uip.c ****   }
 982:Lib/uip/uip.c **** 
 983:Lib/uip/uip.c ****   /* If we are configured to use ping IP address assignment, we use
 984:Lib/uip/uip.c ****      the destination IP address of this ping packet and assign it to
 985:Lib/uip/uip.c ****      yourself. */
 986:Lib/uip/uip.c **** #if UIP_PINGADDRCONF
 987:Lib/uip/uip.c ****   if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
 988:Lib/uip/uip.c ****     uip_hostaddr = BUF->destipaddr;
 989:Lib/uip/uip.c ****   }
 990:Lib/uip/uip.c **** #endif /* UIP_PINGADDRCONF */
 991:Lib/uip/uip.c **** 
 992:Lib/uip/uip.c ****   ICMPBUF->type = ICMP_ECHO_REPLY;
 993:Lib/uip/uip.c **** 
 994:Lib/uip/uip.c ****   if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
 995:Lib/uip/uip.c ****     ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
 996:Lib/uip/uip.c ****   } else {
 997:Lib/uip/uip.c ****     ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
 998:Lib/uip/uip.c ****   }
 999:Lib/uip/uip.c **** 
1000:Lib/uip/uip.c ****   /* Swap IP addresses. */
1001:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
1002:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
1003:Lib/uip/uip.c **** 
1004:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.icmp.sent);
1005:Lib/uip/uip.c ****   BUF->ttl = UIP_TTL;
1006:Lib/uip/uip.c ****   goto ip_send_nolen;
1007:Lib/uip/uip.c **** 
1008:Lib/uip/uip.c ****   /* End of IPv4 input header processing code. */
1009:Lib/uip/uip.c **** #else /* !UIP_CONF_IPV6 */
1010:Lib/uip/uip.c **** 
1011:Lib/uip/uip.c ****   /* This is IPv6 ICMPv6 processing code. */
1012:Lib/uip/uip.c ****   DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);
1013:Lib/uip/uip.c **** 
1014:Lib/uip/uip.c ****   if(BUF->proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
1015:Lib/uip/uip.c **** 					 here. */
1016:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.drop);
1017:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.protoerr);
1018:Lib/uip/uip.c ****     UIP_LOG("ip: neither tcp nor icmp6.");
1019:Lib/uip/uip.c ****     goto drop;
1020:Lib/uip/uip.c ****   }
1021:Lib/uip/uip.c **** 
1022:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.icmp.recv);
1023:Lib/uip/uip.c **** 
1024:Lib/uip/uip.c ****   /* If we get a neighbor solicitation for our address we should send
1025:Lib/uip/uip.c ****      a neighbor advertisement message back. */
1026:Lib/uip/uip.c ****   if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) {
1027:Lib/uip/uip.c ****     if(uip_ipaddr_cmp(&ICMPBUF->icmp6data, &uip_hostaddr)) {
1028:Lib/uip/uip.c **** 
1029:Lib/uip/uip.c ****       if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
1030:Lib/uip/uip.c **** 	/* Save the sender's address in our neighbor list. */
1031:Lib/uip/uip.c **** 	uip_neighbor_add(&ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
1032:Lib/uip/uip.c ****       }
1033:Lib/uip/uip.c **** 
1034:Lib/uip/uip.c ****       /* We should now send a neighbor advertisement back to where the
1035:Lib/uip/uip.c **** 	 neighbor solicitation came from. */
1036:Lib/uip/uip.c ****       ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
1037:Lib/uip/uip.c ****       ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
1038:Lib/uip/uip.c **** 
1039:Lib/uip/uip.c ****       ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
1040:Lib/uip/uip.c **** 
1041:Lib/uip/uip.c ****       uip_ipaddr_copy(&ICMPBUF->destipaddr, &ICMPBUF->srcipaddr);
1042:Lib/uip/uip.c ****       uip_ipaddr_copy(&ICMPBUF->srcipaddr, &uip_hostaddr);
1043:Lib/uip/uip.c ****       ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
1044:Lib/uip/uip.c ****       ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
1045:Lib/uip/uip.c ****       memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
1046:Lib/uip/uip.c ****       ICMPBUF->icmpchksum = 0;
1047:Lib/uip/uip.c ****       ICMPBUF->icmpchksum = ~uip_icmp6chksum();
1048:Lib/uip/uip.c **** 
1049:Lib/uip/uip.c ****       goto send;
1050:Lib/uip/uip.c **** 
1051:Lib/uip/uip.c ****     }
1052:Lib/uip/uip.c ****     goto drop;
1053:Lib/uip/uip.c ****   } else if(ICMPBUF->type == ICMP6_ECHO) {
1054:Lib/uip/uip.c ****     /* ICMP echo (i.e., ping) processing. This is simple, we only
1055:Lib/uip/uip.c ****        change the ICMP type from ECHO to ECHO_REPLY and update the
1056:Lib/uip/uip.c ****        ICMP checksum before we return the packet. */
1057:Lib/uip/uip.c **** 
1058:Lib/uip/uip.c ****     ICMPBUF->type = ICMP6_ECHO_REPLY;
1059:Lib/uip/uip.c **** 
1060:Lib/uip/uip.c ****     uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
1061:Lib/uip/uip.c ****     uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
1062:Lib/uip/uip.c ****     ICMPBUF->icmpchksum = 0;
1063:Lib/uip/uip.c ****     ICMPBUF->icmpchksum = ~uip_icmp6chksum();
1064:Lib/uip/uip.c **** 
1065:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.icmp.sent);
1066:Lib/uip/uip.c ****     goto send;
1067:Lib/uip/uip.c ****   } else {
1068:Lib/uip/uip.c ****     DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
1069:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.icmp.drop);
1070:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.icmp.typeerr);
1071:Lib/uip/uip.c ****     UIP_LOG("icmp: unknown ICMP message.");
1072:Lib/uip/uip.c ****     goto drop;
1073:Lib/uip/uip.c ****   }
1074:Lib/uip/uip.c **** 
1075:Lib/uip/uip.c ****   /* End of IPv6 ICMP processing. */
1076:Lib/uip/uip.c **** 
1077:Lib/uip/uip.c **** #endif /* !UIP_CONF_IPV6 */
1078:Lib/uip/uip.c **** 
1079:Lib/uip/uip.c **** #if UIP_UDP
1080:Lib/uip/uip.c ****   /* UDP input processing. */
1081:Lib/uip/uip.c ****  udp_input:
1082:Lib/uip/uip.c ****   /* UDP processing is really just a hack. We don't do anything to the
1083:Lib/uip/uip.c ****      UDP/IP headers, but let the UDP application do all the hard
1084:Lib/uip/uip.c ****      work. If the application sets uip_slen, it has a packet to
1085:Lib/uip/uip.c ****      send. */
1086:Lib/uip/uip.c **** #if UIP_UDP_CHECKSUMS
1087:Lib/uip/uip.c ****   uip_len = uip_len - UIP_IPUDPH_LEN;
1088:Lib/uip/uip.c ****   uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
1089:Lib/uip/uip.c ****   if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
1090:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.udp.drop);
1091:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.udp.chkerr);
1092:Lib/uip/uip.c ****     UIP_LOG("udp: bad checksum.");
1093:Lib/uip/uip.c ****     goto drop;
1094:Lib/uip/uip.c ****   }
1095:Lib/uip/uip.c **** #else /* UIP_UDP_CHECKSUMS */
1096:Lib/uip/uip.c ****   uip_len = uip_len - UIP_IPUDPH_LEN;
1097:Lib/uip/uip.c **** #endif /* UIP_UDP_CHECKSUMS */
1098:Lib/uip/uip.c **** 
1099:Lib/uip/uip.c ****   /* Demultiplex this UDP packet between the UDP "connections". */
1100:Lib/uip/uip.c ****   for(uip_udp_conn = &uip_udp_conns[0];
1101:Lib/uip/uip.c ****       uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
1102:Lib/uip/uip.c ****       ++uip_udp_conn) {
1103:Lib/uip/uip.c ****     /* If the local UDP port is non-zero, the connection is considered
1104:Lib/uip/uip.c ****        to be used. If so, the local port number is checked against the
1105:Lib/uip/uip.c ****        destination port number in the received packet. If the two port
1106:Lib/uip/uip.c ****        numbers match, the remote port number is checked if the
1107:Lib/uip/uip.c ****        connection is bound to a remote port. Finally, if the
1108:Lib/uip/uip.c ****        connection is bound to a remote IP address, the source IP
1109:Lib/uip/uip.c ****        address of the packet is checked. */
1110:Lib/uip/uip.c ****     if(uip_udp_conn->lport != 0 &&
1111:Lib/uip/uip.c ****        UDPBUF->destport == uip_udp_conn->lport &&
1112:Lib/uip/uip.c ****        (uip_udp_conn->rport == 0 ||
1113:Lib/uip/uip.c ****         UDPBUF->srcport == uip_udp_conn->rport) &&
1114:Lib/uip/uip.c ****        (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
1115:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
1116:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
1117:Lib/uip/uip.c ****       goto udp_found;
1118:Lib/uip/uip.c ****     }
1119:Lib/uip/uip.c ****   }
1120:Lib/uip/uip.c ****   UIP_LOG("udp: no matching connection found");
1121:Lib/uip/uip.c **** #if UIP_CONF_ICMP_DEST_UNREACH && !UIP_CONF_IPV6
1122:Lib/uip/uip.c ****   /* Copy fields from packet header into payload of this ICMP packet. */
1123:Lib/uip/uip.c ****   memcpy(&(ICMPBUF->payload[0]), ICMPBUF, UIP_IPH_LEN + 8);
1124:Lib/uip/uip.c **** 
1125:Lib/uip/uip.c ****   /* Set the ICMP type and code. */
1126:Lib/uip/uip.c ****   ICMPBUF->type = ICMP_DEST_UNREACHABLE;
1127:Lib/uip/uip.c ****   ICMPBUF->icode = ICMP_PORT_UNREACHABLE;
1128:Lib/uip/uip.c **** 
1129:Lib/uip/uip.c ****   /* Calculate the ICMP checksum. */
1130:Lib/uip/uip.c ****   ICMPBUF->icmpchksum = 0;
1131:Lib/uip/uip.c ****   ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
1132:Lib/uip/uip.c **** 
1133:Lib/uip/uip.c ****   /* Set the IP destination address to be the source address of the
1134:Lib/uip/uip.c ****      original packet. */
1135:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
1136:Lib/uip/uip.c **** 
1137:Lib/uip/uip.c ****   /* Set our IP address as the source address. */
1138:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
1139:Lib/uip/uip.c **** 
1140:Lib/uip/uip.c ****   /* The size of the ICMP destination unreachable packet is 36 + the
1141:Lib/uip/uip.c ****      size of the IP header (20) = 56. */
1142:Lib/uip/uip.c ****   uip_len = 36 + UIP_IPH_LEN;
1143:Lib/uip/uip.c ****   ICMPBUF->len[0] = 0;
1144:Lib/uip/uip.c ****   ICMPBUF->len[1] = (u8_t)uip_len;
1145:Lib/uip/uip.c ****   ICMPBUF->ttl = UIP_TTL;
1146:Lib/uip/uip.c ****   ICMPBUF->proto = UIP_PROTO_ICMP;
1147:Lib/uip/uip.c **** 
1148:Lib/uip/uip.c ****   goto ip_send_nolen;
1149:Lib/uip/uip.c **** #else /* UIP_CONF_ICMP_DEST_UNREACH */
1150:Lib/uip/uip.c ****   goto drop;
1151:Lib/uip/uip.c **** #endif /* UIP_CONF_ICMP_DEST_UNREACH */
1152:Lib/uip/uip.c **** 
1153:Lib/uip/uip.c ****  udp_found:
1154:Lib/uip/uip.c ****   uip_conn = NULL;
1155:Lib/uip/uip.c ****   uip_flags = UIP_NEWDATA;
1156:Lib/uip/uip.c ****   uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
1157:Lib/uip/uip.c ****   uip_slen = 0;
1158:Lib/uip/uip.c ****   UIP_UDP_APPCALL();
1159:Lib/uip/uip.c **** 
1160:Lib/uip/uip.c ****  udp_send:
1161:Lib/uip/uip.c ****   if(uip_slen == 0) {
1162:Lib/uip/uip.c ****     goto drop;
1163:Lib/uip/uip.c ****   }
1164:Lib/uip/uip.c ****   uip_len = uip_slen + UIP_IPUDPH_LEN;
1165:Lib/uip/uip.c **** 
1166:Lib/uip/uip.c **** #if UIP_CONF_IPV6
1167:Lib/uip/uip.c ****   /* For IPv6, the IP length field does not include the IPv6 IP header
1168:Lib/uip/uip.c ****      length. */
1169:Lib/uip/uip.c ****   BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
1170:Lib/uip/uip.c ****   BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
1171:Lib/uip/uip.c **** #else /* UIP_CONF_IPV6 */
1172:Lib/uip/uip.c ****   BUF->len[0] = (uip_len >> 8);
1173:Lib/uip/uip.c ****   BUF->len[1] = (uip_len & 0xff);
1174:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
1175:Lib/uip/uip.c **** 
1176:Lib/uip/uip.c ****   BUF->ttl = uip_udp_conn->ttl;
1177:Lib/uip/uip.c ****   BUF->proto = UIP_PROTO_UDP;
1178:Lib/uip/uip.c **** 
1179:Lib/uip/uip.c ****   UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
1180:Lib/uip/uip.c ****   UDPBUF->udpchksum = 0;
1181:Lib/uip/uip.c **** 
1182:Lib/uip/uip.c ****   BUF->srcport  = uip_udp_conn->lport;
1183:Lib/uip/uip.c ****   BUF->destport = uip_udp_conn->rport;
1184:Lib/uip/uip.c **** 
1185:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
1186:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
1187:Lib/uip/uip.c **** 
1188:Lib/uip/uip.c ****   uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
1189:Lib/uip/uip.c **** 
1190:Lib/uip/uip.c **** #if UIP_UDP_CHECKSUMS
1191:Lib/uip/uip.c ****   /* Calculate UDP checksum. */
1192:Lib/uip/uip.c ****   UDPBUF->udpchksum = ~(uip_udpchksum());
1193:Lib/uip/uip.c ****   if(UDPBUF->udpchksum == 0) {
1194:Lib/uip/uip.c ****     UDPBUF->udpchksum = 0xffff;
1195:Lib/uip/uip.c ****   }
1196:Lib/uip/uip.c **** #endif /* UIP_UDP_CHECKSUMS */
1197:Lib/uip/uip.c **** 
1198:Lib/uip/uip.c ****   goto ip_send_nolen;
1199:Lib/uip/uip.c **** #endif /* UIP_UDP */
1200:Lib/uip/uip.c **** 
1201:Lib/uip/uip.c ****   /* TCP input processing. */
1202:Lib/uip/uip.c ****  tcp_input:
1203:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.tcp.recv);
1204:Lib/uip/uip.c **** 
1205:Lib/uip/uip.c ****   /* Start of TCP input header processing code. */
1206:Lib/uip/uip.c **** 
1207:Lib/uip/uip.c ****   if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
1208:Lib/uip/uip.c **** 				       checksum. */
1209:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.tcp.drop);
1210:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.tcp.chkerr);
1211:Lib/uip/uip.c ****     UIP_LOG("tcp: bad checksum.");
1212:Lib/uip/uip.c ****     goto drop;
1213:Lib/uip/uip.c ****   }
1214:Lib/uip/uip.c **** 
1215:Lib/uip/uip.c ****   /* Demultiplex this segment. */
1216:Lib/uip/uip.c ****   /* First check any active connections. */
1217:Lib/uip/uip.c ****   for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
1218:Lib/uip/uip.c ****       ++uip_connr) {
1219:Lib/uip/uip.c ****     if(uip_connr->tcpstateflags != UIP_CLOSED &&
1220:Lib/uip/uip.c ****        BUF->destport == uip_connr->lport &&
1221:Lib/uip/uip.c ****        BUF->srcport == uip_connr->rport &&
1222:Lib/uip/uip.c ****        uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
1223:Lib/uip/uip.c ****       goto found;
1224:Lib/uip/uip.c ****     }
1225:Lib/uip/uip.c ****   }
1226:Lib/uip/uip.c **** 
1227:Lib/uip/uip.c ****   /* If we didn't find and active connection that expected the packet,
1228:Lib/uip/uip.c ****      either this packet is an old duplicate, or this is a SYN packet
1229:Lib/uip/uip.c ****      destined for a connection in LISTEN. If the SYN flag isn't set,
1230:Lib/uip/uip.c ****      it is an old packet and we send a RST. */
1231:Lib/uip/uip.c ****   if((BUF->flags & TCP_CTL) != TCP_SYN) {
1232:Lib/uip/uip.c ****     goto reset;
1233:Lib/uip/uip.c ****   }
1234:Lib/uip/uip.c **** 
1235:Lib/uip/uip.c ****   tmp16 = BUF->destport;
1236:Lib/uip/uip.c ****   /* Next, check listening connections. */
1237:Lib/uip/uip.c ****   for(c = 0; c < UIP_LISTENPORTS; ++c) {
1238:Lib/uip/uip.c ****     if(tmp16 == uip_listenports[c]) {
1239:Lib/uip/uip.c ****       goto found_listen;
1240:Lib/uip/uip.c ****     }
1241:Lib/uip/uip.c ****   }
1242:Lib/uip/uip.c **** 
1243:Lib/uip/uip.c ****   /* No matching connection found, so we send a RST packet. */
1244:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.tcp.synrst);
1245:Lib/uip/uip.c **** 
1246:Lib/uip/uip.c ****  reset:
1247:Lib/uip/uip.c ****   /* We do not send resets in response to resets. */
1248:Lib/uip/uip.c ****   if(BUF->flags & TCP_RST) {
1249:Lib/uip/uip.c ****     goto drop;
1250:Lib/uip/uip.c ****   }
1251:Lib/uip/uip.c **** 
1252:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.tcp.rst);
1253:Lib/uip/uip.c **** 
1254:Lib/uip/uip.c ****   BUF->flags = TCP_RST | TCP_ACK;
1255:Lib/uip/uip.c ****   uip_len = UIP_IPTCPH_LEN;
1256:Lib/uip/uip.c ****   BUF->tcpoffset = 5 << 4;
1257:Lib/uip/uip.c **** 
1258:Lib/uip/uip.c ****   /* Flip the seqno and ackno fields in the TCP header. */
1259:Lib/uip/uip.c ****   c = BUF->seqno[3];
1260:Lib/uip/uip.c ****   BUF->seqno[3] = BUF->ackno[3];
1261:Lib/uip/uip.c ****   BUF->ackno[3] = c;
1262:Lib/uip/uip.c **** 
1263:Lib/uip/uip.c ****   c = BUF->seqno[2];
1264:Lib/uip/uip.c ****   BUF->seqno[2] = BUF->ackno[2];
1265:Lib/uip/uip.c ****   BUF->ackno[2] = c;
1266:Lib/uip/uip.c **** 
1267:Lib/uip/uip.c ****   c = BUF->seqno[1];
1268:Lib/uip/uip.c ****   BUF->seqno[1] = BUF->ackno[1];
1269:Lib/uip/uip.c ****   BUF->ackno[1] = c;
1270:Lib/uip/uip.c **** 
1271:Lib/uip/uip.c ****   c = BUF->seqno[0];
1272:Lib/uip/uip.c ****   BUF->seqno[0] = BUF->ackno[0];
1273:Lib/uip/uip.c ****   BUF->ackno[0] = c;
1274:Lib/uip/uip.c **** 
1275:Lib/uip/uip.c ****   /* We also have to increase the sequence number we are
1276:Lib/uip/uip.c ****      acknowledging. If the least significant byte overflowed, we need
1277:Lib/uip/uip.c ****      to propagate the carry to the other bytes as well. */
1278:Lib/uip/uip.c ****   if(++BUF->ackno[3] == 0) {
1279:Lib/uip/uip.c ****     if(++BUF->ackno[2] == 0) {
1280:Lib/uip/uip.c ****       if(++BUF->ackno[1] == 0) {
1281:Lib/uip/uip.c **** 	++BUF->ackno[0];
1282:Lib/uip/uip.c ****       }
1283:Lib/uip/uip.c ****     }
1284:Lib/uip/uip.c ****   }
1285:Lib/uip/uip.c **** 
1286:Lib/uip/uip.c ****   /* Swap port numbers. */
1287:Lib/uip/uip.c ****   tmp16 = BUF->srcport;
1288:Lib/uip/uip.c ****   BUF->srcport = BUF->destport;
1289:Lib/uip/uip.c ****   BUF->destport = tmp16;
1290:Lib/uip/uip.c **** 
1291:Lib/uip/uip.c ****   /* Swap IP addresses. */
1292:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
1293:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
1294:Lib/uip/uip.c **** 
1295:Lib/uip/uip.c ****   /* And send out the RST packet! */
1296:Lib/uip/uip.c ****   goto tcp_send_noconn;
1297:Lib/uip/uip.c **** 
1298:Lib/uip/uip.c ****   /* This label will be jumped to if we matched the incoming packet
1299:Lib/uip/uip.c ****      with a connection in LISTEN. In that case, we should create a new
1300:Lib/uip/uip.c ****      connection and send a SYNACK in return. */
1301:Lib/uip/uip.c ****  found_listen:
1302:Lib/uip/uip.c ****   /* First we check if there are any connections available. Unused
1303:Lib/uip/uip.c ****      connections are kept in the same table as used connections, but
1304:Lib/uip/uip.c ****      unused ones have the tcpstate set to CLOSED. Also, connections in
1305:Lib/uip/uip.c ****      TIME_WAIT are kept track of and we'll use the oldest one if no
1306:Lib/uip/uip.c ****      CLOSED connections are found. Thanks to Eddie C. Dost for a very
1307:Lib/uip/uip.c ****      nice algorithm for the TIME_WAIT search. */
1308:Lib/uip/uip.c ****   uip_connr = 0;
1309:Lib/uip/uip.c ****   for(c = 0; c < UIP_CONNS; ++c) {
1310:Lib/uip/uip.c ****     if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
1311:Lib/uip/uip.c ****       uip_connr = &uip_conns[c];
1312:Lib/uip/uip.c ****       break;
1313:Lib/uip/uip.c ****     }
1314:Lib/uip/uip.c ****     if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
1315:Lib/uip/uip.c ****       if(uip_connr == 0 ||
1316:Lib/uip/uip.c **** 	 uip_conns[c].timer > uip_connr->timer) {
1317:Lib/uip/uip.c **** 	uip_connr = &uip_conns[c];
1318:Lib/uip/uip.c ****       }
1319:Lib/uip/uip.c ****     }
1320:Lib/uip/uip.c ****   }
1321:Lib/uip/uip.c **** 
1322:Lib/uip/uip.c ****   if(uip_connr == 0) {
1323:Lib/uip/uip.c ****     /* All connections are used already, we drop packet and hope that
1324:Lib/uip/uip.c ****        the remote end will retransmit the packet at a time when we
1325:Lib/uip/uip.c ****        have more spare connections. */
1326:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.tcp.syndrop);
1327:Lib/uip/uip.c ****     UIP_LOG("tcp: found no unused connections.");
1328:Lib/uip/uip.c ****     goto drop;
1329:Lib/uip/uip.c ****   }
1330:Lib/uip/uip.c ****   uip_conn = uip_connr;
1331:Lib/uip/uip.c **** 
1332:Lib/uip/uip.c ****   /* Fill in the necessary fields for the new connection. */
1333:Lib/uip/uip.c ****   uip_connr->rto = uip_connr->timer = UIP_RTO;
1334:Lib/uip/uip.c ****   uip_connr->sa = 0;
1335:Lib/uip/uip.c ****   uip_connr->sv = 4;
1336:Lib/uip/uip.c ****   uip_connr->nrtx = 0;
1337:Lib/uip/uip.c ****   uip_connr->lport = BUF->destport;
1338:Lib/uip/uip.c ****   uip_connr->rport = BUF->srcport;
1339:Lib/uip/uip.c ****   uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
1340:Lib/uip/uip.c ****   uip_connr->tcpstateflags = UIP_SYN_RCVD;
1341:Lib/uip/uip.c **** 
1342:Lib/uip/uip.c ****   uip_connr->snd_nxt[0] = iss[0];
1343:Lib/uip/uip.c ****   uip_connr->snd_nxt[1] = iss[1];
1344:Lib/uip/uip.c ****   uip_connr->snd_nxt[2] = iss[2];
1345:Lib/uip/uip.c ****   uip_connr->snd_nxt[3] = iss[3];
1346:Lib/uip/uip.c ****   uip_connr->len = 1;
1347:Lib/uip/uip.c **** 
1348:Lib/uip/uip.c ****   /* rcv_nxt should be the seqno from the incoming packet + 1. */
1349:Lib/uip/uip.c ****   uip_connr->rcv_nxt[3] = BUF->seqno[3];
1350:Lib/uip/uip.c ****   uip_connr->rcv_nxt[2] = BUF->seqno[2];
1351:Lib/uip/uip.c ****   uip_connr->rcv_nxt[1] = BUF->seqno[1];
1352:Lib/uip/uip.c ****   uip_connr->rcv_nxt[0] = BUF->seqno[0];
1353:Lib/uip/uip.c ****   uip_add_rcv_nxt(1);
1354:Lib/uip/uip.c **** 
1355:Lib/uip/uip.c ****   /* Parse the TCP MSS option, if present. */
1356:Lib/uip/uip.c ****   if((BUF->tcpoffset & 0xf0) > 0x50) {
1357:Lib/uip/uip.c ****     for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
1358:Lib/uip/uip.c ****       opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
1359:Lib/uip/uip.c ****       if(opt == TCP_OPT_END) {
1360:Lib/uip/uip.c **** 	/* End of options. */
1361:Lib/uip/uip.c **** 	break;
1362:Lib/uip/uip.c ****       } else if(opt == TCP_OPT_NOOP) {
1363:Lib/uip/uip.c **** 	++c;
1364:Lib/uip/uip.c **** 	/* NOP option. */
1365:Lib/uip/uip.c ****       } else if(opt == TCP_OPT_MSS &&
1366:Lib/uip/uip.c **** 		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
1367:Lib/uip/uip.c **** 	/* An MSS option with the right option length. */
1368:Lib/uip/uip.c **** 	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
1369:Lib/uip/uip.c **** 	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
1370:Lib/uip/uip.c **** 	uip_connr->initialmss = uip_connr->mss =
1371:Lib/uip/uip.c **** 	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
1372:Lib/uip/uip.c **** 
1373:Lib/uip/uip.c **** 	/* And we are done processing options. */
1374:Lib/uip/uip.c **** 	break;
1375:Lib/uip/uip.c ****       } else {
1376:Lib/uip/uip.c **** 	/* All other options have a length field, so that we easily
1377:Lib/uip/uip.c **** 	   can skip past them. */
1378:Lib/uip/uip.c **** 	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
1379:Lib/uip/uip.c **** 	  /* If the length field is zero, the options are malformed
1380:Lib/uip/uip.c **** 	     and we don't process them further. */
1381:Lib/uip/uip.c **** 	  break;
1382:Lib/uip/uip.c **** 	}
1383:Lib/uip/uip.c **** 	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
1384:Lib/uip/uip.c ****       }
1385:Lib/uip/uip.c ****     }
1386:Lib/uip/uip.c ****   }
1387:Lib/uip/uip.c **** 
1388:Lib/uip/uip.c ****   /* Our response will be a SYNACK. */
1389:Lib/uip/uip.c **** #if UIP_ACTIVE_OPEN
1390:Lib/uip/uip.c ****  tcp_send_synack:
1391:Lib/uip/uip.c ****   BUF->flags = TCP_ACK;
1392:Lib/uip/uip.c **** 
1393:Lib/uip/uip.c ****  tcp_send_syn:
1394:Lib/uip/uip.c ****   BUF->flags |= TCP_SYN;
1395:Lib/uip/uip.c **** #else /* UIP_ACTIVE_OPEN */
1396:Lib/uip/uip.c ****  tcp_send_synack:
1397:Lib/uip/uip.c ****   BUF->flags = TCP_SYN | TCP_ACK;
1398:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
1399:Lib/uip/uip.c **** 
1400:Lib/uip/uip.c ****   /* We send out the TCP Maximum Segment Size option with our
1401:Lib/uip/uip.c ****      SYNACK. */
1402:Lib/uip/uip.c ****   BUF->optdata[0] = TCP_OPT_MSS;
1403:Lib/uip/uip.c ****   BUF->optdata[1] = TCP_OPT_MSS_LEN;
1404:Lib/uip/uip.c ****   BUF->optdata[2] = (UIP_TCP_MSS) / 256;
1405:Lib/uip/uip.c ****   BUF->optdata[3] = (UIP_TCP_MSS) & 255;
1406:Lib/uip/uip.c ****   uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
1407:Lib/uip/uip.c ****   BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
1408:Lib/uip/uip.c ****   goto tcp_send;
1409:Lib/uip/uip.c **** 
1410:Lib/uip/uip.c ****   /* This label will be jumped to if we found an active connection. */
1411:Lib/uip/uip.c ****  found:
1412:Lib/uip/uip.c ****   uip_conn = uip_connr;
1413:Lib/uip/uip.c ****   uip_flags = 0;
1414:Lib/uip/uip.c ****   /* We do a very naive form of TCP reset processing; we just accept
1415:Lib/uip/uip.c ****      any RST and kill our connection. We should in fact check if the
1416:Lib/uip/uip.c ****      sequence number of this reset is within our advertised window
1417:Lib/uip/uip.c ****      before we accept the reset. */
1418:Lib/uip/uip.c ****   if(BUF->flags & TCP_RST) {
1419:Lib/uip/uip.c ****     uip_connr->tcpstateflags = UIP_CLOSED;
1420:Lib/uip/uip.c ****     UIP_LOG("tcp: got reset, aborting connection.");
1421:Lib/uip/uip.c ****     uip_flags = UIP_ABORT;
1422:Lib/uip/uip.c ****     UIP_APPCALL();
1423:Lib/uip/uip.c ****     goto drop;
1424:Lib/uip/uip.c ****   }
1425:Lib/uip/uip.c ****   /* Calculate the length of the data, if the application has sent
1426:Lib/uip/uip.c ****      any data to us. */
1427:Lib/uip/uip.c ****   c = (BUF->tcpoffset >> 4) << 2;
1428:Lib/uip/uip.c ****   /* uip_len will contain the length of the actual TCP data. This is
1429:Lib/uip/uip.c ****      calculated by subtracing the length of the TCP header (in
1430:Lib/uip/uip.c ****      c) and the length of the IP header (20 bytes). */
1431:Lib/uip/uip.c ****   uip_len = uip_len - c - UIP_IPH_LEN;
1432:Lib/uip/uip.c **** 
1433:Lib/uip/uip.c ****   /* First, check if the sequence number of the incoming packet is
1434:Lib/uip/uip.c ****      what we're expecting next. If not, we send out an ACK with the
1435:Lib/uip/uip.c ****      correct numbers in. */
1436:Lib/uip/uip.c ****   if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
1437:Lib/uip/uip.c ****        ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
1438:Lib/uip/uip.c ****     if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
1439:Lib/uip/uip.c ****        (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
1440:Lib/uip/uip.c **** 	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
1441:Lib/uip/uip.c **** 	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
1442:Lib/uip/uip.c **** 	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
1443:Lib/uip/uip.c ****       goto tcp_send_ack;
1444:Lib/uip/uip.c ****     }
1445:Lib/uip/uip.c ****   }
1446:Lib/uip/uip.c **** 
1447:Lib/uip/uip.c ****   /* Next, check if the incoming segment acknowledges any outstanding
1448:Lib/uip/uip.c ****      data. If so, we update the sequence number, reset the length of
1449:Lib/uip/uip.c ****      the outstanding data, calculate RTT estimations, and reset the
1450:Lib/uip/uip.c ****      retransmission timer. */
1451:Lib/uip/uip.c ****   if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
1452:Lib/uip/uip.c ****     uip_add32(uip_connr->snd_nxt, uip_connr->len);
1453:Lib/uip/uip.c **** 
1454:Lib/uip/uip.c ****     if(BUF->ackno[0] == uip_acc32[0] &&
1455:Lib/uip/uip.c ****        BUF->ackno[1] == uip_acc32[1] &&
1456:Lib/uip/uip.c ****        BUF->ackno[2] == uip_acc32[2] &&
1457:Lib/uip/uip.c ****        BUF->ackno[3] == uip_acc32[3]) {
1458:Lib/uip/uip.c ****       /* Update sequence number. */
1459:Lib/uip/uip.c ****       uip_connr->snd_nxt[0] = uip_acc32[0];
1460:Lib/uip/uip.c ****       uip_connr->snd_nxt[1] = uip_acc32[1];
1461:Lib/uip/uip.c ****       uip_connr->snd_nxt[2] = uip_acc32[2];
1462:Lib/uip/uip.c ****       uip_connr->snd_nxt[3] = uip_acc32[3];
1463:Lib/uip/uip.c **** 
1464:Lib/uip/uip.c ****       /* Do RTT estimation, unless we have done retransmissions. */
1465:Lib/uip/uip.c ****       if(uip_connr->nrtx == 0) {
1466:Lib/uip/uip.c **** 	signed char m;
1467:Lib/uip/uip.c **** 	m = uip_connr->rto - uip_connr->timer;
1468:Lib/uip/uip.c **** 	/* This is taken directly from VJs original code in his paper */
1469:Lib/uip/uip.c **** 	m = m - (uip_connr->sa >> 3);
1470:Lib/uip/uip.c **** 	uip_connr->sa += m;
1471:Lib/uip/uip.c **** 	if(m < 0) {
1472:Lib/uip/uip.c **** 	  m = -m;
1473:Lib/uip/uip.c **** 	}
1474:Lib/uip/uip.c **** 	m = m - (uip_connr->sv >> 2);
1475:Lib/uip/uip.c **** 	uip_connr->sv += m;
1476:Lib/uip/uip.c **** 	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
1477:Lib/uip/uip.c **** 
1478:Lib/uip/uip.c ****       }
1479:Lib/uip/uip.c ****       /* Set the acknowledged flag. */
1480:Lib/uip/uip.c ****       uip_flags = UIP_ACKDATA;
1481:Lib/uip/uip.c ****       /* Reset the retransmission timer. */
1482:Lib/uip/uip.c ****       uip_connr->timer = uip_connr->rto;
1483:Lib/uip/uip.c **** 
1484:Lib/uip/uip.c ****       /* Reset length of outstanding data. */
1485:Lib/uip/uip.c ****       uip_connr->len = 0;
1486:Lib/uip/uip.c ****     }
1487:Lib/uip/uip.c **** 
1488:Lib/uip/uip.c ****   }
1489:Lib/uip/uip.c **** 
1490:Lib/uip/uip.c ****   /* Do different things depending on in what state the connection is. */
1491:Lib/uip/uip.c ****   switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
1492:Lib/uip/uip.c ****     /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
1493:Lib/uip/uip.c **** 	implemented, since we force the application to close when the
1494:Lib/uip/uip.c **** 	peer sends a FIN (hence the application goes directly from
1495:Lib/uip/uip.c **** 	ESTABLISHED to LAST_ACK). */
1496:Lib/uip/uip.c ****   case UIP_SYN_RCVD:
1497:Lib/uip/uip.c ****     /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
1498:Lib/uip/uip.c ****        we are waiting for an ACK that acknowledges the data we sent
1499:Lib/uip/uip.c ****        out the last time. Therefore, we want to have the UIP_ACKDATA
1500:Lib/uip/uip.c ****        flag set. If so, we enter the ESTABLISHED state. */
1501:Lib/uip/uip.c ****     if(uip_flags & UIP_ACKDATA) {
1502:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_ESTABLISHED;
1503:Lib/uip/uip.c ****       uip_flags = UIP_CONNECTED;
1504:Lib/uip/uip.c ****       uip_connr->len = 0;
1505:Lib/uip/uip.c ****       if(uip_len > 0) {
1506:Lib/uip/uip.c ****         uip_flags |= UIP_NEWDATA;
1507:Lib/uip/uip.c ****         uip_add_rcv_nxt(uip_len);
1508:Lib/uip/uip.c ****       }
1509:Lib/uip/uip.c ****       uip_slen = 0;
1510:Lib/uip/uip.c ****       UIP_APPCALL();
1511:Lib/uip/uip.c ****       goto appsend;
1512:Lib/uip/uip.c ****     }
1513:Lib/uip/uip.c ****     goto drop;
1514:Lib/uip/uip.c **** #if UIP_ACTIVE_OPEN
1515:Lib/uip/uip.c ****   case UIP_SYN_SENT:
1516:Lib/uip/uip.c ****     /* In SYN_SENT, we wait for a SYNACK that is sent in response to
1517:Lib/uip/uip.c ****        our SYN. The rcv_nxt is set to sequence number in the SYNACK
1518:Lib/uip/uip.c ****        plus one, and we send an ACK. We move into the ESTABLISHED
1519:Lib/uip/uip.c ****        state. */
1520:Lib/uip/uip.c ****     if((uip_flags & UIP_ACKDATA) &&
1521:Lib/uip/uip.c ****        (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
1522:Lib/uip/uip.c **** 
1523:Lib/uip/uip.c ****       /* Parse the TCP MSS option, if present. */
1524:Lib/uip/uip.c ****       if((BUF->tcpoffset & 0xf0) > 0x50) {
1525:Lib/uip/uip.c **** 	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
1526:Lib/uip/uip.c **** 	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
1527:Lib/uip/uip.c **** 	  if(opt == TCP_OPT_END) {
1528:Lib/uip/uip.c **** 	    /* End of options. */
1529:Lib/uip/uip.c **** 	    break;
1530:Lib/uip/uip.c **** 	  } else if(opt == TCP_OPT_NOOP) {
1531:Lib/uip/uip.c **** 	    ++c;
1532:Lib/uip/uip.c **** 	    /* NOP option. */
1533:Lib/uip/uip.c **** 	  } else if(opt == TCP_OPT_MSS &&
1534:Lib/uip/uip.c **** 		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
1535:Lib/uip/uip.c **** 	    /* An MSS option with the right option length. */
1536:Lib/uip/uip.c **** 	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
1537:Lib/uip/uip.c **** 	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
1538:Lib/uip/uip.c **** 	    uip_connr->initialmss =
1539:Lib/uip/uip.c **** 	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
1540:Lib/uip/uip.c **** 
1541:Lib/uip/uip.c **** 	    /* And we are done processing options. */
1542:Lib/uip/uip.c **** 	    break;
1543:Lib/uip/uip.c **** 	  } else {
1544:Lib/uip/uip.c **** 	    /* All other options have a length field, so that we easily
1545:Lib/uip/uip.c **** 	       can skip past them. */
1546:Lib/uip/uip.c **** 	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
1547:Lib/uip/uip.c **** 	      /* If the length field is zero, the options are malformed
1548:Lib/uip/uip.c **** 		 and we don't process them further. */
1549:Lib/uip/uip.c **** 	      break;
1550:Lib/uip/uip.c **** 	    }
1551:Lib/uip/uip.c **** 	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
1552:Lib/uip/uip.c **** 	  }
1553:Lib/uip/uip.c **** 	}
1554:Lib/uip/uip.c ****       }
1555:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_ESTABLISHED;
1556:Lib/uip/uip.c ****       uip_connr->rcv_nxt[0] = BUF->seqno[0];
1557:Lib/uip/uip.c ****       uip_connr->rcv_nxt[1] = BUF->seqno[1];
1558:Lib/uip/uip.c ****       uip_connr->rcv_nxt[2] = BUF->seqno[2];
1559:Lib/uip/uip.c ****       uip_connr->rcv_nxt[3] = BUF->seqno[3];
1560:Lib/uip/uip.c ****       uip_add_rcv_nxt(1);
1561:Lib/uip/uip.c ****       uip_flags = UIP_CONNECTED | UIP_NEWDATA;
1562:Lib/uip/uip.c ****       uip_connr->len = 0;
1563:Lib/uip/uip.c ****       uip_len = 0;
1564:Lib/uip/uip.c ****       uip_slen = 0;
1565:Lib/uip/uip.c ****       UIP_APPCALL();
1566:Lib/uip/uip.c ****       goto appsend;
1567:Lib/uip/uip.c ****     }
1568:Lib/uip/uip.c ****     /* Inform the application that the connection failed */
1569:Lib/uip/uip.c ****     uip_flags = UIP_ABORT;
1570:Lib/uip/uip.c ****     UIP_APPCALL();
1571:Lib/uip/uip.c ****     /* The connection is closed after we send the RST */
1572:Lib/uip/uip.c ****     uip_conn->tcpstateflags = UIP_CLOSED;
1573:Lib/uip/uip.c ****     goto reset;
1574:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
1575:Lib/uip/uip.c **** 
1576:Lib/uip/uip.c ****   case UIP_ESTABLISHED:
1577:Lib/uip/uip.c ****     /* In the ESTABLISHED state, we call upon the application to feed
1578:Lib/uip/uip.c ****     data into the uip_buf. If the UIP_ACKDATA flag is set, the
1579:Lib/uip/uip.c ****     application should put new data into the buffer, otherwise we are
1580:Lib/uip/uip.c ****     retransmitting an old segment, and the application should put that
1581:Lib/uip/uip.c ****     data into the buffer.
1582:Lib/uip/uip.c **** 
1583:Lib/uip/uip.c ****     If the incoming packet is a FIN, we should close the connection on
1584:Lib/uip/uip.c ****     this side as well, and we send out a FIN and enter the LAST_ACK
1585:Lib/uip/uip.c ****     state. We require that there is no outstanding data; otherwise the
1586:Lib/uip/uip.c ****     sequence numbers will be screwed up. */
1587:Lib/uip/uip.c **** 
1588:Lib/uip/uip.c ****     if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
1589:Lib/uip/uip.c ****       if(uip_outstanding(uip_connr)) {
1590:Lib/uip/uip.c **** 	goto drop;
1591:Lib/uip/uip.c ****       }
1592:Lib/uip/uip.c ****       uip_add_rcv_nxt(1 + uip_len);
1593:Lib/uip/uip.c ****       uip_flags |= UIP_CLOSE;
1594:Lib/uip/uip.c ****       if(uip_len > 0) {
1595:Lib/uip/uip.c **** 	uip_flags |= UIP_NEWDATA;
1596:Lib/uip/uip.c ****       }
1597:Lib/uip/uip.c ****       UIP_APPCALL();
1598:Lib/uip/uip.c ****       uip_connr->len = 1;
1599:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_LAST_ACK;
1600:Lib/uip/uip.c ****       uip_connr->nrtx = 0;
1601:Lib/uip/uip.c ****     tcp_send_finack:
1602:Lib/uip/uip.c ****       BUF->flags = TCP_FIN | TCP_ACK;
1603:Lib/uip/uip.c ****       goto tcp_send_nodata;
1604:Lib/uip/uip.c ****     }
1605:Lib/uip/uip.c **** 
1606:Lib/uip/uip.c ****     /* Check the URG flag. If this is set, the segment carries urgent
1607:Lib/uip/uip.c ****        data that we must pass to the application. */
1608:Lib/uip/uip.c ****     if((BUF->flags & TCP_URG) != 0) {
1609:Lib/uip/uip.c **** #if UIP_URGDATA > 0
1610:Lib/uip/uip.c ****       uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
1611:Lib/uip/uip.c ****       if(uip_urglen > uip_len) {
1612:Lib/uip/uip.c **** 	/* There is more urgent data in the next segment to come. */
1613:Lib/uip/uip.c **** 	uip_urglen = uip_len;
1614:Lib/uip/uip.c ****       }
1615:Lib/uip/uip.c ****       uip_add_rcv_nxt(uip_urglen);
1616:Lib/uip/uip.c ****       uip_len -= uip_urglen;
1617:Lib/uip/uip.c ****       uip_urgdata = uip_appdata;
1618:Lib/uip/uip.c ****       uip_appdata += uip_urglen;
1619:Lib/uip/uip.c ****     } else {
1620:Lib/uip/uip.c ****       uip_urglen = 0;
1621:Lib/uip/uip.c **** #else /* UIP_URGDATA > 0 */
1622:Lib/uip/uip.c ****       uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
1623:Lib/uip/uip.c ****       uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
1624:Lib/uip/uip.c **** #endif /* UIP_URGDATA > 0 */
1625:Lib/uip/uip.c ****     }
1626:Lib/uip/uip.c **** 
1627:Lib/uip/uip.c ****     /* If uip_len > 0 we have TCP data in the packet, and we flag this
1628:Lib/uip/uip.c ****        by setting the UIP_NEWDATA flag and update the sequence number
1629:Lib/uip/uip.c ****        we acknowledge. If the application has stopped the dataflow
1630:Lib/uip/uip.c ****        using uip_stop(), we must not accept any data packets from the
1631:Lib/uip/uip.c ****        remote host. */
1632:Lib/uip/uip.c ****     if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
1633:Lib/uip/uip.c ****       uip_flags |= UIP_NEWDATA;
1634:Lib/uip/uip.c ****       uip_add_rcv_nxt(uip_len);
1635:Lib/uip/uip.c ****     }
1636:Lib/uip/uip.c **** 
1637:Lib/uip/uip.c ****     /* Check if the available buffer space advertised by the other end
1638:Lib/uip/uip.c ****        is smaller than the initial MSS for this connection. If so, we
1639:Lib/uip/uip.c ****        set the current MSS to the window size to ensure that the
1640:Lib/uip/uip.c ****        application does not send more data than the other end can
1641:Lib/uip/uip.c ****        handle.
1642:Lib/uip/uip.c **** 
1643:Lib/uip/uip.c ****        If the remote host advertises a zero window, we set the MSS to
1644:Lib/uip/uip.c ****        the initial MSS so that the application will send an entire MSS
1645:Lib/uip/uip.c ****        of data. This data will not be acknowledged by the receiver,
1646:Lib/uip/uip.c ****        and the application will retransmit it. This is called the
1647:Lib/uip/uip.c ****        "persistent timer" and uses the retransmission mechanism.
1648:Lib/uip/uip.c ****     */
1649:Lib/uip/uip.c ****     tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
1650:Lib/uip/uip.c ****     if(tmp16 > uip_connr->initialmss ||
1651:Lib/uip/uip.c ****        tmp16 == 0) {
1652:Lib/uip/uip.c ****       tmp16 = uip_connr->initialmss;
1653:Lib/uip/uip.c ****     }
1654:Lib/uip/uip.c ****     uip_connr->mss = tmp16;
1655:Lib/uip/uip.c **** 
1656:Lib/uip/uip.c ****     /* If this packet constitutes an ACK for outstanding data (flagged
1657:Lib/uip/uip.c ****        by the UIP_ACKDATA flag, we should call the application since it
1658:Lib/uip/uip.c ****        might want to send more data. If the incoming packet had data
1659:Lib/uip/uip.c ****        from the peer (as flagged by the UIP_NEWDATA flag), the
1660:Lib/uip/uip.c ****        application must also be notified.
1661:Lib/uip/uip.c **** 
1662:Lib/uip/uip.c ****        When the application is called, the global variable uip_len
1663:Lib/uip/uip.c ****        contains the length of the incoming data. The application can
1664:Lib/uip/uip.c ****        access the incoming data through the global pointer
1665:Lib/uip/uip.c ****        uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
1666:Lib/uip/uip.c ****        bytes into the uip_buf array.
1667:Lib/uip/uip.c **** 
1668:Lib/uip/uip.c ****        If the application wishes to send any data, this data should be
1669:Lib/uip/uip.c ****        put into the uip_appdata and the length of the data should be
1670:Lib/uip/uip.c ****        put into uip_len. If the application don't have any data to
1671:Lib/uip/uip.c ****        send, uip_len must be set to 0. */
1672:Lib/uip/uip.c ****     if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
1673:Lib/uip/uip.c ****       uip_slen = 0;
1674:Lib/uip/uip.c ****       UIP_APPCALL();
1675:Lib/uip/uip.c **** 
1676:Lib/uip/uip.c ****     appsend:
1677:Lib/uip/uip.c **** 
1678:Lib/uip/uip.c ****       if(uip_flags & UIP_ABORT) {
1679:Lib/uip/uip.c **** 	uip_slen = 0;
1680:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_CLOSED;
1681:Lib/uip/uip.c **** 	BUF->flags = TCP_RST | TCP_ACK;
1682:Lib/uip/uip.c **** 	goto tcp_send_nodata;
1683:Lib/uip/uip.c ****       }
1684:Lib/uip/uip.c **** 
1685:Lib/uip/uip.c ****       if(uip_flags & UIP_CLOSE) {
1686:Lib/uip/uip.c **** 	uip_slen = 0;
1687:Lib/uip/uip.c **** 	uip_connr->len = 1;
1688:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
1689:Lib/uip/uip.c **** 	uip_connr->nrtx = 0;
1690:Lib/uip/uip.c **** 	BUF->flags = TCP_FIN | TCP_ACK;
1691:Lib/uip/uip.c **** 	goto tcp_send_nodata;
1692:Lib/uip/uip.c ****       }
1693:Lib/uip/uip.c **** 
1694:Lib/uip/uip.c ****       /* If uip_slen > 0, the application has data to be sent. */
1695:Lib/uip/uip.c ****       if(uip_slen > 0) {
1696:Lib/uip/uip.c **** 
1697:Lib/uip/uip.c **** 	/* If the connection has acknowledged data, the contents of
1698:Lib/uip/uip.c **** 	   the ->len variable should be discarded. */
1699:Lib/uip/uip.c **** 	if((uip_flags & UIP_ACKDATA) != 0) {
1700:Lib/uip/uip.c **** 	  uip_connr->len = 0;
1701:Lib/uip/uip.c **** 	}
1702:Lib/uip/uip.c **** 
1703:Lib/uip/uip.c **** 	/* If the ->len variable is non-zero the connection has
1704:Lib/uip/uip.c **** 	   already data in transit and cannot send anymore right
1705:Lib/uip/uip.c **** 	   now. */
1706:Lib/uip/uip.c **** 	if(uip_connr->len == 0) {
1707:Lib/uip/uip.c **** 
1708:Lib/uip/uip.c **** 	  /* The application cannot send more than what is allowed by
1709:Lib/uip/uip.c **** 	     the mss (the minumum of the MSS and the available
1710:Lib/uip/uip.c **** 	     window). */
1711:Lib/uip/uip.c **** 	  if(uip_slen > uip_connr->mss) {
1712:Lib/uip/uip.c **** 	    uip_slen = uip_connr->mss;
1713:Lib/uip/uip.c **** 	  }
1714:Lib/uip/uip.c **** 
1715:Lib/uip/uip.c **** 	  /* Remember how much data we send out now so that we know
1716:Lib/uip/uip.c **** 	     when everything has been acknowledged. */
1717:Lib/uip/uip.c **** 	  uip_connr->len = uip_slen;
1718:Lib/uip/uip.c **** 	} else {
1719:Lib/uip/uip.c **** 
1720:Lib/uip/uip.c **** 	  /* If the application already had unacknowledged data, we
1721:Lib/uip/uip.c **** 	     make sure that the application does not send (i.e.,
1722:Lib/uip/uip.c **** 	     retransmit) out more than it previously sent out. */
1723:Lib/uip/uip.c **** 	  uip_slen = uip_connr->len;
1724:Lib/uip/uip.c **** 	}
1725:Lib/uip/uip.c ****       }
1726:Lib/uip/uip.c ****       uip_connr->nrtx = 0;
1727:Lib/uip/uip.c ****     apprexmit:
1728:Lib/uip/uip.c ****       uip_appdata = uip_sappdata;
1729:Lib/uip/uip.c **** 
1730:Lib/uip/uip.c ****       /* If the application has data to be sent, or if the incoming
1731:Lib/uip/uip.c ****          packet had new data in it, we must send out a packet. */
1732:Lib/uip/uip.c ****       if(uip_slen > 0 && uip_connr->len > 0) {
1733:Lib/uip/uip.c **** 	/* Add the length of the IP and TCP headers. */
1734:Lib/uip/uip.c **** 	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
1735:Lib/uip/uip.c **** 	/* We always set the ACK flag in response packets. */
1736:Lib/uip/uip.c **** 	BUF->flags = TCP_ACK | TCP_PSH;
1737:Lib/uip/uip.c **** 	/* Send the packet. */
1738:Lib/uip/uip.c **** 	goto tcp_send_noopts;
1739:Lib/uip/uip.c ****       }
1740:Lib/uip/uip.c ****       /* If there is no data to send, just send out a pure ACK if
1741:Lib/uip/uip.c **** 	 there is newdata. */
1742:Lib/uip/uip.c ****       if(uip_flags & UIP_NEWDATA) {
1743:Lib/uip/uip.c **** 	uip_len = UIP_TCPIP_HLEN;
1744:Lib/uip/uip.c **** 	BUF->flags = TCP_ACK;
1745:Lib/uip/uip.c **** 	goto tcp_send_noopts;
1746:Lib/uip/uip.c ****       }
1747:Lib/uip/uip.c ****     }
1748:Lib/uip/uip.c ****     goto drop;
1749:Lib/uip/uip.c ****   case UIP_LAST_ACK:
1750:Lib/uip/uip.c ****     /* We can close this connection if the peer has acknowledged our
1751:Lib/uip/uip.c ****        FIN. This is indicated by the UIP_ACKDATA flag. */
1752:Lib/uip/uip.c ****     if(uip_flags & UIP_ACKDATA) {
1753:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_CLOSED;
1754:Lib/uip/uip.c ****       uip_flags = UIP_CLOSE;
1755:Lib/uip/uip.c ****       UIP_APPCALL();
1756:Lib/uip/uip.c ****     }
1757:Lib/uip/uip.c ****     break;
1758:Lib/uip/uip.c **** 
1759:Lib/uip/uip.c ****   case UIP_FIN_WAIT_1:
1760:Lib/uip/uip.c ****     /* The application has closed the connection, but the remote host
1761:Lib/uip/uip.c ****        hasn't closed its end yet. Thus we do nothing but wait for a
1762:Lib/uip/uip.c ****        FIN from the other side. */
1763:Lib/uip/uip.c ****     if(uip_len > 0) {
1764:Lib/uip/uip.c ****       uip_add_rcv_nxt(uip_len);
1765:Lib/uip/uip.c ****     }
1766:Lib/uip/uip.c ****     if(BUF->flags & TCP_FIN) {
1767:Lib/uip/uip.c ****       if(uip_flags & UIP_ACKDATA) {
1768:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_TIME_WAIT;
1769:Lib/uip/uip.c **** 	uip_connr->timer = 0;
1770:Lib/uip/uip.c **** 	uip_connr->len = 0;
1771:Lib/uip/uip.c ****       } else {
1772:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_CLOSING;
1773:Lib/uip/uip.c ****       }
1774:Lib/uip/uip.c ****       uip_add_rcv_nxt(1);
1775:Lib/uip/uip.c ****       uip_flags = UIP_CLOSE;
1776:Lib/uip/uip.c ****       UIP_APPCALL();
1777:Lib/uip/uip.c ****       goto tcp_send_ack;
1778:Lib/uip/uip.c ****     } else if(uip_flags & UIP_ACKDATA) {
1779:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
1780:Lib/uip/uip.c ****       uip_connr->len = 0;
1781:Lib/uip/uip.c ****       goto drop;
1782:Lib/uip/uip.c ****     }
1783:Lib/uip/uip.c ****     if(uip_len > 0) {
1784:Lib/uip/uip.c ****       goto tcp_send_ack;
1785:Lib/uip/uip.c ****     }
1786:Lib/uip/uip.c ****     goto drop;
1787:Lib/uip/uip.c **** 
1788:Lib/uip/uip.c ****   case UIP_FIN_WAIT_2:
1789:Lib/uip/uip.c ****     if(uip_len > 0) {
1790:Lib/uip/uip.c ****       uip_add_rcv_nxt(uip_len);
1791:Lib/uip/uip.c ****     }
1792:Lib/uip/uip.c ****     if(BUF->flags & TCP_FIN) {
1793:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_TIME_WAIT;
1794:Lib/uip/uip.c ****       uip_connr->timer = 0;
1795:Lib/uip/uip.c ****       uip_add_rcv_nxt(1);
1796:Lib/uip/uip.c ****       uip_flags = UIP_CLOSE;
1797:Lib/uip/uip.c ****       UIP_APPCALL();
1798:Lib/uip/uip.c ****       goto tcp_send_ack;
1799:Lib/uip/uip.c ****     }
1800:Lib/uip/uip.c ****     if(uip_len > 0) {
1801:Lib/uip/uip.c ****       goto tcp_send_ack;
1802:Lib/uip/uip.c ****     }
1803:Lib/uip/uip.c ****     goto drop;
1804:Lib/uip/uip.c **** 
1805:Lib/uip/uip.c ****   case UIP_TIME_WAIT:
1806:Lib/uip/uip.c ****     goto tcp_send_ack;
1807:Lib/uip/uip.c **** 
1808:Lib/uip/uip.c ****   case UIP_CLOSING:
1809:Lib/uip/uip.c ****     if(uip_flags & UIP_ACKDATA) {
1810:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_TIME_WAIT;
1811:Lib/uip/uip.c ****       uip_connr->timer = 0;
1812:Lib/uip/uip.c ****     }
1813:Lib/uip/uip.c ****   }
1814:Lib/uip/uip.c ****   goto drop;
1815:Lib/uip/uip.c **** 
1816:Lib/uip/uip.c ****   /* We jump here when we are ready to send the packet, and just want
1817:Lib/uip/uip.c ****      to set the appropriate TCP sequence numbers in the TCP header. */
1818:Lib/uip/uip.c ****  tcp_send_ack:
1819:Lib/uip/uip.c ****   BUF->flags = TCP_ACK;
1820:Lib/uip/uip.c **** 
1821:Lib/uip/uip.c ****  tcp_send_nodata:
1822:Lib/uip/uip.c ****   uip_len = UIP_IPTCPH_LEN;
1823:Lib/uip/uip.c **** 
1824:Lib/uip/uip.c ****  tcp_send_noopts:
1825:Lib/uip/uip.c ****   BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
1826:Lib/uip/uip.c **** 
1827:Lib/uip/uip.c ****   /* We're done with the input processing. We are now ready to send a
1828:Lib/uip/uip.c ****      reply. Our job is to fill in all the fields of the TCP and IP
1829:Lib/uip/uip.c ****      headers before calculating the checksum and finally send the
1830:Lib/uip/uip.c ****      packet. */
1831:Lib/uip/uip.c ****  tcp_send:
1832:Lib/uip/uip.c ****   BUF->ackno[0] = uip_connr->rcv_nxt[0];
1833:Lib/uip/uip.c ****   BUF->ackno[1] = uip_connr->rcv_nxt[1];
1834:Lib/uip/uip.c ****   BUF->ackno[2] = uip_connr->rcv_nxt[2];
1835:Lib/uip/uip.c ****   BUF->ackno[3] = uip_connr->rcv_nxt[3];
1836:Lib/uip/uip.c **** 
1837:Lib/uip/uip.c ****   BUF->seqno[0] = uip_connr->snd_nxt[0];
1838:Lib/uip/uip.c ****   BUF->seqno[1] = uip_connr->snd_nxt[1];
1839:Lib/uip/uip.c ****   BUF->seqno[2] = uip_connr->snd_nxt[2];
1840:Lib/uip/uip.c ****   BUF->seqno[3] = uip_connr->snd_nxt[3];
1841:Lib/uip/uip.c **** 
1842:Lib/uip/uip.c ****   BUF->proto = UIP_PROTO_TCP;
1843:Lib/uip/uip.c **** 
1844:Lib/uip/uip.c ****   BUF->srcport  = uip_connr->lport;
1845:Lib/uip/uip.c ****   BUF->destport = uip_connr->rport;
1846:Lib/uip/uip.c **** 
1847:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
1848:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
1849:Lib/uip/uip.c **** 
1850:Lib/uip/uip.c ****   if(uip_connr->tcpstateflags & UIP_STOPPED) {
1851:Lib/uip/uip.c ****     /* If the connection has issued uip_stop(), we advertise a zero
1852:Lib/uip/uip.c ****        window so that the remote host will stop sending data. */
1853:Lib/uip/uip.c ****     BUF->wnd[0] = BUF->wnd[1] = 0;
1854:Lib/uip/uip.c ****   } else {
1855:Lib/uip/uip.c ****     BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
1856:Lib/uip/uip.c ****     BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
1857:Lib/uip/uip.c ****   }
1858:Lib/uip/uip.c **** 
1859:Lib/uip/uip.c ****  tcp_send_noconn:
1860:Lib/uip/uip.c ****   BUF->ttl = UIP_TTL;
1861:Lib/uip/uip.c **** #if UIP_CONF_IPV6
1862:Lib/uip/uip.c ****   /* For IPv6, the IP length field does not include the IPv6 IP header
1863:Lib/uip/uip.c ****      length. */
1864:Lib/uip/uip.c ****   BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
1865:Lib/uip/uip.c ****   BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
1866:Lib/uip/uip.c **** #else /* UIP_CONF_IPV6 */
1867:Lib/uip/uip.c ****   BUF->len[0] = (uip_len >> 8);
1868:Lib/uip/uip.c ****   BUF->len[1] = (uip_len & 0xff);
1869:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
1870:Lib/uip/uip.c **** 
1871:Lib/uip/uip.c ****   BUF->urgp[0] = BUF->urgp[1] = 0;
1872:Lib/uip/uip.c **** 
1873:Lib/uip/uip.c ****   /* Calculate TCP checksum. */
1874:Lib/uip/uip.c ****   BUF->tcpchksum = 0;
1875:Lib/uip/uip.c ****   BUF->tcpchksum = ~(uip_tcpchksum());
1876:Lib/uip/uip.c **** 
1877:Lib/uip/uip.c ****  ip_send_nolen:
1878:Lib/uip/uip.c **** #if UIP_CONF_IPV6
1879:Lib/uip/uip.c ****   BUF->vtc = 0x60;
1880:Lib/uip/uip.c ****   BUF->tcflow = 0x00;
1881:Lib/uip/uip.c ****   BUF->flow = 0x00;
1882:Lib/uip/uip.c **** #else /* UIP_CONF_IPV6 */
1883:Lib/uip/uip.c ****   BUF->vhl = 0x45;
1884:Lib/uip/uip.c ****   BUF->tos = 0;
1885:Lib/uip/uip.c ****   BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
1886:Lib/uip/uip.c ****   ++ipid;
1887:Lib/uip/uip.c ****   BUF->ipid[0] = ipid >> 8;
1888:Lib/uip/uip.c ****   BUF->ipid[1] = ipid & 0xff;
1889:Lib/uip/uip.c ****   /* Calculate IP checksum. */
1890:Lib/uip/uip.c ****   BUF->ipchksum = 0;
1891:Lib/uip/uip.c ****   BUF->ipchksum = ~(uip_ipchksum());
1892:Lib/uip/uip.c ****   DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
1893:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
1894:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.tcp.sent);
1895:Lib/uip/uip.c **** #if UIP_CONF_IPV6
1896:Lib/uip/uip.c ****  send:
1897:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
1898:Lib/uip/uip.c ****   DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
1899:Lib/uip/uip.c **** 	       (BUF->len[0] << 8) | BUF->len[1]);
1900:Lib/uip/uip.c **** 
1901:Lib/uip/uip.c ****   UIP_STAT(++uip_stat.ip.sent);
1902:Lib/uip/uip.c ****   /* Return and let the caller do the actual transmission. */
1903:Lib/uip/uip.c ****   uip_flags = 0;
1904:Lib/uip/uip.c ****   return;
1905:Lib/uip/uip.c **** 
1906:Lib/uip/uip.c ****  drop:
1907:Lib/uip/uip.c ****   uip_len = 0;
1908:Lib/uip/uip.c ****   uip_flags = 0;
1909:Lib/uip/uip.c ****   return;
1910:Lib/uip/uip.c **** }
1911:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
1912:Lib/uip/uip.c **** u16_t
1913:Lib/uip/uip.c **** htons(u16_t val)
1914:Lib/uip/uip.c **** {
1915:Lib/uip/uip.c ****   return HTONS(val);
 287               		.loc 1 1915 0
 288 0014 9827      		eor r25,r24
 289 0016 8927      		eor r24,r25
 290               	.LVL26:
 291 0018 9827      		eor r25,r24
 292               	.LBE7:
 293               	.LBE6:
 294 001a 0895      		ret
 295               	.LVL27:
 296               	.L20:
 317:Lib/uip/uip.c **** }
 297               		.loc 1 317 0
 298 001c 8FEF      		ldi r24,lo8(-1)
 299 001e 9FEF      		ldi r25,lo8(-1)
 300               	.LVL28:
 318:Lib/uip/uip.c **** #endif
 301               		.loc 1 318 0
 302 0020 0895      		ret
 303               		.cfi_endproc
 304               	.LFE9:
 306               		.section	.text.uip_tcpchksum,"ax",@progbits
 307               	.global	uip_tcpchksum
 309               	uip_tcpchksum:
 310               	.LFB11:
 358:Lib/uip/uip.c ****   return upper_layer_chksum(UIP_PROTO_TCP);
 311               		.loc 1 358 0
 312               		.cfi_startproc
 313 0000 CF93      		push r28
 314               	.LCFI0:
 315               		.cfi_def_cfa_offset 3
 316               		.cfi_offset 28, -2
 317 0002 DF93      		push r29
 318               	.LCFI1:
 319               		.cfi_def_cfa_offset 4
 320               		.cfi_offset 29, -3
 321               	/* prologue: function */
 322               	/* frame size = 0 */
 323               	/* stack size = 2 */
 324               	.L__stack_usage = 2
 325               	.LVL29:
 326               	.LBB12:
 327               	.LBB13:
 330:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 328               		.loc 1 330 0
 329 0004 C091 0000 		lds r28,uip_buf+16
 330 0008 D0E0      		ldi r29,0
 331 000a DC2F      		mov r29,r28
 332 000c CC27      		clr r28
 333 000e 8091 0000 		lds r24,uip_buf+17
 334 0012 C80F      		add r28,r24
 335 0014 D11D      		adc r29,__zero_reg__
 336               	.LVL30:
 338:Lib/uip/uip.c **** 
 337               		.loc 1 338 0
 338 0016 48E0      		ldi r20,lo8(8)
 339 0018 50E0      		ldi r21,0
 340 001a 60E0      		ldi r22,lo8(uip_buf+26)
 341 001c 70E0      		ldi r23,hi8(uip_buf+26)
 342 001e CE01      		movw r24,r28
 343 0020 0E97      		sbiw r24,14
 344               	.LVL31:
 345 0022 0E94 0000 		call chksum
 346               	.LVL32:
 341:Lib/uip/uip.c **** 	       upper_layer_len);
 347               		.loc 1 341 0
 348 0026 AE01      		movw r20,r28
 349 0028 4451      		subi r20,20
 350 002a 5109      		sbc r21,__zero_reg__
 351               	.LVL33:
 352 002c 60E0      		ldi r22,lo8(uip_buf+34)
 353 002e 70E0      		ldi r23,hi8(uip_buf+34)
 354 0030 0E94 0000 		call chksum
 355               	.LVL34:
 344:Lib/uip/uip.c **** }
 356               		.loc 1 344 0
 357 0034 0097      		sbiw r24,0
 358 0036 01F0      		breq .L23
 359               	.LVL35:
 360               	.LBB14:
 361               	.LBB15:
 362               		.loc 1 1915 0
 363 0038 9827      		eor r25,r24
 364 003a 8927      		eor r24,r25
 365               	.LVL36:
 366 003c 9827      		eor r25,r24
 367 003e 00C0      		rjmp .L22
 368               	.LVL37:
 369               	.L23:
 370               	.LBE15:
 371               	.LBE14:
 344:Lib/uip/uip.c **** }
 372               		.loc 1 344 0
 373 0040 8FEF      		ldi r24,lo8(-1)
 374 0042 9FEF      		ldi r25,lo8(-1)
 375               	.LVL38:
 376               	.L22:
 377               	/* epilogue start */
 378               	.LBE13:
 379               	.LBE12:
 360:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 380               		.loc 1 360 0
 381 0044 DF91      		pop r29
 382 0046 CF91      		pop r28
 383 0048 0895      		ret
 384               		.cfi_endproc
 385               	.LFE11:
 387               		.section	.text.uip_init,"ax",@progbits
 388               	.global	uip_init
 390               	uip_init:
 391               	.LFB12:
 373:Lib/uip/uip.c ****   for(c = 0; c < UIP_LISTENPORTS; ++c) {
 392               		.loc 1 373 0
 393               		.cfi_startproc
 394               	/* prologue: function */
 395               	/* frame size = 0 */
 396               	/* stack size = 0 */
 397               	.L__stack_usage = 0
 374:Lib/uip/uip.c ****     uip_listenports[c] = 0;
 398               		.loc 1 374 0
 399 0000 80E0      		ldi r24,0
 400               	.L25:
 375:Lib/uip/uip.c ****   }
 401               		.loc 1 375 0 discriminator 3
 402 0002 E82F      		mov r30,r24
 403 0004 F0E0      		ldi r31,0
 404 0006 EE0F      		lsl r30
 405 0008 FF1F      		rol r31
 406 000a E050      		subi r30,lo8(-(uip_listenports))
 407 000c F040      		sbci r31,hi8(-(uip_listenports))
 408 000e 1182      		std Z+1,__zero_reg__
 409 0010 1082      		st Z,__zero_reg__
 374:Lib/uip/uip.c ****     uip_listenports[c] = 0;
 410               		.loc 1 374 0 discriminator 3
 411 0012 8F5F      		subi r24,lo8(-(1))
 412 0014 8530      		cpi r24,lo8(5)
 413 0016 01F4      		brne .L25
 377:Lib/uip/uip.c ****     uip_conns[c].tcpstateflags = UIP_CLOSED;
 414               		.loc 1 377 0
 415 0018 80E0      		ldi r24,0
 378:Lib/uip/uip.c ****   }
 416               		.loc 1 378 0
 417 001a 91E7      		ldi r25,lo8(113)
 418               	.L26:
 378:Lib/uip/uip.c ****   }
 419               		.loc 1 378 0 is_stmt 0 discriminator 3
 420 001c 989F      		mul r25,r24
 421 001e F001      		movw r30,r0
 422 0020 1124      		clr __zero_reg__
 423 0022 E050      		subi r30,lo8(-(uip_conns))
 424 0024 F040      		sbci r31,hi8(-(uip_conns))
 425 0026 118E      		std Z+25,__zero_reg__
 377:Lib/uip/uip.c ****     uip_conns[c].tcpstateflags = UIP_CLOSED;
 426               		.loc 1 377 0 is_stmt 1 discriminator 3
 427 0028 8F5F      		subi r24,lo8(-(1))
 428 002a 8330      		cpi r24,lo8(3)
 429 002c 01F4      		brne .L26
 381:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 430               		.loc 1 381 0
 431 002e 80E0      		ldi r24,0
 432 0030 94E0      		ldi r25,lo8(4)
 433 0032 9093 0000 		sts lastport+1,r25
 434 0036 8093 0000 		sts lastport,r24
 435 003a 1092 0000 		sts uip_udp_conns+4+1,__zero_reg__
 436 003e 1092 0000 		sts uip_udp_conns+4,__zero_reg__
 437 0042 81E0      		ldi r24,lo8(1)
 438 0044 8093 0000 		sts c,r24
 439 0048 0895      		ret
 440               		.cfi_endproc
 441               	.LFE12:
 443               		.section	.text.uip_connect,"ax",@progbits
 444               	.global	uip_connect
 446               	uip_connect:
 447               	.LFB13:
 401:Lib/uip/uip.c ****   register struct uip_conn *conn, *cconn;
 448               		.loc 1 401 0
 449               		.cfi_startproc
 450               	.LVL39:
 451 0000 CF93      		push r28
 452               	.LCFI2:
 453               		.cfi_def_cfa_offset 3
 454               		.cfi_offset 28, -2
 455 0002 DF93      		push r29
 456               	.LCFI3:
 457               		.cfi_def_cfa_offset 4
 458               		.cfi_offset 29, -3
 459               	/* prologue: function */
 460               	/* frame size = 0 */
 461               	/* stack size = 2 */
 462               	.L__stack_usage = 2
 463 0004 EC01      		movw r28,r24
 464               	.L30:
 465 0006 2091 0000 		lds r18,lastport
 466 000a 3091 0000 		lds r19,lastport+1
 467               	.LVL40:
 468               	.L34:
 406:Lib/uip/uip.c **** 
 469               		.loc 1 406 0
 470 000e 2F5F      		subi r18,-1
 471 0010 3F4F      		sbci r19,-1
 408:Lib/uip/uip.c ****     lastport = 4096;
 472               		.loc 1 408 0
 473 0012 2115      		cp r18,__zero_reg__
 474 0014 8DE7      		ldi r24,125
 475 0016 3807      		cpc r19,r24
 476 0018 00F0      		brlo .L31
 409:Lib/uip/uip.c ****   }
 477               		.loc 1 409 0
 478 001a 20E0      		ldi r18,0
 479 001c 30E1      		ldi r19,lo8(16)
 480               	.L31:
 481               	.LBB20:
 482               	.LBB21:
 483               		.loc 1 1915 0
 484 001e 522F      		mov r21,r18
 485 0020 432F      		mov r20,r19
 486 0022 E0E0      		ldi r30,lo8(uip_conns)
 487 0024 F0E0      		ldi r31,hi8(uip_conns)
 488               	.LBE21:
 489               	.LBE20:
 414:Lib/uip/uip.c ****     conn = &uip_conns[c];
 490               		.loc 1 414 0
 491 0026 90E0      		ldi r25,0
 492               	.L32:
 414:Lib/uip/uip.c ****     conn = &uip_conns[c];
 493               		.loc 1 414 0 is_stmt 0 discriminator 1
 494 0028 9330      		cpi r25,lo8(3)
 495 002a 01F0      		breq .L52
 496               	.LVL41:
 416:Lib/uip/uip.c ****        conn->lport == htons(lastport)) {
 497               		.loc 1 416 0 is_stmt 1
 498 002c 818D      		ldd r24,Z+25
 499 002e 8823      		tst r24
 500 0030 01F0      		breq .L33
 416:Lib/uip/uip.c ****        conn->lport == htons(lastport)) {
 501               		.loc 1 416 0 is_stmt 0 discriminator 1
 502 0032 A481      		ldd r26,Z+4
 503 0034 B581      		ldd r27,Z+5
 504 0036 A417      		cp r26,r20
 505 0038 B507      		cpc r27,r21
 506 003a 01F0      		breq .L34
 507               	.L33:
 508 003c 9F5F      		subi r25,lo8(-(1))
 509               	.LVL42:
 510 003e EF58      		subi r30,-113
 511 0040 FF4F      		sbci r31,-1
 512 0042 00C0      		rjmp .L32
 513               	.LVL43:
 514               	.L52:
 515 0044 3093 0000 		sts lastport+1,r19
 516 0048 2093 0000 		sts lastport,r18
 517               	.LVL44:
 423:Lib/uip/uip.c ****     cconn = &uip_conns[c];
 518               		.loc 1 423 0 is_stmt 1
 519 004c 1092 0000 		sts c,__zero_reg__
 520 0050 90E0      		ldi r25,0
 422:Lib/uip/uip.c ****   for(c = 0; c < UIP_CONNS; ++c) {
 521               		.loc 1 422 0
 522 0052 E0E0      		ldi r30,0
 523 0054 F0E0      		ldi r31,0
 424:Lib/uip/uip.c ****     if(cconn->tcpstateflags == UIP_CLOSED) {
 524               		.loc 1 424 0
 525 0056 21E7      		ldi r18,lo8(113)
 526               	.LVL45:
 527               	.L36:
 423:Lib/uip/uip.c ****     cconn = &uip_conns[c];
 528               		.loc 1 423 0 discriminator 1
 529 0058 9330      		cpi r25,lo8(3)
 530 005a 01F0      		breq .L53
 424:Lib/uip/uip.c ****     if(cconn->tcpstateflags == UIP_CLOSED) {
 531               		.loc 1 424 0
 532 005c 299F      		mul r18,r25
 533 005e D001      		movw r26,r0
 534 0060 1124      		clr __zero_reg__
 535 0062 A050      		subi r26,lo8(-(uip_conns))
 536 0064 B040      		sbci r27,hi8(-(uip_conns))
 537               	.LVL46:
 425:Lib/uip/uip.c ****       conn = cconn;
 538               		.loc 1 425 0
 539 0066 5996      		adiw r26,25
 540 0068 8C91      		ld r24,X
 541 006a 5997      		sbiw r26,25
 542 006c 8111      		cpse r24,__zero_reg__
 543 006e 00C0      		rjmp .L37
 544 0070 9093 0000 		sts c,r25
 424:Lib/uip/uip.c ****     if(cconn->tcpstateflags == UIP_CLOSED) {
 545               		.loc 1 424 0
 546 0074 FD01      		movw r30,r26
 547               	.LVL47:
 548 0076 00C0      		rjmp .L38
 549               	.LVL48:
 550               	.L37:
 429:Lib/uip/uip.c ****       if(conn == 0 ||
 551               		.loc 1 429 0
 552 0078 8730      		cpi r24,lo8(7)
 553 007a 01F4      		brne .L43
 430:Lib/uip/uip.c **** 	 cconn->timer > conn->timer) {
 554               		.loc 1 430 0
 555 007c 3097      		sbiw r30,0
 556 007e 01F0      		breq .L39
 430:Lib/uip/uip.c **** 	 cconn->timer > conn->timer) {
 557               		.loc 1 430 0 is_stmt 0 discriminator 1
 558 0080 5A96      		adiw r26,26
 559 0082 3C91      		ld r19,X
 560 0084 5A97      		sbiw r26,26
 561 0086 828D      		ldd r24,Z+26
 562 0088 8317      		cp r24,r19
 563 008a 00F0      		brlo .L39
 564               	.L43:
 565 008c DF01      		movw r26,r30
 566               	.LVL49:
 567               	.L39:
 568 008e 9F5F      		subi r25,lo8(-(1))
 569               	.LVL50:
 422:Lib/uip/uip.c ****   for(c = 0; c < UIP_CONNS; ++c) {
 570               		.loc 1 422 0 is_stmt 1 discriminator 2
 571 0090 FD01      		movw r30,r26
 572 0092 00C0      		rjmp .L36
 573               	.LVL51:
 574               	.L53:
 575 0094 9093 0000 		sts c,r25
 437:Lib/uip/uip.c ****     return 0;
 576               		.loc 1 437 0
 577 0098 3097      		sbiw r30,0
 578 009a 01F0      		breq .L44
 579               	.LVL52:
 580               	.L38:
 441:Lib/uip/uip.c **** 
 581               		.loc 1 441 0
 582 009c 82E0      		ldi r24,lo8(2)
 583 009e 818F      		std Z+25,r24
 443:Lib/uip/uip.c ****   conn->snd_nxt[1] = iss[1];
 584               		.loc 1 443 0
 585 00a0 8091 0000 		lds r24,iss
 586 00a4 8487      		std Z+12,r24
 444:Lib/uip/uip.c ****   conn->snd_nxt[2] = iss[2];
 587               		.loc 1 444 0
 588 00a6 8091 0000 		lds r24,iss+1
 589 00aa 8587      		std Z+13,r24
 445:Lib/uip/uip.c ****   conn->snd_nxt[3] = iss[3];
 590               		.loc 1 445 0
 591 00ac 8091 0000 		lds r24,iss+2
 592 00b0 8687      		std Z+14,r24
 446:Lib/uip/uip.c **** 
 593               		.loc 1 446 0
 594 00b2 8091 0000 		lds r24,iss+3
 595 00b6 8787      		std Z+15,r24
 448:Lib/uip/uip.c **** 
 596               		.loc 1 448 0
 597 00b8 24EB      		ldi r18,lo8(-76)
 598 00ba 35E0      		ldi r19,lo8(5)
 599 00bc 338B      		std Z+19,r19
 600 00be 228B      		std Z+18,r18
 601 00c0 358B      		std Z+21,r19
 602 00c2 248B      		std Z+20,r18
 450:Lib/uip/uip.c ****   conn->nrtx = 0;
 603               		.loc 1 450 0
 604 00c4 81E0      		ldi r24,lo8(1)
 605 00c6 90E0      		ldi r25,0
 606 00c8 918B      		std Z+17,r25
 607 00ca 808B      		std Z+16,r24
 451:Lib/uip/uip.c ****   conn->timer = 1; /* Send the SYN next time around. */
 608               		.loc 1 451 0
 609 00cc 138E      		std Z+27,__zero_reg__
 452:Lib/uip/uip.c ****   conn->rto = UIP_RTO;
 610               		.loc 1 452 0
 611 00ce 828F      		std Z+26,r24
 453:Lib/uip/uip.c ****   conn->sa = 0;
 612               		.loc 1 453 0
 613 00d0 83E0      		ldi r24,lo8(3)
 614 00d2 808F      		std Z+24,r24
 454:Lib/uip/uip.c ****   conn->sv = 16;   /* Initial value of the RTT variance. */
 615               		.loc 1 454 0
 616 00d4 168A      		std Z+22,__zero_reg__
 455:Lib/uip/uip.c ****   conn->lport = htons(lastport);
 617               		.loc 1 455 0
 618 00d6 80E1      		ldi r24,lo8(16)
 619 00d8 878B      		std Z+23,r24
 456:Lib/uip/uip.c ****   conn->rport = rport;
 620               		.loc 1 456 0
 621 00da 5583      		std Z+5,r21
 622 00dc 4483      		std Z+4,r20
 457:Lib/uip/uip.c ****   uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 623               		.loc 1 457 0
 624 00de 7783      		std Z+7,r23
 625 00e0 6683      		std Z+6,r22
 458:Lib/uip/uip.c **** 
 626               		.loc 1 458 0
 627 00e2 8881      		ld r24,Y
 628 00e4 9981      		ldd r25,Y+1
 629 00e6 AA81      		ldd r26,Y+2
 630 00e8 BB81      		ldd r27,Y+3
 631 00ea 8083      		st Z,r24
 632 00ec 9183      		std Z+1,r25
 633 00ee A283      		std Z+2,r26
 634 00f0 B383      		std Z+3,r27
 460:Lib/uip/uip.c **** }
 635               		.loc 1 460 0
 636 00f2 CF01      		movw r24,r30
 637 00f4 00C0      		rjmp .L41
 638               	.L44:
 438:Lib/uip/uip.c ****   }
 639               		.loc 1 438 0
 640 00f6 80E0      		ldi r24,0
 641 00f8 90E0      		ldi r25,0
 642               	.L41:
 643               	/* epilogue start */
 461:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 644               		.loc 1 461 0
 645 00fa DF91      		pop r29
 646 00fc CF91      		pop r28
 647               	.LVL53:
 648 00fe 0895      		ret
 649               		.cfi_endproc
 650               	.LFE13:
 652               		.section	.text.uip_udp_new,"ax",@progbits
 653               	.global	uip_udp_new
 655               	uip_udp_new:
 656               	.LFB14:
 467:Lib/uip/uip.c ****   register struct uip_udp_conn *conn;
 657               		.loc 1 467 0
 658               		.cfi_startproc
 659               	.LVL54:
 660               	/* prologue: function */
 661               	/* frame size = 0 */
 662               	/* stack size = 0 */
 663               	.L__stack_usage = 0
 664               	.L55:
 665 0000 2091 0000 		lds r18,lastport
 666 0004 3091 0000 		lds r19,lastport+1
 479:Lib/uip/uip.c ****       goto again;
 667               		.loc 1 479 0
 668 0008 E091 0000 		lds r30,uip_udp_conns+4
 669 000c F091 0000 		lds r31,uip_udp_conns+4+1
 670               	.L57:
 472:Lib/uip/uip.c **** 
 671               		.loc 1 472 0
 672 0010 2F5F      		subi r18,-1
 673 0012 3F4F      		sbci r19,-1
 474:Lib/uip/uip.c ****     lastport = 4096;
 674               		.loc 1 474 0
 675 0014 2115      		cp r18,__zero_reg__
 676 0016 4DE7      		ldi r20,125
 677 0018 3407      		cpc r19,r20
 678 001a 00F0      		brlo .L56
 475:Lib/uip/uip.c ****   }
 679               		.loc 1 475 0
 680 001c 20E0      		ldi r18,0
 681 001e 30E1      		ldi r19,lo8(16)
 682               	.L56:
 683               	.LBB24:
 684               	.LBB25:
 685               		.loc 1 1915 0
 686 0020 522F      		mov r21,r18
 687 0022 432F      		mov r20,r19
 688               	.LBE25:
 689               	.LBE24:
 479:Lib/uip/uip.c ****       goto again;
 690               		.loc 1 479 0
 691 0024 E417      		cp r30,r20
 692 0026 F507      		cpc r31,r21
 693 0028 01F0      		breq .L57
 694 002a 3093 0000 		sts lastport+1,r19
 695 002e 2093 0000 		sts lastport,r18
 696               	.LVL55:
 487:Lib/uip/uip.c ****       conn = &uip_udp_conns[c];
 697               		.loc 1 487 0
 698 0032 EF2B      		or r30,r31
 699 0034 01F0      		breq .L71
 700 0036 81E0      		ldi r24,lo8(1)
 701               	.LVL56:
 702 0038 8093 0000 		sts c,r24
 494:Lib/uip/uip.c ****   }
 703               		.loc 1 494 0
 704 003c 80E0      		ldi r24,0
 705 003e 90E0      		ldi r25,0
 706 0040 0895      		ret
 707               	.LVL57:
 708               	.L71:
 709 0042 1092 0000 		sts c,__zero_reg__
 710               	.LVL58:
 497:Lib/uip/uip.c ****   conn->rport = rport;
 711               		.loc 1 497 0
 712 0046 5093 0000 		sts uip_udp_conns+4+1,r21
 713 004a 4093 0000 		sts uip_udp_conns+4,r20
 498:Lib/uip/uip.c ****   if(ripaddr == NULL) {
 714               		.loc 1 498 0
 715 004e 7093 0000 		sts uip_udp_conns+6+1,r23
 716 0052 6093 0000 		sts uip_udp_conns+6,r22
 499:Lib/uip/uip.c ****     memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
 717               		.loc 1 499 0
 718 0056 0097      		sbiw r24,0
 719 0058 01F4      		brne .L69
 500:Lib/uip/uip.c ****   } else {
 720               		.loc 1 500 0
 721 005a E0E0      		ldi r30,lo8(uip_udp_conns)
 722 005c F0E0      		ldi r31,hi8(uip_udp_conns)
 723 005e 84E0      		ldi r24,lo8(4)
 724               	.LVL59:
 725 0060 DF01      		movw r26,r30
 726               		0:
 727 0062 1D92      		st X+,__zero_reg__
 728 0064 8A95      		dec r24
 729 0066 01F4      		brne 0b
 730 0068 00C0      		rjmp .L60
 731               	.LVL60:
 732               	.L69:
 502:Lib/uip/uip.c ****   }
 733               		.loc 1 502 0
 734 006a FC01      		movw r30,r24
 735 006c 8081      		ld r24,Z
 736 006e 9181      		ldd r25,Z+1
 737 0070 A281      		ldd r26,Z+2
 738 0072 B381      		ldd r27,Z+3
 739               	.LVL61:
 740 0074 8093 0000 		sts uip_udp_conns,r24
 741 0078 9093 0000 		sts uip_udp_conns+1,r25
 742 007c A093 0000 		sts uip_udp_conns+2,r26
 743 0080 B093 0000 		sts uip_udp_conns+3,r27
 744               	.LVL62:
 745               	.L60:
 504:Lib/uip/uip.c **** 
 746               		.loc 1 504 0
 747 0084 80E4      		ldi r24,lo8(64)
 748 0086 8093 0000 		sts uip_udp_conns+8,r24
 488:Lib/uip/uip.c ****       break;
 749               		.loc 1 488 0
 750 008a 80E0      		ldi r24,lo8(uip_udp_conns)
 751 008c 90E0      		ldi r25,hi8(uip_udp_conns)
 506:Lib/uip/uip.c **** }
 752               		.loc 1 506 0
 753 008e 0895      		ret
 754               		.cfi_endproc
 755               	.LFE14:
 757               		.section	.text.uip_unlisten,"ax",@progbits
 758               	.global	uip_unlisten
 760               	uip_unlisten:
 761               	.LFB15:
 512:Lib/uip/uip.c ****   for(c = 0; c < UIP_LISTENPORTS; ++c) {
 762               		.loc 1 512 0
 763               		.cfi_startproc
 764               	.LVL63:
 765               	/* prologue: function */
 766               	/* frame size = 0 */
 767               	/* stack size = 0 */
 768               	.L__stack_usage = 0
 769 0000 9C01      		movw r18,r24
 513:Lib/uip/uip.c ****     if(uip_listenports[c] == port) {
 770               		.loc 1 513 0
 771 0002 90E0      		ldi r25,0
 772               	.LVL64:
 773               	.L73:
 513:Lib/uip/uip.c ****     if(uip_listenports[c] == port) {
 774               		.loc 1 513 0 is_stmt 0 discriminator 1
 775 0004 9530      		cpi r25,lo8(5)
 776 0006 01F0      		breq .L77
 514:Lib/uip/uip.c ****       uip_listenports[c] = 0;
 777               		.loc 1 514 0 is_stmt 1
 778 0008 E92F      		mov r30,r25
 779 000a F0E0      		ldi r31,0
 780 000c 81E0      		ldi r24,lo8(1)
 781 000e 890F      		add r24,r25
 782 0010 EE0F      		lsl r30
 783 0012 FF1F      		rol r31
 784 0014 E050      		subi r30,lo8(-(uip_listenports))
 785 0016 F040      		sbci r31,hi8(-(uip_listenports))
 786 0018 4081      		ld r20,Z
 787 001a 5181      		ldd r21,Z+1
 788 001c 4217      		cp r20,r18
 789 001e 5307      		cpc r21,r19
 790 0020 01F4      		brne .L76
 791 0022 9093 0000 		sts c,r25
 515:Lib/uip/uip.c ****       return;
 792               		.loc 1 515 0
 793 0026 1182      		std Z+1,__zero_reg__
 794 0028 1082      		st Z,__zero_reg__
 516:Lib/uip/uip.c ****     }
 795               		.loc 1 516 0
 796 002a 0895      		ret
 797               	.L76:
 798 002c 982F      		mov r25,r24
 799 002e 00C0      		rjmp .L73
 800               	.L77:
 801 0030 9093 0000 		sts c,r25
 802 0034 0895      		ret
 803               		.cfi_endproc
 804               	.LFE15:
 806               		.section	.text.uip_listen,"ax",@progbits
 807               	.global	uip_listen
 809               	uip_listen:
 810               	.LFB16:
 523:Lib/uip/uip.c ****   for(c = 0; c < UIP_LISTENPORTS; ++c) {
 811               		.loc 1 523 0
 812               		.cfi_startproc
 813               	.LVL65:
 814               	/* prologue: function */
 815               	/* frame size = 0 */
 816               	/* stack size = 0 */
 817               	.L__stack_usage = 0
 818 0000 9C01      		movw r18,r24
 524:Lib/uip/uip.c ****     if(uip_listenports[c] == 0) {
 819               		.loc 1 524 0
 820 0002 90E0      		ldi r25,0
 821               	.LVL66:
 822               	.L79:
 524:Lib/uip/uip.c ****     if(uip_listenports[c] == 0) {
 823               		.loc 1 524 0 is_stmt 0 discriminator 1
 824 0004 9530      		cpi r25,lo8(5)
 825 0006 01F0      		breq .L83
 525:Lib/uip/uip.c ****       uip_listenports[c] = port;
 826               		.loc 1 525 0 is_stmt 1
 827 0008 E92F      		mov r30,r25
 828 000a F0E0      		ldi r31,0
 829 000c 81E0      		ldi r24,lo8(1)
 830 000e 890F      		add r24,r25
 831 0010 EE0F      		lsl r30
 832 0012 FF1F      		rol r31
 833 0014 E050      		subi r30,lo8(-(uip_listenports))
 834 0016 F040      		sbci r31,hi8(-(uip_listenports))
 835 0018 4081      		ld r20,Z
 836 001a 5181      		ldd r21,Z+1
 837 001c 452B      		or r20,r21
 838 001e 01F4      		brne .L82
 839 0020 9093 0000 		sts c,r25
 526:Lib/uip/uip.c ****       return;
 840               		.loc 1 526 0
 841 0024 3183      		std Z+1,r19
 842 0026 2083      		st Z,r18
 527:Lib/uip/uip.c ****     }
 843               		.loc 1 527 0
 844 0028 0895      		ret
 845               	.L82:
 846 002a 982F      		mov r25,r24
 847 002c 00C0      		rjmp .L79
 848               	.L83:
 849 002e 9093 0000 		sts c,r25
 850 0032 0895      		ret
 851               		.cfi_endproc
 852               	.LFE16:
 854               		.section	.text.uip_process,"ax",@progbits
 855               	.global	uip_process
 857               	uip_process:
 858               	.LFB18:
 676:Lib/uip/uip.c ****   register struct uip_conn *uip_connr = uip_conn;
 859               		.loc 1 676 0
 860               		.cfi_startproc
 861               	.LVL67:
 862 0000 AF92      		push r10
 863               	.LCFI4:
 864               		.cfi_def_cfa_offset 3
 865               		.cfi_offset 10, -2
 866 0002 BF92      		push r11
 867               	.LCFI5:
 868               		.cfi_def_cfa_offset 4
 869               		.cfi_offset 11, -3
 870 0004 CF92      		push r12
 871               	.LCFI6:
 872               		.cfi_def_cfa_offset 5
 873               		.cfi_offset 12, -4
 874 0006 DF92      		push r13
 875               	.LCFI7:
 876               		.cfi_def_cfa_offset 6
 877               		.cfi_offset 13, -5
 878 0008 EF92      		push r14
 879               	.LCFI8:
 880               		.cfi_def_cfa_offset 7
 881               		.cfi_offset 14, -6
 882 000a FF92      		push r15
 883               	.LCFI9:
 884               		.cfi_def_cfa_offset 8
 885               		.cfi_offset 15, -7
 886 000c 0F93      		push r16
 887               	.LCFI10:
 888               		.cfi_def_cfa_offset 9
 889               		.cfi_offset 16, -8
 890 000e 1F93      		push r17
 891               	.LCFI11:
 892               		.cfi_def_cfa_offset 10
 893               		.cfi_offset 17, -9
 894 0010 CF93      		push r28
 895               	.LCFI12:
 896               		.cfi_def_cfa_offset 11
 897               		.cfi_offset 28, -10
 898 0012 DF93      		push r29
 899               	.LCFI13:
 900               		.cfi_def_cfa_offset 12
 901               		.cfi_offset 29, -11
 902               	/* prologue: function */
 903               	/* frame size = 0 */
 904               	/* stack size = 10 */
 905               	.L__stack_usage = 10
 906               	.LVL68:
 680:Lib/uip/uip.c ****     goto udp_send;
 907               		.loc 1 680 0
 908 0014 8430      		cpi r24,lo8(4)
 909 0016 01F4      		brne .+2
 910 0018 00C0      		rjmp .L85
 677:Lib/uip/uip.c **** 
 911               		.loc 1 677 0
 912 001a C091 0000 		lds r28,uip_conn
 913 001e D091 0000 		lds r29,uip_conn+1
 685:Lib/uip/uip.c **** 
 914               		.loc 1 685 0
 915 0022 20E0      		ldi r18,lo8(uip_buf+54)
 916 0024 30E0      		ldi r19,hi8(uip_buf+54)
 917 0026 3093 0000 		sts uip_appdata+1,r19
 918 002a 2093 0000 		sts uip_appdata,r18
 919 002e 3093 0000 		sts uip_sappdata+1,r19
 920 0032 2093 0000 		sts uip_sappdata,r18
 689:Lib/uip/uip.c ****     if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
 921               		.loc 1 689 0
 922 0036 8330      		cpi r24,lo8(3)
 923 0038 01F4      		brne .L86
 690:Lib/uip/uip.c ****        !uip_outstanding(uip_connr)) {
 924               		.loc 1 690 0
 925 003a 898D      		ldd r24,Y+25
 926               	.LVL69:
 927 003c 8F70      		andi r24,lo8(15)
 928 003e 8330      		cpi r24,lo8(3)
 929 0040 01F0      		breq .+2
 930 0042 00C0      		rjmp .L94
 690:Lib/uip/uip.c ****        !uip_outstanding(uip_connr)) {
 931               		.loc 1 690 0 is_stmt 0 discriminator 1
 932 0044 8889      		ldd r24,Y+16
 933 0046 9989      		ldd r25,Y+17
 934 0048 892B      		or r24,r25
 935 004a 01F0      		breq .+2
 936 004c 00C0      		rjmp .L94
 692:Lib/uip/uip.c **** 	uip_flags = UIP_POLL;
 937               		.loc 1 692 0 is_stmt 1
 938 004e 1092 0000 		sts uip_slen+1,__zero_reg__
 939 0052 1092 0000 		sts uip_slen,__zero_reg__
 940 0056 1092 0000 		sts uip_len+1,__zero_reg__
 941 005a 1092 0000 		sts uip_len,__zero_reg__
 942 005e 00C0      		rjmp .L325
 943               	.LVL70:
 944               	.L86:
 700:Lib/uip/uip.c **** #if UIP_REASSEMBLY
 945               		.loc 1 700 0
 946 0060 8230      		cpi r24,lo8(2)
 947 0062 01F0      		breq .+2
 948 0064 00C0      		rjmp .L89
 707:Lib/uip/uip.c ****       if(++iss[2] == 0) {
 949               		.loc 1 707 0
 950 0066 8091 0000 		lds r24,iss+3
 951               	.LVL71:
 952 006a 8F5F      		subi r24,lo8(-(1))
 953 006c 8093 0000 		sts iss+3,r24
 954 0070 8111      		cpse r24,__zero_reg__
 955 0072 00C0      		rjmp .L91
 708:Lib/uip/uip.c **** 	if(++iss[1] == 0) {
 956               		.loc 1 708 0
 957 0074 8091 0000 		lds r24,iss+2
 958 0078 8F5F      		subi r24,lo8(-(1))
 959 007a 8093 0000 		sts iss+2,r24
 960 007e 8111      		cpse r24,__zero_reg__
 961 0080 00C0      		rjmp .L91
 709:Lib/uip/uip.c **** 	  ++iss[0];
 962               		.loc 1 709 0
 963 0082 8091 0000 		lds r24,iss+1
 964 0086 8F5F      		subi r24,lo8(-(1))
 965 0088 8093 0000 		sts iss+1,r24
 966 008c 8111      		cpse r24,__zero_reg__
 967 008e 00C0      		rjmp .L91
 710:Lib/uip/uip.c **** 	}
 968               		.loc 1 710 0
 969 0090 8091 0000 		lds r24,iss
 970 0094 8F5F      		subi r24,lo8(-(1))
 971 0096 8093 0000 		sts iss,r24
 972               	.L91:
 716:Lib/uip/uip.c ****     uip_slen = 0;
 973               		.loc 1 716 0
 974 009a 1092 0000 		sts uip_len+1,__zero_reg__
 975 009e 1092 0000 		sts uip_len,__zero_reg__
 717:Lib/uip/uip.c **** 
 976               		.loc 1 717 0
 977 00a2 1092 0000 		sts uip_slen+1,__zero_reg__
 978 00a6 1092 0000 		sts uip_slen,__zero_reg__
 723:Lib/uip/uip.c ****        uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
 979               		.loc 1 723 0
 980 00aa 898D      		ldd r24,Y+25
 981 00ac 982F      		mov r25,r24
 982 00ae 9D7F      		andi r25,lo8(-3)
 983 00b0 9530      		cpi r25,lo8(5)
 984 00b2 01F4      		brne .L93
 725:Lib/uip/uip.c ****       if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 985               		.loc 1 725 0
 986 00b4 8A8D      		ldd r24,Y+26
 987 00b6 8F5F      		subi r24,lo8(-(1))
 988 00b8 8A8F      		std Y+26,r24
 726:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_CLOSED;
 989               		.loc 1 726 0
 990 00ba 8837      		cpi r24,lo8(120)
 991 00bc 01F0      		breq .+2
 992 00be 00C0      		rjmp .L94
 727:Lib/uip/uip.c ****       }
 993               		.loc 1 727 0
 994 00c0 198E      		std Y+25,__zero_reg__
 995 00c2 00C0      		rjmp .L94
 996               	.L93:
 729:Lib/uip/uip.c ****       /* If the connection has outstanding data, we increase the
 997               		.loc 1 729 0
 998 00c4 8823      		tst r24
 999 00c6 01F4      		brne .+2
 1000 00c8 00C0      		rjmp .L94
 733:Lib/uip/uip.c **** 	if(uip_connr->timer-- == 0) {
 1001               		.loc 1 733 0
 1002 00ca 2889      		ldd r18,Y+16
 1003 00cc 3989      		ldd r19,Y+17
 1004 00ce 232B      		or r18,r19
 1005 00d0 01F4      		brne .+2
 1006 00d2 00C0      		rjmp .L95
 734:Lib/uip/uip.c **** 	  if(uip_connr->nrtx == UIP_MAXRTX ||
 1007               		.loc 1 734 0
 1008 00d4 9A8D      		ldd r25,Y+26
 1009 00d6 2FEF      		ldi r18,lo8(-1)
 1010 00d8 290F      		add r18,r25
 1011 00da 2A8F      		std Y+26,r18
 1012 00dc 9111      		cpse r25,__zero_reg__
 1013 00de 00C0      		rjmp .L94
 735:Lib/uip/uip.c **** 	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
 1014               		.loc 1 735 0
 1015 00e0 9B8D      		ldd r25,Y+27
 1016 00e2 9830      		cpi r25,lo8(8)
 1017 00e4 01F0      		breq .L96
 735:Lib/uip/uip.c **** 	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
 1018               		.loc 1 735 0 is_stmt 0 discriminator 1
 1019 00e6 2FEF      		ldi r18,lo8(-1)
 1020 00e8 280F      		add r18,r24
 1021 00ea 2230      		cpi r18,lo8(2)
 1022 00ec 00F4      		brsh .L97
 737:Lib/uip/uip.c **** 	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
 1023               		.loc 1 737 0 is_stmt 1
 1024 00ee 9530      		cpi r25,lo8(5)
 1025 00f0 01F4      		brne .L97
 1026               	.L96:
 739:Lib/uip/uip.c **** 
 1027               		.loc 1 739 0
 1028 00f2 198E      		std Y+25,__zero_reg__
 744:Lib/uip/uip.c **** 	    UIP_APPCALL();
 1029               		.loc 1 744 0
 1030 00f4 80E8      		ldi r24,lo8(-128)
 1031 00f6 8093 0000 		sts uip_flags,r24
 745:Lib/uip/uip.c **** 
 1032               		.loc 1 745 0
 1033 00fa 0E94 0000 		call uIPManagement_TCPCallback
 1034               	.LVL72:
 1035 00fe 00C0      		rjmp .L326
 1036               	.L97:
 753:Lib/uip/uip.c **** 					 4:
 1037               		.loc 1 753 0
 1038 0100 9530      		cpi r25,lo8(5)
 1039 0102 00F4      		brsh .L206
 753:Lib/uip/uip.c **** 					 4:
 1040               		.loc 1 753 0 is_stmt 0 discriminator 1
 1041 0104 23E0      		ldi r18,lo8(3)
 1042 0106 30E0      		ldi r19,0
 1043 0108 092E      		mov r0,r25
 1044 010a 00C0      		rjmp 2f
 1045               		1:
 1046 010c 220F      		lsl r18
 1047               		2:
 1048 010e 0A94      		dec r0
 1049 0110 02F4      		brpl 1b
 1050 0112 00C0      		rjmp .L99
 1051               	.L206:
 753:Lib/uip/uip.c **** 					 4:
 1052               		.loc 1 753 0
 1053 0114 20E3      		ldi r18,lo8(48)
 1054               	.L99:
 753:Lib/uip/uip.c **** 					 4:
 1055               		.loc 1 753 0 discriminator 4
 1056 0116 2A8F      		std Y+26,r18
 756:Lib/uip/uip.c **** 
 1057               		.loc 1 756 0 is_stmt 1 discriminator 4
 1058 0118 9F5F      		subi r25,lo8(-(1))
 1059 011a 9B8F      		std Y+27,r25
 765:Lib/uip/uip.c **** 	  case UIP_SYN_RCVD:
 1060               		.loc 1 765 0 discriminator 4
 1061 011c 8F70      		andi r24,lo8(15)
 1062 011e 8330      		cpi r24,lo8(3)
 1063 0120 01F0      		breq .L100
 1064 0122 00F4      		brsh .L101
 1065 0124 8130      		cpi r24,lo8(1)
 1066 0126 01F4      		brne .+2
 1067 0128 00C0      		rjmp .L102
 1068 012a 8230      		cpi r24,lo8(2)
 1069 012c 01F0      		breq .+2
 1070 012e 00C0      		rjmp .L94
 774:Lib/uip/uip.c **** 	    goto tcp_send_syn;
 1071               		.loc 1 774 0
 1072 0130 1092 0000 		sts uip_buf+47,__zero_reg__
 775:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 1073               		.loc 1 775 0
 1074 0134 00C0      		rjmp .L105
 1075               	.L101:
 765:Lib/uip/uip.c **** 	  case UIP_SYN_RCVD:
 1076               		.loc 1 765 0 discriminator 4
 1077 0136 8630      		cpi r24,lo8(6)
 1078 0138 01F4      		brne .+2
 1079 013a 00C0      		rjmp .L104
 1080 013c 8830      		cpi r24,lo8(8)
 1081 013e 01F4      		brne .+2
 1082 0140 00C0      		rjmp .L104
 1083 0142 8430      		cpi r24,lo8(4)
 1084 0144 01F0      		breq .+2
 1085 0146 00C0      		rjmp .L94
 1086 0148 00C0      		rjmp .L104
 1087               	.L100:
 783:Lib/uip/uip.c **** 	    UIP_APPCALL();
 1088               		.loc 1 783 0
 1089 014a 84E0      		ldi r24,lo8(4)
 1090 014c 8093 0000 		sts uip_flags,r24
 784:Lib/uip/uip.c **** 	    goto apprexmit;
 1091               		.loc 1 784 0
 1092 0150 0E94 0000 		call uIPManagement_TCPCallback
 1093               	.LVL73:
 785:Lib/uip/uip.c **** 
 1094               		.loc 1 785 0
 1095 0154 00C0      		rjmp .L106
 1096               	.L95:
 795:Lib/uip/uip.c **** 	/* If there was no need for a retransmission, we poll the
 1097               		.loc 1 795 0
 1098 0156 8F70      		andi r24,lo8(15)
 1099 0158 8330      		cpi r24,lo8(3)
 1100 015a 01F0      		breq .+2
 1101 015c 00C0      		rjmp .L94
 1102               	.L325:
 799:Lib/uip/uip.c **** 	UIP_APPCALL();
 1103               		.loc 1 799 0
 1104 015e 88E0      		ldi r24,lo8(8)
 1105 0160 8093 0000 		sts uip_flags,r24
 1106 0164 00C0      		rjmp .L317
 1107               	.LVL74:
 1108               	.L89:
 807:Lib/uip/uip.c ****     if(uip_udp_conn->lport != 0) {
 1109               		.loc 1 807 0
 1110 0166 8530      		cpi r24,lo8(5)
 1111 0168 01F4      		brne .L107
 808:Lib/uip/uip.c ****       uip_conn = NULL;
 1112               		.loc 1 808 0
 1113 016a E091 0000 		lds r30,uip_udp_conn
 1114 016e F091 0000 		lds r31,uip_udp_conn+1
 1115 0172 8481      		ldd r24,Z+4
 1116 0174 9581      		ldd r25,Z+5
 1117               	.LVL75:
 1118 0176 892B      		or r24,r25
 1119 0178 01F4      		brne .+2
 1120 017a 00C0      		rjmp .L94
 809:Lib/uip/uip.c ****       uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 1121               		.loc 1 809 0
 1122 017c 1092 0000 		sts uip_conn+1,__zero_reg__
 1123 0180 1092 0000 		sts uip_conn,__zero_reg__
 810:Lib/uip/uip.c ****       uip_len = uip_slen = 0;
 1124               		.loc 1 810 0
 1125 0184 80E0      		ldi r24,lo8(uip_buf+42)
 1126 0186 90E0      		ldi r25,hi8(uip_buf+42)
 1127 0188 9093 0000 		sts uip_appdata+1,r25
 1128 018c 8093 0000 		sts uip_appdata,r24
 1129 0190 9093 0000 		sts uip_sappdata+1,r25
 1130 0194 8093 0000 		sts uip_sappdata,r24
 811:Lib/uip/uip.c ****       uip_flags = UIP_POLL;
 1131               		.loc 1 811 0
 1132 0198 1092 0000 		sts uip_slen+1,__zero_reg__
 1133 019c 1092 0000 		sts uip_slen,__zero_reg__
 1134 01a0 1092 0000 		sts uip_len+1,__zero_reg__
 1135 01a4 1092 0000 		sts uip_len,__zero_reg__
 812:Lib/uip/uip.c ****       UIP_UDP_APPCALL();
 1136               		.loc 1 812 0
 1137 01a8 88E0      		ldi r24,lo8(8)
 1138 01aa 8093 0000 		sts uip_flags,r24
 1139 01ae 00C0      		rjmp .L314
 1140               	.LVL76:
 1141               	.L107:
 836:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.ip.drop);
 1142               		.loc 1 836 0
 1143 01b0 8091 0000 		lds r24,uip_buf+14
 1144               	.LVL77:
 1145 01b4 8534      		cpi r24,lo8(69)
 1146 01b6 01F0      		breq .+2
 1147 01b8 00C0      		rjmp .L94
 851:Lib/uip/uip.c ****     uip_len = (BUF->len[0] << 8) + BUF->len[1];
 1148               		.loc 1 851 0
 1149 01ba 0091 0000 		lds r16,uip_buf+16
 1150 01be 10E0      		ldi r17,0
 1151 01c0 102F      		mov r17,r16
 1152 01c2 0027      		clr r16
 1153 01c4 8091 0000 		lds r24,uip_buf+17
 1154 01c8 080F      		add r16,r24
 1155 01ca 111D      		adc r17,__zero_reg__
 1156 01cc 8091 0000 		lds r24,uip_len
 1157 01d0 9091 0000 		lds r25,uip_len+1
 1158 01d4 8017      		cp r24,r16
 1159 01d6 9107      		cpc r25,r17
 1160 01d8 00F4      		brsh .+2
 1161 01da 00C0      		rjmp .L94
 852:Lib/uip/uip.c **** #if UIP_CONF_IPV6
 1162               		.loc 1 852 0
 1163 01dc 1093 0000 		sts uip_len+1,r17
 1164 01e0 0093 0000 		sts uip_len,r16
 871:Lib/uip/uip.c ****      BUF->ipoffset[1] != 0) {
 1165               		.loc 1 871 0
 1166 01e4 8091 0000 		lds r24,uip_buf+20
 1167 01e8 8F73      		andi r24,lo8(63)
 1168 01ea 01F0      		breq .+2
 1169 01ec 00C0      		rjmp .L94
 872:Lib/uip/uip.c **** #if UIP_REASSEMBLY
 1170               		.loc 1 872 0 discriminator 1
 1171 01ee F090 0000 		lds r15,uip_buf+21
 871:Lib/uip/uip.c ****      BUF->ipoffset[1] != 0) {
 1172               		.loc 1 871 0 discriminator 1
 1173 01f2 F110      		cpse r15,__zero_reg__
 1174 01f4 00C0      		rjmp .L94
 887:Lib/uip/uip.c ****     /* If we are configured to use ping IP address configuration and
 1175               		.loc 1 887 0
 1176 01f6 2091 0000 		lds r18,uip_hostaddr
 1177 01fa 3091 0000 		lds r19,uip_hostaddr+1
 1178 01fe C091 0000 		lds r28,uip_all_zeroes_addr
 1179 0202 D091 0000 		lds r29,uip_all_zeroes_addr+1
 1180               	.LVL78:
 1181 0206 2C17      		cp r18,r28
 1182 0208 3D07      		cpc r19,r29
 1183 020a 01F4      		brne .L108
 887:Lib/uip/uip.c ****     /* If we are configured to use ping IP address configuration and
 1184               		.loc 1 887 0 is_stmt 0 discriminator 1
 1185 020c 4091 0000 		lds r20,uip_hostaddr+2
 1186 0210 5091 0000 		lds r21,uip_hostaddr+2+1
 1187 0214 8091 0000 		lds r24,uip_all_zeroes_addr+2
 1188 0218 9091 0000 		lds r25,uip_all_zeroes_addr+2+1
 1189 021c 4817      		cp r20,r24
 1190 021e 5907      		cpc r21,r25
 1191 0220 01F4      		brne .+2
 1192 0222 00C0      		rjmp .L109
 1193               	.L108:
 906:Lib/uip/uip.c ****        uip_ipaddr_cmp(&BUF->destipaddr, &uip_broadcast_addr))
 1194               		.loc 1 906 0 is_stmt 1
 1195 0224 4091 0000 		lds r20,uip_buf+23
 1196 0228 8091 0000 		lds r24,uip_buf+30
 1197 022c 9091 0000 		lds r25,uip_buf+30+1
 1198 0230 4131      		cpi r20,lo8(17)
 1199 0232 01F4      		brne .L110
 906:Lib/uip/uip.c ****        uip_ipaddr_cmp(&BUF->destipaddr, &uip_broadcast_addr))
 1200               		.loc 1 906 0 is_stmt 0 discriminator 1
 1201 0234 4091 0000 		lds r20,uip_broadcast_addr
 1202 0238 5091 0000 		lds r21,uip_broadcast_addr+1
 1203 023c 8417      		cp r24,r20
 1204 023e 9507      		cpc r25,r21
 1205 0240 01F4      		brne .L110
 907:Lib/uip/uip.c **** 	{
 1206               		.loc 1 907 0 is_stmt 1
 1207 0242 6091 0000 		lds r22,uip_buf+32
 1208 0246 7091 0000 		lds r23,uip_buf+32+1
 1209 024a 4091 0000 		lds r20,uip_broadcast_addr+2
 1210 024e 5091 0000 		lds r21,uip_broadcast_addr+2+1
 1211 0252 6417      		cp r22,r20
 1212 0254 7507      		cpc r23,r21
 1213 0256 01F4      		brne .L110
 909:Lib/uip/uip.c **** 		  uip_ipaddr_copy(&BUF->srcipaddr, &uip_broadcast_addr);
 1214               		.loc 1 909 0
 1215 0258 8091 0000 		lds r24,uip_buf+26
 1216 025c 9091 0000 		lds r25,uip_buf+26+1
 1217 0260 C817      		cp r28,r24
 1218 0262 D907      		cpc r29,r25
 1219 0264 01F0      		breq .+2
 1220 0266 00C0      		rjmp .L111
 909:Lib/uip/uip.c **** 		  uip_ipaddr_copy(&BUF->srcipaddr, &uip_broadcast_addr);
 1221               		.loc 1 909 0 is_stmt 0 discriminator 1
 1222 0268 2091 0000 		lds r18,uip_buf+28
 1223 026c 3091 0000 		lds r19,uip_buf+28+1
 1224 0270 8091 0000 		lds r24,uip_all_zeroes_addr+2
 1225 0274 9091 0000 		lds r25,uip_all_zeroes_addr+2+1
 1226 0278 2817      		cp r18,r24
 1227 027a 3907      		cpc r19,r25
 1228 027c 01F0      		breq .+2
 1229 027e 00C0      		rjmp .L111
 910:Lib/uip/uip.c **** 
 1230               		.loc 1 910 0 is_stmt 1
 1231 0280 8091 0000 		lds r24,uip_broadcast_addr
 1232 0284 9091 0000 		lds r25,uip_broadcast_addr+1
 1233 0288 A091 0000 		lds r26,uip_broadcast_addr+2
 1234 028c B091 0000 		lds r27,uip_broadcast_addr+3
 1235 0290 8093 0000 		sts uip_buf+26,r24
 1236 0294 9093 0000 		sts uip_buf+26+1,r25
 1237 0298 A093 0000 		sts uip_buf+26+2,r26
 1238 029c B093 0000 		sts uip_buf+26+3,r27
 1239 02a0 00C0      		rjmp .L111
 1240               	.L110:
 918:Lib/uip/uip.c ****       UIP_STAT(++uip_stat.ip.drop);
 1241               		.loc 1 918 0
 1242 02a2 2817      		cp r18,r24
 1243 02a4 3907      		cpc r19,r25
 1244 02a6 01F0      		breq .+2
 1245 02a8 00C0      		rjmp .L94
 918:Lib/uip/uip.c ****       UIP_STAT(++uip_stat.ip.drop);
 1246               		.loc 1 918 0 is_stmt 0 discriminator 1
 1247 02aa 2091 0000 		lds r18,uip_buf+32
 1248 02ae 3091 0000 		lds r19,uip_buf+32+1
 1249 02b2 8091 0000 		lds r24,uip_hostaddr+2
 1250 02b6 9091 0000 		lds r25,uip_hostaddr+2+1
 1251 02ba 2817      		cp r18,r24
 1252 02bc 3907      		cpc r19,r25
 1253 02be 01F0      		breq .+2
 1254 02c0 00C0      		rjmp .L94
 1255               	.L109:
 937:Lib/uip/uip.c **** 				    checksum. */
 1256               		.loc 1 937 0 is_stmt 1
 1257 02c2 0E94 0000 		call uip_ipchksum
 1258               	.LVL79:
 1259 02c6 0196      		adiw r24,1
 1260 02c8 01F0      		breq .+2
 1261 02ca 00C0      		rjmp .L94
 946:Lib/uip/uip.c **** 				       proceed with TCP input
 1262               		.loc 1 946 0
 1263 02cc 8091 0000 		lds r24,uip_buf+23
 1264 02d0 8630      		cpi r24,lo8(6)
 1265 02d2 01F4      		brne .+2
 1266 02d4 00C0      		rjmp .L112
 953:Lib/uip/uip.c ****     goto udp_input;
 1267               		.loc 1 953 0
 1268 02d6 8131      		cpi r24,lo8(17)
 1269 02d8 01F0      		breq .L111
 960:Lib/uip/uip.c **** 					here. */
 1270               		.loc 1 960 0
 1271 02da 8130      		cpi r24,lo8(1)
 1272 02dc 01F0      		breq .+2
 1273 02de 00C0      		rjmp .L94
 976:Lib/uip/uip.c ****     UIP_STAT(++uip_stat.icmp.drop);
 1274               		.loc 1 976 0
 1275 02e0 8091 0000 		lds r24,uip_buf+34
 1276 02e4 8830      		cpi r24,lo8(8)
 1277 02e6 01F0      		breq .+2
 1278 02e8 00C0      		rjmp .L94
 992:Lib/uip/uip.c **** 
 1279               		.loc 1 992 0
 1280 02ea 1092 0000 		sts uip_buf+34,__zero_reg__
 994:Lib/uip/uip.c ****     ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
 1281               		.loc 1 994 0
 1282 02ee 8091 0000 		lds r24,uip_buf+36
 1283 02f2 9091 0000 		lds r25,uip_buf+36+1
 1284 02f6 873F      		cpi r24,-9
 1285 02f8 6FEF      		ldi r22,-1
 1286 02fa 9607      		cpc r25,r22
 1287 02fc 00F0      		brlo .L113
 995:Lib/uip/uip.c ****   } else {
 1288               		.loc 1 995 0
 1289 02fe 0996      		adiw r24,9
 1290 0300 00C0      		rjmp .L313
 1291               	.L113:
 997:Lib/uip/uip.c ****   }
 1292               		.loc 1 997 0
 1293 0302 0896      		adiw r24,8
 1294               	.L313:
 1295 0304 9093 0000 		sts uip_buf+36+1,r25
 1296 0308 8093 0000 		sts uip_buf+36,r24
1001:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
 1297               		.loc 1 1001 0
 1298 030c 8091 0000 		lds r24,uip_buf+26
 1299 0310 9091 0000 		lds r25,uip_buf+26+1
 1300 0314 A091 0000 		lds r26,uip_buf+26+2
 1301 0318 B091 0000 		lds r27,uip_buf+26+3
 1302 031c 8093 0000 		sts uip_buf+30,r24
 1303 0320 9093 0000 		sts uip_buf+30+1,r25
 1304 0324 A093 0000 		sts uip_buf+30+2,r26
 1305 0328 B093 0000 		sts uip_buf+30+3,r27
1002:Lib/uip/uip.c **** 
 1306               		.loc 1 1002 0
 1307 032c 8091 0000 		lds r24,uip_hostaddr
 1308 0330 9091 0000 		lds r25,uip_hostaddr+1
 1309 0334 A091 0000 		lds r26,uip_hostaddr+2
 1310 0338 B091 0000 		lds r27,uip_hostaddr+3
 1311 033c 8093 0000 		sts uip_buf+26,r24
 1312 0340 9093 0000 		sts uip_buf+26+1,r25
 1313 0344 A093 0000 		sts uip_buf+26+2,r26
 1314 0348 B093 0000 		sts uip_buf+26+3,r27
1005:Lib/uip/uip.c ****   goto ip_send_nolen;
 1315               		.loc 1 1005 0
 1316 034c 80E4      		ldi r24,lo8(64)
 1317 034e 8093 0000 		sts uip_buf+22,r24
1006:Lib/uip/uip.c **** 
 1318               		.loc 1 1006 0
 1319 0352 00C0      		rjmp .L115
 1320               	.L111:
1096:Lib/uip/uip.c **** #endif /* UIP_UDP_CHECKSUMS */
 1321               		.loc 1 1096 0
 1322 0354 0C51      		subi r16,28
 1323 0356 1109      		sbc r17,__zero_reg__
 1324 0358 1093 0000 		sts uip_len+1,r17
 1325 035c 0093 0000 		sts uip_len,r16
1100:Lib/uip/uip.c ****       uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
 1326               		.loc 1 1100 0
 1327 0360 80E0      		ldi r24,lo8(uip_udp_conns)
 1328 0362 90E0      		ldi r25,hi8(uip_udp_conns)
 1329 0364 9093 0000 		sts uip_udp_conn+1,r25
 1330 0368 8093 0000 		sts uip_udp_conn,r24
1111:Lib/uip/uip.c ****        (uip_udp_conn->rport == 0 ||
 1331               		.loc 1 1111 0
 1332 036c A090 0000 		lds r10,uip_buf+36
 1333 0370 B090 0000 		lds r11,uip_buf+36+1
1113:Lib/uip/uip.c ****        (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
 1334               		.loc 1 1113 0
 1335 0374 2091 0000 		lds r18,uip_buf+34
 1336 0378 3091 0000 		lds r19,uip_buf+34+1
1114:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
 1337               		.loc 1 1114 0
 1338 037c 4091 0000 		lds r20,uip_all_zeroes_addr+2
 1339 0380 5091 0000 		lds r21,uip_all_zeroes_addr+2+1
1115:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
 1340               		.loc 1 1115 0
 1341 0384 6091 0000 		lds r22,uip_broadcast_addr
 1342 0388 7091 0000 		lds r23,uip_broadcast_addr+1
 1343 038c A091 0000 		lds r26,uip_broadcast_addr+2
 1344 0390 B091 0000 		lds r27,uip_broadcast_addr+2+1
1116:Lib/uip/uip.c ****       goto udp_found;
 1345               		.loc 1 1116 0
 1346 0394 0091 0000 		lds r16,uip_buf+26
 1347 0398 1091 0000 		lds r17,uip_buf+26+1
 1348 039c E090 0000 		lds r14,uip_buf+28
 1349 03a0 F090 0000 		lds r15,uip_buf+28+1
 1350               	.L116:
1101:Lib/uip/uip.c ****       ++uip_udp_conn) {
 1351               		.loc 1 1101 0 discriminator 1
 1352 03a4 E091 0000 		lds r30,uip_udp_conn
 1353 03a8 F091 0000 		lds r31,uip_udp_conn+1
1100:Lib/uip/uip.c ****       uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
 1354               		.loc 1 1100 0 discriminator 1
 1355 03ac 80E0      		ldi r24,hi8(uip_udp_conns+30)
 1356 03ae E030      		cpi r30,lo8(uip_udp_conns+30)
 1357 03b0 F807      		cpc r31,r24
 1358 03b2 00F4      		brsh .L328
1110:Lib/uip/uip.c ****        UDPBUF->destport == uip_udp_conn->lport &&
 1359               		.loc 1 1110 0
 1360 03b4 8481      		ldd r24,Z+4
 1361 03b6 9581      		ldd r25,Z+5
 1362 03b8 0097      		sbiw r24,0
 1363 03ba 01F0      		breq .L117
1110:Lib/uip/uip.c ****        UDPBUF->destport == uip_udp_conn->lport &&
 1364               		.loc 1 1110 0 is_stmt 0 discriminator 1
 1365 03bc 8A15      		cp r24,r10
 1366 03be 9B05      		cpc r25,r11
 1367 03c0 01F4      		brne .L117
1112:Lib/uip/uip.c ****         UDPBUF->srcport == uip_udp_conn->rport) &&
 1368               		.loc 1 1112 0 is_stmt 1
 1369 03c2 8681      		ldd r24,Z+6
 1370 03c4 9781      		ldd r25,Z+7
1111:Lib/uip/uip.c ****        (uip_udp_conn->rport == 0 ||
 1371               		.loc 1 1111 0
 1372 03c6 0097      		sbiw r24,0
 1373 03c8 01F0      		breq .L118
1112:Lib/uip/uip.c ****         UDPBUF->srcport == uip_udp_conn->rport) &&
 1374               		.loc 1 1112 0
 1375 03ca 8217      		cp r24,r18
 1376 03cc 9307      		cpc r25,r19
 1377 03ce 01F4      		brne .L117
 1378               	.L118:
1114:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
 1379               		.loc 1 1114 0
 1380 03d0 8081      		ld r24,Z
 1381 03d2 9181      		ldd r25,Z+1
1113:Lib/uip/uip.c ****        (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
 1382               		.loc 1 1113 0
 1383 03d4 C817      		cp r28,r24
 1384 03d6 D907      		cpc r29,r25
 1385 03d8 01F4      		brne .L119
1114:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
 1386               		.loc 1 1114 0
 1387 03da C280      		ldd r12,Z+2
 1388 03dc D380      		ldd r13,Z+3
 1389 03de C416      		cp r12,r20
 1390 03e0 D506      		cpc r13,r21
 1391 03e2 01F4      		brne .+2
 1392 03e4 00C0      		rjmp .L120
 1393               	.L119:
1114:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
 1394               		.loc 1 1114 0 is_stmt 0 discriminator 1
 1395 03e6 8617      		cp r24,r22
 1396 03e8 9707      		cpc r25,r23
 1397 03ea 01F4      		brne .L121
1115:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
 1398               		.loc 1 1115 0 is_stmt 1
 1399 03ec C280      		ldd r12,Z+2
 1400 03ee D380      		ldd r13,Z+3
 1401 03f0 CA16      		cp r12,r26
 1402 03f2 DB06      		cpc r13,r27
 1403 03f4 01F4      		brne .+2
 1404 03f6 00C0      		rjmp .L120
 1405               	.L121:
1115:Lib/uip/uip.c **** 	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
 1406               		.loc 1 1115 0 is_stmt 0 discriminator 1
 1407 03f8 8017      		cp r24,r16
 1408 03fa 9107      		cpc r25,r17
 1409 03fc 01F4      		brne .L117
1116:Lib/uip/uip.c ****       goto udp_found;
 1410               		.loc 1 1116 0 is_stmt 1
 1411 03fe 8281      		ldd r24,Z+2
 1412 0400 9381      		ldd r25,Z+3
 1413 0402 E816      		cp r14,r24
 1414 0404 F906      		cpc r15,r25
 1415 0406 01F4      		brne .+2
 1416 0408 00C0      		rjmp .L120
 1417               	.L117:
1102:Lib/uip/uip.c ****     /* If the local UDP port is non-zero, the connection is considered
 1418               		.loc 1 1102 0
 1419 040a 7E96      		adiw r30,30
 1420 040c F093 0000 		sts uip_udp_conn+1,r31
 1421 0410 E093 0000 		sts uip_udp_conn,r30
 1422 0414 00C0      		rjmp .L116
 1423               	.L328:
1123:Lib/uip/uip.c **** 
 1424               		.loc 1 1123 0
 1425 0416 8CE1      		ldi r24,lo8(28)
 1426 0418 E0E0      		ldi r30,lo8(uip_buf+14)
 1427 041a F0E0      		ldi r31,hi8(uip_buf+14)
 1428 041c A0E0      		ldi r26,lo8(uip_buf+42)
 1429 041e B0E0      		ldi r27,hi8(uip_buf+42)
 1430               		0:
 1431 0420 0190      		ld r0,Z+
 1432 0422 0D92      		st X+,r0
 1433 0424 8A95      		dec r24
 1434 0426 01F4      		brne 0b
1126:Lib/uip/uip.c ****   ICMPBUF->icode = ICMP_PORT_UNREACHABLE;
 1435               		.loc 1 1126 0
 1436 0428 83E0      		ldi r24,lo8(3)
 1437 042a 8093 0000 		sts uip_buf+34,r24
1127:Lib/uip/uip.c **** 
 1438               		.loc 1 1127 0
 1439 042e 8093 0000 		sts uip_buf+35,r24
1130:Lib/uip/uip.c ****   ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
 1440               		.loc 1 1130 0
 1441 0432 1092 0000 		sts uip_buf+36+1,__zero_reg__
 1442 0436 1092 0000 		sts uip_buf+36,__zero_reg__
1131:Lib/uip/uip.c **** 
 1443               		.loc 1 1131 0
 1444 043a 64E2      		ldi r22,lo8(36)
 1445 043c 70E0      		ldi r23,0
 1446 043e 80E0      		ldi r24,lo8(uip_buf+34)
 1447 0440 90E0      		ldi r25,hi8(uip_buf+34)
 1448 0442 0E94 0000 		call uip_chksum
 1449               	.LVL80:
 1450 0446 8095      		com r24
 1451 0448 9095      		com r25
 1452 044a 9093 0000 		sts uip_buf+36+1,r25
 1453 044e 8093 0000 		sts uip_buf+36,r24
1135:Lib/uip/uip.c **** 
 1454               		.loc 1 1135 0
 1455 0452 8091 0000 		lds r24,uip_buf+26
 1456 0456 9091 0000 		lds r25,uip_buf+26+1
 1457 045a A091 0000 		lds r26,uip_buf+26+2
 1458 045e B091 0000 		lds r27,uip_buf+26+3
 1459 0462 8093 0000 		sts uip_buf+30,r24
 1460 0466 9093 0000 		sts uip_buf+30+1,r25
 1461 046a A093 0000 		sts uip_buf+30+2,r26
 1462 046e B093 0000 		sts uip_buf+30+3,r27
1138:Lib/uip/uip.c **** 
 1463               		.loc 1 1138 0
 1464 0472 8091 0000 		lds r24,uip_hostaddr
 1465 0476 9091 0000 		lds r25,uip_hostaddr+1
 1466 047a A091 0000 		lds r26,uip_hostaddr+2
 1467 047e B091 0000 		lds r27,uip_hostaddr+3
 1468 0482 8093 0000 		sts uip_buf+26,r24
 1469 0486 9093 0000 		sts uip_buf+26+1,r25
 1470 048a A093 0000 		sts uip_buf+26+2,r26
 1471 048e B093 0000 		sts uip_buf+26+3,r27
1142:Lib/uip/uip.c ****   ICMPBUF->len[0] = 0;
 1472               		.loc 1 1142 0
 1473 0492 88E3      		ldi r24,lo8(56)
 1474 0494 90E0      		ldi r25,0
 1475 0496 9093 0000 		sts uip_len+1,r25
 1476 049a 8093 0000 		sts uip_len,r24
1143:Lib/uip/uip.c ****   ICMPBUF->len[1] = (u8_t)uip_len;
 1477               		.loc 1 1143 0
 1478 049e 1092 0000 		sts uip_buf+16,__zero_reg__
1144:Lib/uip/uip.c ****   ICMPBUF->ttl = UIP_TTL;
 1479               		.loc 1 1144 0
 1480 04a2 8093 0000 		sts uip_buf+17,r24
1145:Lib/uip/uip.c ****   ICMPBUF->proto = UIP_PROTO_ICMP;
 1481               		.loc 1 1145 0
 1482 04a6 80E4      		ldi r24,lo8(64)
 1483 04a8 8093 0000 		sts uip_buf+22,r24
1146:Lib/uip/uip.c **** 
 1484               		.loc 1 1146 0
 1485 04ac 81E0      		ldi r24,lo8(1)
 1486 04ae 8093 0000 		sts uip_buf+23,r24
1148:Lib/uip/uip.c **** #else /* UIP_CONF_ICMP_DEST_UNREACH */
 1487               		.loc 1 1148 0
 1488 04b2 00C0      		rjmp .L115
 1489               	.L120:
1154:Lib/uip/uip.c ****   uip_flags = UIP_NEWDATA;
 1490               		.loc 1 1154 0
 1491 04b4 1092 0000 		sts uip_conn+1,__zero_reg__
 1492 04b8 1092 0000 		sts uip_conn,__zero_reg__
1155:Lib/uip/uip.c ****   uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 1493               		.loc 1 1155 0
 1494 04bc 82E0      		ldi r24,lo8(2)
 1495 04be 8093 0000 		sts uip_flags,r24
1156:Lib/uip/uip.c ****   uip_slen = 0;
 1496               		.loc 1 1156 0
 1497 04c2 80E0      		ldi r24,lo8(uip_buf+42)
 1498 04c4 90E0      		ldi r25,hi8(uip_buf+42)
 1499 04c6 9093 0000 		sts uip_appdata+1,r25
 1500 04ca 8093 0000 		sts uip_appdata,r24
 1501 04ce 9093 0000 		sts uip_sappdata+1,r25
 1502 04d2 8093 0000 		sts uip_sappdata,r24
1157:Lib/uip/uip.c ****   UIP_UDP_APPCALL();
 1503               		.loc 1 1157 0
 1504 04d6 1092 0000 		sts uip_slen+1,__zero_reg__
 1505 04da 1092 0000 		sts uip_slen,__zero_reg__
 1506               	.L314:
1158:Lib/uip/uip.c **** 
 1507               		.loc 1 1158 0
 1508 04de 0E94 0000 		call uIPManagement_UDPCallback
 1509               	.LVL81:
 1510               	.L85:
1161:Lib/uip/uip.c ****     goto drop;
 1511               		.loc 1 1161 0
 1512 04e2 8091 0000 		lds r24,uip_slen
 1513 04e6 9091 0000 		lds r25,uip_slen+1
 1514 04ea 0097      		sbiw r24,0
 1515 04ec 01F4      		brne .+2
 1516 04ee 00C0      		rjmp .L94
1164:Lib/uip/uip.c **** 
 1517               		.loc 1 1164 0
 1518 04f0 9C01      		movw r18,r24
 1519 04f2 245E      		subi r18,-28
 1520 04f4 3F4F      		sbci r19,-1
 1521 04f6 3093 0000 		sts uip_len+1,r19
 1522 04fa 2093 0000 		sts uip_len,r18
1172:Lib/uip/uip.c ****   BUF->len[1] = (uip_len & 0xff);
 1523               		.loc 1 1172 0
 1524 04fe 3093 0000 		sts uip_buf+16,r19
1173:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 1525               		.loc 1 1173 0
 1526 0502 2093 0000 		sts uip_buf+17,r18
1176:Lib/uip/uip.c ****   BUF->proto = UIP_PROTO_UDP;
 1527               		.loc 1 1176 0
 1528 0506 E091 0000 		lds r30,uip_udp_conn
 1529 050a F091 0000 		lds r31,uip_udp_conn+1
 1530 050e 2085      		ldd r18,Z+8
 1531 0510 2093 0000 		sts uip_buf+22,r18
1177:Lib/uip/uip.c **** 
 1532               		.loc 1 1177 0
 1533 0514 21E1      		ldi r18,lo8(17)
 1534 0516 2093 0000 		sts uip_buf+23,r18
1179:Lib/uip/uip.c ****   UDPBUF->udpchksum = 0;
 1535               		.loc 1 1179 0
 1536 051a 0896      		adiw r24,8
 1537 051c 9827      		eor r25,r24
 1538 051e 8927      		eor r24,r25
 1539 0520 9827      		eor r25,r24
 1540 0522 9093 0000 		sts uip_buf+38+1,r25
 1541 0526 8093 0000 		sts uip_buf+38,r24
1180:Lib/uip/uip.c **** 
 1542               		.loc 1 1180 0
 1543 052a 1092 0000 		sts uip_buf+40+1,__zero_reg__
 1544 052e 1092 0000 		sts uip_buf+40,__zero_reg__
1182:Lib/uip/uip.c ****   BUF->destport = uip_udp_conn->rport;
 1545               		.loc 1 1182 0
 1546 0532 8481      		ldd r24,Z+4
 1547 0534 9581      		ldd r25,Z+5
 1548 0536 9093 0000 		sts uip_buf+34+1,r25
 1549 053a 8093 0000 		sts uip_buf+34,r24
1183:Lib/uip/uip.c **** 
 1550               		.loc 1 1183 0
 1551 053e 8681      		ldd r24,Z+6
 1552 0540 9781      		ldd r25,Z+7
 1553 0542 9093 0000 		sts uip_buf+36+1,r25
 1554 0546 8093 0000 		sts uip_buf+36,r24
1185:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
 1555               		.loc 1 1185 0
 1556 054a 8091 0000 		lds r24,uip_hostaddr
 1557 054e 9091 0000 		lds r25,uip_hostaddr+1
 1558 0552 A091 0000 		lds r26,uip_hostaddr+2
 1559 0556 B091 0000 		lds r27,uip_hostaddr+3
 1560 055a 8093 0000 		sts uip_buf+26,r24
 1561 055e 9093 0000 		sts uip_buf+26+1,r25
 1562 0562 A093 0000 		sts uip_buf+26+2,r26
 1563 0566 B093 0000 		sts uip_buf+26+3,r27
1186:Lib/uip/uip.c **** 
 1564               		.loc 1 1186 0
 1565 056a 8081      		ld r24,Z
 1566 056c 9181      		ldd r25,Z+1
 1567 056e A281      		ldd r26,Z+2
 1568 0570 B381      		ldd r27,Z+3
 1569 0572 8093 0000 		sts uip_buf+30,r24
 1570 0576 9093 0000 		sts uip_buf+30+1,r25
 1571 057a A093 0000 		sts uip_buf+30+2,r26
 1572 057e B093 0000 		sts uip_buf+30+3,r27
1188:Lib/uip/uip.c **** 
 1573               		.loc 1 1188 0
 1574 0582 80E0      		ldi r24,lo8(uip_buf+54)
 1575 0584 90E0      		ldi r25,hi8(uip_buf+54)
 1576 0586 9093 0000 		sts uip_appdata+1,r25
 1577 058a 8093 0000 		sts uip_appdata,r24
1198:Lib/uip/uip.c **** #endif /* UIP_UDP */
 1578               		.loc 1 1198 0
 1579 058e 00C0      		rjmp .L115
 1580               	.L112:
1207:Lib/uip/uip.c **** 				       checksum. */
 1581               		.loc 1 1207 0
 1582 0590 0E94 0000 		call uip_tcpchksum
 1583               	.LVL82:
 1584 0594 0196      		adiw r24,1
 1585 0596 01F0      		breq .+2
 1586 0598 00C0      		rjmp .L94
1220:Lib/uip/uip.c ****        BUF->srcport == uip_connr->rport &&
 1587               		.loc 1 1220 0
 1588 059a 4091 0000 		lds r20,uip_buf+36
 1589 059e 5091 0000 		lds r21,uip_buf+36+1
1221:Lib/uip/uip.c ****        uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
 1590               		.loc 1 1221 0
 1591 05a2 8091 0000 		lds r24,uip_buf+34
 1592 05a6 9091 0000 		lds r25,uip_buf+34+1
1222:Lib/uip/uip.c ****       goto found;
 1593               		.loc 1 1222 0
 1594 05aa 6091 0000 		lds r22,uip_buf+26
 1595 05ae 7091 0000 		lds r23,uip_buf+26+1
 1596 05b2 E091 0000 		lds r30,uip_buf+28
 1597 05b6 F091 0000 		lds r31,uip_buf+28+1
 1598 05ba C0E0      		ldi r28,lo8(uip_conns)
 1599 05bc D0E0      		ldi r29,hi8(uip_conns)
 1600               	.L125:
 1601               	.LVL83:
1219:Lib/uip/uip.c ****        BUF->destport == uip_connr->lport &&
 1602               		.loc 1 1219 0
 1603 05be 298D      		ldd r18,Y+25
 1604 05c0 2223      		tst r18
 1605 05c2 01F0      		breq .L123
1219:Lib/uip/uip.c ****        BUF->destport == uip_connr->lport &&
 1606               		.loc 1 1219 0 is_stmt 0 discriminator 1
 1607 05c4 AC81      		ldd r26,Y+4
 1608 05c6 BD81      		ldd r27,Y+5
 1609 05c8 4A17      		cp r20,r26
 1610 05ca 5B07      		cpc r21,r27
 1611 05cc 01F4      		brne .L123
1220:Lib/uip/uip.c ****        BUF->srcport == uip_connr->rport &&
 1612               		.loc 1 1220 0 is_stmt 1
 1613 05ce AE81      		ldd r26,Y+6
 1614 05d0 BF81      		ldd r27,Y+7
 1615 05d2 8A17      		cp r24,r26
 1616 05d4 9B07      		cpc r25,r27
 1617 05d6 01F4      		brne .L123
1221:Lib/uip/uip.c ****        uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
 1618               		.loc 1 1221 0
 1619 05d8 A881      		ld r26,Y
 1620 05da B981      		ldd r27,Y+1
 1621 05dc 6A17      		cp r22,r26
 1622 05de 7B07      		cpc r23,r27
 1623 05e0 01F4      		brne .L123
1222:Lib/uip/uip.c ****       goto found;
 1624               		.loc 1 1222 0
 1625 05e2 AA81      		ldd r26,Y+2
 1626 05e4 BB81      		ldd r27,Y+3
 1627 05e6 EA17      		cp r30,r26
 1628 05e8 FB07      		cpc r31,r27
 1629 05ea 01F4      		brne .+2
 1630 05ec 00C0      		rjmp .L124
 1631               	.L123:
1218:Lib/uip/uip.c ****     if(uip_connr->tcpstateflags != UIP_CLOSED &&
 1632               		.loc 1 1218 0
 1633 05ee CF58      		subi r28,-113
 1634 05f0 DF4F      		sbci r29,-1
 1635               	.LVL84:
1217:Lib/uip/uip.c ****       ++uip_connr) {
 1636               		.loc 1 1217 0
 1637 05f2 20E0      		ldi r18,hi8(uip_conns+339)
 1638 05f4 C030      		cpi r28,lo8(uip_conns+339)
 1639 05f6 D207      		cpc r29,r18
 1640 05f8 01F4      		brne .L125
1231:Lib/uip/uip.c ****     goto reset;
 1641               		.loc 1 1231 0
 1642 05fa 8091 0000 		lds r24,uip_buf+47
 1643 05fe 8F73      		andi r24,lo8(63)
 1644 0600 8230      		cpi r24,lo8(2)
 1645 0602 01F4      		brne .L127
1235:Lib/uip/uip.c ****   /* Next, check listening connections. */
 1646               		.loc 1 1235 0
 1647 0604 5093 0000 		sts tmp16+1,r21
 1648 0608 4093 0000 		sts tmp16,r20
1237:Lib/uip/uip.c ****     if(tmp16 == uip_listenports[c]) {
 1649               		.loc 1 1237 0
 1650 060c 80E0      		ldi r24,0
 1651               	.L128:
1237:Lib/uip/uip.c ****     if(tmp16 == uip_listenports[c]) {
 1652               		.loc 1 1237 0 is_stmt 0 discriminator 1
 1653 060e 8530      		cpi r24,lo8(5)
 1654 0610 01F0      		breq .L329
1238:Lib/uip/uip.c ****       goto found_listen;
 1655               		.loc 1 1238 0 is_stmt 1
 1656 0612 E82F      		mov r30,r24
 1657 0614 F0E0      		ldi r31,0
 1658 0616 EE0F      		lsl r30
 1659 0618 FF1F      		rol r31
 1660 061a E050      		subi r30,lo8(-(uip_listenports))
 1661 061c F040      		sbci r31,hi8(-(uip_listenports))
 1662 061e 2081      		ld r18,Z
 1663 0620 3181      		ldd r19,Z+1
 1664 0622 8F5F      		subi r24,lo8(-(1))
 1665 0624 4217      		cp r20,r18
 1666 0626 5307      		cpc r21,r19
 1667 0628 01F4      		brne .L128
 1668               	.L129:
 1669               	.LVL85:
1309:Lib/uip/uip.c ****     if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
 1670               		.loc 1 1309 0
 1671 062a 1092 0000 		sts c,__zero_reg__
 1672 062e 80E0      		ldi r24,0
1308:Lib/uip/uip.c ****   for(c = 0; c < UIP_CONNS; ++c) {
 1673               		.loc 1 1308 0
 1674 0630 C0E0      		ldi r28,0
 1675 0632 D0E0      		ldi r29,0
1310:Lib/uip/uip.c ****       uip_connr = &uip_conns[c];
 1676               		.loc 1 1310 0
 1677 0634 91E7      		ldi r25,lo8(113)
1309:Lib/uip/uip.c ****     if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
 1678               		.loc 1 1309 0
 1679 0636 00C0      		rjmp .L136
 1680               	.LVL86:
 1681               	.L329:
 1682 0638 8093 0000 		sts c,r24
 1683               	.L127:
1248:Lib/uip/uip.c ****     goto drop;
 1684               		.loc 1 1248 0
 1685 063c 8091 0000 		lds r24,uip_buf+47
 1686 0640 82FD      		sbrc r24,2
 1687 0642 00C0      		rjmp .L94
1254:Lib/uip/uip.c ****   uip_len = UIP_IPTCPH_LEN;
 1688               		.loc 1 1254 0
 1689 0644 84E1      		ldi r24,lo8(20)
 1690 0646 8093 0000 		sts uip_buf+47,r24
1255:Lib/uip/uip.c ****   BUF->tcpoffset = 5 << 4;
 1691               		.loc 1 1255 0
 1692 064a 88E2      		ldi r24,lo8(40)
 1693 064c 90E0      		ldi r25,0
 1694 064e 9093 0000 		sts uip_len+1,r25
 1695 0652 8093 0000 		sts uip_len,r24
1256:Lib/uip/uip.c **** 
 1696               		.loc 1 1256 0
 1697 0656 80E5      		ldi r24,lo8(80)
 1698 0658 8093 0000 		sts uip_buf+46,r24
1259:Lib/uip/uip.c ****   BUF->seqno[3] = BUF->ackno[3];
 1699               		.loc 1 1259 0
 1700 065c 3091 0000 		lds r19,uip_buf+41
1260:Lib/uip/uip.c ****   BUF->ackno[3] = c;
 1701               		.loc 1 1260 0
 1702 0660 8091 0000 		lds r24,uip_buf+45
 1703 0664 8093 0000 		sts uip_buf+41,r24
1263:Lib/uip/uip.c ****   BUF->seqno[2] = BUF->ackno[2];
 1704               		.loc 1 1263 0
 1705 0668 2091 0000 		lds r18,uip_buf+40
1264:Lib/uip/uip.c ****   BUF->ackno[2] = c;
 1706               		.loc 1 1264 0
 1707 066c 8091 0000 		lds r24,uip_buf+44
 1708 0670 8093 0000 		sts uip_buf+40,r24
1265:Lib/uip/uip.c **** 
 1709               		.loc 1 1265 0
 1710 0674 2093 0000 		sts uip_buf+44,r18
1267:Lib/uip/uip.c ****   BUF->seqno[1] = BUF->ackno[1];
 1711               		.loc 1 1267 0
 1712 0678 9091 0000 		lds r25,uip_buf+39
1268:Lib/uip/uip.c ****   BUF->ackno[1] = c;
 1713               		.loc 1 1268 0
 1714 067c 8091 0000 		lds r24,uip_buf+43
 1715 0680 8093 0000 		sts uip_buf+39,r24
1269:Lib/uip/uip.c **** 
 1716               		.loc 1 1269 0
 1717 0684 9093 0000 		sts uip_buf+43,r25
1271:Lib/uip/uip.c ****   BUF->seqno[0] = BUF->ackno[0];
 1718               		.loc 1 1271 0
 1719 0688 8091 0000 		lds r24,uip_buf+38
 1720 068c 8093 0000 		sts c,r24
1272:Lib/uip/uip.c ****   BUF->ackno[0] = c;
 1721               		.loc 1 1272 0
 1722 0690 4091 0000 		lds r20,uip_buf+42
 1723 0694 4093 0000 		sts uip_buf+38,r20
1273:Lib/uip/uip.c **** 
 1724               		.loc 1 1273 0
 1725 0698 8093 0000 		sts uip_buf+42,r24
1278:Lib/uip/uip.c ****     if(++BUF->ackno[2] == 0) {
 1726               		.loc 1 1278 0
 1727 069c 3F5F      		subi r19,lo8(-(1))
 1728 069e 3093 0000 		sts uip_buf+45,r19
 1729 06a2 3111      		cpse r19,__zero_reg__
 1730 06a4 00C0      		rjmp .L133
1279:Lib/uip/uip.c ****       if(++BUF->ackno[1] == 0) {
 1731               		.loc 1 1279 0
 1732 06a6 2F5F      		subi r18,lo8(-(1))
 1733 06a8 2093 0000 		sts uip_buf+44,r18
 1734 06ac 2111      		cpse r18,__zero_reg__
 1735 06ae 00C0      		rjmp .L133
1280:Lib/uip/uip.c **** 	++BUF->ackno[0];
 1736               		.loc 1 1280 0
 1737 06b0 9F5F      		subi r25,lo8(-(1))
 1738 06b2 9093 0000 		sts uip_buf+43,r25
 1739 06b6 9111      		cpse r25,__zero_reg__
 1740 06b8 00C0      		rjmp .L133
1281:Lib/uip/uip.c ****       }
 1741               		.loc 1 1281 0
 1742 06ba 8F5F      		subi r24,lo8(-(1))
 1743 06bc 8093 0000 		sts uip_buf+42,r24
 1744               	.L133:
1287:Lib/uip/uip.c ****   BUF->srcport = BUF->destport;
 1745               		.loc 1 1287 0
 1746 06c0 8091 0000 		lds r24,uip_buf+34
 1747 06c4 9091 0000 		lds r25,uip_buf+34+1
 1748 06c8 9093 0000 		sts tmp16+1,r25
 1749 06cc 8093 0000 		sts tmp16,r24
1288:Lib/uip/uip.c ****   BUF->destport = tmp16;
 1750               		.loc 1 1288 0
 1751 06d0 2091 0000 		lds r18,uip_buf+36
 1752 06d4 3091 0000 		lds r19,uip_buf+36+1
 1753 06d8 3093 0000 		sts uip_buf+34+1,r19
 1754 06dc 2093 0000 		sts uip_buf+34,r18
1289:Lib/uip/uip.c **** 
 1755               		.loc 1 1289 0
 1756 06e0 9093 0000 		sts uip_buf+36+1,r25
 1757 06e4 8093 0000 		sts uip_buf+36,r24
1292:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
 1758               		.loc 1 1292 0
 1759 06e8 8091 0000 		lds r24,uip_buf+26
 1760 06ec 9091 0000 		lds r25,uip_buf+26+1
 1761 06f0 A091 0000 		lds r26,uip_buf+26+2
 1762 06f4 B091 0000 		lds r27,uip_buf+26+3
 1763 06f8 8093 0000 		sts uip_buf+30,r24
 1764 06fc 9093 0000 		sts uip_buf+30+1,r25
 1765 0700 A093 0000 		sts uip_buf+30+2,r26
 1766 0704 B093 0000 		sts uip_buf+30+3,r27
1293:Lib/uip/uip.c **** 
 1767               		.loc 1 1293 0
 1768 0708 8091 0000 		lds r24,uip_hostaddr
 1769 070c 9091 0000 		lds r25,uip_hostaddr+1
 1770 0710 A091 0000 		lds r26,uip_hostaddr+2
 1771 0714 B091 0000 		lds r27,uip_hostaddr+3
 1772 0718 8093 0000 		sts uip_buf+26,r24
 1773 071c 9093 0000 		sts uip_buf+26+1,r25
 1774 0720 A093 0000 		sts uip_buf+26+2,r26
 1775 0724 B093 0000 		sts uip_buf+26+3,r27
1296:Lib/uip/uip.c **** 
 1776               		.loc 1 1296 0
 1777 0728 00C0      		rjmp .L135
 1778               	.L137:
1314:Lib/uip/uip.c ****       if(uip_connr == 0 ||
 1779               		.loc 1 1314 0
 1780 072a 4730      		cpi r20,lo8(7)
 1781 072c 01F0      		breq .L330
 1782               	.L139:
 1783 072e 8F5F      		subi r24,lo8(-(1))
 1784               	.LVL87:
 1785               	.L136:
1309:Lib/uip/uip.c ****     if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
 1786               		.loc 1 1309 0 discriminator 1
 1787 0730 8330      		cpi r24,lo8(3)
 1788 0732 01F0      		breq .L331
1310:Lib/uip/uip.c ****       uip_connr = &uip_conns[c];
 1789               		.loc 1 1310 0
 1790 0734 282F      		mov r18,r24
 1791 0736 30E0      		ldi r19,0
 1792 0738 929F      		mul r25,r18
 1793 073a F001      		movw r30,r0
 1794 073c 939F      		mul r25,r19
 1795 073e F00D      		add r31,r0
 1796 0740 1124      		clr __zero_reg__
 1797 0742 E050      		subi r30,lo8(-(uip_conns))
 1798 0744 F040      		sbci r31,hi8(-(uip_conns))
 1799 0746 418D      		ldd r20,Z+25
 1800 0748 4111      		cpse r20,__zero_reg__
 1801 074a 00C0      		rjmp .L137
 1802 074c 8093 0000 		sts c,r24
1311:Lib/uip/uip.c ****       break;
 1803               		.loc 1 1311 0
 1804 0750 EF01      		movw r28,r30
 1805               	.LVL88:
 1806 0752 00C0      		rjmp .L138
 1807               	.L330:
1315:Lib/uip/uip.c **** 	 uip_conns[c].timer > uip_connr->timer) {
 1808               		.loc 1 1315 0
 1809 0754 2097      		sbiw r28,0
 1810 0756 01F0      		breq .L140
1315:Lib/uip/uip.c **** 	 uip_conns[c].timer > uip_connr->timer) {
 1811               		.loc 1 1315 0 is_stmt 0 discriminator 1
 1812 0758 528D      		ldd r21,Z+26
 1813 075a 4A8D      		ldd r20,Y+26
 1814 075c 4517      		cp r20,r21
 1815 075e 00F4      		brsh .L139
 1816               	.L140:
1317:Lib/uip/uip.c ****       }
 1817               		.loc 1 1317 0 is_stmt 1
 1818 0760 929F      		mul r25,r18
 1819 0762 E001      		movw r28,r0
 1820 0764 939F      		mul r25,r19
 1821 0766 D00D      		add r29,r0
 1822 0768 1124      		clr __zero_reg__
 1823               	.LVL89:
 1824 076a C050      		subi r28,lo8(-(uip_conns))
 1825 076c D040      		sbci r29,hi8(-(uip_conns))
 1826               	.LVL90:
 1827 076e 00C0      		rjmp .L139
 1828               	.L331:
 1829 0770 8093 0000 		sts c,r24
1322:Lib/uip/uip.c ****     /* All connections are used already, we drop packet and hope that
 1830               		.loc 1 1322 0
 1831 0774 2097      		sbiw r28,0
 1832 0776 01F4      		brne .+2
 1833 0778 00C0      		rjmp .L94
 1834               	.LVL91:
 1835               	.L138:
1330:Lib/uip/uip.c **** 
 1836               		.loc 1 1330 0
 1837 077a D093 0000 		sts uip_conn+1,r29
 1838 077e C093 0000 		sts uip_conn,r28
1333:Lib/uip/uip.c ****   uip_connr->sa = 0;
 1839               		.loc 1 1333 0
 1840 0782 83E0      		ldi r24,lo8(3)
 1841 0784 8A8F      		std Y+26,r24
 1842 0786 888F      		std Y+24,r24
1334:Lib/uip/uip.c ****   uip_connr->sv = 4;
 1843               		.loc 1 1334 0
 1844 0788 1E8A      		std Y+22,__zero_reg__
1335:Lib/uip/uip.c ****   uip_connr->nrtx = 0;
 1845               		.loc 1 1335 0
 1846 078a 84E0      		ldi r24,lo8(4)
 1847 078c 8F8B      		std Y+23,r24
1336:Lib/uip/uip.c ****   uip_connr->lport = BUF->destport;
 1848               		.loc 1 1336 0
 1849 078e 1B8E      		std Y+27,__zero_reg__
1337:Lib/uip/uip.c ****   uip_connr->rport = BUF->srcport;
 1850               		.loc 1 1337 0
 1851 0790 8091 0000 		lds r24,uip_buf+36
 1852 0794 9091 0000 		lds r25,uip_buf+36+1
 1853 0798 9D83      		std Y+5,r25
 1854 079a 8C83      		std Y+4,r24
1338:Lib/uip/uip.c ****   uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
 1855               		.loc 1 1338 0
 1856 079c 8091 0000 		lds r24,uip_buf+34
 1857 07a0 9091 0000 		lds r25,uip_buf+34+1
 1858 07a4 9F83      		std Y+7,r25
 1859 07a6 8E83      		std Y+6,r24
1339:Lib/uip/uip.c ****   uip_connr->tcpstateflags = UIP_SYN_RCVD;
 1860               		.loc 1 1339 0
 1861 07a8 8091 0000 		lds r24,uip_buf+26
 1862 07ac 9091 0000 		lds r25,uip_buf+26+1
 1863 07b0 A091 0000 		lds r26,uip_buf+26+2
 1864 07b4 B091 0000 		lds r27,uip_buf+26+3
 1865 07b8 8883      		st Y,r24
 1866 07ba 9983      		std Y+1,r25
 1867 07bc AA83      		std Y+2,r26
 1868 07be BB83      		std Y+3,r27
1340:Lib/uip/uip.c **** 
 1869               		.loc 1 1340 0
 1870 07c0 81E0      		ldi r24,lo8(1)
 1871 07c2 898F      		std Y+25,r24
1342:Lib/uip/uip.c ****   uip_connr->snd_nxt[1] = iss[1];
 1872               		.loc 1 1342 0
 1873 07c4 8091 0000 		lds r24,iss
 1874 07c8 8C87      		std Y+12,r24
1343:Lib/uip/uip.c ****   uip_connr->snd_nxt[2] = iss[2];
 1875               		.loc 1 1343 0
 1876 07ca 8091 0000 		lds r24,iss+1
 1877 07ce 8D87      		std Y+13,r24
1344:Lib/uip/uip.c ****   uip_connr->snd_nxt[3] = iss[3];
 1878               		.loc 1 1344 0
 1879 07d0 8091 0000 		lds r24,iss+2
 1880 07d4 8E87      		std Y+14,r24
1345:Lib/uip/uip.c ****   uip_connr->len = 1;
 1881               		.loc 1 1345 0
 1882 07d6 8091 0000 		lds r24,iss+3
 1883 07da 8F87      		std Y+15,r24
1346:Lib/uip/uip.c **** 
 1884               		.loc 1 1346 0
 1885 07dc 81E0      		ldi r24,lo8(1)
 1886 07de 90E0      		ldi r25,0
 1887 07e0 998B      		std Y+17,r25
 1888 07e2 888B      		std Y+16,r24
1349:Lib/uip/uip.c ****   uip_connr->rcv_nxt[2] = BUF->seqno[2];
 1889               		.loc 1 1349 0
 1890 07e4 8091 0000 		lds r24,uip_buf+41
 1891 07e8 8B87      		std Y+11,r24
1350:Lib/uip/uip.c ****   uip_connr->rcv_nxt[1] = BUF->seqno[1];
 1892               		.loc 1 1350 0
 1893 07ea 8091 0000 		lds r24,uip_buf+40
 1894 07ee 8A87      		std Y+10,r24
1351:Lib/uip/uip.c ****   uip_connr->rcv_nxt[0] = BUF->seqno[0];
 1895               		.loc 1 1351 0
 1896 07f0 8091 0000 		lds r24,uip_buf+39
 1897 07f4 8987      		std Y+9,r24
1352:Lib/uip/uip.c ****   uip_add_rcv_nxt(1);
 1898               		.loc 1 1352 0
 1899 07f6 8091 0000 		lds r24,uip_buf+38
 1900 07fa 8887      		std Y+8,r24
1353:Lib/uip/uip.c **** 
 1901               		.loc 1 1353 0
 1902 07fc 81E0      		ldi r24,lo8(1)
 1903 07fe 90E0      		ldi r25,0
 1904 0800 0E94 0000 		call uip_add_rcv_nxt
 1905               	.LVL92:
1356:Lib/uip/uip.c ****     for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 1906               		.loc 1 1356 0
 1907 0804 8091 0000 		lds r24,uip_buf+46
 1908 0808 982F      		mov r25,r24
 1909 080a 907F      		andi r25,lo8(-16)
 1910 080c 9135      		cpi r25,lo8(81)
 1911 080e 00F0      		brlo .L102
1357:Lib/uip/uip.c ****       opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
 1912               		.loc 1 1357 0
 1913 0810 8295      		swap r24
 1914 0812 8F70      		andi r24,lo8(15)
 1915 0814 90E0      		ldi r25,0
 1916 0816 0597      		sbiw r24,5
 1917 0818 880F      		lsl r24
 1918 081a 991F      		rol r25
 1919 081c 880F      		lsl r24
 1920 081e 991F      		rol r25
 1921               	.L142:
1357:Lib/uip/uip.c ****       opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
 1922               		.loc 1 1357 0 is_stmt 0 discriminator 1
 1923 0820 EF2D      		mov r30,r15
 1924 0822 F0E0      		ldi r31,0
 1925 0824 E817      		cp r30,r24
 1926 0826 F907      		cpc r31,r25
 1927 0828 04F4      		brge .L315
1358:Lib/uip/uip.c ****       if(opt == TCP_OPT_END) {
 1928               		.loc 1 1358 0 is_stmt 1
 1929 082a E050      		subi r30,lo8(-(uip_buf))
 1930 082c F040      		sbci r31,hi8(-(uip_buf))
 1931 082e 26A9      		ldd r18,Z+54
1359:Lib/uip/uip.c **** 	/* End of options. */
 1932               		.loc 1 1359 0
 1933 0830 2223      		tst r18
 1934 0832 01F0      		breq .L315
1362:Lib/uip/uip.c **** 	++c;
 1935               		.loc 1 1362 0
 1936 0834 2130      		cpi r18,lo8(1)
 1937 0836 01F4      		brne .L144
1363:Lib/uip/uip.c **** 	/* NOP option. */
 1938               		.loc 1 1363 0
 1939 0838 F394      		inc r15
 1940 083a 00C0      		rjmp .L142
 1941               	.L144:
1365:Lib/uip/uip.c **** 		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
 1942               		.loc 1 1365 0
 1943 083c 2230      		cpi r18,lo8(2)
 1944 083e 01F4      		brne .L146
1365:Lib/uip/uip.c **** 		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
 1945               		.loc 1 1365 0 is_stmt 0 discriminator 1
 1946 0840 27A9      		ldd r18,Z+55
 1947 0842 2430      		cpi r18,lo8(4)
 1948 0844 01F4      		brne .L146
 1949 0846 F092 0000 		sts c,r15
1368:Lib/uip/uip.c **** 	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
 1950               		.loc 1 1368 0 is_stmt 1
 1951 084a 80AD      		ldd r24,Z+56
 1952 084c 90E0      		ldi r25,0
 1953 084e 982F      		mov r25,r24
 1954 0850 8827      		clr r24
 1955 0852 21AD      		ldd r18,Z+57
 1956 0854 822B      		or r24,r18
 1957 0856 9093 0000 		sts tmp16+1,r25
 1958 085a 8093 0000 		sts tmp16,r24
1371:Lib/uip/uip.c **** 
 1959               		.loc 1 1371 0
 1960 085e 853B      		cpi r24,-75
 1961 0860 65E0      		ldi r22,5
 1962 0862 9607      		cpc r25,r22
 1963 0864 00F0      		brlo .L147
 1964 0866 84EB      		ldi r24,lo8(-76)
 1965 0868 95E0      		ldi r25,lo8(5)
 1966               	.L147:
1370:Lib/uip/uip.c **** 	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
 1967               		.loc 1 1370 0
 1968 086a 9B8B      		std Y+19,r25
 1969 086c 8A8B      		std Y+18,r24
 1970 086e 9D8B      		std Y+21,r25
 1971 0870 8C8B      		std Y+20,r24
1374:Lib/uip/uip.c ****       } else {
 1972               		.loc 1 1374 0
 1973 0872 00C0      		rjmp .L102
 1974               	.L146:
1378:Lib/uip/uip.c **** 	  /* If the length field is zero, the options are malformed
 1975               		.loc 1 1378 0
 1976 0874 27A9      		ldd r18,Z+55
 1977 0876 2223      		tst r18
 1978 0878 01F0      		breq .L315
1383:Lib/uip/uip.c ****       }
 1979               		.loc 1 1383 0
 1980 087a F20E      		add r15,r18
 1981 087c 00C0      		rjmp .L142
 1982               	.L315:
 1983 087e F092 0000 		sts c,r15
 1984               	.LVL93:
 1985               	.L102:
1391:Lib/uip/uip.c **** 
 1986               		.loc 1 1391 0
 1987 0882 80E1      		ldi r24,lo8(16)
 1988 0884 8093 0000 		sts uip_buf+47,r24
 1989               	.LVL94:
 1990               	.L105:
1394:Lib/uip/uip.c **** #else /* UIP_ACTIVE_OPEN */
 1991               		.loc 1 1394 0
 1992 0888 8091 0000 		lds r24,uip_buf+47
 1993 088c 8260      		ori r24,lo8(2)
 1994 088e 8093 0000 		sts uip_buf+47,r24
1402:Lib/uip/uip.c ****   BUF->optdata[1] = TCP_OPT_MSS_LEN;
 1995               		.loc 1 1402 0
 1996 0892 82E0      		ldi r24,lo8(2)
 1997 0894 8093 0000 		sts uip_buf+54,r24
1403:Lib/uip/uip.c ****   BUF->optdata[2] = (UIP_TCP_MSS) / 256;
 1998               		.loc 1 1403 0
 1999 0898 84E0      		ldi r24,lo8(4)
 2000 089a 8093 0000 		sts uip_buf+55,r24
1404:Lib/uip/uip.c ****   BUF->optdata[3] = (UIP_TCP_MSS) & 255;
 2001               		.loc 1 1404 0
 2002 089e 85E0      		ldi r24,lo8(5)
 2003 08a0 8093 0000 		sts uip_buf+56,r24
1405:Lib/uip/uip.c ****   uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
 2004               		.loc 1 1405 0
 2005 08a4 84EB      		ldi r24,lo8(-76)
 2006 08a6 8093 0000 		sts uip_buf+57,r24
1406:Lib/uip/uip.c ****   BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
 2007               		.loc 1 1406 0
 2008 08aa 8CE2      		ldi r24,lo8(44)
 2009 08ac 90E0      		ldi r25,0
 2010 08ae 9093 0000 		sts uip_len+1,r25
 2011 08b2 8093 0000 		sts uip_len,r24
1407:Lib/uip/uip.c ****   goto tcp_send;
 2012               		.loc 1 1407 0
 2013 08b6 80E6      		ldi r24,lo8(96)
 2014 08b8 00C0      		rjmp .L322
 2015               	.L124:
1412:Lib/uip/uip.c ****   uip_flags = 0;
 2016               		.loc 1 1412 0
 2017 08ba D093 0000 		sts uip_conn+1,r29
 2018 08be C093 0000 		sts uip_conn,r28
1413:Lib/uip/uip.c ****   /* We do a very naive form of TCP reset processing; we just accept
 2019               		.loc 1 1413 0
 2020 08c2 1092 0000 		sts uip_flags,__zero_reg__
1418:Lib/uip/uip.c ****     uip_connr->tcpstateflags = UIP_CLOSED;
 2021               		.loc 1 1418 0
 2022 08c6 9091 0000 		lds r25,uip_buf+47
 2023 08ca 792F      		mov r23,r25
 2024 08cc 7470      		andi r23,lo8(4)
 2025 08ce F72E      		mov r15,r23
 2026 08d0 92FF      		sbrs r25,2
 2027 08d2 00C0      		rjmp .L151
1419:Lib/uip/uip.c ****     UIP_LOG("tcp: got reset, aborting connection.");
 2028               		.loc 1 1419 0
 2029 08d4 198E      		std Y+25,__zero_reg__
1421:Lib/uip/uip.c ****     UIP_APPCALL();
 2030               		.loc 1 1421 0
 2031 08d6 80E2      		ldi r24,lo8(32)
 2032 08d8 00C0      		rjmp .L323
 2033               	.L151:
1427:Lib/uip/uip.c ****   /* uip_len will contain the length of the actual TCP data. This is
 2034               		.loc 1 1427 0
 2035 08da 8091 0000 		lds r24,uip_buf+46
 2036 08de 8295      		swap r24
 2037 08e0 8F70      		andi r24,lo8(15)
 2038 08e2 880F      		lsl r24
 2039 08e4 880F      		lsl r24
 2040 08e6 8093 0000 		sts c,r24
1431:Lib/uip/uip.c **** 
 2041               		.loc 1 1431 0
 2042 08ea 081B      		sub r16,r24
 2043 08ec 1109      		sbc r17,__zero_reg__
 2044 08ee 0451      		subi r16,20
 2045 08f0 1109      		sbc r17,__zero_reg__
 2046 08f2 1093 0000 		sts uip_len+1,r17
 2047 08f6 0093 0000 		sts uip_len,r16
1436:Lib/uip/uip.c ****        ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
 2048               		.loc 1 1436 0
 2049 08fa 2F70      		andi r18,lo8(15)
 2050 08fc 2230      		cpi r18,lo8(2)
 2051 08fe 01F4      		brne .L152
1436:Lib/uip/uip.c ****        ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
 2052               		.loc 1 1436 0 is_stmt 0 discriminator 1
 2053 0900 892F      		mov r24,r25
 2054 0902 8F73      		andi r24,lo8(63)
 2055 0904 8231      		cpi r24,lo8(18)
 2056 0906 01F0      		breq .L153
 2057               	.L152:
1438:Lib/uip/uip.c ****        (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
 2058               		.loc 1 1438 0 is_stmt 1
 2059 0908 012B      		or r16,r17
 2060 090a 01F4      		brne .L154
1438:Lib/uip/uip.c ****        (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
 2061               		.loc 1 1438 0 is_stmt 0 discriminator 2
 2062 090c 892F      		mov r24,r25
 2063 090e 8370      		andi r24,lo8(3)
 2064 0910 01F0      		breq .L153
 2065               	.L154:
1438:Lib/uip/uip.c ****        (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
 2066               		.loc 1 1438 0 discriminator 3
 2067 0912 2091 0000 		lds r18,uip_buf+38
 2068 0916 8885      		ldd r24,Y+8
 2069 0918 2813      		cpse r18,r24
 2070 091a 00C0      		rjmp .L168
1439:Lib/uip/uip.c **** 	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
 2071               		.loc 1 1439 0 is_stmt 1
 2072 091c 2091 0000 		lds r18,uip_buf+39
 2073 0920 8985      		ldd r24,Y+9
 2074 0922 2813      		cpse r18,r24
 2075 0924 00C0      		rjmp .L168
1440:Lib/uip/uip.c **** 	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
 2076               		.loc 1 1440 0
 2077 0926 2091 0000 		lds r18,uip_buf+40
 2078 092a 8A85      		ldd r24,Y+10
 2079 092c 2813      		cpse r18,r24
 2080 092e 00C0      		rjmp .L168
1441:Lib/uip/uip.c **** 	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
 2081               		.loc 1 1441 0
 2082 0930 2091 0000 		lds r18,uip_buf+41
 2083 0934 8B85      		ldd r24,Y+11
 2084 0936 2813      		cpse r18,r24
 2085 0938 00C0      		rjmp .L168
 2086               	.L153:
1451:Lib/uip/uip.c ****     uip_add32(uip_connr->snd_nxt, uip_connr->len);
 2087               		.loc 1 1451 0
 2088 093a 94FF      		sbrs r25,4
 2089 093c 00C0      		rjmp .L157
1451:Lib/uip/uip.c ****     uip_add32(uip_connr->snd_nxt, uip_connr->len);
 2090               		.loc 1 1451 0 is_stmt 0 discriminator 1
 2091 093e 6889      		ldd r22,Y+16
 2092 0940 7989      		ldd r23,Y+17
 2093 0942 6115      		cp r22,__zero_reg__
 2094 0944 7105      		cpc r23,__zero_reg__
 2095 0946 01F4      		brne .+2
 2096 0948 00C0      		rjmp .L157
1452:Lib/uip/uip.c **** 
 2097               		.loc 1 1452 0 is_stmt 1
 2098 094a CE01      		movw r24,r28
 2099 094c 0C96      		adiw r24,12
 2100 094e 0E94 0000 		call uip_add32
 2101               	.LVL95:
1454:Lib/uip/uip.c ****        BUF->ackno[1] == uip_acc32[1] &&
 2102               		.loc 1 1454 0
 2103 0952 3091 0000 		lds r19,uip_buf+42
 2104 0956 8091 0000 		lds r24,uip_acc32
 2105 095a 3813      		cpse r19,r24
 2106 095c 00C0      		rjmp .L157
1455:Lib/uip/uip.c ****        BUF->ackno[2] == uip_acc32[2] &&
 2107               		.loc 1 1455 0 discriminator 1
 2108 095e 2091 0000 		lds r18,uip_buf+43
1454:Lib/uip/uip.c ****        BUF->ackno[1] == uip_acc32[1] &&
 2109               		.loc 1 1454 0 discriminator 1
 2110 0962 8091 0000 		lds r24,uip_acc32+1
 2111 0966 2813      		cpse r18,r24
 2112 0968 00C0      		rjmp .L157
1456:Lib/uip/uip.c ****        BUF->ackno[3] == uip_acc32[3]) {
 2113               		.loc 1 1456 0
 2114 096a 9091 0000 		lds r25,uip_buf+44
1455:Lib/uip/uip.c ****        BUF->ackno[2] == uip_acc32[2] &&
 2115               		.loc 1 1455 0
 2116 096e 8091 0000 		lds r24,uip_acc32+2
 2117 0972 9813      		cpse r25,r24
 2118 0974 00C0      		rjmp .L157
1457:Lib/uip/uip.c ****       /* Update sequence number. */
 2119               		.loc 1 1457 0
 2120 0976 8091 0000 		lds r24,uip_buf+45
1456:Lib/uip/uip.c ****        BUF->ackno[3] == uip_acc32[3]) {
 2121               		.loc 1 1456 0
 2122 097a 4091 0000 		lds r20,uip_acc32+3
 2123 097e 8413      		cpse r24,r20
 2124 0980 00C0      		rjmp .L157
1459:Lib/uip/uip.c ****       uip_connr->snd_nxt[1] = uip_acc32[1];
 2125               		.loc 1 1459 0
 2126 0982 3C87      		std Y+12,r19
1460:Lib/uip/uip.c ****       uip_connr->snd_nxt[2] = uip_acc32[2];
 2127               		.loc 1 1460 0
 2128 0984 2D87      		std Y+13,r18
1461:Lib/uip/uip.c ****       uip_connr->snd_nxt[3] = uip_acc32[3];
 2129               		.loc 1 1461 0
 2130 0986 9E87      		std Y+14,r25
1462:Lib/uip/uip.c **** 
 2131               		.loc 1 1462 0
 2132 0988 8F87      		std Y+15,r24
1465:Lib/uip/uip.c **** 	signed char m;
 2133               		.loc 1 1465 0
 2134 098a 8B8D      		ldd r24,Y+27
 2135 098c 8111      		cpse r24,__zero_reg__
 2136 098e 00C0      		rjmp .L159
 2137               	.LVL96:
 2138               	.LBB26:
1469:Lib/uip/uip.c **** 	uip_connr->sa += m;
 2139               		.loc 1 1469 0
 2140 0990 9E89      		ldd r25,Y+22
 2141 0992 888D      		ldd r24,Y+24
 2142 0994 2A8D      		ldd r18,Y+26
 2143 0996 821B      		sub r24,r18
 2144               	.LVL97:
 2145 0998 292F      		mov r18,r25
 2146 099a 2695      		lsr r18
 2147 099c 2695      		lsr r18
 2148 099e 2695      		lsr r18
 2149 09a0 821B      		sub r24,r18
 2150               	.LVL98:
1470:Lib/uip/uip.c **** 	if(m < 0) {
 2151               		.loc 1 1470 0
 2152 09a2 980F      		add r25,r24
 2153 09a4 9E8B      		std Y+22,r25
1472:Lib/uip/uip.c **** 	}
 2154               		.loc 1 1472 0
 2155 09a6 87FD      		sbrc r24,7
 2156 09a8 8195      		neg r24
 2157               	.LVL99:
1474:Lib/uip/uip.c **** 	uip_connr->sv += m;
 2158               		.loc 1 1474 0
 2159 09aa 2F89      		ldd r18,Y+23
 2160               	.LVL100:
1475:Lib/uip/uip.c **** 	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
 2161               		.loc 1 1475 0
 2162 09ac 322F      		mov r19,r18
 2163 09ae 3695      		lsr r19
 2164 09b0 3695      		lsr r19
 2165 09b2 231B      		sub r18,r19
 2166               	.LVL101:
 2167 09b4 820F      		add r24,r18
 2168               	.LVL102:
 2169 09b6 8F8B      		std Y+23,r24
1476:Lib/uip/uip.c **** 
 2170               		.loc 1 1476 0
 2171 09b8 9695      		lsr r25
 2172 09ba 9695      		lsr r25
 2173 09bc 9695      		lsr r25
 2174 09be 890F      		add r24,r25
 2175 09c0 888F      		std Y+24,r24
 2176               	.L159:
 2177               	.LBE26:
1480:Lib/uip/uip.c ****       /* Reset the retransmission timer. */
 2178               		.loc 1 1480 0
 2179 09c2 81E0      		ldi r24,lo8(1)
 2180 09c4 8093 0000 		sts uip_flags,r24
1482:Lib/uip/uip.c **** 
 2181               		.loc 1 1482 0
 2182 09c8 888D      		ldd r24,Y+24
 2183 09ca 8A8F      		std Y+26,r24
1485:Lib/uip/uip.c ****     }
 2184               		.loc 1 1485 0
 2185 09cc 198A      		std Y+17,__zero_reg__
 2186 09ce 188A      		std Y+16,__zero_reg__
 2187               	.L157:
1491:Lib/uip/uip.c ****     /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
 2188               		.loc 1 1491 0
 2189 09d0 298D      		ldd r18,Y+25
 2190 09d2 E22F      		mov r30,r18
 2191 09d4 EF70      		andi r30,lo8(15)
 2192 09d6 8E2F      		mov r24,r30
 2193 09d8 90E0      		ldi r25,0
 2194 09da FC01      		movw r30,r24
 2195 09dc 3197      		sbiw r30,1
 2196 09de E830      		cpi r30,8
 2197 09e0 F105      		cpc r31,__zero_reg__
 2198 09e2 00F0      		brlo .+2
 2199 09e4 00C0      		rjmp .L94
 2200 09e6 E050      		subi r30,lo8(-(gs(.L162)))
 2201 09e8 F040      		sbci r31,hi8(-(gs(.L162)))
 2202 09ea 0C94 0000 		jmp __tablejump2__
 2203               		.section	.progmem.gcc_sw_table.uip_process,"a",@progbits
 2204               		.p2align	1
 2205               	.L162:
 2206 0000 0000      		.word gs(.L161)
 2207 0002 0000      		.word gs(.L163)
 2208 0004 0000      		.word gs(.L164)
 2209 0006 0000      		.word gs(.L165)
 2210 0008 0000      		.word gs(.L166)
 2211 000a 0000      		.word gs(.L167)
 2212 000c 0000      		.word gs(.L168)
 2213 000e 0000      		.word gs(.L169)
 2214               		.section	.text.uip_process
 2215               	.L161:
1501:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_ESTABLISHED;
 2216               		.loc 1 1501 0
 2217 09ee 8091 0000 		lds r24,uip_flags
 2218 09f2 80FF      		sbrs r24,0
 2219 09f4 00C0      		rjmp .L94
1502:Lib/uip/uip.c ****       uip_flags = UIP_CONNECTED;
 2220               		.loc 1 1502 0
 2221 09f6 83E0      		ldi r24,lo8(3)
 2222 09f8 898F      		std Y+25,r24
1503:Lib/uip/uip.c ****       uip_connr->len = 0;
 2223               		.loc 1 1503 0
 2224 09fa 80E4      		ldi r24,lo8(64)
 2225 09fc 8093 0000 		sts uip_flags,r24
1504:Lib/uip/uip.c ****       if(uip_len > 0) {
 2226               		.loc 1 1504 0
 2227 0a00 198A      		std Y+17,__zero_reg__
 2228 0a02 188A      		std Y+16,__zero_reg__
1505:Lib/uip/uip.c ****         uip_flags |= UIP_NEWDATA;
 2229               		.loc 1 1505 0
 2230 0a04 8091 0000 		lds r24,uip_len
 2231 0a08 9091 0000 		lds r25,uip_len+1
 2232 0a0c 0097      		sbiw r24,0
 2233 0a0e 01F4      		brne .+2
 2234 0a10 00C0      		rjmp .L318
1506:Lib/uip/uip.c ****         uip_add_rcv_nxt(uip_len);
 2235               		.loc 1 1506 0
 2236 0a12 22E4      		ldi r18,lo8(66)
 2237 0a14 2093 0000 		sts uip_flags,r18
1507:Lib/uip/uip.c ****       }
 2238               		.loc 1 1507 0
 2239 0a18 0E94 0000 		call uip_add_rcv_nxt
 2240               	.LVL103:
 2241 0a1c 00C0      		rjmp .L318
 2242               	.L163:
1520:Lib/uip/uip.c ****        (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
 2243               		.loc 1 1520 0
 2244 0a1e 8091 0000 		lds r24,uip_flags
 2245 0a22 80FF      		sbrs r24,0
 2246 0a24 00C0      		rjmp .L171
1520:Lib/uip/uip.c ****        (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
 2247               		.loc 1 1520 0 is_stmt 0 discriminator 1
 2248 0a26 8091 0000 		lds r24,uip_buf+47
 2249 0a2a 8F73      		andi r24,lo8(63)
 2250 0a2c 8231      		cpi r24,lo8(18)
 2251 0a2e 01F0      		breq .+2
 2252 0a30 00C0      		rjmp .L171
1524:Lib/uip/uip.c **** 	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 2253               		.loc 1 1524 0 is_stmt 1
 2254 0a32 8091 0000 		lds r24,uip_buf+46
 2255 0a36 982F      		mov r25,r24
 2256 0a38 907F      		andi r25,lo8(-16)
 2257 0a3a 9135      		cpi r25,lo8(81)
 2258 0a3c 00F0      		brlo .L173
1525:Lib/uip/uip.c **** 	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
 2259               		.loc 1 1525 0
 2260 0a3e 8295      		swap r24
 2261 0a40 8F70      		andi r24,lo8(15)
 2262 0a42 90E0      		ldi r25,0
 2263 0a44 0597      		sbiw r24,5
 2264 0a46 880F      		lsl r24
 2265 0a48 991F      		rol r25
 2266 0a4a 880F      		lsl r24
 2267 0a4c 991F      		rol r25
 2268               	.L174:
1525:Lib/uip/uip.c **** 	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
 2269               		.loc 1 1525 0 is_stmt 0 discriminator 1
 2270 0a4e EF2D      		mov r30,r15
 2271 0a50 F0E0      		ldi r31,0
 2272 0a52 E817      		cp r30,r24
 2273 0a54 F907      		cpc r31,r25
 2274 0a56 04F4      		brge .L316
1526:Lib/uip/uip.c **** 	  if(opt == TCP_OPT_END) {
 2275               		.loc 1 1526 0 is_stmt 1
 2276 0a58 E050      		subi r30,lo8(-(uip_buf))
 2277 0a5a F040      		sbci r31,hi8(-(uip_buf))
 2278 0a5c 26A9      		ldd r18,Z+54
1527:Lib/uip/uip.c **** 	    /* End of options. */
 2279               		.loc 1 1527 0
 2280 0a5e 2223      		tst r18
 2281 0a60 01F0      		breq .L316
1530:Lib/uip/uip.c **** 	    ++c;
 2282               		.loc 1 1530 0
 2283 0a62 2130      		cpi r18,lo8(1)
 2284 0a64 01F4      		brne .L177
1531:Lib/uip/uip.c **** 	    /* NOP option. */
 2285               		.loc 1 1531 0
 2286 0a66 F394      		inc r15
 2287 0a68 00C0      		rjmp .L174
 2288               	.L177:
1533:Lib/uip/uip.c **** 		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
 2289               		.loc 1 1533 0
 2290 0a6a 2230      		cpi r18,lo8(2)
 2291 0a6c 01F4      		brne .L179
1533:Lib/uip/uip.c **** 		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
 2292               		.loc 1 1533 0 is_stmt 0 discriminator 1
 2293 0a6e 27A9      		ldd r18,Z+55
 2294 0a70 2430      		cpi r18,lo8(4)
 2295 0a72 01F4      		brne .L179
 2296 0a74 F092 0000 		sts c,r15
1536:Lib/uip/uip.c **** 	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
 2297               		.loc 1 1536 0 is_stmt 1
 2298 0a78 80AD      		ldd r24,Z+56
 2299 0a7a 90E0      		ldi r25,0
 2300 0a7c 982F      		mov r25,r24
 2301 0a7e 8827      		clr r24
 2302 0a80 21AD      		ldd r18,Z+57
 2303 0a82 822B      		or r24,r18
 2304 0a84 9093 0000 		sts tmp16+1,r25
 2305 0a88 8093 0000 		sts tmp16,r24
1539:Lib/uip/uip.c **** 
 2306               		.loc 1 1539 0
 2307 0a8c 853B      		cpi r24,-75
 2308 0a8e 25E0      		ldi r18,5
 2309 0a90 9207      		cpc r25,r18
 2310 0a92 00F0      		brlo .L180
 2311 0a94 84EB      		ldi r24,lo8(-76)
 2312 0a96 95E0      		ldi r25,lo8(5)
 2313               	.L180:
 2314 0a98 9B8B      		std Y+19,r25
 2315 0a9a 8A8B      		std Y+18,r24
1538:Lib/uip/uip.c **** 	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
 2316               		.loc 1 1538 0
 2317 0a9c 9D8B      		std Y+21,r25
 2318 0a9e 8C8B      		std Y+20,r24
1542:Lib/uip/uip.c **** 	  } else {
 2319               		.loc 1 1542 0
 2320 0aa0 00C0      		rjmp .L173
 2321               	.L179:
1546:Lib/uip/uip.c **** 	      /* If the length field is zero, the options are malformed
 2322               		.loc 1 1546 0
 2323 0aa2 27A9      		ldd r18,Z+55
 2324 0aa4 2223      		tst r18
 2325 0aa6 01F0      		breq .L316
1551:Lib/uip/uip.c **** 	  }
 2326               		.loc 1 1551 0
 2327 0aa8 F20E      		add r15,r18
 2328 0aaa 00C0      		rjmp .L174
 2329               	.L316:
 2330 0aac F092 0000 		sts c,r15
 2331               	.L173:
1555:Lib/uip/uip.c ****       uip_connr->rcv_nxt[0] = BUF->seqno[0];
 2332               		.loc 1 1555 0
 2333 0ab0 83E0      		ldi r24,lo8(3)
 2334 0ab2 898F      		std Y+25,r24
1556:Lib/uip/uip.c ****       uip_connr->rcv_nxt[1] = BUF->seqno[1];
 2335               		.loc 1 1556 0
 2336 0ab4 8091 0000 		lds r24,uip_buf+38
 2337 0ab8 8887      		std Y+8,r24
1557:Lib/uip/uip.c ****       uip_connr->rcv_nxt[2] = BUF->seqno[2];
 2338               		.loc 1 1557 0
 2339 0aba 8091 0000 		lds r24,uip_buf+39
 2340 0abe 8987      		std Y+9,r24
1558:Lib/uip/uip.c ****       uip_connr->rcv_nxt[3] = BUF->seqno[3];
 2341               		.loc 1 1558 0
 2342 0ac0 8091 0000 		lds r24,uip_buf+40
 2343 0ac4 8A87      		std Y+10,r24
1559:Lib/uip/uip.c ****       uip_add_rcv_nxt(1);
 2344               		.loc 1 1559 0
 2345 0ac6 8091 0000 		lds r24,uip_buf+41
 2346 0aca 8B87      		std Y+11,r24
1560:Lib/uip/uip.c ****       uip_flags = UIP_CONNECTED | UIP_NEWDATA;
 2347               		.loc 1 1560 0
 2348 0acc 81E0      		ldi r24,lo8(1)
 2349 0ace 90E0      		ldi r25,0
 2350 0ad0 0E94 0000 		call uip_add_rcv_nxt
 2351               	.LVL104:
1561:Lib/uip/uip.c ****       uip_connr->len = 0;
 2352               		.loc 1 1561 0
 2353 0ad4 82E4      		ldi r24,lo8(66)
 2354 0ad6 8093 0000 		sts uip_flags,r24
1562:Lib/uip/uip.c ****       uip_len = 0;
 2355               		.loc 1 1562 0
 2356 0ada 198A      		std Y+17,__zero_reg__
 2357 0adc 188A      		std Y+16,__zero_reg__
1563:Lib/uip/uip.c ****       uip_slen = 0;
 2358               		.loc 1 1563 0
 2359 0ade 1092 0000 		sts uip_len+1,__zero_reg__
 2360 0ae2 1092 0000 		sts uip_len,__zero_reg__
 2361 0ae6 00C0      		rjmp .L318
 2362               	.L171:
1569:Lib/uip/uip.c ****     UIP_APPCALL();
 2363               		.loc 1 1569 0
 2364 0ae8 80E2      		ldi r24,lo8(32)
 2365 0aea 8093 0000 		sts uip_flags,r24
1570:Lib/uip/uip.c ****     /* The connection is closed after we send the RST */
 2366               		.loc 1 1570 0
 2367 0aee 0E94 0000 		call uIPManagement_TCPCallback
 2368               	.LVL105:
1572:Lib/uip/uip.c ****     goto reset;
 2369               		.loc 1 1572 0
 2370 0af2 E091 0000 		lds r30,uip_conn
 2371 0af6 F091 0000 		lds r31,uip_conn+1
 2372 0afa 118E      		std Z+25,__zero_reg__
1573:Lib/uip/uip.c **** #endif /* UIP_ACTIVE_OPEN */
 2373               		.loc 1 1573 0
 2374 0afc 00C0      		rjmp .L127
 2375               	.L164:
1588:Lib/uip/uip.c ****       if(uip_outstanding(uip_connr)) {
 2376               		.loc 1 1588 0
 2377 0afe 8091 0000 		lds r24,uip_buf+47
 2378 0b02 80FF      		sbrs r24,0
 2379 0b04 00C0      		rjmp .L183
1588:Lib/uip/uip.c ****       if(uip_outstanding(uip_connr)) {
 2380               		.loc 1 1588 0 is_stmt 0 discriminator 1
 2381 0b06 24FD      		sbrc r18,4
 2382 0b08 00C0      		rjmp .L183
1589:Lib/uip/uip.c **** 	goto drop;
 2383               		.loc 1 1589 0 is_stmt 1
 2384 0b0a 8889      		ldd r24,Y+16
 2385 0b0c 9989      		ldd r25,Y+17
 2386 0b0e 892B      		or r24,r25
 2387 0b10 01F0      		breq .+2
 2388 0b12 00C0      		rjmp .L94
1592:Lib/uip/uip.c ****       uip_flags |= UIP_CLOSE;
 2389               		.loc 1 1592 0
 2390 0b14 8091 0000 		lds r24,uip_len
 2391 0b18 9091 0000 		lds r25,uip_len+1
 2392 0b1c 0196      		adiw r24,1
 2393 0b1e 0E94 0000 		call uip_add_rcv_nxt
 2394               	.LVL106:
1593:Lib/uip/uip.c ****       if(uip_len > 0) {
 2395               		.loc 1 1593 0
 2396 0b22 8091 0000 		lds r24,uip_flags
 2397 0b26 982F      		mov r25,r24
 2398 0b28 9061      		ori r25,lo8(16)
 2399 0b2a 9093 0000 		sts uip_flags,r25
1594:Lib/uip/uip.c **** 	uip_flags |= UIP_NEWDATA;
 2400               		.loc 1 1594 0
 2401 0b2e 2091 0000 		lds r18,uip_len
 2402 0b32 3091 0000 		lds r19,uip_len+1
 2403 0b36 232B      		or r18,r19
 2404 0b38 01F0      		breq .L184
1595:Lib/uip/uip.c ****       }
 2405               		.loc 1 1595 0
 2406 0b3a 8261      		ori r24,lo8(18)
 2407 0b3c 8093 0000 		sts uip_flags,r24
 2408               	.L184:
1597:Lib/uip/uip.c ****       uip_connr->len = 1;
 2409               		.loc 1 1597 0
 2410 0b40 0E94 0000 		call uIPManagement_TCPCallback
 2411               	.LVL107:
1598:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_LAST_ACK;
 2412               		.loc 1 1598 0
 2413 0b44 81E0      		ldi r24,lo8(1)
 2414 0b46 90E0      		ldi r25,0
 2415 0b48 998B      		std Y+17,r25
 2416 0b4a 888B      		std Y+16,r24
1599:Lib/uip/uip.c ****       uip_connr->nrtx = 0;
 2417               		.loc 1 1599 0
 2418 0b4c 88E0      		ldi r24,lo8(8)
 2419               	.L327:
 2420 0b4e 898F      		std Y+25,r24
1600:Lib/uip/uip.c ****     tcp_send_finack:
 2421               		.loc 1 1600 0
 2422 0b50 1B8E      		std Y+27,__zero_reg__
 2423               	.LVL108:
 2424               	.L104:
1602:Lib/uip/uip.c ****       goto tcp_send_nodata;
 2425               		.loc 1 1602 0
 2426 0b52 81E1      		ldi r24,lo8(17)
 2427 0b54 00C0      		rjmp .L320
 2428               	.L183:
1608:Lib/uip/uip.c **** #if UIP_URGDATA > 0
 2429               		.loc 1 1608 0
 2430 0b56 85FF      		sbrs r24,5
 2431 0b58 00C0      		rjmp .L185
 2432 0b5a 8091 0000 		lds r24,uip_buf+52
 2433 0b5e 9091 0000 		lds r25,uip_buf+52+1
 2434 0b62 9827      		eor r25,r24
 2435 0b64 8927      		eor r24,r25
 2436 0b66 9827      		eor r25,r24
1622:Lib/uip/uip.c ****       uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
 2437               		.loc 1 1622 0
 2438 0b68 4091 0000 		lds r20,uip_appdata
 2439 0b6c 5091 0000 		lds r21,uip_appdata+1
 2440 0b70 480F      		add r20,r24
 2441 0b72 591F      		adc r21,r25
 2442 0b74 5093 0000 		sts uip_appdata+1,r21
 2443 0b78 4093 0000 		sts uip_appdata,r20
1623:Lib/uip/uip.c **** #endif /* UIP_URGDATA > 0 */
 2444               		.loc 1 1623 0
 2445 0b7c 4091 0000 		lds r20,uip_len
 2446 0b80 5091 0000 		lds r21,uip_len+1
 2447 0b84 BA01      		movw r22,r20
 2448 0b86 681B      		sub r22,r24
 2449 0b88 790B      		sbc r23,r25
 2450 0b8a 7093 0000 		sts uip_len+1,r23
 2451 0b8e 6093 0000 		sts uip_len,r22
 2452               	.L185:
1632:Lib/uip/uip.c ****       uip_flags |= UIP_NEWDATA;
 2453               		.loc 1 1632 0
 2454 0b92 4091 0000 		lds r20,uip_len
 2455 0b96 5091 0000 		lds r21,uip_len+1
 2456 0b9a 4115      		cp r20,__zero_reg__
 2457 0b9c 5105      		cpc r21,__zero_reg__
 2458 0b9e 01F0      		breq .L186
1632:Lib/uip/uip.c ****       uip_flags |= UIP_NEWDATA;
 2459               		.loc 1 1632 0 is_stmt 0 discriminator 1
 2460 0ba0 24FD      		sbrc r18,4
 2461 0ba2 00C0      		rjmp .L186
1633:Lib/uip/uip.c ****       uip_add_rcv_nxt(uip_len);
 2462               		.loc 1 1633 0 is_stmt 1
 2463 0ba4 9091 0000 		lds r25,uip_flags
 2464 0ba8 9260      		ori r25,lo8(2)
 2465 0baa 9093 0000 		sts uip_flags,r25
1634:Lib/uip/uip.c ****     }
 2466               		.loc 1 1634 0
 2467 0bae CA01      		movw r24,r20
 2468 0bb0 0E94 0000 		call uip_add_rcv_nxt
 2469               	.LVL109:
 2470               	.L186:
1649:Lib/uip/uip.c ****     if(tmp16 > uip_connr->initialmss ||
 2471               		.loc 1 1649 0
 2472 0bb4 8091 0000 		lds r24,uip_buf+48
 2473 0bb8 90E0      		ldi r25,0
 2474 0bba 982F      		mov r25,r24
 2475 0bbc 8827      		clr r24
 2476 0bbe 2091 0000 		lds r18,uip_buf+49
 2477 0bc2 820F      		add r24,r18
 2478 0bc4 911D      		adc r25,__zero_reg__
 2479 0bc6 9093 0000 		sts tmp16+1,r25
 2480 0bca 8093 0000 		sts tmp16,r24
1650:Lib/uip/uip.c ****        tmp16 == 0) {
 2481               		.loc 1 1650 0
 2482 0bce 2C89      		ldd r18,Y+20
 2483 0bd0 3D89      		ldd r19,Y+21
 2484 0bd2 2817      		cp r18,r24
 2485 0bd4 3907      		cpc r19,r25
 2486 0bd6 00F0      		brlo .L187
1650:Lib/uip/uip.c ****        tmp16 == 0) {
 2487               		.loc 1 1650 0 is_stmt 0 discriminator 1
 2488 0bd8 892B      		or r24,r25
 2489 0bda 01F4      		brne .L188
 2490               	.L187:
1652:Lib/uip/uip.c ****     }
 2491               		.loc 1 1652 0 is_stmt 1
 2492 0bdc 3093 0000 		sts tmp16+1,r19
 2493 0be0 2093 0000 		sts tmp16,r18
 2494               	.L188:
1654:Lib/uip/uip.c **** 
 2495               		.loc 1 1654 0
 2496 0be4 8091 0000 		lds r24,tmp16
 2497 0be8 9091 0000 		lds r25,tmp16+1
 2498 0bec 9B8B      		std Y+19,r25
 2499 0bee 8A8B      		std Y+18,r24
1672:Lib/uip/uip.c ****       uip_slen = 0;
 2500               		.loc 1 1672 0
 2501 0bf0 8091 0000 		lds r24,uip_flags
 2502 0bf4 8370      		andi r24,lo8(3)
 2503 0bf6 01F4      		brne .+2
 2504 0bf8 00C0      		rjmp .L94
 2505               	.L318:
1673:Lib/uip/uip.c ****       UIP_APPCALL();
 2506               		.loc 1 1673 0
 2507 0bfa 1092 0000 		sts uip_slen+1,__zero_reg__
 2508 0bfe 1092 0000 		sts uip_slen,__zero_reg__
 2509               	.LVL110:
 2510               	.L317:
1674:Lib/uip/uip.c **** 
 2511               		.loc 1 1674 0
 2512 0c02 0E94 0000 		call uIPManagement_TCPCallback
 2513               	.LVL111:
 2514               	.L88:
1678:Lib/uip/uip.c **** 	uip_slen = 0;
 2515               		.loc 1 1678 0
 2516 0c06 8091 0000 		lds r24,uip_flags
 2517 0c0a 85FF      		sbrs r24,5
 2518 0c0c 00C0      		rjmp .L189
1679:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_CLOSED;
 2519               		.loc 1 1679 0
 2520 0c0e 1092 0000 		sts uip_slen+1,__zero_reg__
 2521 0c12 1092 0000 		sts uip_slen,__zero_reg__
1680:Lib/uip/uip.c **** 	BUF->flags = TCP_RST | TCP_ACK;
 2522               		.loc 1 1680 0
 2523 0c16 198E      		std Y+25,__zero_reg__
 2524               	.LVL112:
 2525               	.L326:
1681:Lib/uip/uip.c **** 	goto tcp_send_nodata;
 2526               		.loc 1 1681 0
 2527 0c18 84E1      		ldi r24,lo8(20)
 2528 0c1a 00C0      		rjmp .L320
 2529               	.LVL113:
 2530               	.L189:
1685:Lib/uip/uip.c **** 	uip_slen = 0;
 2531               		.loc 1 1685 0
 2532 0c1c 84FF      		sbrs r24,4
 2533 0c1e 00C0      		rjmp .L190
1686:Lib/uip/uip.c **** 	uip_connr->len = 1;
 2534               		.loc 1 1686 0
 2535 0c20 1092 0000 		sts uip_slen+1,__zero_reg__
 2536 0c24 1092 0000 		sts uip_slen,__zero_reg__
1687:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
 2537               		.loc 1 1687 0
 2538 0c28 81E0      		ldi r24,lo8(1)
 2539 0c2a 90E0      		ldi r25,0
 2540 0c2c 998B      		std Y+17,r25
 2541 0c2e 888B      		std Y+16,r24
1688:Lib/uip/uip.c **** 	uip_connr->nrtx = 0;
 2542               		.loc 1 1688 0
 2543 0c30 84E0      		ldi r24,lo8(4)
 2544 0c32 00C0      		rjmp .L327
 2545               	.L190:
1695:Lib/uip/uip.c **** 
 2546               		.loc 1 1695 0
 2547 0c34 2091 0000 		lds r18,uip_slen
 2548 0c38 3091 0000 		lds r19,uip_slen+1
 2549 0c3c 2115      		cp r18,__zero_reg__
 2550 0c3e 3105      		cpc r19,__zero_reg__
 2551 0c40 01F0      		breq .L191
1699:Lib/uip/uip.c **** 	  uip_connr->len = 0;
 2552               		.loc 1 1699 0
 2553 0c42 80FF      		sbrs r24,0
 2554 0c44 00C0      		rjmp .L192
1700:Lib/uip/uip.c **** 	}
 2555               		.loc 1 1700 0
 2556 0c46 198A      		std Y+17,__zero_reg__
 2557 0c48 188A      		std Y+16,__zero_reg__
 2558               	.L192:
1706:Lib/uip/uip.c **** 
 2559               		.loc 1 1706 0
 2560 0c4a 8889      		ldd r24,Y+16
 2561 0c4c 9989      		ldd r25,Y+17
 2562 0c4e 0097      		sbiw r24,0
 2563 0c50 01F4      		brne .L193
1711:Lib/uip/uip.c **** 	    uip_slen = uip_connr->mss;
 2564               		.loc 1 1711 0
 2565 0c52 8A89      		ldd r24,Y+18
 2566 0c54 9B89      		ldd r25,Y+19
 2567 0c56 8217      		cp r24,r18
 2568 0c58 9307      		cpc r25,r19
 2569 0c5a 00F4      		brsh .L194
1712:Lib/uip/uip.c **** 	  }
 2570               		.loc 1 1712 0
 2571 0c5c 9093 0000 		sts uip_slen+1,r25
 2572 0c60 8093 0000 		sts uip_slen,r24
 2573               	.L194:
1717:Lib/uip/uip.c **** 	} else {
 2574               		.loc 1 1717 0
 2575 0c64 8091 0000 		lds r24,uip_slen
 2576 0c68 9091 0000 		lds r25,uip_slen+1
 2577 0c6c 998B      		std Y+17,r25
 2578 0c6e 888B      		std Y+16,r24
 2579 0c70 00C0      		rjmp .L191
 2580               	.L193:
1723:Lib/uip/uip.c **** 	}
 2581               		.loc 1 1723 0
 2582 0c72 9093 0000 		sts uip_slen+1,r25
 2583 0c76 8093 0000 		sts uip_slen,r24
 2584               	.L191:
1726:Lib/uip/uip.c ****     apprexmit:
 2585               		.loc 1 1726 0
 2586 0c7a 1B8E      		std Y+27,__zero_reg__
 2587               	.LVL114:
 2588               	.L106:
1728:Lib/uip/uip.c **** 
 2589               		.loc 1 1728 0
 2590 0c7c 8091 0000 		lds r24,uip_sappdata
 2591 0c80 9091 0000 		lds r25,uip_sappdata+1
 2592 0c84 9093 0000 		sts uip_appdata+1,r25
 2593 0c88 8093 0000 		sts uip_appdata,r24
1732:Lib/uip/uip.c **** 	/* Add the length of the IP and TCP headers. */
 2594               		.loc 1 1732 0
 2595 0c8c 8091 0000 		lds r24,uip_slen
 2596 0c90 9091 0000 		lds r25,uip_slen+1
 2597 0c94 892B      		or r24,r25
 2598 0c96 01F0      		breq .L195
1732:Lib/uip/uip.c **** 	/* Add the length of the IP and TCP headers. */
 2599               		.loc 1 1732 0 is_stmt 0 discriminator 1
 2600 0c98 8889      		ldd r24,Y+16
 2601 0c9a 9989      		ldd r25,Y+17
 2602 0c9c 0097      		sbiw r24,0
 2603 0c9e 01F0      		breq .L195
1734:Lib/uip/uip.c **** 	/* We always set the ACK flag in response packets. */
 2604               		.loc 1 1734 0 is_stmt 1
 2605 0ca0 8896      		adiw r24,40
 2606 0ca2 9093 0000 		sts uip_len+1,r25
 2607 0ca6 8093 0000 		sts uip_len,r24
1736:Lib/uip/uip.c **** 	/* Send the packet. */
 2608               		.loc 1 1736 0
 2609 0caa 88E1      		ldi r24,lo8(24)
 2610 0cac 00C0      		rjmp .L321
 2611               	.L195:
1742:Lib/uip/uip.c **** 	uip_len = UIP_TCPIP_HLEN;
 2612               		.loc 1 1742 0
 2613 0cae 8091 0000 		lds r24,uip_flags
 2614 0cb2 81FF      		sbrs r24,1
 2615 0cb4 00C0      		rjmp .L94
1743:Lib/uip/uip.c **** 	BUF->flags = TCP_ACK;
 2616               		.loc 1 1743 0
 2617 0cb6 88E2      		ldi r24,lo8(40)
 2618 0cb8 90E0      		ldi r25,0
 2619 0cba 9093 0000 		sts uip_len+1,r25
 2620 0cbe 8093 0000 		sts uip_len,r24
1744:Lib/uip/uip.c **** 	goto tcp_send_noopts;
 2621               		.loc 1 1744 0
 2622 0cc2 80E1      		ldi r24,lo8(16)
 2623               	.L321:
 2624 0cc4 8093 0000 		sts uip_buf+47,r24
1745:Lib/uip/uip.c ****       }
 2625               		.loc 1 1745 0
 2626 0cc8 00C0      		rjmp .L196
 2627               	.L169:
1752:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_CLOSED;
 2628               		.loc 1 1752 0
 2629 0cca 8091 0000 		lds r24,uip_flags
 2630 0cce 80FF      		sbrs r24,0
 2631 0cd0 00C0      		rjmp .L94
1753:Lib/uip/uip.c ****       uip_flags = UIP_CLOSE;
 2632               		.loc 1 1753 0
 2633 0cd2 198E      		std Y+25,__zero_reg__
1754:Lib/uip/uip.c ****       UIP_APPCALL();
 2634               		.loc 1 1754 0
 2635 0cd4 80E1      		ldi r24,lo8(16)
 2636               	.L323:
 2637 0cd6 8093 0000 		sts uip_flags,r24
1755:Lib/uip/uip.c ****     }
 2638               		.loc 1 1755 0
 2639 0cda 0E94 0000 		call uIPManagement_TCPCallback
 2640               	.LVL115:
 2641 0cde 00C0      		rjmp .L94
 2642               	.L165:
1763:Lib/uip/uip.c ****       uip_add_rcv_nxt(uip_len);
 2643               		.loc 1 1763 0
 2644 0ce0 8091 0000 		lds r24,uip_len
 2645 0ce4 9091 0000 		lds r25,uip_len+1
 2646 0ce8 0097      		sbiw r24,0
 2647 0cea 01F0      		breq .L197
1764:Lib/uip/uip.c ****     }
 2648               		.loc 1 1764 0
 2649 0cec 0E94 0000 		call uip_add_rcv_nxt
 2650               	.LVL116:
 2651               	.L197:
1766:Lib/uip/uip.c ****       if(uip_flags & UIP_ACKDATA) {
 2652               		.loc 1 1766 0
 2653 0cf0 9091 0000 		lds r25,uip_buf+47
 2654 0cf4 8091 0000 		lds r24,uip_flags
 2655 0cf8 90FF      		sbrs r25,0
 2656 0cfa 00C0      		rjmp .L198
1767:Lib/uip/uip.c **** 	uip_connr->tcpstateflags = UIP_TIME_WAIT;
 2657               		.loc 1 1767 0
 2658 0cfc 80FF      		sbrs r24,0
 2659 0cfe 00C0      		rjmp .L199
1768:Lib/uip/uip.c **** 	uip_connr->timer = 0;
 2660               		.loc 1 1768 0
 2661 0d00 87E0      		ldi r24,lo8(7)
 2662 0d02 898F      		std Y+25,r24
1769:Lib/uip/uip.c **** 	uip_connr->len = 0;
 2663               		.loc 1 1769 0
 2664 0d04 1A8E      		std Y+26,__zero_reg__
1770:Lib/uip/uip.c ****       } else {
 2665               		.loc 1 1770 0
 2666 0d06 198A      		std Y+17,__zero_reg__
 2667 0d08 188A      		std Y+16,__zero_reg__
 2668 0d0a 00C0      		rjmp .L319
 2669               	.L199:
1772:Lib/uip/uip.c ****       }
 2670               		.loc 1 1772 0
 2671 0d0c 86E0      		ldi r24,lo8(6)
 2672 0d0e 898F      		std Y+25,r24
 2673 0d10 00C0      		rjmp .L319
 2674               	.L198:
1778:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
 2675               		.loc 1 1778 0
 2676 0d12 80FF      		sbrs r24,0
 2677 0d14 00C0      		rjmp .L203
1779:Lib/uip/uip.c ****       uip_connr->len = 0;
 2678               		.loc 1 1779 0
 2679 0d16 85E0      		ldi r24,lo8(5)
 2680 0d18 898F      		std Y+25,r24
1780:Lib/uip/uip.c ****       goto drop;
 2681               		.loc 1 1780 0
 2682 0d1a 198A      		std Y+17,__zero_reg__
 2683 0d1c 188A      		std Y+16,__zero_reg__
1781:Lib/uip/uip.c ****     }
 2684               		.loc 1 1781 0
 2685 0d1e 00C0      		rjmp .L94
 2686               	.L166:
1789:Lib/uip/uip.c ****       uip_add_rcv_nxt(uip_len);
 2687               		.loc 1 1789 0
 2688 0d20 8091 0000 		lds r24,uip_len
 2689 0d24 9091 0000 		lds r25,uip_len+1
 2690 0d28 0097      		sbiw r24,0
 2691 0d2a 01F0      		breq .L202
1790:Lib/uip/uip.c ****     }
 2692               		.loc 1 1790 0
 2693 0d2c 0E94 0000 		call uip_add_rcv_nxt
 2694               	.LVL117:
 2695               	.L202:
1792:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_TIME_WAIT;
 2696               		.loc 1 1792 0
 2697 0d30 8091 0000 		lds r24,uip_buf+47
 2698 0d34 80FF      		sbrs r24,0
 2699 0d36 00C0      		rjmp .L203
1793:Lib/uip/uip.c ****       uip_connr->timer = 0;
 2700               		.loc 1 1793 0
 2701 0d38 87E0      		ldi r24,lo8(7)
 2702 0d3a 898F      		std Y+25,r24
1794:Lib/uip/uip.c ****       uip_add_rcv_nxt(1);
 2703               		.loc 1 1794 0
 2704 0d3c 1A8E      		std Y+26,__zero_reg__
 2705               	.L319:
1795:Lib/uip/uip.c ****       uip_flags = UIP_CLOSE;
 2706               		.loc 1 1795 0
 2707 0d3e 81E0      		ldi r24,lo8(1)
 2708 0d40 90E0      		ldi r25,0
 2709 0d42 0E94 0000 		call uip_add_rcv_nxt
 2710               	.LVL118:
1796:Lib/uip/uip.c ****       UIP_APPCALL();
 2711               		.loc 1 1796 0
 2712 0d46 80E1      		ldi r24,lo8(16)
 2713 0d48 8093 0000 		sts uip_flags,r24
1797:Lib/uip/uip.c ****       goto tcp_send_ack;
 2714               		.loc 1 1797 0
 2715 0d4c 0E94 0000 		call uIPManagement_TCPCallback
 2716               	.LVL119:
1798:Lib/uip/uip.c ****     }
 2717               		.loc 1 1798 0
 2718 0d50 00C0      		rjmp .L168
 2719               	.L203:
1800:Lib/uip/uip.c ****       goto tcp_send_ack;
 2720               		.loc 1 1800 0
 2721 0d52 8091 0000 		lds r24,uip_len
 2722 0d56 9091 0000 		lds r25,uip_len+1
 2723 0d5a 892B      		or r24,r25
 2724 0d5c 01F4      		brne .L168
 2725 0d5e 00C0      		rjmp .L94
 2726               	.L167:
1809:Lib/uip/uip.c ****       uip_connr->tcpstateflags = UIP_TIME_WAIT;
 2727               		.loc 1 1809 0
 2728 0d60 8091 0000 		lds r24,uip_flags
 2729 0d64 80FF      		sbrs r24,0
 2730 0d66 00C0      		rjmp .L94
1810:Lib/uip/uip.c ****       uip_connr->timer = 0;
 2731               		.loc 1 1810 0
 2732 0d68 87E0      		ldi r24,lo8(7)
 2733 0d6a 898F      		std Y+25,r24
1811:Lib/uip/uip.c ****     }
 2734               		.loc 1 1811 0
 2735 0d6c 1A8E      		std Y+26,__zero_reg__
 2736 0d6e 00C0      		rjmp .L94
 2737               	.L168:
1819:Lib/uip/uip.c **** 
 2738               		.loc 1 1819 0
 2739 0d70 80E1      		ldi r24,lo8(16)
 2740               	.LVL120:
 2741               	.L320:
 2742 0d72 8093 0000 		sts uip_buf+47,r24
 2743               	.L98:
 2744               	.LVL121:
1822:Lib/uip/uip.c **** 
 2745               		.loc 1 1822 0
 2746 0d76 88E2      		ldi r24,lo8(40)
 2747 0d78 90E0      		ldi r25,0
 2748 0d7a 9093 0000 		sts uip_len+1,r25
 2749 0d7e 8093 0000 		sts uip_len,r24
 2750               	.L196:
1825:Lib/uip/uip.c **** 
 2751               		.loc 1 1825 0
 2752 0d82 80E5      		ldi r24,lo8(80)
 2753               	.L322:
 2754 0d84 8093 0000 		sts uip_buf+46,r24
 2755               	.L150:
1832:Lib/uip/uip.c ****   BUF->ackno[1] = uip_connr->rcv_nxt[1];
 2756               		.loc 1 1832 0
 2757 0d88 8885      		ldd r24,Y+8
 2758 0d8a 8093 0000 		sts uip_buf+42,r24
1833:Lib/uip/uip.c ****   BUF->ackno[2] = uip_connr->rcv_nxt[2];
 2759               		.loc 1 1833 0
 2760 0d8e 8985      		ldd r24,Y+9
 2761 0d90 8093 0000 		sts uip_buf+43,r24
1834:Lib/uip/uip.c ****   BUF->ackno[3] = uip_connr->rcv_nxt[3];
 2762               		.loc 1 1834 0
 2763 0d94 8A85      		ldd r24,Y+10
 2764 0d96 8093 0000 		sts uip_buf+44,r24
1835:Lib/uip/uip.c **** 
 2765               		.loc 1 1835 0
 2766 0d9a 8B85      		ldd r24,Y+11
 2767 0d9c 8093 0000 		sts uip_buf+45,r24
1837:Lib/uip/uip.c ****   BUF->seqno[1] = uip_connr->snd_nxt[1];
 2768               		.loc 1 1837 0
 2769 0da0 8C85      		ldd r24,Y+12
 2770 0da2 8093 0000 		sts uip_buf+38,r24
1838:Lib/uip/uip.c ****   BUF->seqno[2] = uip_connr->snd_nxt[2];
 2771               		.loc 1 1838 0
 2772 0da6 8D85      		ldd r24,Y+13
 2773 0da8 8093 0000 		sts uip_buf+39,r24
1839:Lib/uip/uip.c ****   BUF->seqno[3] = uip_connr->snd_nxt[3];
 2774               		.loc 1 1839 0
 2775 0dac 8E85      		ldd r24,Y+14
 2776 0dae 8093 0000 		sts uip_buf+40,r24
1840:Lib/uip/uip.c **** 
 2777               		.loc 1 1840 0
 2778 0db2 8F85      		ldd r24,Y+15
 2779 0db4 8093 0000 		sts uip_buf+41,r24
1842:Lib/uip/uip.c **** 
 2780               		.loc 1 1842 0
 2781 0db8 86E0      		ldi r24,lo8(6)
 2782 0dba 8093 0000 		sts uip_buf+23,r24
1844:Lib/uip/uip.c ****   BUF->destport = uip_connr->rport;
 2783               		.loc 1 1844 0
 2784 0dbe 8C81      		ldd r24,Y+4
 2785 0dc0 9D81      		ldd r25,Y+5
 2786 0dc2 9093 0000 		sts uip_buf+34+1,r25
 2787 0dc6 8093 0000 		sts uip_buf+34,r24
1845:Lib/uip/uip.c **** 
 2788               		.loc 1 1845 0
 2789 0dca 8E81      		ldd r24,Y+6
 2790 0dcc 9F81      		ldd r25,Y+7
 2791 0dce 9093 0000 		sts uip_buf+36+1,r25
 2792 0dd2 8093 0000 		sts uip_buf+36,r24
1847:Lib/uip/uip.c ****   uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
 2793               		.loc 1 1847 0
 2794 0dd6 8091 0000 		lds r24,uip_hostaddr
 2795 0dda 9091 0000 		lds r25,uip_hostaddr+1
 2796 0dde A091 0000 		lds r26,uip_hostaddr+2
 2797 0de2 B091 0000 		lds r27,uip_hostaddr+3
 2798 0de6 8093 0000 		sts uip_buf+26,r24
 2799 0dea 9093 0000 		sts uip_buf+26+1,r25
 2800 0dee A093 0000 		sts uip_buf+26+2,r26
 2801 0df2 B093 0000 		sts uip_buf+26+3,r27
1848:Lib/uip/uip.c **** 
 2802               		.loc 1 1848 0
 2803 0df6 8881      		ld r24,Y
 2804 0df8 9981      		ldd r25,Y+1
 2805 0dfa AA81      		ldd r26,Y+2
 2806 0dfc BB81      		ldd r27,Y+3
 2807 0dfe 8093 0000 		sts uip_buf+30,r24
 2808 0e02 9093 0000 		sts uip_buf+30+1,r25
 2809 0e06 A093 0000 		sts uip_buf+30+2,r26
 2810 0e0a B093 0000 		sts uip_buf+30+3,r27
1850:Lib/uip/uip.c ****     /* If the connection has issued uip_stop(), we advertise a zero
 2811               		.loc 1 1850 0
 2812 0e0e 898D      		ldd r24,Y+25
 2813 0e10 84FF      		sbrs r24,4
 2814 0e12 00C0      		rjmp .L204
1853:Lib/uip/uip.c ****   } else {
 2815               		.loc 1 1853 0
 2816 0e14 1092 0000 		sts uip_buf+49,__zero_reg__
 2817 0e18 1092 0000 		sts uip_buf+48,__zero_reg__
 2818 0e1c 00C0      		rjmp .L135
 2819               	.L204:
1855:Lib/uip/uip.c ****     BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
 2820               		.loc 1 1855 0
 2821 0e1e 85E0      		ldi r24,lo8(5)
 2822 0e20 8093 0000 		sts uip_buf+48,r24
1856:Lib/uip/uip.c ****   }
 2823               		.loc 1 1856 0
 2824 0e24 84EB      		ldi r24,lo8(-76)
 2825 0e26 8093 0000 		sts uip_buf+49,r24
 2826               	.L135:
1860:Lib/uip/uip.c **** #if UIP_CONF_IPV6
 2827               		.loc 1 1860 0
 2828 0e2a 80E4      		ldi r24,lo8(64)
 2829 0e2c 8093 0000 		sts uip_buf+22,r24
1867:Lib/uip/uip.c ****   BUF->len[1] = (uip_len & 0xff);
 2830               		.loc 1 1867 0
 2831 0e30 8091 0000 		lds r24,uip_len
 2832 0e34 9091 0000 		lds r25,uip_len+1
 2833 0e38 9093 0000 		sts uip_buf+16,r25
1868:Lib/uip/uip.c **** #endif /* UIP_CONF_IPV6 */
 2834               		.loc 1 1868 0
 2835 0e3c 8093 0000 		sts uip_buf+17,r24
1871:Lib/uip/uip.c **** 
 2836               		.loc 1 1871 0
 2837 0e40 1092 0000 		sts uip_buf+53,__zero_reg__
 2838 0e44 1092 0000 		sts uip_buf+52,__zero_reg__
1874:Lib/uip/uip.c ****   BUF->tcpchksum = ~(uip_tcpchksum());
 2839               		.loc 1 1874 0
 2840 0e48 1092 0000 		sts uip_buf+50+1,__zero_reg__
 2841 0e4c 1092 0000 		sts uip_buf+50,__zero_reg__
1875:Lib/uip/uip.c **** 
 2842               		.loc 1 1875 0
 2843 0e50 0E94 0000 		call uip_tcpchksum
 2844               	.LVL122:
 2845 0e54 8095      		com r24
 2846 0e56 9095      		com r25
 2847 0e58 9093 0000 		sts uip_buf+50+1,r25
 2848 0e5c 8093 0000 		sts uip_buf+50,r24
 2849               	.LVL123:
 2850               	.L115:
1883:Lib/uip/uip.c ****   BUF->tos = 0;
 2851               		.loc 1 1883 0
 2852 0e60 85E4      		ldi r24,lo8(69)
 2853 0e62 8093 0000 		sts uip_buf+14,r24
1884:Lib/uip/uip.c ****   BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
 2854               		.loc 1 1884 0
 2855 0e66 1092 0000 		sts uip_buf+15,__zero_reg__
1885:Lib/uip/uip.c ****   ++ipid;
 2856               		.loc 1 1885 0
 2857 0e6a 1092 0000 		sts uip_buf+21,__zero_reg__
 2858 0e6e 1092 0000 		sts uip_buf+20,__zero_reg__
1886:Lib/uip/uip.c ****   BUF->ipid[0] = ipid >> 8;
 2859               		.loc 1 1886 0
 2860 0e72 8091 0000 		lds r24,ipid
 2861 0e76 9091 0000 		lds r25,ipid+1
 2862 0e7a 0196      		adiw r24,1
 2863 0e7c 9093 0000 		sts ipid+1,r25
 2864 0e80 8093 0000 		sts ipid,r24
1887:Lib/uip/uip.c ****   BUF->ipid[1] = ipid & 0xff;
 2865               		.loc 1 1887 0
 2866 0e84 9093 0000 		sts uip_buf+18,r25
1888:Lib/uip/uip.c ****   /* Calculate IP checksum. */
 2867               		.loc 1 1888 0
 2868 0e88 8093 0000 		sts uip_buf+19,r24
1890:Lib/uip/uip.c ****   BUF->ipchksum = ~(uip_ipchksum());
 2869               		.loc 1 1890 0
 2870 0e8c 1092 0000 		sts uip_buf+24+1,__zero_reg__
 2871 0e90 1092 0000 		sts uip_buf+24,__zero_reg__
1891:Lib/uip/uip.c ****   DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
 2872               		.loc 1 1891 0
 2873 0e94 0E94 0000 		call uip_ipchksum
 2874               	.LVL124:
 2875 0e98 8095      		com r24
 2876 0e9a 9095      		com r25
 2877 0e9c 9093 0000 		sts uip_buf+24+1,r25
 2878 0ea0 8093 0000 		sts uip_buf+24,r24
 2879 0ea4 00C0      		rjmp .L324
 2880               	.L94:
1907:Lib/uip/uip.c ****   uip_flags = 0;
 2881               		.loc 1 1907 0
 2882 0ea6 1092 0000 		sts uip_len+1,__zero_reg__
 2883 0eaa 1092 0000 		sts uip_len,__zero_reg__
 2884               	.L324:
1908:Lib/uip/uip.c ****   return;
 2885               		.loc 1 1908 0
 2886 0eae 1092 0000 		sts uip_flags,__zero_reg__
 2887               	/* epilogue start */
1910:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
 2888               		.loc 1 1910 0
 2889 0eb2 DF91      		pop r29
 2890 0eb4 CF91      		pop r28
 2891 0eb6 1F91      		pop r17
 2892 0eb8 0F91      		pop r16
 2893 0eba FF90      		pop r15
 2894 0ebc EF90      		pop r14
 2895 0ebe DF90      		pop r13
 2896 0ec0 CF90      		pop r12
 2897 0ec2 BF90      		pop r11
 2898 0ec4 AF90      		pop r10
 2899 0ec6 0895      		ret
 2900               		.cfi_endproc
 2901               	.LFE18:
 2903               		.section	.text.htons,"ax",@progbits
 2904               	.global	htons
 2906               	htons:
 2907               	.LFB19:
1914:Lib/uip/uip.c ****   return HTONS(val);
 2908               		.loc 1 1914 0
 2909               		.cfi_startproc
 2910               	.LVL125:
 2911               	/* prologue: function */
 2912               	/* frame size = 0 */
 2913               	/* stack size = 0 */
 2914               	.L__stack_usage = 0
1916:Lib/uip/uip.c **** }
 2915               		.loc 1 1916 0
 2916 0000 9827      		eor r25,r24
 2917 0002 8927      		eor r24,r25
 2918               	.LVL126:
 2919 0004 9827      		eor r25,r24
 2920 0006 0895      		ret
 2921               		.cfi_endproc
 2922               	.LFE19:
 2924               		.section	.text.htonl,"ax",@progbits
 2925               	.global	htonl
 2927               	htonl:
 2928               	.LFB20:
1917:Lib/uip/uip.c **** 
1918:Lib/uip/uip.c **** u32_t
1919:Lib/uip/uip.c **** htonl(u32_t val)
1920:Lib/uip/uip.c **** {
 2929               		.loc 1 1920 0
 2930               		.cfi_startproc
 2931               	.LVL127:
 2932               	/* prologue: function */
 2933               	/* frame size = 0 */
 2934               	/* stack size = 0 */
 2935               	.L__stack_usage = 0
 2936 0000 0E94 0000 		call __bswapsi2
 2937               	.LVL128:
1921:Lib/uip/uip.c ****   return HTONL(val);
1922:Lib/uip/uip.c **** }
 2938               		.loc 1 1922 0
 2939 0004 0895      		ret
 2940               		.cfi_endproc
 2941               	.LFE20:
 2943               		.section	.text.uip_send,"ax",@progbits
 2944               	.global	uip_send
 2946               	uip_send:
 2947               	.LFB21:
1923:Lib/uip/uip.c **** /*---------------------------------------------------------------------------*/
1924:Lib/uip/uip.c **** void
1925:Lib/uip/uip.c **** uip_send(const void *data, int len)
1926:Lib/uip/uip.c **** {
 2948               		.loc 1 1926 0
 2949               		.cfi_startproc
 2950               	.LVL129:
 2951               	/* prologue: function */
 2952               	/* frame size = 0 */
 2953               	/* stack size = 0 */
 2954               	.L__stack_usage = 0
 2955 0000 9C01      		movw r18,r24
1927:Lib/uip/uip.c ****   int copylen;
1928:Lib/uip/uip.c **** #define MIN(a,b) ((a) < (b)? (a): (b))
1929:Lib/uip/uip.c ****   copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
 2956               		.loc 1 1929 0
 2957 0002 8091 0000 		lds r24,uip_sappdata
 2958 0006 9091 0000 		lds r25,uip_sappdata+1
 2959               	.LVL130:
 2960 000a 40E0      		ldi r20,lo8(uip_buf+1514)
 2961 000c 50E0      		ldi r21,hi8(uip_buf+1514)
 2962 000e 481B      		sub r20,r24
 2963 0010 590B      		sbc r21,r25
 2964 0012 6417      		cp r22,r20
 2965 0014 7507      		cpc r23,r21
 2966 0016 04F4      		brge .L335
 2967 0018 AB01      		movw r20,r22
 2968               	.L335:
 2969               	.LVL131:
1930:Lib/uip/uip.c **** 		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
1931:Lib/uip/uip.c ****   if(copylen > 0) {
 2970               		.loc 1 1931 0
 2971 001a 1416      		cp __zero_reg__,r20
 2972 001c 1506      		cpc __zero_reg__,r21
 2973 001e 04F4      		brge .L334
1932:Lib/uip/uip.c ****     uip_slen = copylen;
 2974               		.loc 1 1932 0
 2975 0020 5093 0000 		sts uip_slen+1,r21
 2976 0024 4093 0000 		sts uip_slen,r20
1933:Lib/uip/uip.c ****     if(data != uip_sappdata) {
 2977               		.loc 1 1933 0
 2978 0028 8217      		cp r24,r18
 2979 002a 9307      		cpc r25,r19
 2980 002c 01F0      		breq .L334
1934:Lib/uip/uip.c ****       memcpy(uip_sappdata, (data), uip_slen);
 2981               		.loc 1 1934 0
 2982 002e B901      		movw r22,r18
 2983               	.LVL132:
 2984 0030 0C94 0000 		jmp memcpy
 2985               	.LVL133:
 2986               	.L334:
 2987 0034 0895      		ret
 2988               		.cfi_endproc
 2989               	.LFE21:
 2991               		.local	tmp16
 2992               		.comm	tmp16,2,1
 2993               		.local	c
 2994               		.comm	c,1,1
 2995               		.comm	uip_acc32,4,1
 2996               		.local	lastport
 2997               		.comm	lastport,2,1
 2998               		.local	iss
 2999               		.comm	iss,4,1
 3000               		.local	ipid
 3001               		.comm	ipid,2,1
 3002               		.comm	uip_udp_conns,30,1
 3003               		.comm	uip_udp_conn,2,1
 3004               		.comm	uip_listenports,10,1
 3005               		.comm	uip_conns,339,1
 3006               		.comm	uip_conn,2,1
 3007               		.comm	uip_flags,1,1
 3008               		.comm	uip_slen,2,1
 3009               		.comm	uip_len,2,1
 3010               		.comm	uip_sappdata,2,1
 3011               		.comm	uip_appdata,2,1
 3012               		.comm	uip_buf,1516,1
 3013               	.global	uip_ethaddr
 3014               		.section .bss
 3017               	uip_ethaddr:
 3018 0000 0000 0000 		.zero	6
 3018      0000 
 3019               	.global	uip_all_zeroes_addr
 3020               		.section	.rodata
 3023               	uip_all_zeroes_addr:
 3024 0000 0000 0000 		.zero	4
 3025               	.global	uip_broadcast_addr
 3028               	uip_broadcast_addr:
 3029 0004 FF        		.byte	-1
 3030 0005 FF        		.byte	-1
 3031 0006 FF        		.byte	-1
 3032 0007 FF        		.byte	-1
 3033               		.comm	uip_netmask,4,1
 3034               		.comm	uip_draddr,4,1
 3035               		.comm	uip_hostaddr,4,1
 3036               		.text
 3037               	.Letext0:
 3038               		.file 2 "Lib/FATFs/integer.h"
 3039               		.file 3 "Lib/FATFs/ff.h"
 3040               		.file 4 "/usr/lib/avr/include/stdint.h"
 3041               		.file 5 "Lib/uip/clock.h"
 3042               		.file 6 "Lib/uip/timer.h"
 3043               		.file 7 "Lib/uip/uipopt.h"
 3044               		.file 8 "Lib/uip/uip.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uip.c
     /tmp/ccz3o2XF.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccz3o2XF.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccz3o2XF.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccz3o2XF.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccz3o2XF.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccz3o2XF.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccz3o2XF.s:13     .text.chksum:0000000000000000 chksum
     /tmp/ccz3o2XF.s:94     .text.uip_setipid:0000000000000000 uip_setipid
     /tmp/ccz3o2XF.s:2999   .bss:000000000000000f ipid
     /tmp/ccz3o2XF.s:113    .text.uip_add32:0000000000000000 uip_add32
                            *COM*:0000000000000004 uip_acc32
     /tmp/ccz3o2XF.s:189    .text.unlikely.uip_add_rcv_nxt:0000000000000000 uip_add_rcv_nxt
                            *COM*:0000000000000002 uip_conn
     /tmp/ccz3o2XF.s:235    .text.uip_chksum:0000000000000000 uip_chksum
     /tmp/ccz3o2XF.s:264    .text.uip_ipchksum:0000000000000000 uip_ipchksum
                            *COM*:00000000000005ec uip_buf
     /tmp/ccz3o2XF.s:309    .text.uip_tcpchksum:0000000000000000 uip_tcpchksum
     /tmp/ccz3o2XF.s:390    .text.uip_init:0000000000000000 uip_init
                            *COM*:000000000000000a uip_listenports
                            *COM*:0000000000000153 uip_conns
     /tmp/ccz3o2XF.s:2994   .bss:0000000000000009 lastport
                            *COM*:000000000000001e uip_udp_conns
     /tmp/ccz3o2XF.s:2992   .bss:0000000000000008 c
     /tmp/ccz3o2XF.s:446    .text.uip_connect:0000000000000000 uip_connect
     /tmp/ccz3o2XF.s:2997   .bss:000000000000000b iss
     /tmp/ccz3o2XF.s:655    .text.uip_udp_new:0000000000000000 uip_udp_new
     /tmp/ccz3o2XF.s:760    .text.uip_unlisten:0000000000000000 uip_unlisten
     /tmp/ccz3o2XF.s:809    .text.uip_listen:0000000000000000 uip_listen
     /tmp/ccz3o2XF.s:857    .text.uip_process:0000000000000000 uip_process
                            *COM*:0000000000000002 uip_appdata
                            *COM*:0000000000000002 uip_sappdata
                            *COM*:0000000000000002 uip_slen
                            *COM*:0000000000000002 uip_len
                            *COM*:0000000000000001 uip_flags
                            *COM*:0000000000000002 uip_udp_conn
                            *COM*:0000000000000004 uip_hostaddr
     /tmp/ccz3o2XF.s:3023   .rodata:0000000000000000 uip_all_zeroes_addr
     /tmp/ccz3o2XF.s:3028   .rodata:0000000000000004 uip_broadcast_addr
                             .bss:0000000000000006 tmp16
     /tmp/ccz3o2XF.s:2906   .text.htons:0000000000000000 htons
     /tmp/ccz3o2XF.s:2927   .text.htonl:0000000000000000 htonl
     /tmp/ccz3o2XF.s:2946   .text.uip_send:0000000000000000 uip_send
     /tmp/ccz3o2XF.s:3017   .bss:0000000000000000 uip_ethaddr
                            *COM*:0000000000000004 uip_netmask
                            *COM*:0000000000000004 uip_draddr

UNDEFINED SYMBOLS
uIPManagement_TCPCallback
uIPManagement_UDPCallback
__tablejump2__
__bswapsi2
memcpy
__do_copy_data
__do_clear_bss
