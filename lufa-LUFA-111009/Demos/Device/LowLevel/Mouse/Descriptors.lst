   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB97:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  41:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  42:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  43:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  44:Descriptors.c ****  *  more details on HID report descriptors.
  45:Descriptors.c ****  */
  46:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM MouseReport[] =
  47:Descriptors.c **** {
  48:Descriptors.c **** 	HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  49:Descriptors.c **** 	HID_RI_USAGE(8, 0x02), /* Mouse */
  50:Descriptors.c **** 	HID_RI_COLLECTION(8, 0x01), /* Application */
  51:Descriptors.c **** 	    HID_RI_USAGE(8, 0x01), /* Pointer */
  52:Descriptors.c **** 	    HID_RI_COLLECTION(8, 0x00), /* Physical */
  53:Descriptors.c **** 	        HID_RI_USAGE_PAGE(8, 0x09), /* Button */
  54:Descriptors.c **** 	        HID_RI_USAGE_MINIMUM(8, 0x01),
  55:Descriptors.c **** 	        HID_RI_USAGE_MAXIMUM(8, 0x03),
  56:Descriptors.c **** 	        HID_RI_LOGICAL_MINIMUM(8, 0x00),
  57:Descriptors.c **** 	        HID_RI_LOGICAL_MAXIMUM(8, 0x01),
  58:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x03),
  59:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x01),
  60:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE),
  61:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x01),
  62:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x05),
  63:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_CONSTANT),
  64:Descriptors.c **** 	        HID_RI_USAGE_PAGE(8, 0x01), /* Generic Desktop */
  65:Descriptors.c **** 	        HID_RI_USAGE(8, 0x30), /* Usage X */
  66:Descriptors.c **** 	        HID_RI_USAGE(8, 0x31), /* Usage Y */
  67:Descriptors.c **** 	        HID_RI_LOGICAL_MINIMUM(8, -1),
  68:Descriptors.c **** 	        HID_RI_LOGICAL_MAXIMUM(8, 1),
  69:Descriptors.c **** 	        HID_RI_PHYSICAL_MINIMUM(8, -1),
  70:Descriptors.c **** 	        HID_RI_PHYSICAL_MAXIMUM(8, 1),
  71:Descriptors.c **** 	        HID_RI_REPORT_COUNT(8, 0x02),
  72:Descriptors.c **** 	        HID_RI_REPORT_SIZE(8, 0x08),
  73:Descriptors.c **** 	        HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_RELATIVE),
  74:Descriptors.c **** 	    HID_RI_END_COLLECTION(0),
  75:Descriptors.c **** 	HID_RI_END_COLLECTION(0),
  76:Descriptors.c **** };
  77:Descriptors.c **** 
  78:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  79:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  80:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  81:Descriptors.c ****  *  process begins.
  82:Descriptors.c ****  */
  83:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  84:Descriptors.c **** {
  85:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  86:Descriptors.c **** 
  87:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  88:Descriptors.c **** 	.Class                  = USB_CSCP_NoDeviceClass,
  89:Descriptors.c **** 	.SubClass               = USB_CSCP_NoDeviceSubclass,
  90:Descriptors.c **** 	.Protocol               = USB_CSCP_NoDeviceProtocol,
  91:Descriptors.c **** 
  92:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  93:Descriptors.c **** 
  94:Descriptors.c **** 	.VendorID               = 0x03EB,
  95:Descriptors.c **** 	.ProductID              = 0x2041,
  96:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
  97:Descriptors.c **** 
  98:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
  99:Descriptors.c **** 	.ProductStrIndex        = 0x02,
 100:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
 101:Descriptors.c **** 
 102:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
 103:Descriptors.c **** };
 104:Descriptors.c **** 
 105:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
 106:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
 107:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 108:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 109:Descriptors.c ****  */
 110:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
 111:Descriptors.c **** {
 112:Descriptors.c **** 	.Config =
 113:Descriptors.c **** 		{
 114:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 115:Descriptors.c **** 
 116:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 117:Descriptors.c **** 			.TotalInterfaces        = 1,
 118:Descriptors.c **** 
 119:Descriptors.c **** 			.ConfigurationNumber    = 1,
 120:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 121:Descriptors.c **** 
 122:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 123:Descriptors.c **** 
 124:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 125:Descriptors.c **** 		},
 126:Descriptors.c **** 
 127:Descriptors.c **** 	.HID_Interface =
 128:Descriptors.c **** 		{
 129:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 130:Descriptors.c **** 
 131:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 132:Descriptors.c **** 			.AlternateSetting       = 0x00,
 133:Descriptors.c **** 
 134:Descriptors.c **** 			.TotalEndpoints         = 1,
 135:Descriptors.c **** 
 136:Descriptors.c **** 			.Class                  = HID_CSCP_HIDClass,
 137:Descriptors.c **** 			.SubClass               = HID_CSCP_BootSubclass,
 138:Descriptors.c **** 			.Protocol               = HID_CSCP_MouseBootProtocol,
 139:Descriptors.c **** 
 140:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 141:Descriptors.c **** 		},
 142:Descriptors.c **** 
 143:Descriptors.c **** 	.HID_MouseHID =
 144:Descriptors.c **** 		{
 145:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_HID_t), .Type = HID_DTYPE_HID},
 146:Descriptors.c **** 
 147:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 148:Descriptors.c **** 			.CountryCode            = 0x00,
 149:Descriptors.c **** 			.TotalReportDescriptors = 1,
 150:Descriptors.c **** 			.HIDReportType          = HID_DTYPE_Report,
 151:Descriptors.c **** 			.HIDReportLength        = sizeof(MouseReport)
 152:Descriptors.c **** 		},
 153:Descriptors.c **** 
 154:Descriptors.c **** 	.HID_ReportINEndpoint =
 155:Descriptors.c **** 		{
 156:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 157:Descriptors.c **** 
 158:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | MOUSE_EPNUM),
 159:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 160:Descriptors.c **** 			.EndpointSize           = MOUSE_EPSIZE,
 161:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 162:Descriptors.c **** 		}
 163:Descriptors.c **** };
 164:Descriptors.c **** 
 165:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 166:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 167:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 168:Descriptors.c ****  */
 169:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 170:Descriptors.c **** {
 171:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 172:Descriptors.c **** 
 173:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 174:Descriptors.c **** };
 175:Descriptors.c **** 
 176:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 177:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 178:Descriptors.c ****  *  Descriptor.
 179:Descriptors.c ****  */
 180:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 181:Descriptors.c **** {
 182:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(11), .Type = DTYPE_String},
 183:Descriptors.c **** 
 184:Descriptors.c **** 	.UnicodeString          = L"Dean Camera"
 185:Descriptors.c **** };
 186:Descriptors.c **** 
 187:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 188:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 189:Descriptors.c ****  *  Descriptor.
 190:Descriptors.c ****  */
 191:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 192:Descriptors.c **** {
 193:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(15), .Type = DTYPE_String},
 194:Descriptors.c **** 
 195:Descriptors.c **** 	.UnicodeString          = L"LUFA Mouse Demo"
 196:Descriptors.c **** };
 197:Descriptors.c **** 
 198:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 199:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 200:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 201:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 202:Descriptors.c ****  *  USB host.
 203:Descriptors.c ****  */
 204:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 205:Descriptors.c ****                                     const uint8_t wIndex,
 206:Descriptors.c ****                                     const void** const DescriptorAddress)
 207:Descriptors.c **** {
  17               		.loc 1 207 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 208:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 209:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 210:Descriptors.c **** 
 211:Descriptors.c **** 	const void* Address = NULL;
 212:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 213:Descriptors.c **** 
 214:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 214 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2330      		cpi r18,3
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 00F4      		brsh .L4
  31 000c 2130      		cpi r18,1
  32 000e 3105      		cpc r19,__zero_reg__
  33 0010 01F0      		breq .L5
  34 0012 2230      		cpi r18,2
  35 0014 3105      		cpc r19,__zero_reg__
  36 0016 01F4      		brne .L14
  37               	.LVL1:
 215:Descriptors.c **** 	{
 216:Descriptors.c **** 		case DTYPE_Device:
 217:Descriptors.c **** 			Address = &DeviceDescriptor;
 218:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 219:Descriptors.c **** 			break;
 220:Descriptors.c **** 		case DTYPE_Configuration:
 221:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 222:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  38               		.loc 1 222 0
  39 0018 82E2      		ldi r24,lo8(34)
  40 001a 90E0      		ldi r25,0
  41               	.LVL2:
 221:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  42               		.loc 1 221 0
  43 001c 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  44 001e 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 223:Descriptors.c **** 			break;
  45               		.loc 1 223 0
  46 0020 00C0      		rjmp .L2
  47               	.LVL3:
  48               	.L4:
 214:Descriptors.c **** 	{
  49               		.loc 1 214 0
  50 0022 2132      		cpi r18,33
  51 0024 3105      		cpc r19,__zero_reg__
  52 0026 01F0      		breq .L7
  53 0028 2232      		cpi r18,34
  54 002a 3105      		cpc r19,__zero_reg__
  55 002c 01F4      		brne .L14
  56               	.LVL4:
 224:Descriptors.c **** 		case DTYPE_String:
 225:Descriptors.c **** 			switch (DescriptorNumber)
 226:Descriptors.c **** 			{
 227:Descriptors.c **** 				case 0x00:
 228:Descriptors.c **** 					Address = &LanguageString;
 229:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 230:Descriptors.c **** 					break;
 231:Descriptors.c **** 				case 0x01:
 232:Descriptors.c **** 					Address = &ManufacturerString;
 233:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 234:Descriptors.c **** 					break;
 235:Descriptors.c **** 				case 0x02:
 236:Descriptors.c **** 					Address = &ProductString;
 237:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 238:Descriptors.c **** 					break;
 239:Descriptors.c **** 			}
 240:Descriptors.c **** 
 241:Descriptors.c **** 			break;
 242:Descriptors.c **** 		case HID_DTYPE_HID:
 243:Descriptors.c **** 			Address = &ConfigurationDescriptor.HID_MouseHID;
 244:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);
 245:Descriptors.c **** 			break;
 246:Descriptors.c **** 		case HID_DTYPE_Report:
 247:Descriptors.c **** 			Address = &MouseReport;
 248:Descriptors.c **** 			Size    = sizeof(MouseReport);
  57               		.loc 1 248 0
  58 002e 86E3      		ldi r24,lo8(54)
  59 0030 90E0      		ldi r25,0
  60               	.LVL5:
 247:Descriptors.c **** 			Size    = sizeof(MouseReport);
  61               		.loc 1 247 0
  62 0032 20E0      		ldi r18,lo8(MouseReport)
  63 0034 30E0      		ldi r19,hi8(MouseReport)
 249:Descriptors.c **** 			break;
  64               		.loc 1 249 0
  65 0036 00C0      		rjmp .L2
  66               	.LVL6:
  67               	.L5:
 218:Descriptors.c **** 			break;
  68               		.loc 1 218 0
  69 0038 82E1      		ldi r24,lo8(18)
  70 003a 90E0      		ldi r25,0
  71               	.LVL7:
 217:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  72               		.loc 1 217 0
  73 003c 20E0      		ldi r18,lo8(DeviceDescriptor)
  74 003e 30E0      		ldi r19,hi8(DeviceDescriptor)
  75 0040 00C0      		rjmp .L2
  76               	.LVL8:
  77               	.L3:
 225:Descriptors.c **** 			{
  78               		.loc 1 225 0
  79 0042 9927      		clr r25
  80               	.LVL9:
  81 0044 8130      		cpi r24,1
  82 0046 9105      		cpc r25,__zero_reg__
  83 0048 01F0      		breq .L9
  84 004a 00F0      		brlo .L10
  85 004c 0297      		sbiw r24,2
  86 004e 01F4      		brne .L14
  87               	.LVL10:
  88               	.LBB2:
 237:Descriptors.c **** 					break;
  89               		.loc 1 237 0
  90 0050 E0E0      		ldi r30,lo8(ProductString)
  91 0052 F0E0      		ldi r31,hi8(ProductString)
  92 0054 00C0      		rjmp .L15
  93               	.LVL11:
  94               	.L10:
  95               	.LBE2:
  96               	.LBB3:
 229:Descriptors.c **** 					break;
  97               		.loc 1 229 0
  98 0056 E0E0      		ldi r30,lo8(LanguageString)
  99 0058 F0E0      		ldi r31,hi8(LanguageString)
 100 005a 00C0      		rjmp .L15
 101               	.LVL12:
 102               	.L9:
 103               	.LBE3:
 104               	.LBB4:
 233:Descriptors.c **** 					break;
 105               		.loc 1 233 0
 106 005c E0E0      		ldi r30,lo8(ManufacturerString)
 107 005e F0E0      		ldi r31,hi8(ManufacturerString)
 108               	.LVL13:
 109               	.L15:
 110               	.LBE4:
 111               	.LBB5:
 237:Descriptors.c **** 					break;
 112               		.loc 1 237 0
 113               	/* #APP */
 114               	 ;  237 "Descriptors.c" 1
 115 0060 8491      		lpm r24, Z
 116               		
 117               	 ;  0 "" 2
 118               	.LVL14:
 119               	/* #NOAPP */
 120               	.LBE5:
 121 0062 90E0      		ldi r25,0
 122               	.LVL15:
 236:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 123               		.loc 1 236 0
 124 0064 9F01      		movw r18,r30
 238:Descriptors.c **** 			}
 125               		.loc 1 238 0
 126 0066 00C0      		rjmp .L2
 127               	.LVL16:
 128               	.L7:
 244:Descriptors.c **** 			break;
 129               		.loc 1 244 0
 130 0068 89E0      		ldi r24,lo8(9)
 131 006a 90E0      		ldi r25,0
 132               	.LVL17:
 243:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);
 133               		.loc 1 243 0
 134 006c 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
 135 006e 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
 136               	.LVL18:
 245:Descriptors.c **** 		case HID_DTYPE_Report:
 137               		.loc 1 245 0
 138 0070 00C0      		rjmp .L2
 139               	.LVL19:
 140               	.L14:
 212:Descriptors.c **** 
 141               		.loc 1 212 0
 142 0072 80E0      		ldi r24,0
 143 0074 90E0      		ldi r25,0
 211:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 144               		.loc 1 211 0
 145 0076 20E0      		ldi r18,0
 146 0078 30E0      		ldi r19,0
 147               	.LVL20:
 148               	.L2:
 250:Descriptors.c **** 	}
 251:Descriptors.c **** 
 252:Descriptors.c **** 	*DescriptorAddress = Address;
 149               		.loc 1 252 0
 150 007a FA01      		movw r30,r20
 151 007c 3183      		std Z+1,r19
 152 007e 2083      		st Z,r18
 253:Descriptors.c **** 	return Size;
 254:Descriptors.c **** }
 153               		.loc 1 254 0
 154 0080 0895      		ret
 155               		.cfi_endproc
 156               	.LFE97:
 158               	.global	ProductString
 159               		.section	.progmem.data,"a",@progbits
 162               	ProductString:
 163 0000 20        		.byte	32
 164 0001 03        		.byte	3
 165 0002 4C00      		.string	"L"
 166 0004 5500      		.string	"U"
 167 0006 4600      		.string	"F"
 168 0008 4100      		.string	"A"
 169 000a 2000      		.string	" "
 170 000c 4D00      		.string	"M"
 171 000e 6F00      		.string	"o"
 172 0010 7500      		.string	"u"
 173 0012 7300      		.string	"s"
 174 0014 6500      		.string	"e"
 175 0016 2000      		.string	" "
 176 0018 4400      		.string	"D"
 177 001a 6500      		.string	"e"
 178 001c 6D00      		.string	"m"
 179 001e 6F00      		.string	"o"
 180 0020 00        		.string	""
 181 0021 00        		.string	""
 182               	.global	ManufacturerString
 185               	ManufacturerString:
 186 0022 18        		.byte	24
 187 0023 03        		.byte	3
 188 0024 4400      		.string	"D"
 189 0026 6500      		.string	"e"
 190 0028 6100      		.string	"a"
 191 002a 6E00      		.string	"n"
 192 002c 2000      		.string	" "
 193 002e 4300      		.string	"C"
 194 0030 6100      		.string	"a"
 195 0032 6D00      		.string	"m"
 196 0034 6500      		.string	"e"
 197 0036 7200      		.string	"r"
 198 0038 6100      		.string	"a"
 199 003a 00        		.string	""
 200 003b 00        		.string	""
 201               	.global	LanguageString
 204               	LanguageString:
 205 003c 04        		.byte	4
 206 003d 03        		.byte	3
 207 003e 0904      		.word	1033
 208               	.global	ConfigurationDescriptor
 211               	ConfigurationDescriptor:
 212 0040 09        		.byte	9
 213 0041 02        		.byte	2
 214 0042 2200      		.word	34
 215 0044 01        		.byte	1
 216 0045 01        		.byte	1
 217 0046 00        		.byte	0
 218 0047 C0        		.byte	-64
 219 0048 32        		.byte	50
 220 0049 09        		.byte	9
 221 004a 04        		.byte	4
 222 004b 00        		.byte	0
 223 004c 00        		.byte	0
 224 004d 01        		.byte	1
 225 004e 03        		.byte	3
 226 004f 01        		.byte	1
 227 0050 02        		.byte	2
 228 0051 00        		.byte	0
 229 0052 09        		.byte	9
 230 0053 21        		.byte	33
 231 0054 1101      		.word	273
 232 0056 00        		.byte	0
 233 0057 01        		.byte	1
 234 0058 22        		.byte	34
 235 0059 3600      		.word	54
 236 005b 07        		.byte	7
 237 005c 05        		.byte	5
 238 005d 81        		.byte	-127
 239 005e 03        		.byte	3
 240 005f 0800      		.word	8
 241 0061 01        		.byte	1
 242               	.global	DeviceDescriptor
 245               	DeviceDescriptor:
 246 0062 12        		.byte	18
 247 0063 01        		.byte	1
 248 0064 1001      		.word	272
 249 0066 00        		.byte	0
 250 0067 00        		.byte	0
 251 0068 00        		.byte	0
 252 0069 08        		.byte	8
 253 006a EB03      		.word	1003
 254 006c 4120      		.word	8257
 255 006e 0100      		.word	1
 256 0070 01        		.byte	1
 257 0071 02        		.byte	2
 258 0072 00        		.byte	0
 259 0073 01        		.byte	1
 260               	.global	MouseReport
 263               	MouseReport:
 264 0074 05        		.byte	5
 265 0075 01        		.byte	1
 266 0076 09        		.byte	9
 267 0077 02        		.byte	2
 268 0078 A1        		.byte	-95
 269 0079 01        		.byte	1
 270 007a 09        		.byte	9
 271 007b 01        		.byte	1
 272 007c A1        		.byte	-95
 273 007d 00        		.byte	0
 274 007e 05        		.byte	5
 275 007f 09        		.byte	9
 276 0080 19        		.byte	25
 277 0081 01        		.byte	1
 278 0082 29        		.byte	41
 279 0083 03        		.byte	3
 280 0084 15        		.byte	21
 281 0085 00        		.byte	0
 282 0086 25        		.byte	37
 283 0087 01        		.byte	1
 284 0088 95        		.byte	-107
 285 0089 03        		.byte	3
 286 008a 75        		.byte	117
 287 008b 01        		.byte	1
 288 008c 81        		.byte	-127
 289 008d 02        		.byte	2
 290 008e 95        		.byte	-107
 291 008f 01        		.byte	1
 292 0090 75        		.byte	117
 293 0091 05        		.byte	5
 294 0092 81        		.byte	-127
 295 0093 01        		.byte	1
 296 0094 05        		.byte	5
 297 0095 01        		.byte	1
 298 0096 09        		.byte	9
 299 0097 30        		.byte	48
 300 0098 09        		.byte	9
 301 0099 31        		.byte	49
 302 009a 15        		.byte	21
 303 009b FF        		.byte	-1
 304 009c 25        		.byte	37
 305 009d 01        		.byte	1
 306 009e 35        		.byte	53
 307 009f FF        		.byte	-1
 308 00a0 45        		.byte	69
 309 00a1 01        		.byte	1
 310 00a2 95        		.byte	-107
 311 00a3 02        		.byte	2
 312 00a4 75        		.byte	117
 313 00a5 08        		.byte	8
 314 00a6 81        		.byte	-127
 315 00a7 06        		.byte	6
 316 00a8 C0        		.byte	-64
 317 00a9 C0        		.byte	-64
 318               		.text
 319               	.Letext0:
 320               		.file 2 "/usr/lib/avr/include/stdint.h"
 321               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 322               		.file 4 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 323               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 324               		.file 6 "Descriptors.h"
 325               		.file 7 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/cc8E4n41.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8E4n41.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8E4n41.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8E4n41.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc8E4n41.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8E4n41.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8E4n41.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/cc8E4n41.s:211    .progmem.data:0000000000000040 ConfigurationDescriptor
     /tmp/cc8E4n41.s:263    .progmem.data:0000000000000074 MouseReport
     /tmp/cc8E4n41.s:245    .progmem.data:0000000000000062 DeviceDescriptor
     /tmp/cc8E4n41.s:162    .progmem.data:0000000000000000 ProductString
     /tmp/cc8E4n41.s:204    .progmem.data:000000000000003c LanguageString
     /tmp/cc8E4n41.s:185    .progmem.data:0000000000000022 ManufacturerString

NO UNDEFINED SYMBOLS
