   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB97:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2010  Denver Gingerich (denver [at] ossguy [dot] com)
  11:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  12:Descriptors.c **** 
  13:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  14:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  15:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  16:Descriptors.c ****   all copies and that both that the copyright notice and this
  17:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  18:Descriptors.c ****   documentation, and that the name of the author not be used in
  19:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  20:Descriptors.c ****   software without specific, written prior permission.
  21:Descriptors.c **** 
  22:Descriptors.c ****   The author disclaim all warranties with regard to this
  23:Descriptors.c ****   software, including all implied warranties of merchantability
  24:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  25:Descriptors.c ****   special, indirect or consequential damages or any damages
  26:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  27:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  28:Descriptors.c ****   arising out of or in connection with the use or performance of
  29:Descriptors.c ****   this software.
  30:Descriptors.c **** */
  31:Descriptors.c **** 
  32:Descriptors.c **** /** \file
  33:Descriptors.c ****  *
  34:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  35:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  36:Descriptors.c ****  *  the device's capabilities and functions.
  37:Descriptors.c ****  */
  38:Descriptors.c **** 
  39:Descriptors.c **** #include "Descriptors.h"
  40:Descriptors.c **** 
  41:Descriptors.c **** /** HID report descriptor. This is a HID class specific descriptor, which defines the structure of 
  42:Descriptors.c ****  *  reports sent and received by the HID device to and from the USB host. It indicates what data is
  43:Descriptors.c ****  *  where in the report each element is located and exactly how the data should be interpreted and 
  44:Descriptors.c ****  *
  45:Descriptors.c ****  *  See the HID class specification for more information on HID report descriptors.
  46:Descriptors.c ****  */
  47:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM KeyboardReport[] =
  48:Descriptors.c **** {
  49:Descriptors.c **** 	/* Use the HID class driver's standard Keyboard report.
  50:Descriptors.c **** 	 *   Max simultaneous keys: 6
  51:Descriptors.c **** 	 */
  52:Descriptors.c **** 	HID_DESCRIPTOR_KEYBOARD(6)
  53:Descriptors.c **** };
  54:Descriptors.c **** 
  55:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  56:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  57:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  58:Descriptors.c ****  *  process begins.
  59:Descriptors.c ****  */
  60:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  61:Descriptors.c **** {
  62:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  63:Descriptors.c **** 
  64:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  65:Descriptors.c **** 	.Class                  = USB_CSCP_NoDeviceClass,
  66:Descriptors.c **** 	.SubClass               = USB_CSCP_NoDeviceSubclass,
  67:Descriptors.c **** 	.Protocol               = USB_CSCP_NoDeviceProtocol,
  68:Descriptors.c **** 
  69:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  70:Descriptors.c **** 
  71:Descriptors.c **** 	.VendorID               = 0x03EB,
  72:Descriptors.c **** 	.ProductID              = 0x2042,
  73:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
  74:Descriptors.c **** 
  75:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
  76:Descriptors.c **** 	.ProductStrIndex        = 0x02,
  77:Descriptors.c **** 	.SerialNumStrIndex      = USE_INTERNAL_SERIAL,
  78:Descriptors.c **** 
  79:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  80:Descriptors.c **** };
  81:Descriptors.c **** 
  82:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
  83:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
  84:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
  85:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
  86:Descriptors.c ****  */
  87:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
  88:Descriptors.c **** {
  89:Descriptors.c **** 	.Config =
  90:Descriptors.c **** 		{
  91:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
  92:Descriptors.c **** 
  93:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
  94:Descriptors.c **** 			.TotalInterfaces        = 1,
  95:Descriptors.c **** 
  96:Descriptors.c **** 			.ConfigurationNumber    = 1,
  97:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
  98:Descriptors.c **** 
  99:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 100:Descriptors.c **** 
 101:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 102:Descriptors.c **** 		},
 103:Descriptors.c **** 
 104:Descriptors.c **** 	.HID_Interface =
 105:Descriptors.c **** 		{
 106:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 107:Descriptors.c **** 
 108:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 109:Descriptors.c **** 			.AlternateSetting       = 0x00,
 110:Descriptors.c **** 
 111:Descriptors.c **** 			.TotalEndpoints         = 1,
 112:Descriptors.c **** 
 113:Descriptors.c **** 			.Class                  = HID_CSCP_HIDClass,
 114:Descriptors.c **** 			.SubClass               = HID_CSCP_BootSubclass,
 115:Descriptors.c **** 			.Protocol               = HID_CSCP_KeyboardBootProtocol,
 116:Descriptors.c **** 
 117:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 118:Descriptors.c **** 		},
 119:Descriptors.c **** 
 120:Descriptors.c **** 	.HID_KeyboardHID =
 121:Descriptors.c **** 		{
 122:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_HID_t), .Type = HID_DTYPE_HID},
 123:Descriptors.c **** 
 124:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 125:Descriptors.c **** 			.CountryCode            = 0x00,
 126:Descriptors.c **** 			.TotalReportDescriptors = 1,
 127:Descriptors.c **** 			.HIDReportType          = HID_DTYPE_Report,
 128:Descriptors.c **** 			.HIDReportLength        = sizeof(KeyboardReport)
 129:Descriptors.c **** 		},
 130:Descriptors.c **** 
 131:Descriptors.c **** 	.HID_ReportINEndpoint =
 132:Descriptors.c **** 		{
 133:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 134:Descriptors.c **** 
 135:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | KEYBOARD_EPNUM),
 136:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 137:Descriptors.c **** 			.EndpointSize           = KEYBOARD_EPSIZE,
 138:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 139:Descriptors.c **** 		},
 140:Descriptors.c **** };
 141:Descriptors.c **** 
 142:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 143:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 144:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 145:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 146:Descriptors.c **** {
 147:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 148:Descriptors.c **** 
 149:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 150:Descriptors.c **** };
 151:Descriptors.c **** 
 152:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 153:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 154:Descriptors.c ****  *  Descriptor.
 155:Descriptors.c ****  */
 156:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 157:Descriptors.c **** {
 158:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(32), .Type = DTYPE_String},
 159:Descriptors.c **** 
 160:Descriptors.c **** 	.UnicodeString          = L"Dean Camera and Denver Gingerich"
 161:Descriptors.c **** };
 162:Descriptors.c **** 
 163:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 164:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 165:Descriptors.c ****  *  Descriptor.
 166:Descriptors.c ****  */
 167:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 168:Descriptors.c **** {
 169:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(20), .Type = DTYPE_String},
 170:Descriptors.c **** 
 171:Descriptors.c **** 	.UnicodeString          = L"Magnetic Card Reader"
 172:Descriptors.c **** };
 173:Descriptors.c **** 
 174:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 175:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 176:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 177:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 178:Descriptors.c ****  *  USB host.
 179:Descriptors.c ****  */
 180:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 181:Descriptors.c ****                                     const uint8_t wIndex,
 182:Descriptors.c ****                                     const void** const DescriptorAddress)
 183:Descriptors.c **** {
  17               		.loc 1 183 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 184:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 185:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 186:Descriptors.c **** 
 187:Descriptors.c **** 	const void* Address = NULL;
 188:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 189:Descriptors.c **** 
 190:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 190 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2330      		cpi r18,3
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 00F4      		brsh .L4
  31 000c 2130      		cpi r18,1
  32 000e 3105      		cpc r19,__zero_reg__
  33 0010 01F0      		breq .L5
  34 0012 2230      		cpi r18,2
  35 0014 3105      		cpc r19,__zero_reg__
  36 0016 01F4      		brne .L14
  37               	.LVL1:
 191:Descriptors.c **** 	{
 192:Descriptors.c **** 		case DTYPE_Device:
 193:Descriptors.c **** 			Address = &DeviceDescriptor;
 194:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 195:Descriptors.c **** 			break;
 196:Descriptors.c **** 		case DTYPE_Configuration:
 197:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 198:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  38               		.loc 1 198 0
  39 0018 82E2      		ldi r24,lo8(34)
  40 001a 90E0      		ldi r25,0
  41               	.LVL2:
 197:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  42               		.loc 1 197 0
  43 001c 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  44 001e 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 199:Descriptors.c **** 			break;
  45               		.loc 1 199 0
  46 0020 00C0      		rjmp .L2
  47               	.LVL3:
  48               	.L4:
 190:Descriptors.c **** 	{
  49               		.loc 1 190 0
  50 0022 2132      		cpi r18,33
  51 0024 3105      		cpc r19,__zero_reg__
  52 0026 01F0      		breq .L7
  53 0028 2232      		cpi r18,34
  54 002a 3105      		cpc r19,__zero_reg__
  55 002c 01F4      		brne .L14
  56               	.LVL4:
 200:Descriptors.c **** 		case DTYPE_String:
 201:Descriptors.c **** 			switch (DescriptorNumber)
 202:Descriptors.c **** 			{
 203:Descriptors.c **** 				case 0x00:
 204:Descriptors.c **** 					Address = &LanguageString;
 205:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 206:Descriptors.c **** 					break;
 207:Descriptors.c **** 				case 0x01:
 208:Descriptors.c **** 					Address = &ManufacturerString;
 209:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 210:Descriptors.c **** 					break;
 211:Descriptors.c **** 				case 0x02:
 212:Descriptors.c **** 					Address = &ProductString;
 213:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 214:Descriptors.c **** 					break;
 215:Descriptors.c **** 			}
 216:Descriptors.c **** 
 217:Descriptors.c **** 			break;
 218:Descriptors.c **** 		case HID_DTYPE_HID:
 219:Descriptors.c **** 			Address = &ConfigurationDescriptor.HID_KeyboardHID;
 220:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);
 221:Descriptors.c **** 			break;
 222:Descriptors.c **** 		case HID_DTYPE_Report:
 223:Descriptors.c **** 			Address = &KeyboardReport;
 224:Descriptors.c **** 			Size    = sizeof(KeyboardReport);
  57               		.loc 1 224 0
  58 002e 8FE3      		ldi r24,lo8(63)
  59 0030 90E0      		ldi r25,0
  60               	.LVL5:
 223:Descriptors.c **** 			Size    = sizeof(KeyboardReport);
  61               		.loc 1 223 0
  62 0032 20E0      		ldi r18,lo8(KeyboardReport)
  63 0034 30E0      		ldi r19,hi8(KeyboardReport)
 225:Descriptors.c **** 			break;
  64               		.loc 1 225 0
  65 0036 00C0      		rjmp .L2
  66               	.LVL6:
  67               	.L5:
 194:Descriptors.c **** 			break;
  68               		.loc 1 194 0
  69 0038 82E1      		ldi r24,lo8(18)
  70 003a 90E0      		ldi r25,0
  71               	.LVL7:
 193:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  72               		.loc 1 193 0
  73 003c 20E0      		ldi r18,lo8(DeviceDescriptor)
  74 003e 30E0      		ldi r19,hi8(DeviceDescriptor)
  75 0040 00C0      		rjmp .L2
  76               	.LVL8:
  77               	.L3:
 201:Descriptors.c **** 			{
  78               		.loc 1 201 0
  79 0042 9927      		clr r25
  80               	.LVL9:
  81 0044 8130      		cpi r24,1
  82 0046 9105      		cpc r25,__zero_reg__
  83 0048 01F0      		breq .L9
  84 004a 00F0      		brlo .L10
  85 004c 0297      		sbiw r24,2
  86 004e 01F4      		brne .L14
  87               	.LVL10:
  88               	.LBB2:
 213:Descriptors.c **** 					break;
  89               		.loc 1 213 0
  90 0050 E0E0      		ldi r30,lo8(ProductString)
  91 0052 F0E0      		ldi r31,hi8(ProductString)
  92 0054 00C0      		rjmp .L15
  93               	.LVL11:
  94               	.L10:
  95               	.LBE2:
  96               	.LBB3:
 205:Descriptors.c **** 					break;
  97               		.loc 1 205 0
  98 0056 E0E0      		ldi r30,lo8(LanguageString)
  99 0058 F0E0      		ldi r31,hi8(LanguageString)
 100 005a 00C0      		rjmp .L15
 101               	.LVL12:
 102               	.L9:
 103               	.LBE3:
 104               	.LBB4:
 209:Descriptors.c **** 					break;
 105               		.loc 1 209 0
 106 005c E0E0      		ldi r30,lo8(ManufacturerString)
 107 005e F0E0      		ldi r31,hi8(ManufacturerString)
 108               	.LVL13:
 109               	.L15:
 110               	.LBE4:
 111               	.LBB5:
 213:Descriptors.c **** 					break;
 112               		.loc 1 213 0
 113               	/* #APP */
 114               	 ;  213 "Descriptors.c" 1
 115 0060 8491      		lpm r24, Z
 116               		
 117               	 ;  0 "" 2
 118               	.LVL14:
 119               	/* #NOAPP */
 120               	.LBE5:
 121 0062 90E0      		ldi r25,0
 122               	.LVL15:
 212:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 123               		.loc 1 212 0
 124 0064 9F01      		movw r18,r30
 214:Descriptors.c **** 			}
 125               		.loc 1 214 0
 126 0066 00C0      		rjmp .L2
 127               	.LVL16:
 128               	.L7:
 220:Descriptors.c **** 			break;
 129               		.loc 1 220 0
 130 0068 89E0      		ldi r24,lo8(9)
 131 006a 90E0      		ldi r25,0
 132               	.LVL17:
 219:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_HID_t);
 133               		.loc 1 219 0
 134 006c 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
 135 006e 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
 136               	.LVL18:
 221:Descriptors.c **** 		case HID_DTYPE_Report:
 137               		.loc 1 221 0
 138 0070 00C0      		rjmp .L2
 139               	.LVL19:
 140               	.L14:
 188:Descriptors.c **** 
 141               		.loc 1 188 0
 142 0072 80E0      		ldi r24,0
 143 0074 90E0      		ldi r25,0
 187:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 144               		.loc 1 187 0
 145 0076 20E0      		ldi r18,0
 146 0078 30E0      		ldi r19,0
 147               	.LVL20:
 148               	.L2:
 226:Descriptors.c **** 	}
 227:Descriptors.c **** 
 228:Descriptors.c **** 	*DescriptorAddress = Address;
 149               		.loc 1 228 0
 150 007a FA01      		movw r30,r20
 151 007c 3183      		std Z+1,r19
 152 007e 2083      		st Z,r18
 229:Descriptors.c **** 	return Size;
 230:Descriptors.c **** }
 153               		.loc 1 230 0
 154 0080 0895      		ret
 155               		.cfi_endproc
 156               	.LFE97:
 158               	.global	ProductString
 159               		.section	.progmem.data,"a",@progbits
 162               	ProductString:
 163 0000 2A        		.byte	42
 164 0001 03        		.byte	3
 165 0002 4D00      		.string	"M"
 166 0004 6100      		.string	"a"
 167 0006 6700      		.string	"g"
 168 0008 6E00      		.string	"n"
 169 000a 6500      		.string	"e"
 170 000c 7400      		.string	"t"
 171 000e 6900      		.string	"i"
 172 0010 6300      		.string	"c"
 173 0012 2000      		.string	" "
 174 0014 4300      		.string	"C"
 175 0016 6100      		.string	"a"
 176 0018 7200      		.string	"r"
 177 001a 6400      		.string	"d"
 178 001c 2000      		.string	" "
 179 001e 5200      		.string	"R"
 180 0020 6500      		.string	"e"
 181 0022 6100      		.string	"a"
 182 0024 6400      		.string	"d"
 183 0026 6500      		.string	"e"
 184 0028 7200      		.string	"r"
 185 002a 00        		.string	""
 186 002b 00        		.string	""
 187               	.global	ManufacturerString
 190               	ManufacturerString:
 191 002c 42        		.byte	66
 192 002d 03        		.byte	3
 193 002e 4400      		.string	"D"
 194 0030 6500      		.string	"e"
 195 0032 6100      		.string	"a"
 196 0034 6E00      		.string	"n"
 197 0036 2000      		.string	" "
 198 0038 4300      		.string	"C"
 199 003a 6100      		.string	"a"
 200 003c 6D00      		.string	"m"
 201 003e 6500      		.string	"e"
 202 0040 7200      		.string	"r"
 203 0042 6100      		.string	"a"
 204 0044 2000      		.string	" "
 205 0046 6100      		.string	"a"
 206 0048 6E00      		.string	"n"
 207 004a 6400      		.string	"d"
 208 004c 2000      		.string	" "
 209 004e 4400      		.string	"D"
 210 0050 6500      		.string	"e"
 211 0052 6E00      		.string	"n"
 212 0054 7600      		.string	"v"
 213 0056 6500      		.string	"e"
 214 0058 7200      		.string	"r"
 215 005a 2000      		.string	" "
 216 005c 4700      		.string	"G"
 217 005e 6900      		.string	"i"
 218 0060 6E00      		.string	"n"
 219 0062 6700      		.string	"g"
 220 0064 6500      		.string	"e"
 221 0066 7200      		.string	"r"
 222 0068 6900      		.string	"i"
 223 006a 6300      		.string	"c"
 224 006c 6800      		.string	"h"
 225 006e 00        		.string	""
 226 006f 00        		.string	""
 227               	.global	LanguageString
 230               	LanguageString:
 231 0070 04        		.byte	4
 232 0071 03        		.byte	3
 233 0072 0904      		.word	1033
 234               	.global	ConfigurationDescriptor
 237               	ConfigurationDescriptor:
 238 0074 09        		.byte	9
 239 0075 02        		.byte	2
 240 0076 2200      		.word	34
 241 0078 01        		.byte	1
 242 0079 01        		.byte	1
 243 007a 00        		.byte	0
 244 007b C0        		.byte	-64
 245 007c 32        		.byte	50
 246 007d 09        		.byte	9
 247 007e 04        		.byte	4
 248 007f 00        		.byte	0
 249 0080 00        		.byte	0
 250 0081 01        		.byte	1
 251 0082 03        		.byte	3
 252 0083 01        		.byte	1
 253 0084 01        		.byte	1
 254 0085 00        		.byte	0
 255 0086 09        		.byte	9
 256 0087 21        		.byte	33
 257 0088 1101      		.word	273
 258 008a 00        		.byte	0
 259 008b 01        		.byte	1
 260 008c 22        		.byte	34
 261 008d 3F00      		.word	63
 262 008f 07        		.byte	7
 263 0090 05        		.byte	5
 264 0091 81        		.byte	-127
 265 0092 03        		.byte	3
 266 0093 0800      		.word	8
 267 0095 01        		.byte	1
 268               	.global	DeviceDescriptor
 271               	DeviceDescriptor:
 272 0096 12        		.byte	18
 273 0097 01        		.byte	1
 274 0098 1001      		.word	272
 275 009a 00        		.byte	0
 276 009b 00        		.byte	0
 277 009c 00        		.byte	0
 278 009d 08        		.byte	8
 279 009e EB03      		.word	1003
 280 00a0 4220      		.word	8258
 281 00a2 0100      		.word	1
 282 00a4 01        		.byte	1
 283 00a5 02        		.byte	2
 284 00a6 DC        		.byte	-36
 285 00a7 01        		.byte	1
 286               	.global	KeyboardReport
 289               	KeyboardReport:
 290 00a8 05        		.byte	5
 291 00a9 01        		.byte	1
 292 00aa 09        		.byte	9
 293 00ab 06        		.byte	6
 294 00ac A1        		.byte	-95
 295 00ad 01        		.byte	1
 296 00ae 05        		.byte	5
 297 00af 07        		.byte	7
 298 00b0 19        		.byte	25
 299 00b1 E0        		.byte	-32
 300 00b2 29        		.byte	41
 301 00b3 E7        		.byte	-25
 302 00b4 15        		.byte	21
 303 00b5 00        		.byte	0
 304 00b6 25        		.byte	37
 305 00b7 01        		.byte	1
 306 00b8 75        		.byte	117
 307 00b9 01        		.byte	1
 308 00ba 95        		.byte	-107
 309 00bb 08        		.byte	8
 310 00bc 81        		.byte	-127
 311 00bd 02        		.byte	2
 312 00be 95        		.byte	-107
 313 00bf 01        		.byte	1
 314 00c0 75        		.byte	117
 315 00c1 08        		.byte	8
 316 00c2 81        		.byte	-127
 317 00c3 01        		.byte	1
 318 00c4 05        		.byte	5
 319 00c5 08        		.byte	8
 320 00c6 19        		.byte	25
 321 00c7 01        		.byte	1
 322 00c8 29        		.byte	41
 323 00c9 05        		.byte	5
 324 00ca 95        		.byte	-107
 325 00cb 05        		.byte	5
 326 00cc 75        		.byte	117
 327 00cd 01        		.byte	1
 328 00ce 91        		.byte	-111
 329 00cf 02        		.byte	2
 330 00d0 95        		.byte	-107
 331 00d1 01        		.byte	1
 332 00d2 75        		.byte	117
 333 00d3 03        		.byte	3
 334 00d4 91        		.byte	-111
 335 00d5 01        		.byte	1
 336 00d6 15        		.byte	21
 337 00d7 00        		.byte	0
 338 00d8 25        		.byte	37
 339 00d9 65        		.byte	101
 340 00da 05        		.byte	5
 341 00db 07        		.byte	7
 342 00dc 19        		.byte	25
 343 00dd 00        		.byte	0
 344 00de 29        		.byte	41
 345 00df 65        		.byte	101
 346 00e0 95        		.byte	-107
 347 00e1 06        		.byte	6
 348 00e2 75        		.byte	117
 349 00e3 08        		.byte	8
 350 00e4 81        		.byte	-127
 351 00e5 00        		.byte	0
 352 00e6 C0        		.byte	-64
 353               		.text
 354               	.Letext0:
 355               		.file 2 "/usr/lib/avr/include/stdint.h"
 356               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 357               		.file 4 "../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 358               		.file 5 "../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 359               		.file 6 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccElw8tD.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccElw8tD.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccElw8tD.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccElw8tD.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccElw8tD.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccElw8tD.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccElw8tD.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccElw8tD.s:237    .progmem.data:0000000000000074 ConfigurationDescriptor
     /tmp/ccElw8tD.s:289    .progmem.data:00000000000000a8 KeyboardReport
     /tmp/ccElw8tD.s:271    .progmem.data:0000000000000096 DeviceDescriptor
     /tmp/ccElw8tD.s:162    .progmem.data:0000000000000000 ProductString
     /tmp/ccElw8tD.s:230    .progmem.data:0000000000000070 LanguageString
     /tmp/ccElw8tD.s:190    .progmem.data:000000000000002c ManufacturerString

NO UNDEFINED SYMBOLS
