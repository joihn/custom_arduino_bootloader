   1               		.file	"MassStoreCommands.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.MassStore_WaitForDataReceived,"ax",@progbits
  13               	MassStore_WaitForDataReceived:
  14               	.LFB150:
  15               		.file 1 "Lib/MassStoreCommands.c"
   1:Lib/MassStoreCommands.c **** /*
   2:Lib/MassStoreCommands.c ****              LUFA Library
   3:Lib/MassStoreCommands.c ****      Copyright (C) Dean Camera, 2011.
   4:Lib/MassStoreCommands.c **** 
   5:Lib/MassStoreCommands.c ****   dean [at] fourwalledcubicle [dot] com
   6:Lib/MassStoreCommands.c ****            www.lufa-lib.org
   7:Lib/MassStoreCommands.c **** */
   8:Lib/MassStoreCommands.c **** 
   9:Lib/MassStoreCommands.c **** /*
  10:Lib/MassStoreCommands.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Lib/MassStoreCommands.c **** 
  12:Lib/MassStoreCommands.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Lib/MassStoreCommands.c ****   software and its documentation for any purpose is hereby granted
  14:Lib/MassStoreCommands.c ****   without fee, provided that the above copyright notice appear in
  15:Lib/MassStoreCommands.c ****   all copies and that both that the copyright notice and this
  16:Lib/MassStoreCommands.c ****   permission notice and warranty disclaimer appear in supporting
  17:Lib/MassStoreCommands.c ****   documentation, and that the name of the author not be used in
  18:Lib/MassStoreCommands.c ****   advertising or publicity pertaining to distribution of the
  19:Lib/MassStoreCommands.c ****   software without specific, written prior permission.
  20:Lib/MassStoreCommands.c **** 
  21:Lib/MassStoreCommands.c ****   The author disclaim all warranties with regard to this
  22:Lib/MassStoreCommands.c ****   software, including all implied warranties of merchantability
  23:Lib/MassStoreCommands.c ****   and fitness.  In no event shall the author be liable for any
  24:Lib/MassStoreCommands.c ****   special, indirect or consequential damages or any damages
  25:Lib/MassStoreCommands.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Lib/MassStoreCommands.c ****   in an action of contract, negligence or other tortious action,
  27:Lib/MassStoreCommands.c ****   arising out of or in connection with the use or performance of
  28:Lib/MassStoreCommands.c ****   this software.
  29:Lib/MassStoreCommands.c **** */
  30:Lib/MassStoreCommands.c **** 
  31:Lib/MassStoreCommands.c **** /** \file
  32:Lib/MassStoreCommands.c ****  *
  33:Lib/MassStoreCommands.c ****  *  Mass Storage Device commands, to issue MSD commands to the device for
  34:Lib/MassStoreCommands.c ****  *  reading device status, capacity, and other characteristics. This file
  35:Lib/MassStoreCommands.c ****  *  also contains block read and write functions, so that device blocks
  36:Lib/MassStoreCommands.c ****  *  can be read and written. In general, these functions would be chained
  37:Lib/MassStoreCommands.c ****  *  to a FAT library to give file-level access to an attached device's contents.
  38:Lib/MassStoreCommands.c ****  *
  39:Lib/MassStoreCommands.c ****  *  \note Many Mass Storage devices on the market are non-compliant to the
  40:Lib/MassStoreCommands.c ****  *        specifications and thus can prove difficult to interface with. It
  41:Lib/MassStoreCommands.c ****  *        may be necessary to retry the functions in the module several times
  42:Lib/MassStoreCommands.c ****  *        after they have returned and error to successfully send the command
  43:Lib/MassStoreCommands.c ****  *        to the device. Some devices may also need to have the stream function
  44:Lib/MassStoreCommands.c ****  *        timeout period extended beyond 100ms (some badly designed devices exceeding
  45:Lib/MassStoreCommands.c ****  *        1.5 seconds occasionally) by defining USB_STREAM_TIMEOUT_MS to a
  46:Lib/MassStoreCommands.c ****  *        larger value in the project makefile and passing it to the compiler
  47:Lib/MassStoreCommands.c ****  *        via the -D switch.
  48:Lib/MassStoreCommands.c ****  */
  49:Lib/MassStoreCommands.c **** 
  50:Lib/MassStoreCommands.c **** #define  INCLUDE_FROM_MASSSTORE_COMMANDS_C
  51:Lib/MassStoreCommands.c **** #include "MassStoreCommands.h"
  52:Lib/MassStoreCommands.c **** 
  53:Lib/MassStoreCommands.c **** /** Current Tag value used in issued CBWs to the device. This is automatically incremented
  54:Lib/MassStoreCommands.c ****  *  each time a command is sent, and is not externally accessible.
  55:Lib/MassStoreCommands.c ****  */
  56:Lib/MassStoreCommands.c **** static uint32_t MassStore_Tag = 1;
  57:Lib/MassStoreCommands.c **** 
  58:Lib/MassStoreCommands.c **** 
  59:Lib/MassStoreCommands.c **** /** Routine to send the current CBW to the device, and increment the Tag value as needed.
  60:Lib/MassStoreCommands.c ****  *
  61:Lib/MassStoreCommands.c ****  *  \param[in] SCSICommandBlock  Pointer to a SCSI command block structure to send to the attached 
  62:Lib/MassStoreCommands.c ****  *  \param[in,out] BufferPtr     Pointer to a buffer for the data to send or receive to/from the de
  63:Lib/MassStoreCommands.c ****  *
  64:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum
  65:Lib/MassStoreCommands.c ****  */
  66:Lib/MassStoreCommands.c **** static uint8_t MassStore_SendCommand(MS_CommandBlockWrapper_t* const SCSICommandBlock,
  67:Lib/MassStoreCommands.c ****                                      void* BufferPtr)
  68:Lib/MassStoreCommands.c **** {
  69:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
  70:Lib/MassStoreCommands.c **** 
  71:Lib/MassStoreCommands.c **** 	/* Wrap Tag value when invalid - MS class defines tag values of 0 and 0xFFFFFFFF to be invalid */
  72:Lib/MassStoreCommands.c **** 	if (++MassStore_Tag == 0xFFFFFFFF)
  73:Lib/MassStoreCommands.c **** 	  MassStore_Tag = 1;
  74:Lib/MassStoreCommands.c **** 
  75:Lib/MassStoreCommands.c **** 	/* Each transmission should have a unique tag value, increment before use */
  76:Lib/MassStoreCommands.c **** 	SCSICommandBlock->Tag = MassStore_Tag;
  77:Lib/MassStoreCommands.c **** 
  78:Lib/MassStoreCommands.c **** 	/* Select the OUT data pipe for CBW transmission */
  79:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(MASS_STORE_DATA_OUT_PIPE);
  80:Lib/MassStoreCommands.c **** 	Pipe_Unfreeze();
  81:Lib/MassStoreCommands.c **** 
  82:Lib/MassStoreCommands.c **** 	/* Write the CBW command to the OUT pipe */
  83:Lib/MassStoreCommands.c **** 	if ((ErrorCode = Pipe_Write_Stream_LE(SCSICommandBlock, sizeof(MS_CommandBlockWrapper_t), NULL)) !
  84:Lib/MassStoreCommands.c **** 	                                      PIPE_RWSTREAM_NoError)
  85:Lib/MassStoreCommands.c **** 	{
  86:Lib/MassStoreCommands.c **** 		return ErrorCode;
  87:Lib/MassStoreCommands.c **** 	}
  88:Lib/MassStoreCommands.c **** 
  89:Lib/MassStoreCommands.c **** 	/* Send the data in the OUT pipe to the attached device */
  90:Lib/MassStoreCommands.c **** 	Pipe_ClearOUT();
  91:Lib/MassStoreCommands.c **** 
  92:Lib/MassStoreCommands.c **** 	/* Wait until command has been sent */
  93:Lib/MassStoreCommands.c **** 	Pipe_WaitUntilReady();
  94:Lib/MassStoreCommands.c **** 
  95:Lib/MassStoreCommands.c **** 	/* Freeze pipe after use */
  96:Lib/MassStoreCommands.c **** 	Pipe_Freeze();
  97:Lib/MassStoreCommands.c **** 
  98:Lib/MassStoreCommands.c **** 	/* Send data if any has been given */
  99:Lib/MassStoreCommands.c **** 	if ((BufferPtr != NULL) &&
 100:Lib/MassStoreCommands.c **** 	    ((ErrorCode = MassStore_SendReceiveData(SCSICommandBlock, BufferPtr)) != PIPE_READYWAIT_NoErro
 101:Lib/MassStoreCommands.c **** 	{
 102:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 103:Lib/MassStoreCommands.c **** 		return ErrorCode;
 104:Lib/MassStoreCommands.c **** 	}
 105:Lib/MassStoreCommands.c **** 
 106:Lib/MassStoreCommands.c **** 	return ErrorCode;
 107:Lib/MassStoreCommands.c **** }
 108:Lib/MassStoreCommands.c **** 
 109:Lib/MassStoreCommands.c **** /** Waits until the attached device is ready to accept data following a CBW, checking
 110:Lib/MassStoreCommands.c ****  *  to ensure that the device has not stalled the transaction.
 111:Lib/MassStoreCommands.c ****  *
 112:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum
 113:Lib/MassStoreCommands.c ****  */
 114:Lib/MassStoreCommands.c **** static uint8_t MassStore_WaitForDataReceived(void)
 115:Lib/MassStoreCommands.c **** {
  16               		.loc 1 115 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.LVL0:
  23               	.LBB137:
  24               	.LBB138:
  25               		.file 2 "../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h"
   1:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** /*
   2:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****              LUFA Library
   3:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
   5:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** */
   8:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
   9:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** /*
  10:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  12:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  21:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****   this software.
  29:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** */
  30:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  31:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** /** \file
  32:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *  \brief USB Host definitions for the AVR8 microcontrollers.
  33:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *  \copydetails Group_Host_AVR8
  34:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *
  35:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  */
  38:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  39:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** /** \ingroup Group_Host
  40:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *  \defgroup Group_Host_AVR8 Host Management (AVR8)
  41:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *  \brief USB Host definitions for the AVR8 microcontrollers.
  42:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *
  43:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *  Architecture specific USB Host definitions for the Atmel 8-bit AVR microcontrollers.
  44:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *
  45:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  *  @{
  46:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h ****  */
  47:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  48:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** #ifndef __USBHOST_AVR8_H__
  49:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** #define __USBHOST_AVR8_H__
  50:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  51:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 	/* Includes: */
  52:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		#include "../../../../Common/Common.h"
  53:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		#include "../StdDescriptors.h"
  54:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		#include "../Pipe.h"
  55:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		#include "../USBInterrupt.h"
  56:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  57:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  58:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		#if defined(__cplusplus)
  59:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			extern "C" {
  60:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		#endif
  61:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  62:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 	/* Preprocessor Checks: */
  63:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  64:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  65:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		#endif
  66:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  67:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 	/* Public Interface - May be used in end-application: */
  68:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		/* Macros: */
  69:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			/** Indicates the fixed USB device address which any attached device is enumerated to when in
  70:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *  host mode. As only one USB device may be attached to the AVR in host mode at any one time
  71:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *  and that the address used is not important (other than the fact that it is non-zero), a
  72:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *  fixed value is specified by the library.
  73:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 */
  74:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			#define USB_HOST_DEVICEADDRESS                 1
  75:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  76:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			#if !defined(HOST_DEVICE_SETTLE_DELAY_MS) || defined(__DOXYGEN__)
  77:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				/** Constant for the delay in milliseconds after a device is connected before the library
  78:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				 *  will start the enumeration process. Some devices require a delay of up to 5 seconds
  79:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				 *  after connection before the enumeration process can start or incorrect operation will
  80:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				 *  occur.
  81:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				 *
  82:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				 *  The default delay value may be overridden in the user project makefile by defining the
  83:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				 *  \c HOST_DEVICE_SETTLE_DELAY_MS token to the required delay in milliseconds, and passed to t
  84:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				 *  compiler using the -D switch.
  85:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				 */
  86:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				#define HOST_DEVICE_SETTLE_DELAY_MS        1000
  87:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			#endif
  88:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
  89:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			/** Enum for the error codes for the \ref EVENT_USB_Host_HostError() event.
  90:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *
  91:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *  \see \ref Group_Events for more information on this event.
  92:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 */
  93:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			enum USB_Host_ErrorCodes_t
  94:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			{
  95:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				HOST_ERROR_VBusVoltageDip       = 0, /**< VBUS voltage dipped to an unacceptable level. This
  96:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   error may be the result of an attached device drawing
  97:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   too much current from the VBUS line, or due to the
  98:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   AVR's power source being unable to supply sufficient
  99:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   current.
 100:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      */
 101:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			};
 102:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
 103:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			/** Enum for the error codes for the \ref EVENT_USB_Host_DeviceEnumerationFailed() event.
 104:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *
 105:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *  \see \ref Group_Events for more information on this event.
 106:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 */
 107:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			enum USB_Host_EnumerationErrorCodes_t
 108:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			{
 109:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				HOST_ENUMERROR_NoError          = 0, /**< No error occurred. Used internally, this is not a val
 110:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   ErrorCode parameter value for the \ref EVENT_USB_Host
 111:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   event.
 112:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      */
 113:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				HOST_ENUMERROR_WaitStage        = 1, /**< One of the delays between enumeration steps failed
 114:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   to complete successfully, due to a timeout or other
 115:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   error.
 116:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      */
 117:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				HOST_ENUMERROR_NoDeviceDetected = 2, /**< No device was detected, despite the USB data lines
 118:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   indicating the attachment of a device.
 119:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      */
 120:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				HOST_ENUMERROR_ControlError     = 3, /**< One of the enumeration control requests failed to
 121:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   complete successfully.
 122:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      */
 123:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				HOST_ENUMERROR_PipeConfigError  = 4, /**< The default control pipe (address 0) failed to
 124:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      *   configure correctly.
 125:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				                                      */
 126:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			};
 127:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 
 128:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 		/* Inline Functions: */
 129:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			/** Returns the current USB frame number, when in host mode. Every millisecond the USB bus is ac
 130:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *  the frame number is incremented by one.
 131:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *
 132:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 *  \return Current USB frame number from the USB controller.
 133:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			 */
 134:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			static inline uint16_t USB_Host_GetFrameNumber(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 135:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			static inline uint16_t USB_Host_GetFrameNumber(void)
 136:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 			{
 137:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Host_AVR8.h **** 				return UHFNUM;
  26               		.loc 2 137 0
  27 0000 2091 A200 		lds r18,162
  28 0004 3091 A300 		lds r19,162+1
  29               	.LVL1:
  30               	.LBE138:
  31               	.LBE137:
  32               	.LBB139:
  33               	.LBB140:
  34               		.file 3 "../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h"
   1:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
   2:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****              LUFA Library
   3:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   5:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
   8:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
   9:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /*
  10:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  12:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  21:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****   this software.
  29:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** */
  30:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  31:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \file
  32:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief USB Pipe definitions for the AVR8 microcontrollers.
  33:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \copydetails Group_PipeManagement_AVR8
  34:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  35:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  38:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  39:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeRW
  40:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeRW_AVR8 Pipe Data Reading and Writing (AVR8)
  41:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe data read/write definitions for the Atmel AVR8 architecture.
  42:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  43:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to p
  44:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  45:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  46:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePrimitiveRW
  47:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePrimitiveRW_AVR8 Read/Write of Primitive Data Types (AVR8)
  48:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe primitive data read/write definitions for the Atmel AVR8 architecture.
  49:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  50:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  51:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  from and to pipes.
  52:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  53:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  54:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipePacketManagement
  55:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipePacketManagement_AVR8 Pipe Packet Management (AVR8)
  56:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe packet management definitions for the Atmel AVR8 architecture.
  57:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  58:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Functions, macros, variables, enums and types related to packet management of pipes.
  59:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  60:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  61:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeControlReq
  62:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeControlReq_AVR8 Pipe Control Request Management (AVR8)
  63:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe control request management definitions for the Atmel AVR8 architecture.
  64:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  65:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  Module for host mode request processing. This module allows for the transmission of standard, c
  66:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  vendor control requests to the default control endpoint of an attached device while in host mod
  67:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  68:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \see Chapter 9 of the USB 2.0 specification.
  69:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  70:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  71:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** /** \ingroup Group_PipeManagement
  72:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \defgroup Group_PipeManagement_AVR8 Pipe Management (AVR8)
  73:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  \brief Pipe management definitions for the Atmel AVR8 architecture.
  74:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  75:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  This module contains functions, macros and enums related to pipe management when in USB Host mo
  76:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  module contains the pipe management macros, as well as pipe interrupt and data send/receive fun
  77:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  for various data types.
  78:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *
  79:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  *  @{
  80:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h ****  */
  81:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  82:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #ifndef __PIPE_AVR8_H__
  83:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** #define __PIPE_AVR8_H__
  84:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  85:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Includes: */
  86:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../../../../Common/Common.h"
  87:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#include "../USBTask.h"
  88:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  89:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  90:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if defined(__cplusplus)
  91:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			extern "C" {
  92:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  93:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  94:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Preprocessor Checks: */
  95:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  96:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  97:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		#endif
  98:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
  99:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 100:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Macros: */
 101:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Error Flag Masks */
 102:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 103:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an overflow error occurred in the pipe o
 104:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_OVERFLOW         (1 << 6)
 105:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 106:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that an underflow error occurred in the pipe 
 107:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_UNDERFLOW        (1 << 5)
 108:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 109:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a CRC error occurred in the pipe on the 
 110:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_CRC16            (1 << 4)
 111:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 112:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware timeout error occurred in the
 113:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_TIMEOUT          (1 << 3)
 114:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 115:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware PID error occurred in the pip
 116:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_PID              (1 << 2)
 117:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 118:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data PID error occurred in th
 119:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATAPID          (1 << 1)
 120:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 121:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for \ref Pipe_GetErrorFlags(), indicating that a hardware data toggle error occurred in
 122:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_ERRORFLAG_DATATGL          (1 << 0)
 123:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 124:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 125:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Token Masks */
 126:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 127:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a SETUP token (for CONTROL t
 128:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which will trigger a control request on the attached device when data is written to the pipe
 129:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 130:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_SETUP                (0 << PTOKEN0)
 131:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 132:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a IN token (for non-CONTROL 
 133:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from device to host.
 134:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 135:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_IN                   (1 << PTOKEN0)
 136:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 137:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Token mask for \ref Pipe_ConfigurePipe(). This sets the pipe as a OUT token (for non-CONTROL
 138:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicating that the pipe data will flow from host to device.
 139:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 140:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOKEN_OUT                  (2 << PTOKEN0)
 141:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 142:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			
 143:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** \name Pipe Bank Mode Masks */
 144:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@{
 145:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 146:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have one single bank, which requires less USB FIFO memory but results in slower trans
 147:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  only one USB device (the AVR or the attached device) can access the pipe's bank at the one t
 148:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 149:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_SINGLE                (0 << EPBK0)
 150:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 151:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Pipe_ConfigurePipe() macro. This indicates tha
 152:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  should have two banks, which requires more USB FIFO memory but results in faster transfers a
 153:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  USB device (the AVR or the attached device) can access one bank while the other accesses the
 154:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  bank.
 155:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 156:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_BANK_DOUBLE                (1 << EPBK0)
 157:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			//@}
 158:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 159:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Default size of the default control pipe's bank, until altered by the Endpoint0Size value
 160:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  in the device descriptor of the attached device.
 161:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 162:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_CONTROLPIPE_DEFAULT_SIZE   64
 163:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 164:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Total number of pipes (including the default control pipe at address 0) which may be used in
 165:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the device. Different USB AVR models support different amounts of pipes, this value reflects
 166:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the maximum number of pipes for the currently selected AVR model.
 167:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 168:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_TOTAL_PIPES                7
 169:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 170:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Size in bytes of the largest pipe bank size possible in the device. Not all banks on each AV
 171:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  model supports the largest bank size possible on the device; different pipe numbers support
 172:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  different maximum bank sizes. This value reflects the largest possible bank of any pipe on t
 173:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected USB AVR model.
 174:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 175:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			#define PIPE_MAX_SIZE                   256
 176:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 177:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Enums: */
 178:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enum for the possible error return codes of the \ref Pipe_WaitUntilReady() function.
 179:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 180:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 181:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 182:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			enum Pipe_WaitUntilReady_ErrorCodes_t
 183:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 184:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_NoError                 = 0, /**< Pipe ready for next packet, no error. */
 185:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_PipeStalled             = 1,	/**< The device stalled the pipe while waiting. */
 186:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host while wa
 187:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				PIPE_READYWAIT_Timeout                 = 3, /**< The device failed to accept or send the next p
 188:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   within the software timeout period set by the
 189:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             *   \ref USB_STREAM_TIMEOUT_MS macro.
 190:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                                             */
 191:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			};
 192:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 193:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 		/* Inline Functions: */
 194:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Indicates the number of bytes currently stored in the current pipes's selected bank.
 195:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 196:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \note The return width of this function may differ, depending on the maximum pipe bank size
 197:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *        of the selected AVR model.
 198:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 199:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipeRW_AVR8
 200:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 201:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
 202:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 203:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 204:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint16_t Pipe_BytesInPipe(void)
 205:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 206:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return UPBCX;
 207:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 208:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 209:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Returns the pipe address of the currently selected pipe. This is typically used to save the
 210:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  currently selected pipe number so that it can be restored after another pipe has been manipu
 211:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 212:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Index of the currently selected pipe.
 213:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 214:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 215:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetCurrentPipe(void)
 216:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 217:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPNUM & PIPE_PIPENUM_MASK);
 218:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 219:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 220:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Selects the given pipe number. Any pipe operations which do not require the pipe number to b
 221:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  indicated will operate on the currently selected pipe.
 222:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 223:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to select.
 224:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 225:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 226:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
 227:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPNUM = PipeNumber;
  35               		.loc 3 228 0
  36 0008 81E0      		ldi r24,lo8(1)
  37 000a 8093 A700 		sts 167,r24
  38               	.LVL2:
  39               	.LBE140:
  40               	.LBE139:
  41               	.LBB141:
  42               	.LBB142:
 229:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 230:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 231:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Resets the desired pipe, including the pipe banks and flags.
 232:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 233:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe to reset.
 234:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 235:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
 236:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ResetPipe(const uint8_t PipeNumber)
 237:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 238:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = (1 << PipeNumber);
 239:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPRST = 0;
 240:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 241:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 242:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Enables the currently selected pipe so that data can be sent and received through it to and 
 243:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  an attached device.
 244:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 245:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePi
 246:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 247:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
 248:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_EnablePipe(void)
 249:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 250:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << PEN);
 251:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 252:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 253:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Disables the currently selected pipe so that data cannot be sent and received through it to 
 254:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  from an attached device.
 255:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 256:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
 257:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_DisablePipe(void)
 258:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 259:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << PEN);
 260:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 261:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 262:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is enabled, but not necessarily configured.
 263:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 264:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 * \return Boolean \c true if the currently selected pipe is enabled, \c false otherwise.
 265:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 266:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 267:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsEnabled(void)
 268:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 269:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPCONX & (1 << PEN)) ? true : false);
 270:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 271:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 272:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Gets the current pipe token, indicating the pipe's data direction and type.
 273:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 274:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
 275:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 276:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 277:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeToken(void)
 278:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 279:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPCFG0X & (0x03 << PTOKEN0));
 280:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 281:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 282:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the token for the currently selected pipe to one of the tokens specified by the \c PIPE
 283:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  masks. This can be used on CONTROL type pipes, to allow for bidirectional transfer of data d
 284:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  control requests, or on regular pipes to allow for half-duplex bidirectional data transfer t
 285:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  which have two endpoints of opposite direction sharing the same endpoint address within the 
 286:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 287:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
 288:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 289:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
 290:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetPipeToken(const uint8_t Token)
 291:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 292:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
 293:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 294:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 295:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
 296:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
 297:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInfiniteINRequests(void)
 298:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 299:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << INMODE);
 300:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 301:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 302:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Configures the currently selected pipe to only allow the specified number of IN requests to 
 303:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  accepted by the pipe before it is automatically frozen.
 304:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 305:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] TotalINRequests  Total number of IN requests that the pipe may receive before fre
 306:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 307:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests) ATTR_ALWAYS_INLINE;
 308:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetFiniteINRequests(const uint8_t TotalINRequests)
 309:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 310:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << INMODE);
 311:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINRQX = TotalINRequests;
 312:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 313:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 314:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is configured.
 315:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 316:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
 317:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 318:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 319:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsConfigured(void)
 320:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 321:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPSTAX & (1 << CFGOK)) ? true : false);
 322:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 323:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 324:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Retrieves the endpoint address of the endpoint within the attached device that the currently
 325:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipe is bound to.
 326:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 327:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Endpoint address the currently selected pipe is bound to.
 328:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 329:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INL
 330:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
 331:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
 333:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 334:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 335:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 336:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sets the period between interrupts for an INTERRUPT type pipe to a specified number of milli
 337:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 338:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] Milliseconds  Number of milliseconds between each pipe poll.
 339:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 340:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds) ATTR_ALWAYS_INLINE;
 341:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds)
 342:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 343:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCFG2X = Milliseconds;
 344:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 345:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 346:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Returns a mask indicating which pipe's interrupt periods have elapsed, indicating that the p
 347:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  be serviced.
 348:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 349:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Mask whose bits indicate which pipes have interrupted.
 350:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 351:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeInterrupts(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 352:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetPipeInterrupts(void)
 353:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 354:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return UPINT;
 355:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 356:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 357:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the specified pipe number has interrupted (valid only for INTERRUPT type
 358:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipes).
 359:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 360:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \param[in] PipeNumber  Index of the pipe whose interrupt flag should be tested.
 361:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 362:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the specified pipe has interrupted, \c false otherwise.
 363:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 364:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_HasPipeInterrupted(const uint8_t PipeNumber) ATTR_WARN_UNUSED_RESULT ATT
 365:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_HasPipeInterrupted(const uint8_t PipeNumber)
 366:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 367:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINT & (1 << PipeNumber)) ? true : false);
 368:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 369:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 370:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
 371:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
 372:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Unfreeze(void)
 373:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX &= ~(1 << PFREEZE);
  43               		.loc 3 374 0
  44 000e 8091 A900 		lds r24,169
  45 0012 8F7B      		andi r24,lo8(-65)
  46 0014 8093 A900 		sts 169,r24
  47               	.LBE142:
  48               	.LBE141:
 116:Lib/MassStoreCommands.c **** 	uint16_t TimeoutMSRem        = COMMAND_DATA_TIMEOUT_MS;
  49               		.loc 1 116 0
  50 0018 80E1      		ldi r24,lo8(16)
  51 001a 97E2      		ldi r25,lo8(39)
  52               	.LBB143:
  53               	.LBB144:
  54               	.LBB145:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
  55               		.loc 3 228 0
  56 001c 62E0      		ldi r22,lo8(2)
  57               	.LBE145:
  58               	.LBE144:
  59               	.LBB147:
  60               	.LBB148:
  61 001e 71E0      		ldi r23,lo8(1)
  62               	.LVL3:
  63               	.L2:
  64               	.LBE148:
  65               	.LBE147:
  66               	.LBE143:
  67               	.LBB172:
  68               	.LBB173:
 375:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 376:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 377:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
 378:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
 379:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_Freeze(void)
 380:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPCONX |= (1 << PFREEZE);
 382:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 383:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 384:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe is frozen, and not able to accept data.
 385:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 386:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the currently selected pipe is frozen, \c false otherwise.
 387:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 388:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsFrozen(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 389:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsFrozen(void)
 390:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 391:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPCONX & (1 << PFREEZE)) ? true : false);
 392:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 393:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 394:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Clears the error flags for the currently selected pipe. */
 395:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
 396:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearError(void)
 397:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 398:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPERRX = 0;
 399:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~(1 << PERRI);
 400:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 401:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 402:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the master pipe error flag is set for the currently selected pipe, indicating 
 403:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  some sort of hardware error has occurred on the pipe.
 404:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 405:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \see \ref Pipe_GetErrorFlags() macro for information on retrieving the exact error flag.
 406:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 407:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if an error has occurred on the selected pipe, \c false otherwise.
 408:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 409:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 410:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsError(void)
 411:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 412:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << PERRI)) ? true : false);
 413:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 414:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 415:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Gets a mask of the hardware error flags which have occurred on the currently selected pipe. 
 416:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  value can then be masked against the \c PIPE_ERRORFLAG_* masks to determine what error has o
 417:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 418:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return  Mask comprising of \c PIPE_ERRORFLAG_* bits indicating what error has occurred on t
 419:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 420:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetErrorFlags(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 421:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetErrorFlags(void)
 422:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 423:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPERRX & (PIPE_ERRORFLAG_CRC16 | PIPE_ERRORFLAG_TIMEOUT |
 424:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                   PIPE_ERRORFLAG_PID   | PIPE_ERRORFLAG_DATAPID |
 425:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				                   PIPE_ERRORFLAG_DATATGL)) |
 426:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        (UPSTAX & (PIPE_ERRORFLAG_OVERFLOW | PIPE_ERRORFLAG_UNDERFLOW)));
 427:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 428:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			
 429:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Retrieves the number of busy banks in the currently selected pipe, which have been queued fo
 430:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  transmission via the \ref Pipe_ClearOUT() command, or are awaiting acknowledgement via the
 431:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ref Pipe_ClearIN() command.
 432:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 433:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 434:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 435:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Total number of busy banks in the selected pipe.
 436:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 437:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBusyBanks(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 438:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline uint8_t Pipe_GetBusyBanks(void)
 439:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 440:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return (UPSTAX & (0x03 << NBUSYBK0));
 441:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 442:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 443:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe may be read from (if data is waiting in the pipe
 444:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  bank and the pipe is an IN direction, or if the bank is not yet full if the pipe is an OUT
 445:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  direction). This function will return false if an error has occurred in the pipe, or if the 
 446:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  is an IN direction and no packet (or an empty packet) has been received, or if the pipe is a
 447:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  direction and the pipe bank is full.
 448:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 449:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \note This function is not valid on CONTROL type pipes.
 450:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 451:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 452:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 453:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the currently selected pipe may be read from or written to, depen
 454:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *          on its direction.
 455:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 456:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 457:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsReadWriteAllowed(void)
 458:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 459:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << RWAL)) ? true : false);
 460:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 461:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 462:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if a packet has been received on the currently selected IN pipe from the attached
 463:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 464:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 465:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 466:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
 467:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 468:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 469:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsINReceived(void)
 470:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 471:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << RXINI)) ? true : false);
  69               		.loc 3 471 0
  70 0020 4091 A600 		lds r20,166
  71               	.LBE173:
  72               	.LBE172:
 117:Lib/MassStoreCommands.c **** 	uint16_t PreviousFrameNumber = USB_Host_GetFrameNumber();
 118:Lib/MassStoreCommands.c **** 
 119:Lib/MassStoreCommands.c **** 	/* Select the IN data pipe for data reception */
 120:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(MASS_STORE_DATA_IN_PIPE);
 121:Lib/MassStoreCommands.c **** 	Pipe_Unfreeze();
 122:Lib/MassStoreCommands.c **** 
 123:Lib/MassStoreCommands.c **** 	/* Wait until data received in the IN pipe */
 124:Lib/MassStoreCommands.c **** 	while (!(Pipe_IsINReceived()))
  73               		.loc 1 124 0
  74 0024 40FD      		sbrc r20,0
  75 0026 00C0      		rjmp .L18
  76               	.LBB174:
  77               	.LBB150:
  78               	.LBB151:
  79               		.loc 2 137 0
  80 0028 4091 A200 		lds r20,162
  81 002c 5091 A300 		lds r21,162+1
  82               	.LVL4:
  83               	.LBE151:
  84               	.LBE150:
 125:Lib/MassStoreCommands.c **** 	{
 126:Lib/MassStoreCommands.c **** 		uint16_t CurrentFrameNumber = USB_Host_GetFrameNumber();
 127:Lib/MassStoreCommands.c **** 
 128:Lib/MassStoreCommands.c **** 		/* Check to see if a new frame has been issued (1ms elapsed) */
 129:Lib/MassStoreCommands.c **** 		if (CurrentFrameNumber != PreviousFrameNumber)
  85               		.loc 1 129 0
  86 0030 2417      		cp r18,r20
  87 0032 3507      		cpc r19,r21
  88 0034 01F0      		breq .L3
  89               	.LVL5:
 130:Lib/MassStoreCommands.c **** 		{
 131:Lib/MassStoreCommands.c **** 			/* Save the new frame number and decrement the timeout period */
 132:Lib/MassStoreCommands.c **** 			PreviousFrameNumber = CurrentFrameNumber;
 133:Lib/MassStoreCommands.c **** 			TimeoutMSRem--;
  90               		.loc 1 133 0
  91 0036 0197      		sbiw r24,1
  92               	.LVL6:
 134:Lib/MassStoreCommands.c **** 
 135:Lib/MassStoreCommands.c **** 			/* Check to see if the timeout period for the command has elapsed */
 136:Lib/MassStoreCommands.c **** 			if (!(TimeoutMSRem))
  93               		.loc 1 136 0
  94 0038 01F4      		brne .+2
  95 003a 00C0      		rjmp .L10
  96               	.LVL7:
  97               	.L3:
  98               	.LBB153:
  99               	.LBB154:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 100               		.loc 3 381 0
 101 003c 2091 A900 		lds r18,169
 102 0040 2064      		ori r18,lo8(64)
 103 0042 2093 A900 		sts 169,r18
 104               	.LVL8:
 105               	.LBE154:
 106               	.LBE153:
 107               	.LBB155:
 108               	.LBB146:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 109               		.loc 3 228 0
 110 0046 6093 A700 		sts 167,r22
 111               	.LVL9:
 112               	.LBE146:
 113               	.LBE155:
 114               	.LBB156:
 115               	.LBB157:
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 116               		.loc 3 374 0
 117 004a 2091 A900 		lds r18,169
 118 004e 2F7B      		andi r18,lo8(-65)
 119 0050 2093 A900 		sts 169,r18
 120               	.LBE157:
 121               	.LBE156:
 122               	.LBB158:
 123               	.LBB159:
 472:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 473:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 474:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected OUT pipe is ready to send an OUT packet to the attached
 475:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 476:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 477:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 478:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
 479:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 480:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 481:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsOUTReady(void)
 482:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 483:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << TXOUTI)) ? true : false);
 484:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 485:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 486:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if no SETUP request is currently being sent to the attached device on the selecte
 487:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  CONTROL type pipe.
 488:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 489:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 490:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 491:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the current pipe is ready for a SETUP packet, \c false otherwise.
 492:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 493:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsSETUPSent(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 494:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsSETUPSent(void)
 495:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 496:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << TXSTPI)) ? true : false);
 497:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 498:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 499:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sends the currently selected CONTROL type pipe's contents to the device as a SETUP packet.
 500:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 501:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 502:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 503:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearSETUP(void) ATTR_ALWAYS_INLINE;
 504:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearSETUP(void)
 505:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 506:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~((1 << TXSTPI) | (1 << FIFOCON));
 507:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 508:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 509:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Acknowledges the reception of a setup IN request from the attached device on the currently s
 510:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  pipe, freeing the bank ready for the next packet.
 511:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 512:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 513:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 514:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
 515:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearIN(void)
 516:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 517:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
 518:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 519:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 520:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Sends the currently selected pipe's contents to the device as an OUT packet on the selected 
 521:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the bank ready for the next packet.
 522:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 523:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 524:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 525:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
 526:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearOUT(void)
 527:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 528:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
 529:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 530:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 531:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the device sent a NAK (Negative Acknowledge) in response to the last sent pack
 532:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  the currently selected pipe. This occurs when the host sends a packet to the device, but the
 533:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  is not currently ready to handle the packet (i.e. its endpoint banks are full). Once a NAK h
 534:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  received, it must be cleared using \ref Pipe_ClearNAKReceived() before the previous (or any 
 535:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  can be re-sent.
 536:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 537:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 538:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 539:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if an NAK has been received on the current pipe, \c false otherwise.
 540:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 541:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsNAKReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 542:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsNAKReceived(void)
 543:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 544:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << NAKEDI)) ? true : false);
 545:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 546:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 547:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Clears the NAK condition on the currently selected pipe.
 548:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 549:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 550:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 551:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \see \ref Pipe_IsNAKReceived() for more details.
 552:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 553:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearNAKReceived(void) ATTR_ALWAYS_INLINE;
 554:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearNAKReceived(void)
 555:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 556:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~(1 << NAKEDI);
 557:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 558:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 559:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Determines if the currently selected pipe has had the STALL condition set by the attached de
 560:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 561:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 562:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 563:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c fals
 564:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 565:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 566:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline bool Pipe_IsStalled(void)
 567:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 568:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
 124               		.loc 3 568 0
 125 0054 2091 A600 		lds r18,166
 126               	.LBE159:
 127               	.LBE158:
 137:Lib/MassStoreCommands.c **** 			  return PIPE_RWSTREAM_Timeout;
 138:Lib/MassStoreCommands.c **** 		}
 139:Lib/MassStoreCommands.c **** 
 140:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 141:Lib/MassStoreCommands.c **** 		Pipe_SelectPipe(MASS_STORE_DATA_OUT_PIPE);
 142:Lib/MassStoreCommands.c **** 		Pipe_Unfreeze();
 143:Lib/MassStoreCommands.c **** 
 144:Lib/MassStoreCommands.c **** 		/* Check if pipe stalled (command failed by device) */
 145:Lib/MassStoreCommands.c **** 		if (Pipe_IsStalled())
 128               		.loc 1 145 0
 129 0058 21FD      		sbrc r18,1
 130 005a 00C0      		rjmp .L16
 131               	.LBB160:
 132               	.LBB161:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 133               		.loc 3 381 0
 134 005c 2091 A900 		lds r18,169
 135 0060 2064      		ori r18,lo8(64)
 136 0062 2093 A900 		sts 169,r18
 137               	.LVL10:
 138               	.LBE161:
 139               	.LBE160:
 140               	.LBB162:
 141               	.LBB149:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 142               		.loc 3 228 0
 143 0066 7093 A700 		sts 167,r23
 144               	.LVL11:
 145               	.LBE149:
 146               	.LBE162:
 147               	.LBB163:
 148               	.LBB164:
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 149               		.loc 3 374 0
 150 006a 2091 A900 		lds r18,169
 151 006e 2F7B      		andi r18,lo8(-65)
 152 0070 2093 A900 		sts 169,r18
 153               	.LBE164:
 154               	.LBE163:
 155               	.LBB165:
 156               	.LBB166:
 157               		.loc 3 568 0
 158 0074 2091 A600 		lds r18,166
 159               	.LBE166:
 160               	.LBE165:
 146:Lib/MassStoreCommands.c **** 		{
 147:Lib/MassStoreCommands.c **** 			/* Clear the stall condition on the OUT pipe */
 148:Lib/MassStoreCommands.c **** 			USB_Host_ClearEndpointStall(Pipe_GetBoundEndpointAddress());
 149:Lib/MassStoreCommands.c **** 
 150:Lib/MassStoreCommands.c **** 			return PIPE_RWSTREAM_PipeStalled;
 151:Lib/MassStoreCommands.c **** 		}
 152:Lib/MassStoreCommands.c **** 
 153:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 154:Lib/MassStoreCommands.c **** 		Pipe_SelectPipe(MASS_STORE_DATA_IN_PIPE);
 155:Lib/MassStoreCommands.c **** 		Pipe_Unfreeze();
 156:Lib/MassStoreCommands.c **** 
 157:Lib/MassStoreCommands.c **** 		/* Check if pipe stalled (command failed by device) */
 158:Lib/MassStoreCommands.c **** 		if (Pipe_IsStalled())
 161               		.loc 1 158 0
 162 0078 21FF      		sbrs r18,1
 163 007a 00C0      		rjmp .L7
 164               	.L16:
 165               	.LBB167:
 166               	.LBB168:
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 167               		.loc 3 332 0
 168 007c 8091 AA00 		lds r24,170
 169               	.LVL12:
 170 0080 8F70      		andi r24,lo8(15)
 171               	.LBB169:
 172               	.LBB170:
 279:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 173               		.loc 3 279 0
 174 0082 9091 AA00 		lds r25,170
 175               	.LBE170:
 176               	.LBE169:
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 177               		.loc 3 332 0
 178 0086 9073      		andi r25,lo8(48)
 179 0088 9031      		cpi r25,lo8(16)
 180 008a 01F0      		breq .L12
 181 008c 90E0      		ldi r25,0
 182 008e 00C0      		rjmp .L8
 183               	.L12:
 184 0090 90E8      		ldi r25,lo8(-128)
 185               	.L8:
 186               	.LBE168:
 187               	.LBE167:
 159:Lib/MassStoreCommands.c **** 		{
 160:Lib/MassStoreCommands.c **** 			/* Clear the stall condition on the IN pipe */
 161:Lib/MassStoreCommands.c **** 			USB_Host_ClearEndpointStall(Pipe_GetBoundEndpointAddress());
 188               		.loc 1 161 0
 189 0092 892B      		or r24,r25
 190 0094 0E94 0000 		call USB_Host_ClearEndpointStall
 191               	.LVL13:
 162:Lib/MassStoreCommands.c **** 
 163:Lib/MassStoreCommands.c **** 			return PIPE_RWSTREAM_PipeStalled;
 192               		.loc 1 163 0
 193 0098 81E0      		ldi r24,lo8(1)
 194 009a 0895      		ret
 195               	.LVL14:
 196               	.L7:
 164:Lib/MassStoreCommands.c **** 		}
 165:Lib/MassStoreCommands.c **** 
 166:Lib/MassStoreCommands.c **** 		/* Check to see if the device was disconnected, if so exit function */
 167:Lib/MassStoreCommands.c **** 		if (USB_HostState == HOST_STATE_Unattached)
 197               		.loc 1 167 0
 198 009c 2091 0000 		lds r18,USB_HostState
 199 00a0 2130      		cpi r18,lo8(1)
 200 00a2 01F0      		breq .L13
 201               	.LBB171:
 202               	.LBB152:
 203               		.loc 2 137 0
 204 00a4 9A01      		movw r18,r20
 205 00a6 00C0      		rjmp .L2
 206               	.LVL15:
 207               	.L18:
 208               	.LBE152:
 209               	.LBE171:
 210               	.LBE174:
 211               	.LBB175:
 212               	.LBB176:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 213               		.loc 3 228 0
 214 00a8 81E0      		ldi r24,lo8(1)
 215               	.LVL16:
 216 00aa 8093 A700 		sts 167,r24
 217               	.LVL17:
 218               	.LBE176:
 219               	.LBE175:
 220               	.LBB177:
 221               	.LBB178:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 222               		.loc 3 381 0
 223 00ae 8091 A900 		lds r24,169
 224 00b2 8064      		ori r24,lo8(64)
 225 00b4 8093 A900 		sts 169,r24
 226               	.LVL18:
 227               	.LBE178:
 228               	.LBE177:
 229               	.LBB179:
 230               	.LBB180:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 231               		.loc 3 228 0
 232 00b8 82E0      		ldi r24,lo8(2)
 233 00ba 8093 A700 		sts 167,r24
 234               	.LVL19:
 235               	.LBE180:
 236               	.LBE179:
 237               	.LBB181:
 238               	.LBB182:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 239               		.loc 3 381 0
 240 00be 8091 A900 		lds r24,169
 241 00c2 8064      		ori r24,lo8(64)
 242 00c4 8093 A900 		sts 169,r24
 243               	.LBE182:
 244               	.LBE181:
 168:Lib/MassStoreCommands.c **** 		  return PIPE_RWSTREAM_DeviceDisconnected;
 169:Lib/MassStoreCommands.c **** 	};
 170:Lib/MassStoreCommands.c **** 
 171:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(MASS_STORE_DATA_IN_PIPE);
 172:Lib/MassStoreCommands.c **** 	Pipe_Freeze();
 173:Lib/MassStoreCommands.c **** 
 174:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(MASS_STORE_DATA_OUT_PIPE);
 175:Lib/MassStoreCommands.c **** 	Pipe_Freeze();
 176:Lib/MassStoreCommands.c **** 
 177:Lib/MassStoreCommands.c **** 	return PIPE_RWSTREAM_NoError;
 245               		.loc 1 177 0
 246 00c8 80E0      		ldi r24,0
 247 00ca 0895      		ret
 248               	.LVL20:
 249               	.L10:
 250               	.LBB183:
 137:Lib/MassStoreCommands.c **** 		}
 251               		.loc 1 137 0
 252 00cc 83E0      		ldi r24,lo8(3)
 253               	.LVL21:
 254 00ce 0895      		ret
 255               	.LVL22:
 256               	.L13:
 168:Lib/MassStoreCommands.c **** 		  return PIPE_RWSTREAM_DeviceDisconnected;
 257               		.loc 1 168 0
 258 00d0 82E0      		ldi r24,lo8(2)
 259               	.LVL23:
 260               	.LBE183:
 178:Lib/MassStoreCommands.c **** }
 261               		.loc 1 178 0
 262 00d2 0895      		ret
 263               		.cfi_endproc
 264               	.LFE150:
 266               		.section	.text.MassStore_GetReturnedStatus,"ax",@progbits
 268               	MassStore_GetReturnedStatus:
 269               	.LFB152:
 179:Lib/MassStoreCommands.c **** 
 180:Lib/MassStoreCommands.c **** /** Sends or receives the transaction's data stage to or from the attached device, reading or
 181:Lib/MassStoreCommands.c ****  *  writing to the nominated buffer.
 182:Lib/MassStoreCommands.c ****  *
 183:Lib/MassStoreCommands.c ****  *  \param[in] SCSICommandBlock  Pointer to a SCSI command block structure being sent to the attach
 184:Lib/MassStoreCommands.c ****  *  \param[in,out]  BufferPtr    Pointer to the data buffer to read from or write to
 185:Lib/MassStoreCommands.c ****  *
 186:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum
 187:Lib/MassStoreCommands.c ****  */
 188:Lib/MassStoreCommands.c **** static uint8_t MassStore_SendReceiveData(MS_CommandBlockWrapper_t* const SCSICommandBlock,
 189:Lib/MassStoreCommands.c ****                                          void* BufferPtr)
 190:Lib/MassStoreCommands.c **** {
 191:Lib/MassStoreCommands.c **** 	uint8_t  ErrorCode = PIPE_RWSTREAM_NoError;
 192:Lib/MassStoreCommands.c **** 	uint16_t BytesRem  = SCSICommandBlock->DataTransferLength;
 193:Lib/MassStoreCommands.c **** 
 194:Lib/MassStoreCommands.c **** 	/* Check the direction of the SCSI command data stage */
 195:Lib/MassStoreCommands.c **** 	if (SCSICommandBlock->Flags & MS_COMMAND_DIR_DATA_IN)
 196:Lib/MassStoreCommands.c **** 	{
 197:Lib/MassStoreCommands.c **** 		/* Wait until the device has replied with some data */
 198:Lib/MassStoreCommands.c **** 		if ((ErrorCode = MassStore_WaitForDataReceived()) != PIPE_RWSTREAM_NoError)
 199:Lib/MassStoreCommands.c **** 		  return ErrorCode;
 200:Lib/MassStoreCommands.c **** 
 201:Lib/MassStoreCommands.c **** 		/* Select the IN data pipe for data reception */
 202:Lib/MassStoreCommands.c **** 		Pipe_SelectPipe(MASS_STORE_DATA_IN_PIPE);
 203:Lib/MassStoreCommands.c **** 		Pipe_Unfreeze();
 204:Lib/MassStoreCommands.c **** 
 205:Lib/MassStoreCommands.c **** 		/* Read in the block data from the pipe */
 206:Lib/MassStoreCommands.c **** 		if ((ErrorCode = Pipe_Read_Stream_LE(BufferPtr, BytesRem, NULL)) != PIPE_RWSTREAM_NoError)
 207:Lib/MassStoreCommands.c **** 		  return ErrorCode;
 208:Lib/MassStoreCommands.c **** 
 209:Lib/MassStoreCommands.c **** 		/* Acknowledge the packet */
 210:Lib/MassStoreCommands.c **** 		Pipe_ClearIN();
 211:Lib/MassStoreCommands.c **** 	}
 212:Lib/MassStoreCommands.c **** 	else
 213:Lib/MassStoreCommands.c **** 	{
 214:Lib/MassStoreCommands.c **** 		/* Select the OUT data pipe for data transmission */
 215:Lib/MassStoreCommands.c **** 		Pipe_SelectPipe(MASS_STORE_DATA_OUT_PIPE);
 216:Lib/MassStoreCommands.c **** 		Pipe_Unfreeze();
 217:Lib/MassStoreCommands.c **** 
 218:Lib/MassStoreCommands.c **** 		/* Write the block data to the pipe */
 219:Lib/MassStoreCommands.c **** 		if ((ErrorCode = Pipe_Write_Stream_LE(BufferPtr, BytesRem, NULL)) != PIPE_RWSTREAM_NoError)
 220:Lib/MassStoreCommands.c **** 		  return ErrorCode;
 221:Lib/MassStoreCommands.c **** 
 222:Lib/MassStoreCommands.c **** 		/* Acknowledge the packet */
 223:Lib/MassStoreCommands.c **** 		Pipe_ClearOUT();
 224:Lib/MassStoreCommands.c **** 
 225:Lib/MassStoreCommands.c **** 		while (!(Pipe_IsOUTReady()))
 226:Lib/MassStoreCommands.c **** 		{
 227:Lib/MassStoreCommands.c **** 			if (USB_HostState == HOST_STATE_Unattached)
 228:Lib/MassStoreCommands.c **** 			  return PIPE_RWSTREAM_DeviceDisconnected;
 229:Lib/MassStoreCommands.c **** 		}
 230:Lib/MassStoreCommands.c **** 	}
 231:Lib/MassStoreCommands.c **** 
 232:Lib/MassStoreCommands.c **** 	/* Freeze used pipe after use */
 233:Lib/MassStoreCommands.c **** 	Pipe_Freeze();
 234:Lib/MassStoreCommands.c **** 
 235:Lib/MassStoreCommands.c **** 	return PIPE_RWSTREAM_NoError;
 236:Lib/MassStoreCommands.c **** }
 237:Lib/MassStoreCommands.c **** 
 238:Lib/MassStoreCommands.c **** /** Routine to receive the current CSW from the device.
 239:Lib/MassStoreCommands.c ****  *
 240:Lib/MassStoreCommands.c ****  *  \param[out] SCSICommandStatus  Pointer to a destination where the returned status data should b
 241:Lib/MassStoreCommands.c ****  *
 242:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if
 243:Lib/MassStoreCommands.c ****  */
 244:Lib/MassStoreCommands.c **** static uint8_t MassStore_GetReturnedStatus(MS_CommandStatusWrapper_t* const SCSICommandStatus)
 245:Lib/MassStoreCommands.c **** {
 270               		.loc 1 245 0
 271               		.cfi_startproc
 272               	.LVL24:
 273 0000 CF93      		push r28
 274               	.LCFI0:
 275               		.cfi_def_cfa_offset 3
 276               		.cfi_offset 28, -2
 277 0002 DF93      		push r29
 278               	.LCFI1:
 279               		.cfi_def_cfa_offset 4
 280               		.cfi_offset 29, -3
 281               	/* prologue: function */
 282               	/* frame size = 0 */
 283               	/* stack size = 2 */
 284               	.L__stack_usage = 2
 285 0004 EC01      		movw r28,r24
 286               	.LVL25:
 246:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
 247:Lib/MassStoreCommands.c **** 
 248:Lib/MassStoreCommands.c **** 	/* If an error in the command occurred, abort */
 249:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_WaitForDataReceived()) != PIPE_RWSTREAM_NoError)
 287               		.loc 1 249 0
 288 0006 0E94 0000 		call MassStore_WaitForDataReceived
 289               	.LVL26:
 290 000a 8111      		cpse r24,__zero_reg__
 291 000c 00C0      		rjmp .L20
 292               	.LVL27:
 293               	.LBB184:
 294               	.LBB185:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 295               		.loc 3 228 0
 296 000e 81E0      		ldi r24,lo8(1)
 297               	.LVL28:
 298 0010 8093 A700 		sts 167,r24
 299               	.LVL29:
 300               	.LBE185:
 301               	.LBE184:
 302               	.LBB186:
 303               	.LBB187:
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 304               		.loc 3 374 0
 305 0014 8091 A900 		lds r24,169
 306 0018 8F7B      		andi r24,lo8(-65)
 307 001a 8093 A900 		sts 169,r24
 308               	.LBE187:
 309               	.LBE186:
 250:Lib/MassStoreCommands.c **** 	  return ErrorCode;
 251:Lib/MassStoreCommands.c **** 
 252:Lib/MassStoreCommands.c **** 	/* Select the IN data pipe for data reception */
 253:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(MASS_STORE_DATA_IN_PIPE);
 254:Lib/MassStoreCommands.c **** 	Pipe_Unfreeze();
 255:Lib/MassStoreCommands.c **** 
 256:Lib/MassStoreCommands.c **** 	/* Load in the CSW from the attached device */
 257:Lib/MassStoreCommands.c **** 	if ((ErrorCode = Pipe_Read_Stream_LE(SCSICommandStatus, sizeof(MS_CommandStatusWrapper_t), NULL)) 
 310               		.loc 1 257 0
 311 001e 40E0      		ldi r20,0
 312 0020 50E0      		ldi r21,0
 313 0022 6DE0      		ldi r22,lo8(13)
 314 0024 70E0      		ldi r23,0
 315 0026 CE01      		movw r24,r28
 316 0028 0E94 0000 		call Pipe_Read_Stream_LE
 317               	.LVL30:
 318 002c 8111      		cpse r24,__zero_reg__
 319 002e 00C0      		rjmp .L20
 320               	.LBB188:
 321               	.LBB189:
 517:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 322               		.loc 3 517 0
 323 0030 8091 A600 		lds r24,166
 324               	.LVL31:
 325 0034 8E77      		andi r24,lo8(126)
 326 0036 8093 A600 		sts 166,r24
 327               	.LBE189:
 328               	.LBE188:
 329               	.LBB190:
 330               	.LBB191:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 331               		.loc 3 381 0
 332 003a 8091 A900 		lds r24,169
 333 003e 8064      		ori r24,lo8(64)
 334 0040 8093 A900 		sts 169,r24
 335               	.LBE191:
 336               	.LBE190:
 258:Lib/MassStoreCommands.c **** 	                                     PIPE_RWSTREAM_NoError)
 259:Lib/MassStoreCommands.c **** 	{
 260:Lib/MassStoreCommands.c **** 		return ErrorCode;
 261:Lib/MassStoreCommands.c **** 	}
 262:Lib/MassStoreCommands.c **** 	
 263:Lib/MassStoreCommands.c **** 	/* Clear the data ready for next reception */
 264:Lib/MassStoreCommands.c **** 	Pipe_ClearIN();
 265:Lib/MassStoreCommands.c **** 
 266:Lib/MassStoreCommands.c **** 	/* Freeze the IN pipe after use */
 267:Lib/MassStoreCommands.c **** 	Pipe_Freeze();
 268:Lib/MassStoreCommands.c **** 
 269:Lib/MassStoreCommands.c **** 	/* Check to see if command failed */
 270:Lib/MassStoreCommands.c **** 	if (SCSICommandStatus->Status != MS_SCSI_COMMAND_Pass)
 337               		.loc 1 270 0
 338 0044 8C85      		ldd r24,Y+12
 339 0046 8111      		cpse r24,__zero_reg__
 271:Lib/MassStoreCommands.c **** 	  ErrorCode = MASS_STORE_SCSI_COMMAND_FAILED;
 340               		.loc 1 271 0
 341 0048 80EC      		ldi r24,lo8(-64)
 342               	.L20:
 343               	/* epilogue start */
 272:Lib/MassStoreCommands.c **** 
 273:Lib/MassStoreCommands.c **** 	return ErrorCode;
 274:Lib/MassStoreCommands.c **** }
 344               		.loc 1 274 0
 345 004a DF91      		pop r29
 346 004c CF91      		pop r28
 347               	.LVL32:
 348 004e 0895      		ret
 349               		.cfi_endproc
 350               	.LFE152:
 352               		.section	.text.SwapEndian_32,"ax",@progbits
 354               	SwapEndian_32:
 355               	.LFB14:
 356               		.file 4 "../../../../LUFA/Drivers/USB/../../Common/Endianness.h"
   1:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** /*
   2:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****              LUFA Library
   3:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
   5:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** */
   8:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
   9:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** /*
  10:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  12:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  21:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****   this software.
  29:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** */
  30:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  31:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** /** \file
  32:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  \brief Endianness and Byte Ordering macros and functions.
  33:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *
  34:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  \copydetails Group_Endianness
  35:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  */
  36:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  37:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** /** \ingroup Group_Endianness
  38:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  \defgroup Group_ByteSwapping Byte Reordering
  39:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  \brief Macros and functions for forced byte reordering.
  40:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  */
  41:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  42:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** /** \ingroup Group_Endianness
  43:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  \defgroup Group_EndianConversion Endianness Conversion
  44:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  \brief Macros and functions for automatic endianness conversion.
  45:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  */
  46:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  47:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** /** \ingroup Group_Common
  48:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  \defgroup Group_Endianness Endianness and Byte Ordering
  49:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  \brief Convenience macros and functions relating to byte (re-)ordering
  50:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *
  51:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  Common library convenience macros and functions relating to byte (re-)ordering.
  52:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *
  53:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  *  @{
  54:../../../../LUFA/Drivers/USB/../../Common/Endianness.h ****  */
  55:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  56:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** #ifndef __LUFA_ENDIANNESS_H__
  57:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** #define __LUFA_ENDIANNESS_H__
  58:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  59:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 	/* Enable C linkage for C++ Compilers: */
  60:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		#if defined(__cplusplus)
  61:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			extern "C" {
  62:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		#endif
  63:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  64:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 	/* Preprocessor Checks: */
  65:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		#if !defined(__INCLUDE_FROM_COMMON_H)
  66:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			#error Do not include this file directly. Include LUFA/Common/Common.h instead to gain this func
  67:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		#endif
  68:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		
  69:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		#if !(defined(ARCH_BIG_ENDIAN) || defined(ARCH_LITTLE_ENDIAN))
  70:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			#error ARCH_BIG_ENDIAN or ARCH_LITTLE_ENDIAN not set for the specified architecture.
  71:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		#endif
  72:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  73:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 	/* Public Interface - May be used in end-application: */
  74:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		/* Macros: */
  75:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			/** Swaps the byte ordering of a 16-bit value at compile-time. Do not use this macro for swappin
  76:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  of dynamic values computed at runtime, use \ref SwapEndian_16() instead. The result of this 
  77:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  inside struct or other variable initializers outside of a function, something that is not po
  78:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  inline function variant.
  79:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
  80:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
  81:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
  82:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \param[in] x  16-bit value whose byte ordering is to be swapped.
  83:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
  84:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \return Input value with the byte ordering reversed.
  85:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 */
  86:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			#define SWAPENDIAN_16(x)            (uint16_t)((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))
  87:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
  88:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			/** Swaps the byte ordering of a 32-bit value at compile-time. Do not use this macro for swappin
  89:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  of dynamic values computed at runtime- use \ref SwapEndian_32() instead. The result of this 
  90:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  inside struct or other variable initializers outside of a function, something that is not po
  91:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  inline function variant.
  92:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
  93:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
  94:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
  95:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \param[in] x  32-bit value whose byte ordering is to be swapped.
  96:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
  97:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \return Input value with the byte ordering reversed.
  98:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 */
  99:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			#define SWAPENDIAN_32(x)            (uint32_t)((((x) & 0xFF000000UL) >> 24UL) | (((x) & 0x00FF00
 100:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			                                               (((x) & 0x0000FF00UL) << 8UL)  | (((x) & 0x000000
 101:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 102:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			#if defined(ARCH_BIG_ENDIAN) && !defined(le16_to_cpu)
 103:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define le16_to_cpu(x)           SwapEndian_16(x)
 104:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define le32_to_cpu(x)           SwapEndian_32(x)
 105:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define be16_to_cpu(x)           (x)
 106:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define be32_to_cpu(x)           (x)
 107:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define cpu_to_le16(x)           SwapEndian_16(x)
 108:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define cpu_to_le32(x)           SwapEndian_32(x)
 109:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define cpu_to_be16(x)           (x)
 110:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define cpu_to_be32(x)           (x)
 111:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define LE16_TO_CPU(x)           SWAPENDIAN_16(x)
 112:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define LE32_TO_CPU(x)           SWAPENDIAN_32(x)
 113:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define BE16_TO_CPU(x)           (x)
 114:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define BE32_TO_CPU(x)           (x)
 115:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define CPU_TO_LE16(x)           SWAPENDIAN_16(x)
 116:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define CPU_TO_LE32(x)           SWAPENDIAN_32(x)
 117:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define CPU_TO_BE16(x)           (x)
 118:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define CPU_TO_BE32(x)           (x)			
 119:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			#elif !defined(le16_to_cpu)
 120:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** \name Run-time endianness conversion */
 121:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				//@{
 122:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			
 123:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 16-bit piece of data and the
 124:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 125:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 126:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 127:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 128:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 129:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref LE16_TO_CPU instead.
 130:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 131:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 132:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 133:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 134:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 135:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 136:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 137:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define le16_to_cpu(x)           (x)
 138:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 139:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 32-bit piece of data and the
 140:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 141:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 142:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 143:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 144:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 145:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref LE32_TO_CPU instead.
 146:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 147:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 148:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 149:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 150:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 151:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 152:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 153:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define le32_to_cpu(x)           (x)
 154:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 155:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 16-bit piece of data and the
 156:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 157:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 158:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 159:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 160:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 161:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref BE16_TO_CPU instead.
 162:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 163:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 164:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 165:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 166:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 167:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 168:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 169:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define be16_to_cpu(x)           SwapEndian_16(x)
 170:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 171:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 32-bit piece of data and the
 172:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 173:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 174:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 175:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 176:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 177:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref BE32_TO_CPU instead.
 178:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 179:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 180:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 181:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 182:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 183:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 184:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 185:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define be32_to_cpu(x)           SwapEndian_32(x)
 186:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 187:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 188:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 189:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 190:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 191:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 192:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 193:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_LE16 instead.
 194:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 195:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 196:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 197:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 198:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 199:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 200:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 201:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define cpu_to_le16(x)           (x)
 202:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 203:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 204:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 205:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 206:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 207:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 208:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 209:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_LE32 instead.
 210:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 211:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 212:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 213:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 214:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 215:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 216:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 217:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define cpu_to_le32(x)           (x)
 218:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 219:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 220:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 221:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 222:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 223:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 224:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 225:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_BE16 instead.
 226:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 227:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 228:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 229:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 230:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 231:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 232:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 233:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define cpu_to_be16(x)           SwapEndian_16(x)
 234:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 235:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 236:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 237:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 238:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 239:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 240:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 241:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_BE32 instead.
 242:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 243:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 244:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 245:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 246:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 247:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 248:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 249:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define cpu_to_be32(x)           SwapEndian_32(x)
 250:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 251:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				//@}
 252:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 253:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** \name Compile-time endianness conversion */
 254:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				//@{
 255:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 256:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 16-bit piece of data and the
 257:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 258:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 259:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 260:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 261:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run time endianness
 262:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref le16_to_cpu instead.
 263:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 264:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 265:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 266:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 267:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 268:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 269:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 270:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define LE16_TO_CPU(x)           (x)
 271:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 272:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 32-bit piece of data and the
 273:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 274:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 275:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 276:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 277:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run time endianness
 278:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref le32_to_cpu instead.
 279:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 280:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 281:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 282:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 283:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 284:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 285:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 286:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define LE32_TO_CPU(x)           (x)
 287:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 288:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 16-bit piece of data and the
 289:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 290:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 291:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 292:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 293:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 294:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref be16_to_cpu instead.
 295:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 296:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 297:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 298:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 299:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 300:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 301:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 302:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define BE16_TO_CPU(x)           SWAPENDIAN_16(x)
 303:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 304:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 32-bit piece of data and the
 305:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 306:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 307:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 308:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 309:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 310:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref be32_to_cpu instead.
 311:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 312:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 313:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 314:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 315:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 316:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 317:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 318:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define BE32_TO_CPU(x)           SWAPENDIAN_32(x)
 319:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 320:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 321:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 322:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 323:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 324:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 325:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 326:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_le16 instead.
 327:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 328:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 329:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 330:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 331:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 332:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 333:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 334:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define CPU_TO_LE16(x)           (x)
 335:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 336:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 337:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 338:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 339:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 340:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 341:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 342:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_le32 instead.
 343:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 344:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 345:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 346:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 347:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 348:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 349:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 350:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define CPU_TO_LE32(x)           (x)
 351:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 352:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 353:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 354:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 355:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 356:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 357:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 358:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_be16 instead.
 359:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 360:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 361:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 362:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 363:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 364:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 365:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 366:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define CPU_TO_BE16(x)           SWAPENDIAN_16(x)
 367:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 368:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 369:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 370:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 371:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 372:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 373:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 374:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_be32 instead.
 375:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 376:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 377:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 378:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 379:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *
 380:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 381:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				 */
 382:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				#define CPU_TO_BE32(x)           SWAPENDIAN_32(x)
 383:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 384:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				//! @}
 385:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			#endif
 386:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 387:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 		/* Inline Functions: */
 388:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			/** Function to reverse the byte ordering of the individual bytes in a 16 bit value.
 389:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
 390:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
 391:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
 392:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \param[in] Word  Word of data whose bytes are to be swapped.
 393:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
 394:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \return Input data with the individual bytes reversed.
 395:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 */
 396:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
 397:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			static inline uint16_t SwapEndian_16(const uint16_t Word)
 398:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			{
 399:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				if (GCC_IS_COMPILE_CONST(Word))
 400:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				  return SWAPENDIAN_16(Word);
 401:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			
 402:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				uint8_t Temp;
 403:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 404:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				union
 405:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				{
 406:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 					uint16_t Word;
 407:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 					uint8_t  Bytes[2];
 408:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				} Data;
 409:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 410:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Data.Word = Word;
 411:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 412:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Temp = Data.Bytes[0];
 413:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Data.Bytes[0] = Data.Bytes[1];
 414:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Data.Bytes[1] = Temp;
 415:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 416:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				return Data.Word;
 417:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			}
 418:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 419:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			/** Function to reverse the byte ordering of the individual bytes in a 32 bit value.
 420:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
 421:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
 422:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
 423:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \param[in] DWord  Double word of data whose bytes are to be swapped.
 424:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *
 425:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 *  \return Input data with the individual bytes reversed.
 426:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			 */
 427:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
 428:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			static inline uint32_t SwapEndian_32(const uint32_t DWord)
 429:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			{
 357               		.loc 4 429 0
 358               		.cfi_startproc
 359               	.LVL33:
 360               	/* prologue: function */
 361               	/* frame size = 0 */
 362               	/* stack size = 0 */
 363               	.L__stack_usage = 0
 364 0000 9B01      		movw r18,r22
 430:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				if (GCC_IS_COMPILE_CONST(DWord))
 431:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				  return SWAPENDIAN_32(DWord);
 432:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 433:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				uint8_t Temp;
 434:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 435:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				union
 436:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				{
 437:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 					uint32_t DWord;
 438:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 					uint8_t  Bytes[4];
 439:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				} Data;
 440:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 441:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Data.DWord = DWord;
 442:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 443:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Temp = Data.Bytes[0];
 444:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Data.Bytes[0] = Data.Bytes[3];
 445:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Data.Bytes[3] = Temp;
 446:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 447:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Temp = Data.Bytes[1];
 448:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Data.Bytes[1] = Data.Bytes[2];
 449:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				Data.Bytes[2] = Temp;
 450:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 
 451:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 				return Data.DWord;
 452:../../../../LUFA/Drivers/USB/../../Common/Endianness.h **** 			}
 365               		.loc 4 452 0
 366 0002 692F      		mov r22,r25
 367               	.LVL34:
 368 0004 782F      		mov r23,r24
 369 0006 832F      		mov r24,r19
 370 0008 922F      		mov r25,r18
 371 000a 0895      		ret
 372               		.cfi_endproc
 373               	.LFE14:
 375               		.section	.text.MassStore_SendCommand.constprop.1,"ax",@progbits
 377               	MassStore_SendCommand.constprop.1:
 378               	.LFB163:
  66:Lib/MassStoreCommands.c ****                                      void* BufferPtr)
 379               		.loc 1 66 0
 380               		.cfi_startproc
 381               	.LVL35:
 382 0000 CF92      		push r12
 383               	.LCFI2:
 384               		.cfi_def_cfa_offset 3
 385               		.cfi_offset 12, -2
 386 0002 DF92      		push r13
 387               	.LCFI3:
 388               		.cfi_def_cfa_offset 4
 389               		.cfi_offset 13, -3
 390 0004 EF92      		push r14
 391               	.LCFI4:
 392               		.cfi_def_cfa_offset 5
 393               		.cfi_offset 14, -4
 394 0006 FF92      		push r15
 395               	.LCFI5:
 396               		.cfi_def_cfa_offset 6
 397               		.cfi_offset 15, -5
 398 0008 0F93      		push r16
 399               	.LCFI6:
 400               		.cfi_def_cfa_offset 7
 401               		.cfi_offset 16, -6
 402 000a 1F93      		push r17
 403               	.LCFI7:
 404               		.cfi_def_cfa_offset 8
 405               		.cfi_offset 17, -7
 406 000c CF93      		push r28
 407               	.LCFI8:
 408               		.cfi_def_cfa_offset 9
 409               		.cfi_offset 28, -8
 410 000e DF93      		push r29
 411               	.LCFI9:
 412               		.cfi_def_cfa_offset 10
 413               		.cfi_offset 29, -9
 414               	/* prologue: function */
 415               	/* frame size = 0 */
 416               	/* stack size = 8 */
 417               	.L__stack_usage = 8
 418 0010 EC01      		movw r28,r24
 419 0012 8B01      		movw r16,r22
 420               	.LVL36:
  72:Lib/MassStoreCommands.c **** 	  MassStore_Tag = 1;
 421               		.loc 1 72 0
 422 0014 8091 0000 		lds r24,MassStore_Tag
 423 0018 9091 0000 		lds r25,MassStore_Tag+1
 424 001c A091 0000 		lds r26,MassStore_Tag+2
 425 0020 B091 0000 		lds r27,MassStore_Tag+3
 426               	.LVL37:
 427 0024 0196      		adiw r24,1
 428 0026 A11D      		adc r26,__zero_reg__
 429 0028 B11D      		adc r27,__zero_reg__
 430 002a 8F3F      		cpi r24,-1
 431 002c 2FEF      		ldi r18,-1
 432 002e 9207      		cpc r25,r18
 433 0030 A207      		cpc r26,r18
 434 0032 B207      		cpc r27,r18
 435 0034 01F4      		brne .L41
  73:Lib/MassStoreCommands.c **** 
 436               		.loc 1 73 0
 437 0036 81E0      		ldi r24,lo8(1)
 438 0038 90E0      		ldi r25,0
 439 003a A0E0      		ldi r26,0
 440 003c B0E0      		ldi r27,0
 441               	.L41:
 442 003e 8093 0000 		sts MassStore_Tag,r24
 443 0042 9093 0000 		sts MassStore_Tag+1,r25
 444 0046 A093 0000 		sts MassStore_Tag+2,r26
 445 004a B093 0000 		sts MassStore_Tag+3,r27
  76:Lib/MassStoreCommands.c **** 
 446               		.loc 1 76 0
 447 004e 8091 0000 		lds r24,MassStore_Tag
 448 0052 9091 0000 		lds r25,MassStore_Tag+1
 449 0056 A091 0000 		lds r26,MassStore_Tag+2
 450 005a B091 0000 		lds r27,MassStore_Tag+3
 451 005e 8C83      		std Y+4,r24
 452 0060 9D83      		std Y+5,r25
 453 0062 AE83      		std Y+6,r26
 454 0064 BF83      		std Y+7,r27
 455               	.LVL38:
 456               	.LBB222:
 457               	.LBB223:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 458               		.loc 3 228 0
 459 0066 82E0      		ldi r24,lo8(2)
 460 0068 E82E      		mov r14,r24
 461 006a E092 A700 		sts 167,r14
 462               	.LVL39:
 463               	.LBE223:
 464               	.LBE222:
 465               	.LBB224:
 466               	.LBB225:
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 467               		.loc 3 374 0
 468 006e 8091 A900 		lds r24,169
 469 0072 8F7B      		andi r24,lo8(-65)
 470 0074 8093 A900 		sts 169,r24
 471               	.LBE225:
 472               	.LBE224:
  83:Lib/MassStoreCommands.c **** 	                                      PIPE_RWSTREAM_NoError)
 473               		.loc 1 83 0
 474 0078 40E0      		ldi r20,0
 475 007a 50E0      		ldi r21,0
 476 007c 6FE1      		ldi r22,lo8(31)
 477 007e 70E0      		ldi r23,0
 478               	.LVL40:
 479 0080 CE01      		movw r24,r28
 480 0082 0E94 0000 		call Pipe_Write_Stream_LE
 481               	.LVL41:
 482 0086 F82E      		mov r15,r24
 483               	.LVL42:
 484 0088 8111      		cpse r24,__zero_reg__
 485 008a 00C0      		rjmp .L38
 486               	.LBB226:
 487               	.LBB227:
 528:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 488               		.loc 3 528 0
 489 008c 8091 A600 		lds r24,166
 490 0090 8B77      		andi r24,lo8(123)
 491 0092 8093 A600 		sts 166,r24
 492               	.LBE227:
 493               	.LBE226:
  93:Lib/MassStoreCommands.c **** 
 494               		.loc 1 93 0
 495 0096 0E94 0000 		call Pipe_WaitUntilReady
 496               	.LVL43:
 497               	.LBB228:
 498               	.LBB229:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 499               		.loc 3 381 0
 500 009a 8091 A900 		lds r24,169
 501 009e 8064      		ori r24,lo8(64)
 502 00a0 8093 A900 		sts 169,r24
 503               	.LBE229:
 504               	.LBE228:
  99:Lib/MassStoreCommands.c **** 	    ((ErrorCode = MassStore_SendReceiveData(SCSICommandBlock, BufferPtr)) != PIPE_READYWAIT_NoErro
 505               		.loc 1 99 0
 506 00a4 0115      		cp r16,__zero_reg__
 507 00a6 1105      		cpc r17,__zero_reg__
 508 00a8 01F4      		brne .+2
 509 00aa 00C0      		rjmp .L38
 510               	.LVL44:
 511               	.LBB230:
 512               	.LBB231:
 192:Lib/MassStoreCommands.c **** 
 513               		.loc 1 192 0
 514 00ac C884      		ldd r12,Y+8
 515 00ae D984      		ldd r13,Y+9
 516               	.LVL45:
 195:Lib/MassStoreCommands.c **** 	{
 517               		.loc 1 195 0
 518 00b0 8C85      		ldd r24,Y+12
 519 00b2 87FF      		sbrs r24,7
 520 00b4 00C0      		rjmp .L31
 198:Lib/MassStoreCommands.c **** 		  return ErrorCode;
 521               		.loc 1 198 0
 522 00b6 0E94 0000 		call MassStore_WaitForDataReceived
 523               	.LVL46:
 524 00ba 8111      		cpse r24,__zero_reg__
 525 00bc 00C0      		rjmp .L32
 526               	.LVL47:
 527               	.LBB232:
 528               	.LBB233:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 529               		.loc 3 228 0
 530 00be 81E0      		ldi r24,lo8(1)
 531               	.LVL48:
 532 00c0 8093 A700 		sts 167,r24
 533               	.LVL49:
 534               	.LBE233:
 535               	.LBE232:
 536               	.LBB234:
 537               	.LBB235:
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 538               		.loc 3 374 0
 539 00c4 8091 A900 		lds r24,169
 540 00c8 8F7B      		andi r24,lo8(-65)
 541 00ca 8093 A900 		sts 169,r24
 542               	.LBE235:
 543               	.LBE234:
 206:Lib/MassStoreCommands.c **** 		  return ErrorCode;
 544               		.loc 1 206 0
 545 00ce 40E0      		ldi r20,0
 546 00d0 50E0      		ldi r21,0
 547 00d2 B601      		movw r22,r12
 548 00d4 C801      		movw r24,r16
 549 00d6 0E94 0000 		call Pipe_Read_Stream_LE
 550               	.LVL50:
 551 00da 8111      		cpse r24,__zero_reg__
 552 00dc 00C0      		rjmp .L32
 553               	.LBB236:
 554               	.LBB237:
 517:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 555               		.loc 3 517 0
 556 00de 8091 A600 		lds r24,166
 557               	.LVL51:
 558 00e2 8E77      		andi r24,lo8(126)
 559 00e4 8093 A600 		sts 166,r24
 560 00e8 00C0      		rjmp .L33
 561               	.LVL52:
 562               	.L31:
 563               	.LBE237:
 564               	.LBE236:
 565               	.LBB238:
 566               	.LBB239:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 567               		.loc 3 228 0
 568 00ea E092 A700 		sts 167,r14
 569               	.LVL53:
 570               	.LBE239:
 571               	.LBE238:
 572               	.LBB240:
 573               	.LBB241:
 374:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 574               		.loc 3 374 0
 575 00ee 8091 A900 		lds r24,169
 576 00f2 8F7B      		andi r24,lo8(-65)
 577 00f4 8093 A900 		sts 169,r24
 578               	.LBE241:
 579               	.LBE240:
 219:Lib/MassStoreCommands.c **** 		  return ErrorCode;
 580               		.loc 1 219 0
 581 00f8 40E0      		ldi r20,0
 582 00fa 50E0      		ldi r21,0
 583 00fc B601      		movw r22,r12
 584 00fe C801      		movw r24,r16
 585 0100 0E94 0000 		call Pipe_Write_Stream_LE
 586               	.LVL54:
 587 0104 8111      		cpse r24,__zero_reg__
 588 0106 00C0      		rjmp .L32
 589               	.LBB242:
 590               	.LBB243:
 528:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 591               		.loc 3 528 0
 592 0108 8091 A600 		lds r24,166
 593               	.LVL55:
 594 010c 8B77      		andi r24,lo8(123)
 595 010e 8093 A600 		sts 166,r24
 596               	.L34:
 597               	.LBE243:
 598               	.LBE242:
 599               	.LBB244:
 600               	.LBB245:
 483:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 601               		.loc 3 483 0
 602 0112 8091 A600 		lds r24,166
 603               	.LBE245:
 604               	.LBE244:
 225:Lib/MassStoreCommands.c **** 		{
 605               		.loc 1 225 0
 606 0116 82FD      		sbrc r24,2
 607 0118 00C0      		rjmp .L33
 227:Lib/MassStoreCommands.c **** 			  return PIPE_RWSTREAM_DeviceDisconnected;
 608               		.loc 1 227 0
 609 011a 8091 0000 		lds r24,USB_HostState
 610 011e 8130      		cpi r24,lo8(1)
 611 0120 01F4      		brne .L34
 228:Lib/MassStoreCommands.c **** 		}
 612               		.loc 1 228 0
 613 0122 82E0      		ldi r24,lo8(2)
 614 0124 00C0      		rjmp .L32
 615               	.L33:
 616               	.LBB246:
 617               	.LBB247:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 618               		.loc 3 381 0
 619 0126 8091 A900 		lds r24,169
 620 012a 8064      		ori r24,lo8(64)
 621 012c 8093 A900 		sts 169,r24
 622               	.LVL56:
 623 0130 00C0      		rjmp .L38
 624               	.LVL57:
 625               	.L32:
 626               	.LBE247:
 627               	.LBE246:
 628               	.LBE231:
 629               	.LBE230:
 630               	.LBB248:
 631               	.LBB249:
 632 0132 9091 A900 		lds r25,169
 633 0136 9064      		ori r25,lo8(64)
 634 0138 9093 A900 		sts 169,r25
 635 013c F82E      		mov r15,r24
 636               	.L38:
 637               	.LBE249:
 638               	.LBE248:
 107:Lib/MassStoreCommands.c **** 
 639               		.loc 1 107 0
 640 013e 8F2D      		mov r24,r15
 641               	/* epilogue start */
 642 0140 DF91      		pop r29
 643 0142 CF91      		pop r28
 644               	.LVL58:
 645 0144 1F91      		pop r17
 646 0146 0F91      		pop r16
 647               	.LVL59:
 648 0148 FF90      		pop r15
 649 014a EF90      		pop r14
 650 014c DF90      		pop r13
 651 014e CF90      		pop r12
 652 0150 0895      		ret
 653               		.cfi_endproc
 654               	.LFE163:
 656               		.section	.rodata
 657               	.LC0:
 658 0000 21        		.byte	33
 659 0001 FF        		.byte	-1
 660 0002 0000      		.word	0
 661 0004 0000      		.word	0
 662 0006 0000      		.word	0
 663               		.section	.text.MassStore_MassStorageReset,"ax",@progbits
 664               	.global	MassStore_MassStorageReset
 666               	MassStore_MassStorageReset:
 667               	.LFB153:
 275:Lib/MassStoreCommands.c **** 
 276:Lib/MassStoreCommands.c **** /** Issues a Mass Storage class specific request to reset the attached device's Mass Storage interf
 277:Lib/MassStoreCommands.c ****  *  readying the device for the next CBW. The Data endpoints are cleared of any STALL condition onc
 278:Lib/MassStoreCommands.c ****  *  command completes sucessfuly.
 279:Lib/MassStoreCommands.c ****  *
 280:Lib/MassStoreCommands.c ****  *  \return A value from the USB_Host_SendControlErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAIL
 281:Lib/MassStoreCommands.c ****  */
 282:Lib/MassStoreCommands.c **** uint8_t MassStore_MassStorageReset(void)
 283:Lib/MassStoreCommands.c **** {
 668               		.loc 1 283 0
 669               		.cfi_startproc
 670               	/* prologue: function */
 671               	/* frame size = 0 */
 672               	/* stack size = 0 */
 673               	.L__stack_usage = 0
 284:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode;
 285:Lib/MassStoreCommands.c **** 
 286:Lib/MassStoreCommands.c **** 	USB_ControlRequest = (USB_Request_Header_t)
 674               		.loc 1 286 0
 675 0000 88E0      		ldi r24,lo8(8)
 676 0002 E0E0      		ldi r30,lo8(.LC0)
 677 0004 F0E0      		ldi r31,hi8(.LC0)
 678 0006 A0E0      		ldi r26,lo8(USB_ControlRequest)
 679 0008 B0E0      		ldi r27,hi8(USB_ControlRequest)
 680               		0:
 681 000a 0190      		ld r0,Z+
 682 000c 0D92      		st X+,r0
 683 000e 8A95      		dec r24
 684 0010 01F4      		brne 0b
 685               	.LVL60:
 686               	.LBB250:
 687               	.LBB251:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 688               		.loc 3 228 0
 689 0012 1092 A700 		sts 167,__zero_reg__
 690               	.LVL61:
 691               	.LBE251:
 692               	.LBE250:
 287:Lib/MassStoreCommands.c **** 		{
 288:Lib/MassStoreCommands.c **** 			.bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
 289:Lib/MassStoreCommands.c **** 			.bRequest      = MS_REQ_MassStorageReset,
 290:Lib/MassStoreCommands.c **** 			.wValue        = 0,
 291:Lib/MassStoreCommands.c **** 			.wIndex        = 0,
 292:Lib/MassStoreCommands.c **** 			.wLength       = 0,
 293:Lib/MassStoreCommands.c **** 		};
 294:Lib/MassStoreCommands.c **** 
 295:Lib/MassStoreCommands.c **** 	/* Select the control pipe for the request transfer */
 296:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(PIPE_CONTROLPIPE);
 297:Lib/MassStoreCommands.c **** 	
 298:Lib/MassStoreCommands.c **** 	if ((ErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
 693               		.loc 1 298 0
 694 0016 80E0      		ldi r24,0
 695 0018 90E0      		ldi r25,0
 696 001a 0E94 0000 		call USB_Host_SendControlRequest
 697               	.LVL62:
 698 001e 8111      		cpse r24,__zero_reg__
 699 0020 00C0      		rjmp .L43
 700               	.LVL63:
 701               	.LBB252:
 702               	.LBB253:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 703               		.loc 3 228 0
 704 0022 81E0      		ldi r24,lo8(1)
 705               	.LVL64:
 706 0024 8093 A700 		sts 167,r24
 707               	.LVL65:
 708               	.LBE253:
 709               	.LBE252:
 710               	.LBB254:
 711               	.LBB255:
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 712               		.loc 3 332 0
 713 0028 8091 AA00 		lds r24,170
 714 002c 8F70      		andi r24,lo8(15)
 715               	.LBB256:
 716               	.LBB257:
 279:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 717               		.loc 3 279 0
 718 002e 9091 AA00 		lds r25,170
 719               	.LBE257:
 720               	.LBE256:
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 721               		.loc 3 332 0
 722 0032 9073      		andi r25,lo8(48)
 723 0034 9031      		cpi r25,lo8(16)
 724 0036 01F0      		breq .L47
 725 0038 90E0      		ldi r25,0
 726 003a 00C0      		rjmp .L44
 727               	.L47:
 728 003c 90E8      		ldi r25,lo8(-128)
 729               	.L44:
 730               	.LBE255:
 731               	.LBE254:
 299:Lib/MassStoreCommands.c **** 	  return ErrorCode;
 300:Lib/MassStoreCommands.c **** 	
 301:Lib/MassStoreCommands.c **** 	/* Select first data pipe to clear STALL condition if one exists */
 302:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(MASS_STORE_DATA_IN_PIPE);
 303:Lib/MassStoreCommands.c **** 	
 304:Lib/MassStoreCommands.c **** 	if ((ErrorCode = USB_Host_ClearEndpointStall(Pipe_GetBoundEndpointAddress())) != HOST_SENDCONTROL_
 732               		.loc 1 304 0
 733 003e 892B      		or r24,r25
 734 0040 0E94 0000 		call USB_Host_ClearEndpointStall
 735               	.LVL66:
 736 0044 8111      		cpse r24,__zero_reg__
 737 0046 00C0      		rjmp .L43
 738               	.LVL67:
 739               	.LBB258:
 740               	.LBB259:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 741               		.loc 3 228 0
 742 0048 82E0      		ldi r24,lo8(2)
 743               	.LVL68:
 744 004a 8093 A700 		sts 167,r24
 745               	.LVL69:
 746               	.LBE259:
 747               	.LBE258:
 748               	.LBB260:
 749               	.LBB261:
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 750               		.loc 3 332 0
 751 004e 8091 AA00 		lds r24,170
 752 0052 8F70      		andi r24,lo8(15)
 753               	.LBB262:
 754               	.LBB263:
 279:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 755               		.loc 3 279 0
 756 0054 9091 AA00 		lds r25,170
 757               	.LBE263:
 758               	.LBE262:
 332:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				        ((Pipe_GetPipeToken() == PIPE_TOKEN_IN) ? PIPE_EPDIR_MASK : 0));
 759               		.loc 3 332 0
 760 0058 9073      		andi r25,lo8(48)
 761 005a 9031      		cpi r25,lo8(16)
 762 005c 01F0      		breq .L49
 763 005e 90E0      		ldi r25,0
 764 0060 00C0      		rjmp .L45
 765               	.L49:
 766 0062 90E8      		ldi r25,lo8(-128)
 767               	.L45:
 768               	.LBE261:
 769               	.LBE260:
 305:Lib/MassStoreCommands.c **** 	  return ErrorCode;
 306:Lib/MassStoreCommands.c **** 
 307:Lib/MassStoreCommands.c **** 	/* Select second data pipe to clear STALL condition if one exists */
 308:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(MASS_STORE_DATA_OUT_PIPE);
 309:Lib/MassStoreCommands.c **** 
 310:Lib/MassStoreCommands.c **** 	if ((ErrorCode = USB_Host_ClearEndpointStall(Pipe_GetBoundEndpointAddress())) != HOST_SENDCONTROL_
 770               		.loc 1 310 0
 771 0064 892B      		or r24,r25
 772 0066 0C94 0000 		jmp USB_Host_ClearEndpointStall
 773               	.LVL70:
 774               	.L43:
 311:Lib/MassStoreCommands.c **** 	  return ErrorCode;
 312:Lib/MassStoreCommands.c **** 	
 313:Lib/MassStoreCommands.c **** 	return HOST_SENDCONTROL_Successful;
 314:Lib/MassStoreCommands.c **** }
 775               		.loc 1 314 0
 776 006a 0895      		ret
 777               		.cfi_endproc
 778               	.LFE153:
 780               		.section	.rodata
 781               	.LC1:
 782 0008 A1        		.byte	-95
 783 0009 FE        		.byte	-2
 784 000a 0000      		.word	0
 785 000c 0000      		.word	0
 786 000e 0100      		.word	1
 787               		.section	.text.MassStore_GetMaxLUN,"ax",@progbits
 788               	.global	MassStore_GetMaxLUN
 790               	MassStore_GetMaxLUN:
 791               	.LFB154:
 315:Lib/MassStoreCommands.c **** 
 316:Lib/MassStoreCommands.c **** /** Issues a Mass Storage class specific request to determine the index of the highest numbered Log
 317:Lib/MassStoreCommands.c ****  *  Unit in the attached device.
 318:Lib/MassStoreCommands.c ****  *
 319:Lib/MassStoreCommands.c ****  *  \note Some devices do not support this request, and will STALL it when issued. To get around th
 320:Lib/MassStoreCommands.c ****  *        on unsupported devices the max LUN index will be reported as zero and no error will be re
 321:Lib/MassStoreCommands.c ****  *        if the device STALLs the request.
 322:Lib/MassStoreCommands.c ****  *
 323:Lib/MassStoreCommands.c ****  *  \param[out] MaxLUNIndex  Pointer to the location that the maximum LUN index value should be sto
 324:Lib/MassStoreCommands.c ****  *
 325:Lib/MassStoreCommands.c ****  *  \return A value from the USB_Host_SendControlErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAIL
 326:Lib/MassStoreCommands.c ****  */
 327:Lib/MassStoreCommands.c **** uint8_t MassStore_GetMaxLUN(uint8_t* const MaxLUNIndex)
 328:Lib/MassStoreCommands.c **** {
 792               		.loc 1 328 0
 793               		.cfi_startproc
 794               	.LVL71:
 795 0000 CF93      		push r28
 796               	.LCFI10:
 797               		.cfi_def_cfa_offset 3
 798               		.cfi_offset 28, -2
 799 0002 DF93      		push r29
 800               	.LCFI11:
 801               		.cfi_def_cfa_offset 4
 802               		.cfi_offset 29, -3
 803               	/* prologue: function */
 804               	/* frame size = 0 */
 805               	/* stack size = 2 */
 806               	.L__stack_usage = 2
 807 0004 EC01      		movw r28,r24
 808               	.LVL72:
 329:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = HOST_SENDCONTROL_Successful;
 330:Lib/MassStoreCommands.c **** 
 331:Lib/MassStoreCommands.c **** 	USB_ControlRequest = (USB_Request_Header_t)
 809               		.loc 1 331 0
 810 0006 88E0      		ldi r24,lo8(8)
 811               	.LVL73:
 812 0008 E0E0      		ldi r30,lo8(.LC1)
 813 000a F0E0      		ldi r31,hi8(.LC1)
 814 000c A0E0      		ldi r26,lo8(USB_ControlRequest)
 815 000e B0E0      		ldi r27,hi8(USB_ControlRequest)
 816               		0:
 817 0010 0190      		ld r0,Z+
 818 0012 0D92      		st X+,r0
 819 0014 8A95      		dec r24
 820 0016 01F4      		brne 0b
 821               	.LVL74:
 822               	.LBB264:
 823               	.LBB265:
 228:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 824               		.loc 3 228 0
 825 0018 1092 A700 		sts 167,__zero_reg__
 826               	.LVL75:
 827               	.LBE265:
 828               	.LBE264:
 332:Lib/MassStoreCommands.c **** 		{
 333:Lib/MassStoreCommands.c **** 			.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
 334:Lib/MassStoreCommands.c **** 			.bRequest      = MS_REQ_GetMaxLUN,
 335:Lib/MassStoreCommands.c **** 			.wValue        = 0,
 336:Lib/MassStoreCommands.c **** 			.wIndex        = 0,
 337:Lib/MassStoreCommands.c **** 			.wLength       = 1,
 338:Lib/MassStoreCommands.c **** 		};
 339:Lib/MassStoreCommands.c **** 
 340:Lib/MassStoreCommands.c **** 	/* Select the control pipe for the request transfer */
 341:Lib/MassStoreCommands.c **** 	Pipe_SelectPipe(PIPE_CONTROLPIPE);
 342:Lib/MassStoreCommands.c **** 
 343:Lib/MassStoreCommands.c **** 	if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) == HOST_SENDCONTROL_SetupStalled)
 829               		.loc 1 343 0
 830 001c CE01      		movw r24,r28
 831 001e 0E94 0000 		call USB_Host_SendControlRequest
 832               	.LVL76:
 833 0022 8330      		cpi r24,lo8(3)
 834 0024 01F4      		brne .L51
 835               	.LBB266:
 836               	.LBB267:
 569:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 570:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 
 571:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			/** Clears the STALL condition detection flag on the currently selected pipe, but does not clear
 572:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  STALL condition itself (this must be done via a ClearFeature control request to the device).
 573:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *
 574:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 *  \ingroup Group_PipePacketManagement_AVR8
 575:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			 */
 576:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearStall(void) ATTR_ALWAYS_INLINE;
 577:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			static inline void Pipe_ClearStall(void)
 578:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			{
 579:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 				UPINTX &= ~(1 << RXSTALLI);
 837               		.loc 3 579 0
 838 0026 8091 A600 		lds r24,166
 839               	.LVL77:
 840 002a 8D7F      		andi r24,lo8(-3)
 841 002c 8093 A600 		sts 166,r24
 842               	.LBE267:
 843               	.LBE266:
 344:Lib/MassStoreCommands.c **** 	{
 345:Lib/MassStoreCommands.c **** 		/* Clear the pipe stall */
 346:Lib/MassStoreCommands.c **** 		Pipe_ClearStall();
 347:Lib/MassStoreCommands.c **** 
 348:Lib/MassStoreCommands.c **** 		/* Some faulty Mass Storage devices don't implement the GET_MAX_LUN request, so assume a single L
 349:Lib/MassStoreCommands.c **** 		*MaxLUNIndex = 0;
 844               		.loc 1 349 0
 845 0030 1882      		st Y,__zero_reg__
 846               	.LVL78:
 350:Lib/MassStoreCommands.c **** 
 351:Lib/MassStoreCommands.c **** 		/* Clear the error, and pretend the request executed correctly if the device STALLed it */
 352:Lib/MassStoreCommands.c **** 		ErrorCode = HOST_SENDCONTROL_Successful;
 847               		.loc 1 352 0
 848 0032 80E0      		ldi r24,0
 849               	.LVL79:
 850               	.L51:
 851               	/* epilogue start */
 353:Lib/MassStoreCommands.c **** 	}
 354:Lib/MassStoreCommands.c **** 
 355:Lib/MassStoreCommands.c **** 	return ErrorCode;
 356:Lib/MassStoreCommands.c **** }
 852               		.loc 1 356 0
 853 0034 DF91      		pop r29
 854 0036 CF91      		pop r28
 855               	.LVL80:
 856 0038 0895      		ret
 857               		.cfi_endproc
 858               	.LFE154:
 860               		.section	.text.MassStore_Inquiry,"ax",@progbits
 861               	.global	MassStore_Inquiry
 863               	MassStore_Inquiry:
 864               	.LFB155:
 357:Lib/MassStoreCommands.c **** 
 358:Lib/MassStoreCommands.c **** /** Issues a SCSI Inquiry command to the attached device, to determine the device's information. Th
 359:Lib/MassStoreCommands.c ****  *  gives information on the device's capabilities.
 360:Lib/MassStoreCommands.c ****  *
 361:Lib/MassStoreCommands.c ****  *  \param[in] LUNIndex    Index of the LUN inside the device the command is being addressed to
 362:Lib/MassStoreCommands.c ****  *  \param[out] InquiryPtr  Pointer to the inquiry data structure where the inquiry data from the d
 363:Lib/MassStoreCommands.c ****  *
 364:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if
 365:Lib/MassStoreCommands.c ****  */
 366:Lib/MassStoreCommands.c **** uint8_t MassStore_Inquiry(const uint8_t LUNIndex,
 367:Lib/MassStoreCommands.c ****                           SCSI_Inquiry_Response_t* const InquiryPtr)
 368:Lib/MassStoreCommands.c **** {
 865               		.loc 1 368 0
 866               		.cfi_startproc
 867               	.LVL81:
 868 0000 0F93      		push r16
 869               	.LCFI12:
 870               		.cfi_def_cfa_offset 3
 871               		.cfi_offset 16, -2
 872 0002 1F93      		push r17
 873               	.LCFI13:
 874               		.cfi_def_cfa_offset 4
 875               		.cfi_offset 17, -3
 876 0004 CF93      		push r28
 877               	.LCFI14:
 878               		.cfi_def_cfa_offset 5
 879               		.cfi_offset 28, -4
 880 0006 DF93      		push r29
 881               	.LCFI15:
 882               		.cfi_def_cfa_offset 6
 883               		.cfi_offset 29, -5
 884 0008 CDB7      		in r28,__SP_L__
 885 000a DEB7      		in r29,__SP_H__
 886               	.LCFI16:
 887               		.cfi_def_cfa_register 28
 888 000c AC97      		sbiw r28,44
 889               	.LCFI17:
 890               		.cfi_def_cfa_offset 50
 891 000e 0FB6      		in __tmp_reg__,__SREG__
 892 0010 F894      		cli
 893 0012 DEBF      		out __SP_H__,r29
 894 0014 0FBE      		out __SREG__,__tmp_reg__
 895 0016 CDBF      		out __SP_L__,r28
 896               	/* prologue: function */
 897               	/* frame size = 44 */
 898               	/* stack size = 48 */
 899               	.L__stack_usage = 48
 900               	.LVL82:
 369:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
 370:Lib/MassStoreCommands.c **** 
 371:Lib/MassStoreCommands.c **** 	/* Create a CBW with a SCSI command to issue INQUIRY command */
 372:Lib/MassStoreCommands.c **** 	MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t)
 901               		.loc 1 372 0
 902 0018 FE01      		movw r30,r28
 903 001a 3196      		adiw r30,1
 904 001c 9FE1      		ldi r25,lo8(31)
 905 001e DF01      		movw r26,r30
 906               		0:
 907 0020 1D92      		st X+,__zero_reg__
 908 0022 9A95      		dec r25
 909 0024 01F4      		brne 0b
 910 0026 05E5      		ldi r16,lo8(85)
 911 0028 13E5      		ldi r17,lo8(83)
 912 002a 22E4      		ldi r18,lo8(66)
 913 002c 33E4      		ldi r19,lo8(67)
 914 002e 0983      		std Y+1,r16
 915 0030 1A83      		std Y+2,r17
 916 0032 2B83      		std Y+3,r18
 917 0034 3C83      		std Y+4,r19
 918 0036 04E2      		ldi r16,lo8(36)
 919 0038 10E0      		ldi r17,0
 920 003a 20E0      		ldi r18,0
 921 003c 30E0      		ldi r19,0
 922 003e 0987      		std Y+9,r16
 923 0040 1A87      		std Y+10,r17
 924 0042 2B87      		std Y+11,r18
 925 0044 3C87      		std Y+12,r19
 926 0046 90E8      		ldi r25,lo8(-128)
 927 0048 9D87      		std Y+13,r25
 928 004a 8E87      		std Y+14,r24
 929 004c 86E0      		ldi r24,lo8(6)
 930               	.LVL83:
 931 004e 8F87      		std Y+15,r24
 932 0050 82E1      		ldi r24,lo8(18)
 933 0052 888B      		std Y+16,r24
 934 0054 84E2      		ldi r24,lo8(36)
 935 0056 8C8B      		std Y+20,r24
 373:Lib/MassStoreCommands.c **** 		{
 374:Lib/MassStoreCommands.c **** 			.Signature          = MS_CBW_SIGNATURE,
 375:Lib/MassStoreCommands.c **** 			.DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
 376:Lib/MassStoreCommands.c **** 			.Flags              = MS_COMMAND_DIR_DATA_IN,
 377:Lib/MassStoreCommands.c **** 			.LUN                = LUNIndex,
 378:Lib/MassStoreCommands.c **** 			.SCSICommandLength  = 6,
 379:Lib/MassStoreCommands.c **** 			.SCSICommandData    =
 380:Lib/MassStoreCommands.c **** 				{
 381:Lib/MassStoreCommands.c **** 					SCSI_CMD_INQUIRY,
 382:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 383:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 384:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 385:Lib/MassStoreCommands.c **** 					sizeof(SCSI_Inquiry_Response_t), // Allocation Length
 386:Lib/MassStoreCommands.c **** 					0x00                    // Unused (control)
 387:Lib/MassStoreCommands.c **** 				}
 388:Lib/MassStoreCommands.c **** 		};
 389:Lib/MassStoreCommands.c **** 
 390:Lib/MassStoreCommands.c **** 	MS_CommandStatusWrapper_t SCSICommandStatus;
 391:Lib/MassStoreCommands.c **** 
 392:Lib/MassStoreCommands.c **** 	/* Send the command and any data to the attached device */
 393:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, InquiryPtr)) != PIPE_RWSTREAM_NoError)
 936               		.loc 1 393 0
 937 0058 CF01      		movw r24,r30
 938 005a 0E94 0000 		call MassStore_SendCommand.constprop.1
 939               	.LVL84:
 940 005e 8111      		cpse r24,__zero_reg__
 941 0060 00C0      		rjmp .L56
 394:Lib/MassStoreCommands.c **** 	{
 395:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 396:Lib/MassStoreCommands.c **** 		return ErrorCode;
 397:Lib/MassStoreCommands.c **** 	}
 398:Lib/MassStoreCommands.c **** 
 399:Lib/MassStoreCommands.c **** 	/* Retrieve status information from the attached device */
 400:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
 942               		.loc 1 400 0
 943 0062 CE01      		movw r24,r28
 944               	.LVL85:
 945 0064 8096      		adiw r24,32
 946 0066 0E94 0000 		call MassStore_GetReturnedStatus
 947               	.LVL86:
 948 006a 8823      		tst r24
 949 006c 01F0      		breq .L55
 950               	.L56:
 951               	.LBB268:
 952               	.LBB269:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 953               		.loc 3 381 0
 954 006e 9091 A900 		lds r25,169
 955 0072 9064      		ori r25,lo8(64)
 956 0074 9093 A900 		sts 169,r25
 957               	.LBE269:
 958               	.LBE268:
 401:Lib/MassStoreCommands.c **** 	{
 402:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 403:Lib/MassStoreCommands.c **** 		return ErrorCode;
 959               		.loc 1 403 0
 960 0078 00C0      		rjmp .L54
 961               	.L55:
 962 007a 80E0      		ldi r24,0
 963               	.LVL87:
 964               	.L54:
 965               	/* epilogue start */
 404:Lib/MassStoreCommands.c **** 	}
 405:Lib/MassStoreCommands.c **** 
 406:Lib/MassStoreCommands.c **** 	return ErrorCode;
 407:Lib/MassStoreCommands.c **** }
 966               		.loc 1 407 0
 967 007c AC96      		adiw r28,44
 968 007e 0FB6      		in __tmp_reg__,__SREG__
 969 0080 F894      		cli
 970 0082 DEBF      		out __SP_H__,r29
 971 0084 0FBE      		out __SREG__,__tmp_reg__
 972 0086 CDBF      		out __SP_L__,r28
 973 0088 DF91      		pop r29
 974 008a CF91      		pop r28
 975 008c 1F91      		pop r17
 976 008e 0F91      		pop r16
 977 0090 0895      		ret
 978               		.cfi_endproc
 979               	.LFE155:
 981               		.section	.text.MassStore_RequestSense,"ax",@progbits
 982               	.global	MassStore_RequestSense
 984               	MassStore_RequestSense:
 985               	.LFB156:
 408:Lib/MassStoreCommands.c **** 
 409:Lib/MassStoreCommands.c **** /** Issues a SCSI Request Sense command to the attached device, to determine the current SCSI sense
 410:Lib/MassStoreCommands.c ****  *  gives error codes for the last issued SCSI command to the device.
 411:Lib/MassStoreCommands.c ****  *
 412:Lib/MassStoreCommands.c ****  *  \param[in] LUNIndex   Index of the LUN inside the device the command is being addressed to
 413:Lib/MassStoreCommands.c ****  *  \param[out] SensePtr  Pointer to the sense data structure where the sense data from the device 
 414:Lib/MassStoreCommands.c ****  *
 415:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if
 416:Lib/MassStoreCommands.c ****  */
 417:Lib/MassStoreCommands.c **** uint8_t MassStore_RequestSense(const uint8_t LUNIndex,
 418:Lib/MassStoreCommands.c ****                                SCSI_Request_Sense_Response_t* const SensePtr)
 419:Lib/MassStoreCommands.c **** {
 986               		.loc 1 419 0
 987               		.cfi_startproc
 988               	.LVL88:
 989 0000 0F93      		push r16
 990               	.LCFI18:
 991               		.cfi_def_cfa_offset 3
 992               		.cfi_offset 16, -2
 993 0002 1F93      		push r17
 994               	.LCFI19:
 995               		.cfi_def_cfa_offset 4
 996               		.cfi_offset 17, -3
 997 0004 CF93      		push r28
 998               	.LCFI20:
 999               		.cfi_def_cfa_offset 5
 1000               		.cfi_offset 28, -4
 1001 0006 DF93      		push r29
 1002               	.LCFI21:
 1003               		.cfi_def_cfa_offset 6
 1004               		.cfi_offset 29, -5
 1005 0008 CDB7      		in r28,__SP_L__
 1006 000a DEB7      		in r29,__SP_H__
 1007               	.LCFI22:
 1008               		.cfi_def_cfa_register 28
 1009 000c AC97      		sbiw r28,44
 1010               	.LCFI23:
 1011               		.cfi_def_cfa_offset 50
 1012 000e 0FB6      		in __tmp_reg__,__SREG__
 1013 0010 F894      		cli
 1014 0012 DEBF      		out __SP_H__,r29
 1015 0014 0FBE      		out __SREG__,__tmp_reg__
 1016 0016 CDBF      		out __SP_L__,r28
 1017               	/* prologue: function */
 1018               	/* frame size = 44 */
 1019               	/* stack size = 48 */
 1020               	.L__stack_usage = 48
 1021               	.LVL89:
 420:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
 421:Lib/MassStoreCommands.c **** 
 422:Lib/MassStoreCommands.c **** 	/* Create a CBW with a SCSI command to issue REQUEST SENSE command */
 423:Lib/MassStoreCommands.c **** 	MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t)
 1022               		.loc 1 423 0
 1023 0018 FE01      		movw r30,r28
 1024 001a 3196      		adiw r30,1
 1025 001c 9FE1      		ldi r25,lo8(31)
 1026 001e DF01      		movw r26,r30
 1027               		0:
 1028 0020 1D92      		st X+,__zero_reg__
 1029 0022 9A95      		dec r25
 1030 0024 01F4      		brne 0b
 1031 0026 05E5      		ldi r16,lo8(85)
 1032 0028 13E5      		ldi r17,lo8(83)
 1033 002a 22E4      		ldi r18,lo8(66)
 1034 002c 33E4      		ldi r19,lo8(67)
 1035 002e 0983      		std Y+1,r16
 1036 0030 1A83      		std Y+2,r17
 1037 0032 2B83      		std Y+3,r18
 1038 0034 3C83      		std Y+4,r19
 1039 0036 02E1      		ldi r16,lo8(18)
 1040 0038 10E0      		ldi r17,0
 1041 003a 20E0      		ldi r18,0
 1042 003c 30E0      		ldi r19,0
 1043 003e 0987      		std Y+9,r16
 1044 0040 1A87      		std Y+10,r17
 1045 0042 2B87      		std Y+11,r18
 1046 0044 3C87      		std Y+12,r19
 1047 0046 90E8      		ldi r25,lo8(-128)
 1048 0048 9D87      		std Y+13,r25
 1049 004a 8E87      		std Y+14,r24
 1050 004c 86E0      		ldi r24,lo8(6)
 1051               	.LVL90:
 1052 004e 8F87      		std Y+15,r24
 1053 0050 83E0      		ldi r24,lo8(3)
 1054 0052 888B      		std Y+16,r24
 1055 0054 82E1      		ldi r24,lo8(18)
 1056 0056 8C8B      		std Y+20,r24
 424:Lib/MassStoreCommands.c **** 		{
 425:Lib/MassStoreCommands.c **** 			.Signature          = MS_CBW_SIGNATURE,
 426:Lib/MassStoreCommands.c **** 			.DataTransferLength = sizeof(SCSI_Request_Sense_Response_t),
 427:Lib/MassStoreCommands.c **** 			.Flags              = MS_COMMAND_DIR_DATA_IN,
 428:Lib/MassStoreCommands.c **** 			.LUN                = LUNIndex,
 429:Lib/MassStoreCommands.c **** 			.SCSICommandLength  = 6,
 430:Lib/MassStoreCommands.c **** 			.SCSICommandData =
 431:Lib/MassStoreCommands.c **** 				{
 432:Lib/MassStoreCommands.c **** 					SCSI_CMD_REQUEST_SENSE,
 433:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 434:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 435:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 436:Lib/MassStoreCommands.c **** 					sizeof(SCSI_Request_Sense_Response_t), // Allocation Length
 437:Lib/MassStoreCommands.c **** 					0x00                    // Unused (control)
 438:Lib/MassStoreCommands.c **** 				}
 439:Lib/MassStoreCommands.c **** 		};
 440:Lib/MassStoreCommands.c **** 
 441:Lib/MassStoreCommands.c **** 	MS_CommandStatusWrapper_t SCSICommandStatus;
 442:Lib/MassStoreCommands.c **** 
 443:Lib/MassStoreCommands.c **** 	/* Send the command and any data to the attached device */
 444:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, SensePtr)) != PIPE_RWSTREAM_NoError)
 1057               		.loc 1 444 0
 1058 0058 CF01      		movw r24,r30
 1059 005a 0E94 0000 		call MassStore_SendCommand.constprop.1
 1060               	.LVL91:
 1061 005e 8111      		cpse r24,__zero_reg__
 1062 0060 00C0      		rjmp .L61
 445:Lib/MassStoreCommands.c **** 	{
 446:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 447:Lib/MassStoreCommands.c **** 		return ErrorCode;
 448:Lib/MassStoreCommands.c **** 	}
 449:Lib/MassStoreCommands.c **** 
 450:Lib/MassStoreCommands.c **** 	/* Retrieve status information from the attached device */
 451:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
 1063               		.loc 1 451 0
 1064 0062 CE01      		movw r24,r28
 1065               	.LVL92:
 1066 0064 8096      		adiw r24,32
 1067 0066 0E94 0000 		call MassStore_GetReturnedStatus
 1068               	.LVL93:
 1069 006a 8823      		tst r24
 1070 006c 01F0      		breq .L60
 1071               	.L61:
 1072               	.LBB270:
 1073               	.LBB271:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 1074               		.loc 3 381 0
 1075 006e 9091 A900 		lds r25,169
 1076 0072 9064      		ori r25,lo8(64)
 1077 0074 9093 A900 		sts 169,r25
 1078               	.LBE271:
 1079               	.LBE270:
 452:Lib/MassStoreCommands.c **** 	{
 453:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 454:Lib/MassStoreCommands.c **** 		return ErrorCode;
 1080               		.loc 1 454 0
 1081 0078 00C0      		rjmp .L59
 1082               	.L60:
 1083 007a 80E0      		ldi r24,0
 1084               	.LVL94:
 1085               	.L59:
 1086               	/* epilogue start */
 455:Lib/MassStoreCommands.c **** 	}
 456:Lib/MassStoreCommands.c **** 
 457:Lib/MassStoreCommands.c **** 	return ErrorCode;
 458:Lib/MassStoreCommands.c **** }
 1087               		.loc 1 458 0
 1088 007c AC96      		adiw r28,44
 1089 007e 0FB6      		in __tmp_reg__,__SREG__
 1090 0080 F894      		cli
 1091 0082 DEBF      		out __SP_H__,r29
 1092 0084 0FBE      		out __SREG__,__tmp_reg__
 1093 0086 CDBF      		out __SP_L__,r28
 1094 0088 DF91      		pop r29
 1095 008a CF91      		pop r28
 1096 008c 1F91      		pop r17
 1097 008e 0F91      		pop r16
 1098 0090 0895      		ret
 1099               		.cfi_endproc
 1100               	.LFE156:
 1102               		.section	.text.MassStore_ReadDeviceBlock,"ax",@progbits
 1103               	.global	MassStore_ReadDeviceBlock
 1105               	MassStore_ReadDeviceBlock:
 1106               	.LFB157:
 459:Lib/MassStoreCommands.c **** 
 460:Lib/MassStoreCommands.c **** /** Issues a SCSI Device Block Read command to the attached device, to read in one or more data blo
 461:Lib/MassStoreCommands.c ****  *  storage medium into a buffer.
 462:Lib/MassStoreCommands.c ****  *
 463:Lib/MassStoreCommands.c ****  *  \param[in] LUNIndex      Index of the LUN inside the device the command is being addressed to
 464:Lib/MassStoreCommands.c ****  *  \param[in] BlockAddress  Start block address to read from
 465:Lib/MassStoreCommands.c ****  *  \param[in] Blocks        Number of blocks to read from the device
 466:Lib/MassStoreCommands.c ****  *  \param[in] BlockSize     Size in bytes of each block to read
 467:Lib/MassStoreCommands.c ****  *  \param[out] BufferPtr    Pointer to the buffer where the read data is to be written to
 468:Lib/MassStoreCommands.c ****  *
 469:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if
 470:Lib/MassStoreCommands.c ****  */
 471:Lib/MassStoreCommands.c **** uint8_t MassStore_ReadDeviceBlock(const uint8_t LUNIndex,
 472:Lib/MassStoreCommands.c ****                                   const uint32_t BlockAddress,
 473:Lib/MassStoreCommands.c ****                                   const uint8_t Blocks,
 474:Lib/MassStoreCommands.c ****                                   const uint16_t BlockSize,
 475:Lib/MassStoreCommands.c ****                                   void* BufferPtr)
 476:Lib/MassStoreCommands.c **** {
 1107               		.loc 1 476 0
 1108               		.cfi_startproc
 1109               	.LVL95:
 1110 0000 AF92      		push r10
 1111               	.LCFI24:
 1112               		.cfi_def_cfa_offset 3
 1113               		.cfi_offset 10, -2
 1114 0002 BF92      		push r11
 1115               	.LCFI25:
 1116               		.cfi_def_cfa_offset 4
 1117               		.cfi_offset 11, -3
 1118 0004 CF92      		push r12
 1119               	.LCFI26:
 1120               		.cfi_def_cfa_offset 5
 1121               		.cfi_offset 12, -4
 1122 0006 DF92      		push r13
 1123               	.LCFI27:
 1124               		.cfi_def_cfa_offset 6
 1125               		.cfi_offset 13, -5
 1126 0008 EF92      		push r14
 1127               	.LCFI28:
 1128               		.cfi_def_cfa_offset 7
 1129               		.cfi_offset 14, -6
 1130 000a FF92      		push r15
 1131               	.LCFI29:
 1132               		.cfi_def_cfa_offset 8
 1133               		.cfi_offset 15, -7
 1134 000c 0F93      		push r16
 1135               	.LCFI30:
 1136               		.cfi_def_cfa_offset 9
 1137               		.cfi_offset 16, -8
 1138 000e 1F93      		push r17
 1139               	.LCFI31:
 1140               		.cfi_def_cfa_offset 10
 1141               		.cfi_offset 17, -9
 1142 0010 CF93      		push r28
 1143               	.LCFI32:
 1144               		.cfi_def_cfa_offset 11
 1145               		.cfi_offset 28, -10
 1146 0012 DF93      		push r29
 1147               	.LCFI33:
 1148               		.cfi_def_cfa_offset 12
 1149               		.cfi_offset 29, -11
 1150 0014 CDB7      		in r28,__SP_L__
 1151 0016 DEB7      		in r29,__SP_H__
 1152               	.LCFI34:
 1153               		.cfi_def_cfa_register 28
 1154 0018 AC97      		sbiw r28,44
 1155               	.LCFI35:
 1156               		.cfi_def_cfa_offset 56
 1157 001a 0FB6      		in __tmp_reg__,__SREG__
 1158 001c F894      		cli
 1159 001e DEBF      		out __SP_H__,r29
 1160 0020 0FBE      		out __SREG__,__tmp_reg__
 1161 0022 CDBF      		out __SP_L__,r28
 1162               	/* prologue: function */
 1163               	/* frame size = 44 */
 1164               	/* stack size = 54 */
 1165               	.L__stack_usage = 54
 1166 0024 A82E      		mov r10,r24
 1167 0026 C62E      		mov r12,r22
 1168 0028 B72E      		mov r11,r23
 1169               	.LVL96:
 477:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
 478:Lib/MassStoreCommands.c **** 
 479:Lib/MassStoreCommands.c **** 	/* Create a CBW with a SCSI command to read in the given blocks from the device */
 480:Lib/MassStoreCommands.c **** 	MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t)
 1170               		.loc 1 480 0
 1171 002a FE01      		movw r30,r28
 1172 002c 3196      		adiw r30,1
 1173 002e 8FE1      		ldi r24,lo8(31)
 1174               	.LVL97:
 1175 0030 DF01      		movw r26,r30
 1176               		0:
 1177 0032 1D92      		st X+,__zero_reg__
 1178 0034 8A95      		dec r24
 1179 0036 01F4      		brne 0b
 1180 0038 85E5      		ldi r24,lo8(85)
 1181 003a 93E5      		ldi r25,lo8(83)
 1182 003c A2E4      		ldi r26,lo8(66)
 1183 003e B3E4      		ldi r27,lo8(67)
 1184 0040 8983      		std Y+1,r24
 1185 0042 9A83      		std Y+2,r25
 1186 0044 AB83      		std Y+3,r26
 1187 0046 BC83      		std Y+4,r27
 1188 0048 30E0      		ldi r19,0
 1189 004a D801      		movw r26,r16
 1190 004c 0E94 0000 		call __umulhisi3
 1191 0050 6987      		std Y+9,r22
 1192 0052 7A87      		std Y+10,r23
 1193 0054 8B87      		std Y+11,r24
 1194 0056 9C87      		std Y+12,r25
 1195 0058 80E8      		ldi r24,lo8(-128)
 1196 005a 8D87      		std Y+13,r24
 1197 005c AE86      		std Y+14,r10
 1198 005e 8AE0      		ldi r24,lo8(10)
 1199 0060 8F87      		std Y+15,r24
 1200 0062 88E2      		ldi r24,lo8(40)
 1201 0064 888B      		std Y+16,r24
 1202 0066 BA8A      		std Y+18,r11
 1203 0068 CB8A      		std Y+19,r12
 1204 006a 5C8B      		std Y+20,r21
 1205 006c 4D8B      		std Y+21,r20
 1206 006e 288F      		std Y+24,r18
 481:Lib/MassStoreCommands.c **** 		{
 482:Lib/MassStoreCommands.c **** 			.Signature          = MS_CBW_SIGNATURE,
 483:Lib/MassStoreCommands.c **** 			.DataTransferLength = ((uint32_t)Blocks * BlockSize),
 484:Lib/MassStoreCommands.c **** 			.Flags              = MS_COMMAND_DIR_DATA_IN,
 485:Lib/MassStoreCommands.c **** 			.LUN                = LUNIndex,
 486:Lib/MassStoreCommands.c **** 			.SCSICommandLength  = 10,
 487:Lib/MassStoreCommands.c **** 			.SCSICommandData    =
 488:Lib/MassStoreCommands.c **** 				{
 489:Lib/MassStoreCommands.c **** 					SCSI_CMD_READ_10,
 490:Lib/MassStoreCommands.c **** 					0x00,                   // Unused (control bits, all off)
 491:Lib/MassStoreCommands.c **** 					(BlockAddress >> 24),   // MSB of Block Address
 492:Lib/MassStoreCommands.c **** 					(BlockAddress >> 16),
 493:Lib/MassStoreCommands.c **** 					(BlockAddress >> 8),
 494:Lib/MassStoreCommands.c **** 					(BlockAddress & 0xFF),  // LSB of Block Address
 495:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 496:Lib/MassStoreCommands.c **** 					0x00,                   // MSB of Total Blocks to Read
 497:Lib/MassStoreCommands.c **** 					Blocks,                 // LSB of Total Blocks to Read
 498:Lib/MassStoreCommands.c **** 					0x00                    // Unused (control)
 499:Lib/MassStoreCommands.c **** 				}
 500:Lib/MassStoreCommands.c **** 		};
 501:Lib/MassStoreCommands.c **** 
 502:Lib/MassStoreCommands.c **** 	MS_CommandStatusWrapper_t SCSICommandStatus;
 503:Lib/MassStoreCommands.c **** 
 504:Lib/MassStoreCommands.c **** 	/* Send the command and any data to the attached device */
 505:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, BufferPtr)) != PIPE_RWSTREAM_NoError)
 1207               		.loc 1 505 0
 1208 0070 B701      		movw r22,r14
 1209 0072 CF01      		movw r24,r30
 1210 0074 0E94 0000 		call MassStore_SendCommand.constprop.1
 1211               	.LVL98:
 1212 0078 8111      		cpse r24,__zero_reg__
 1213 007a 00C0      		rjmp .L66
 506:Lib/MassStoreCommands.c **** 	{
 507:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 508:Lib/MassStoreCommands.c **** 		return ErrorCode;
 509:Lib/MassStoreCommands.c **** 	}
 510:Lib/MassStoreCommands.c **** 
 511:Lib/MassStoreCommands.c **** 	/* Retrieve status information from the attached device */
 512:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
 1214               		.loc 1 512 0
 1215 007c CE01      		movw r24,r28
 1216               	.LVL99:
 1217 007e 8096      		adiw r24,32
 1218 0080 0E94 0000 		call MassStore_GetReturnedStatus
 1219               	.LVL100:
 1220 0084 8823      		tst r24
 1221 0086 01F0      		breq .L65
 1222               	.L66:
 1223               	.LBB272:
 1224               	.LBB273:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 1225               		.loc 3 381 0
 1226 0088 9091 A900 		lds r25,169
 1227 008c 9064      		ori r25,lo8(64)
 1228 008e 9093 A900 		sts 169,r25
 1229               	.LBE273:
 1230               	.LBE272:
 513:Lib/MassStoreCommands.c **** 	{
 514:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 515:Lib/MassStoreCommands.c **** 		return ErrorCode;
 1231               		.loc 1 515 0
 1232 0092 00C0      		rjmp .L64
 1233               	.L65:
 1234 0094 80E0      		ldi r24,0
 1235               	.LVL101:
 1236               	.L64:
 1237               	/* epilogue start */
 516:Lib/MassStoreCommands.c **** 	}
 517:Lib/MassStoreCommands.c **** 
 518:Lib/MassStoreCommands.c **** 	return ErrorCode;
 519:Lib/MassStoreCommands.c **** }
 1238               		.loc 1 519 0
 1239 0096 AC96      		adiw r28,44
 1240 0098 0FB6      		in __tmp_reg__,__SREG__
 1241 009a F894      		cli
 1242 009c DEBF      		out __SP_H__,r29
 1243 009e 0FBE      		out __SREG__,__tmp_reg__
 1244 00a0 CDBF      		out __SP_L__,r28
 1245 00a2 DF91      		pop r29
 1246 00a4 CF91      		pop r28
 1247 00a6 1F91      		pop r17
 1248 00a8 0F91      		pop r16
 1249               	.LVL102:
 1250 00aa FF90      		pop r15
 1251 00ac EF90      		pop r14
 1252               	.LVL103:
 1253 00ae DF90      		pop r13
 1254 00b0 CF90      		pop r12
 1255 00b2 BF90      		pop r11
 1256 00b4 AF90      		pop r10
 1257               	.LVL104:
 1258 00b6 0895      		ret
 1259               		.cfi_endproc
 1260               	.LFE157:
 1262               		.section	.text.MassStore_WriteDeviceBlock,"ax",@progbits
 1263               	.global	MassStore_WriteDeviceBlock
 1265               	MassStore_WriteDeviceBlock:
 1266               	.LFB158:
 520:Lib/MassStoreCommands.c **** 
 521:Lib/MassStoreCommands.c **** /** Issues a SCSI Device Block Write command to the attached device, to write one or more data bloc
 522:Lib/MassStoreCommands.c ****  *  storage medium from a buffer.
 523:Lib/MassStoreCommands.c ****  *
 524:Lib/MassStoreCommands.c ****  *  \param[in] LUNIndex      Index of the LUN inside the device the command is being addressed to
 525:Lib/MassStoreCommands.c ****  *  \param[in] BlockAddress  Start block address to write to
 526:Lib/MassStoreCommands.c ****  *  \param[in] Blocks        Number of blocks to write to in the device
 527:Lib/MassStoreCommands.c ****  *  \param[in] BlockSize     Size in bytes of each block to write
 528:Lib/MassStoreCommands.c ****  *  \param[in] BufferPtr     Pointer to the buffer where the write data is to be sourced from
 529:Lib/MassStoreCommands.c ****  *
 530:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if
 531:Lib/MassStoreCommands.c ****  */
 532:Lib/MassStoreCommands.c **** uint8_t MassStore_WriteDeviceBlock(const uint8_t LUNIndex,
 533:Lib/MassStoreCommands.c ****                                    const uint32_t BlockAddress,
 534:Lib/MassStoreCommands.c ****                                    const uint8_t Blocks,
 535:Lib/MassStoreCommands.c ****                                    const uint16_t BlockSize,
 536:Lib/MassStoreCommands.c ****                                    void* BufferPtr)
 537:Lib/MassStoreCommands.c **** {
 1267               		.loc 1 537 0
 1268               		.cfi_startproc
 1269               	.LVL105:
 1270 0000 AF92      		push r10
 1271               	.LCFI36:
 1272               		.cfi_def_cfa_offset 3
 1273               		.cfi_offset 10, -2
 1274 0002 BF92      		push r11
 1275               	.LCFI37:
 1276               		.cfi_def_cfa_offset 4
 1277               		.cfi_offset 11, -3
 1278 0004 CF92      		push r12
 1279               	.LCFI38:
 1280               		.cfi_def_cfa_offset 5
 1281               		.cfi_offset 12, -4
 1282 0006 DF92      		push r13
 1283               	.LCFI39:
 1284               		.cfi_def_cfa_offset 6
 1285               		.cfi_offset 13, -5
 1286 0008 EF92      		push r14
 1287               	.LCFI40:
 1288               		.cfi_def_cfa_offset 7
 1289               		.cfi_offset 14, -6
 1290 000a FF92      		push r15
 1291               	.LCFI41:
 1292               		.cfi_def_cfa_offset 8
 1293               		.cfi_offset 15, -7
 1294 000c 0F93      		push r16
 1295               	.LCFI42:
 1296               		.cfi_def_cfa_offset 9
 1297               		.cfi_offset 16, -8
 1298 000e 1F93      		push r17
 1299               	.LCFI43:
 1300               		.cfi_def_cfa_offset 10
 1301               		.cfi_offset 17, -9
 1302 0010 CF93      		push r28
 1303               	.LCFI44:
 1304               		.cfi_def_cfa_offset 11
 1305               		.cfi_offset 28, -10
 1306 0012 DF93      		push r29
 1307               	.LCFI45:
 1308               		.cfi_def_cfa_offset 12
 1309               		.cfi_offset 29, -11
 1310 0014 CDB7      		in r28,__SP_L__
 1311 0016 DEB7      		in r29,__SP_H__
 1312               	.LCFI46:
 1313               		.cfi_def_cfa_register 28
 1314 0018 AC97      		sbiw r28,44
 1315               	.LCFI47:
 1316               		.cfi_def_cfa_offset 56
 1317 001a 0FB6      		in __tmp_reg__,__SREG__
 1318 001c F894      		cli
 1319 001e DEBF      		out __SP_H__,r29
 1320 0020 0FBE      		out __SREG__,__tmp_reg__
 1321 0022 CDBF      		out __SP_L__,r28
 1322               	/* prologue: function */
 1323               	/* frame size = 44 */
 1324               	/* stack size = 54 */
 1325               	.L__stack_usage = 54
 1326 0024 A82E      		mov r10,r24
 1327 0026 C62E      		mov r12,r22
 1328 0028 B72E      		mov r11,r23
 1329               	.LVL106:
 538:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
 539:Lib/MassStoreCommands.c **** 
 540:Lib/MassStoreCommands.c **** 	/* Create a CBW with a SCSI command to write the given blocks to the device */
 541:Lib/MassStoreCommands.c **** 	MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t)
 1330               		.loc 1 541 0
 1331 002a FE01      		movw r30,r28
 1332 002c 3196      		adiw r30,1
 1333 002e 8FE1      		ldi r24,lo8(31)
 1334               	.LVL107:
 1335 0030 DF01      		movw r26,r30
 1336               		0:
 1337 0032 1D92      		st X+,__zero_reg__
 1338 0034 8A95      		dec r24
 1339 0036 01F4      		brne 0b
 1340 0038 85E5      		ldi r24,lo8(85)
 1341 003a 93E5      		ldi r25,lo8(83)
 1342 003c A2E4      		ldi r26,lo8(66)
 1343 003e B3E4      		ldi r27,lo8(67)
 1344 0040 8983      		std Y+1,r24
 1345 0042 9A83      		std Y+2,r25
 1346 0044 AB83      		std Y+3,r26
 1347 0046 BC83      		std Y+4,r27
 1348 0048 30E0      		ldi r19,0
 1349 004a D801      		movw r26,r16
 1350 004c 0E94 0000 		call __umulhisi3
 1351 0050 6987      		std Y+9,r22
 1352 0052 7A87      		std Y+10,r23
 1353 0054 8B87      		std Y+11,r24
 1354 0056 9C87      		std Y+12,r25
 1355 0058 AE86      		std Y+14,r10
 1356 005a 8AE0      		ldi r24,lo8(10)
 1357 005c 8F87      		std Y+15,r24
 1358 005e 8AE2      		ldi r24,lo8(42)
 1359 0060 888B      		std Y+16,r24
 1360 0062 BA8A      		std Y+18,r11
 1361 0064 CB8A      		std Y+19,r12
 1362 0066 5C8B      		std Y+20,r21
 1363 0068 4D8B      		std Y+21,r20
 1364 006a 288F      		std Y+24,r18
 542:Lib/MassStoreCommands.c **** 		{
 543:Lib/MassStoreCommands.c **** 			.Signature          = MS_CBW_SIGNATURE,
 544:Lib/MassStoreCommands.c **** 			.DataTransferLength = ((uint32_t)Blocks * BlockSize),
 545:Lib/MassStoreCommands.c **** 			.Flags              = MS_COMMAND_DIR_DATA_OUT,
 546:Lib/MassStoreCommands.c **** 			.LUN                = LUNIndex,
 547:Lib/MassStoreCommands.c **** 			.SCSICommandLength  = 10,
 548:Lib/MassStoreCommands.c **** 			.SCSICommandData    =
 549:Lib/MassStoreCommands.c **** 				{
 550:Lib/MassStoreCommands.c **** 					SCSI_CMD_WRITE_10,
 551:Lib/MassStoreCommands.c **** 					0x00,                   // Unused (control bits, all off)
 552:Lib/MassStoreCommands.c **** 					(BlockAddress >> 24),   // MSB of Block Address
 553:Lib/MassStoreCommands.c **** 					(BlockAddress >> 16),
 554:Lib/MassStoreCommands.c **** 					(BlockAddress >> 8),
 555:Lib/MassStoreCommands.c **** 					(BlockAddress & 0xFF),  // LSB of Block Address
 556:Lib/MassStoreCommands.c **** 					0x00,                   // Unused (reserved)
 557:Lib/MassStoreCommands.c **** 					0x00,                   // MSB of Total Blocks to Write
 558:Lib/MassStoreCommands.c **** 					Blocks,                 // LSB of Total Blocks to Write
 559:Lib/MassStoreCommands.c **** 					0x00                    // Unused (control)
 560:Lib/MassStoreCommands.c **** 				}
 561:Lib/MassStoreCommands.c **** 		};
 562:Lib/MassStoreCommands.c **** 
 563:Lib/MassStoreCommands.c **** 	MS_CommandStatusWrapper_t SCSICommandStatus;
 564:Lib/MassStoreCommands.c **** 
 565:Lib/MassStoreCommands.c **** 	/* Send the command and any data to the attached device */
 566:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, BufferPtr)) != PIPE_RWSTREAM_NoError)
 1365               		.loc 1 566 0
 1366 006c B701      		movw r22,r14
 1367 006e CF01      		movw r24,r30
 1368 0070 0E94 0000 		call MassStore_SendCommand.constprop.1
 1369               	.LVL108:
 1370 0074 8111      		cpse r24,__zero_reg__
 1371 0076 00C0      		rjmp .L71
 567:Lib/MassStoreCommands.c **** 	{
 568:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 569:Lib/MassStoreCommands.c **** 		return ErrorCode;
 570:Lib/MassStoreCommands.c **** 	}
 571:Lib/MassStoreCommands.c **** 
 572:Lib/MassStoreCommands.c **** 	/* Retrieve status information from the attached device */
 573:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
 1372               		.loc 1 573 0
 1373 0078 CE01      		movw r24,r28
 1374               	.LVL109:
 1375 007a 8096      		adiw r24,32
 1376 007c 0E94 0000 		call MassStore_GetReturnedStatus
 1377               	.LVL110:
 1378 0080 8823      		tst r24
 1379 0082 01F0      		breq .L70
 1380               	.L71:
 1381               	.LBB274:
 1382               	.LBB275:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 1383               		.loc 3 381 0
 1384 0084 9091 A900 		lds r25,169
 1385 0088 9064      		ori r25,lo8(64)
 1386 008a 9093 A900 		sts 169,r25
 1387               	.LBE275:
 1388               	.LBE274:
 574:Lib/MassStoreCommands.c **** 	{
 575:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 576:Lib/MassStoreCommands.c **** 		return ErrorCode;
 1389               		.loc 1 576 0
 1390 008e 00C0      		rjmp .L69
 1391               	.L70:
 1392 0090 80E0      		ldi r24,0
 1393               	.LVL111:
 1394               	.L69:
 1395               	/* epilogue start */
 577:Lib/MassStoreCommands.c **** 	}
 578:Lib/MassStoreCommands.c **** 
 579:Lib/MassStoreCommands.c **** 	return ErrorCode;
 580:Lib/MassStoreCommands.c **** }
 1396               		.loc 1 580 0
 1397 0092 AC96      		adiw r28,44
 1398 0094 0FB6      		in __tmp_reg__,__SREG__
 1399 0096 F894      		cli
 1400 0098 DEBF      		out __SP_H__,r29
 1401 009a 0FBE      		out __SREG__,__tmp_reg__
 1402 009c CDBF      		out __SP_L__,r28
 1403 009e DF91      		pop r29
 1404 00a0 CF91      		pop r28
 1405 00a2 1F91      		pop r17
 1406 00a4 0F91      		pop r16
 1407               	.LVL112:
 1408 00a6 FF90      		pop r15
 1409 00a8 EF90      		pop r14
 1410               	.LVL113:
 1411 00aa DF90      		pop r13
 1412 00ac CF90      		pop r12
 1413 00ae BF90      		pop r11
 1414 00b0 AF90      		pop r10
 1415               	.LVL114:
 1416 00b2 0895      		ret
 1417               		.cfi_endproc
 1418               	.LFE158:
 1420               		.section	.text.MassStore_TestUnitReady,"ax",@progbits
 1421               	.global	MassStore_TestUnitReady
 1423               	MassStore_TestUnitReady:
 1424               	.LFB159:
 581:Lib/MassStoreCommands.c **** 
 582:Lib/MassStoreCommands.c **** /** Issues a SCSI Device Test Unit Ready command to the attached device, to determine if the device
 583:Lib/MassStoreCommands.c ****  *  other commands.
 584:Lib/MassStoreCommands.c ****  *
 585:Lib/MassStoreCommands.c ****  *  \param[in] LUNIndex      Index of the LUN inside the device the command is being addressed to
 586:Lib/MassStoreCommands.c ****  *
 587:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if
 588:Lib/MassStoreCommands.c ****  */
 589:Lib/MassStoreCommands.c **** uint8_t MassStore_TestUnitReady(const uint8_t LUNIndex)
 590:Lib/MassStoreCommands.c **** {
 1425               		.loc 1 590 0
 1426               		.cfi_startproc
 1427               	.LVL115:
 1428 0000 CF93      		push r28
 1429               	.LCFI48:
 1430               		.cfi_def_cfa_offset 3
 1431               		.cfi_offset 28, -2
 1432 0002 DF93      		push r29
 1433               	.LCFI49:
 1434               		.cfi_def_cfa_offset 4
 1435               		.cfi_offset 29, -3
 1436 0004 CDB7      		in r28,__SP_L__
 1437 0006 DEB7      		in r29,__SP_H__
 1438               	.LCFI50:
 1439               		.cfi_def_cfa_register 28
 1440 0008 AC97      		sbiw r28,44
 1441               	.LCFI51:
 1442               		.cfi_def_cfa_offset 48
 1443 000a 0FB6      		in __tmp_reg__,__SREG__
 1444 000c F894      		cli
 1445 000e DEBF      		out __SP_H__,r29
 1446 0010 0FBE      		out __SREG__,__tmp_reg__
 1447 0012 CDBF      		out __SP_L__,r28
 1448               	/* prologue: function */
 1449               	/* frame size = 44 */
 1450               	/* stack size = 46 */
 1451               	.L__stack_usage = 46
 1452               	.LVL116:
 591:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
 592:Lib/MassStoreCommands.c **** 
 593:Lib/MassStoreCommands.c **** 	/* Create a CBW with a SCSI command to issue TEST UNIT READY command */
 594:Lib/MassStoreCommands.c **** 	MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t)
 1453               		.loc 1 594 0
 1454 0014 FE01      		movw r30,r28
 1455 0016 3196      		adiw r30,1
 1456 0018 9FE1      		ldi r25,lo8(31)
 1457 001a DF01      		movw r26,r30
 1458               		0:
 1459 001c 1D92      		st X+,__zero_reg__
 1460 001e 9A95      		dec r25
 1461 0020 01F4      		brne 0b
 1462 0022 45E5      		ldi r20,lo8(85)
 1463 0024 53E5      		ldi r21,lo8(83)
 1464 0026 62E4      		ldi r22,lo8(66)
 1465 0028 73E4      		ldi r23,lo8(67)
 1466 002a 4983      		std Y+1,r20
 1467 002c 5A83      		std Y+2,r21
 1468 002e 6B83      		std Y+3,r22
 1469 0030 7C83      		std Y+4,r23
 1470 0032 90E8      		ldi r25,lo8(-128)
 1471 0034 9D87      		std Y+13,r25
 1472 0036 8E87      		std Y+14,r24
 1473 0038 86E0      		ldi r24,lo8(6)
 1474               	.LVL117:
 1475 003a 8F87      		std Y+15,r24
 595:Lib/MassStoreCommands.c **** 		{
 596:Lib/MassStoreCommands.c **** 			.Signature          = MS_CBW_SIGNATURE,
 597:Lib/MassStoreCommands.c **** 			.DataTransferLength = 0,
 598:Lib/MassStoreCommands.c **** 			.Flags              = MS_COMMAND_DIR_DATA_IN,
 599:Lib/MassStoreCommands.c **** 			.LUN                = LUNIndex,
 600:Lib/MassStoreCommands.c **** 			.SCSICommandLength  = 6,
 601:Lib/MassStoreCommands.c **** 			.SCSICommandData    =
 602:Lib/MassStoreCommands.c **** 				{
 603:Lib/MassStoreCommands.c **** 					SCSI_CMD_TEST_UNIT_READY,
 604:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 605:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 606:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 607:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 608:Lib/MassStoreCommands.c **** 					0x00                    // Unused (control)
 609:Lib/MassStoreCommands.c **** 				}
 610:Lib/MassStoreCommands.c **** 		};
 611:Lib/MassStoreCommands.c **** 
 612:Lib/MassStoreCommands.c **** 	MS_CommandStatusWrapper_t SCSICommandStatus;
 613:Lib/MassStoreCommands.c **** 
 614:Lib/MassStoreCommands.c **** 	/* Send the command and any data to the attached device */
 615:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, NULL)) != PIPE_RWSTREAM_NoError)
 1476               		.loc 1 615 0
 1477 003c 60E0      		ldi r22,0
 1478 003e 70E0      		ldi r23,0
 1479 0040 CF01      		movw r24,r30
 1480 0042 0E94 0000 		call MassStore_SendCommand.constprop.1
 1481               	.LVL118:
 1482 0046 8111      		cpse r24,__zero_reg__
 1483 0048 00C0      		rjmp .L76
 616:Lib/MassStoreCommands.c **** 	{
 617:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 618:Lib/MassStoreCommands.c **** 		return ErrorCode;
 619:Lib/MassStoreCommands.c **** 	}
 620:Lib/MassStoreCommands.c **** 
 621:Lib/MassStoreCommands.c **** 	/* Retrieve status information from the attached device */
 622:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
 1484               		.loc 1 622 0
 1485 004a CE01      		movw r24,r28
 1486               	.LVL119:
 1487 004c 8096      		adiw r24,32
 1488 004e 0E94 0000 		call MassStore_GetReturnedStatus
 1489               	.LVL120:
 1490 0052 8823      		tst r24
 1491 0054 01F0      		breq .L75
 1492               	.L76:
 1493               	.LBB276:
 1494               	.LBB277:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 1495               		.loc 3 381 0
 1496 0056 9091 A900 		lds r25,169
 1497 005a 9064      		ori r25,lo8(64)
 1498 005c 9093 A900 		sts 169,r25
 1499               	.LBE277:
 1500               	.LBE276:
 623:Lib/MassStoreCommands.c **** 	{
 624:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 625:Lib/MassStoreCommands.c **** 		return ErrorCode;
 1501               		.loc 1 625 0
 1502 0060 00C0      		rjmp .L74
 1503               	.L75:
 1504 0062 80E0      		ldi r24,0
 1505               	.LVL121:
 1506               	.L74:
 1507               	/* epilogue start */
 626:Lib/MassStoreCommands.c **** 	}
 627:Lib/MassStoreCommands.c **** 
 628:Lib/MassStoreCommands.c **** 	return ErrorCode;
 629:Lib/MassStoreCommands.c **** }
 1508               		.loc 1 629 0
 1509 0064 AC96      		adiw r28,44
 1510 0066 0FB6      		in __tmp_reg__,__SREG__
 1511 0068 F894      		cli
 1512 006a DEBF      		out __SP_H__,r29
 1513 006c 0FBE      		out __SREG__,__tmp_reg__
 1514 006e CDBF      		out __SP_L__,r28
 1515 0070 DF91      		pop r29
 1516 0072 CF91      		pop r28
 1517 0074 0895      		ret
 1518               		.cfi_endproc
 1519               	.LFE159:
 1521               		.section	.text.MassStore_ReadCapacity,"ax",@progbits
 1522               	.global	MassStore_ReadCapacity
 1524               	MassStore_ReadCapacity:
 1525               	.LFB160:
 630:Lib/MassStoreCommands.c **** 
 631:Lib/MassStoreCommands.c **** /** Issues a SCSI Device Read Capacity command to the attached device, to determine the capacity of
 632:Lib/MassStoreCommands.c ****  *  given Logical Unit within the device.
 633:Lib/MassStoreCommands.c ****  *
 634:Lib/MassStoreCommands.c ****  *  \param[in] LUNIndex      Index of the LUN inside the device the command is being addressed to
 635:Lib/MassStoreCommands.c ****  *  \param[out] CapacityPtr  Device capacity structure where the capacity data is to be stored
 636:Lib/MassStoreCommands.c ****  *
 637:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if
 638:Lib/MassStoreCommands.c ****  */
 639:Lib/MassStoreCommands.c **** uint8_t MassStore_ReadCapacity(const uint8_t LUNIndex,
 640:Lib/MassStoreCommands.c ****                                SCSI_Capacity_t* const CapacityPtr)
 641:Lib/MassStoreCommands.c **** {
 1526               		.loc 1 641 0
 1527               		.cfi_startproc
 1528               	.LVL122:
 1529 0000 0F93      		push r16
 1530               	.LCFI52:
 1531               		.cfi_def_cfa_offset 3
 1532               		.cfi_offset 16, -2
 1533 0002 1F93      		push r17
 1534               	.LCFI53:
 1535               		.cfi_def_cfa_offset 4
 1536               		.cfi_offset 17, -3
 1537 0004 CF93      		push r28
 1538               	.LCFI54:
 1539               		.cfi_def_cfa_offset 5
 1540               		.cfi_offset 28, -4
 1541 0006 DF93      		push r29
 1542               	.LCFI55:
 1543               		.cfi_def_cfa_offset 6
 1544               		.cfi_offset 29, -5
 1545 0008 CDB7      		in r28,__SP_L__
 1546 000a DEB7      		in r29,__SP_H__
 1547               	.LCFI56:
 1548               		.cfi_def_cfa_register 28
 1549 000c AC97      		sbiw r28,44
 1550               	.LCFI57:
 1551               		.cfi_def_cfa_offset 50
 1552 000e 0FB6      		in __tmp_reg__,__SREG__
 1553 0010 F894      		cli
 1554 0012 DEBF      		out __SP_H__,r29
 1555 0014 0FBE      		out __SREG__,__tmp_reg__
 1556 0016 CDBF      		out __SP_L__,r28
 1557               	/* prologue: function */
 1558               	/* frame size = 44 */
 1559               	/* stack size = 48 */
 1560               	.L__stack_usage = 48
 1561 0018 8B01      		movw r16,r22
 1562               	.LVL123:
 642:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
 643:Lib/MassStoreCommands.c **** 
 644:Lib/MassStoreCommands.c **** 	/* Create a CBW with a SCSI command to issue READ CAPACITY command */
 645:Lib/MassStoreCommands.c **** 	MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t)
 1563               		.loc 1 645 0
 1564 001a FE01      		movw r30,r28
 1565 001c 3196      		adiw r30,1
 1566 001e 9FE1      		ldi r25,lo8(31)
 1567 0020 DF01      		movw r26,r30
 1568               		0:
 1569 0022 1D92      		st X+,__zero_reg__
 1570 0024 9A95      		dec r25
 1571 0026 01F4      		brne 0b
 1572 0028 45E5      		ldi r20,lo8(85)
 1573 002a 53E5      		ldi r21,lo8(83)
 1574 002c 62E4      		ldi r22,lo8(66)
 1575 002e 73E4      		ldi r23,lo8(67)
 1576 0030 4983      		std Y+1,r20
 1577 0032 5A83      		std Y+2,r21
 1578 0034 6B83      		std Y+3,r22
 1579 0036 7C83      		std Y+4,r23
 1580 0038 48E0      		ldi r20,lo8(8)
 1581 003a 50E0      		ldi r21,0
 1582 003c 60E0      		ldi r22,0
 1583 003e 70E0      		ldi r23,0
 1584 0040 4987      		std Y+9,r20
 1585 0042 5A87      		std Y+10,r21
 1586 0044 6B87      		std Y+11,r22
 1587 0046 7C87      		std Y+12,r23
 1588 0048 90E8      		ldi r25,lo8(-128)
 1589 004a 9D87      		std Y+13,r25
 1590 004c 8E87      		std Y+14,r24
 1591 004e 8AE0      		ldi r24,lo8(10)
 1592               	.LVL124:
 1593 0050 8F87      		std Y+15,r24
 1594 0052 85E2      		ldi r24,lo8(37)
 1595 0054 888B      		std Y+16,r24
 646:Lib/MassStoreCommands.c **** 		{
 647:Lib/MassStoreCommands.c **** 			.Signature          = MS_CBW_SIGNATURE,
 648:Lib/MassStoreCommands.c **** 			.DataTransferLength = sizeof(SCSI_Capacity_t),
 649:Lib/MassStoreCommands.c **** 			.Flags              = MS_COMMAND_DIR_DATA_IN,
 650:Lib/MassStoreCommands.c **** 			.LUN                = LUNIndex,
 651:Lib/MassStoreCommands.c **** 			.SCSICommandLength  = 10,
 652:Lib/MassStoreCommands.c **** 			.SCSICommandData    =
 653:Lib/MassStoreCommands.c **** 				{
 654:Lib/MassStoreCommands.c **** 					SCSI_CMD_READ_CAPACITY_10,
 655:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 656:Lib/MassStoreCommands.c **** 					0x00,                   // MSB of Logical block address
 657:Lib/MassStoreCommands.c **** 					0x00,
 658:Lib/MassStoreCommands.c **** 					0x00,
 659:Lib/MassStoreCommands.c **** 					0x00,                   // LSB of Logical block address
 660:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 661:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 662:Lib/MassStoreCommands.c **** 					0x00,                   // Partial Medium Indicator
 663:Lib/MassStoreCommands.c **** 					0x00                    // Unused (control)
 664:Lib/MassStoreCommands.c **** 				}
 665:Lib/MassStoreCommands.c **** 		};
 666:Lib/MassStoreCommands.c **** 
 667:Lib/MassStoreCommands.c **** 	MS_CommandStatusWrapper_t SCSICommandStatus;
 668:Lib/MassStoreCommands.c **** 
 669:Lib/MassStoreCommands.c **** 	/* Send the command and any data to the attached device */
 670:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, CapacityPtr)) != PIPE_RWSTREAM_NoError)
 1596               		.loc 1 670 0
 1597 0056 B801      		movw r22,r16
 1598               	.LVL125:
 1599 0058 CF01      		movw r24,r30
 1600 005a 0E94 0000 		call MassStore_SendCommand.constprop.1
 1601               	.LVL126:
 1602 005e 8111      		cpse r24,__zero_reg__
 1603 0060 00C0      		rjmp .L81
 671:Lib/MassStoreCommands.c **** 	{
 672:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 673:Lib/MassStoreCommands.c **** 		return ErrorCode;
 674:Lib/MassStoreCommands.c **** 	}
 675:Lib/MassStoreCommands.c **** 
 676:Lib/MassStoreCommands.c **** 	/* Endian-correct the read data */
 677:Lib/MassStoreCommands.c **** 	CapacityPtr->Blocks    = SwapEndian_32(CapacityPtr->Blocks);
 1604               		.loc 1 677 0
 1605 0062 F801      		movw r30,r16
 1606 0064 6081      		ld r22,Z
 1607 0066 7181      		ldd r23,Z+1
 1608 0068 8281      		ldd r24,Z+2
 1609 006a 9381      		ldd r25,Z+3
 1610 006c 0E94 0000 		call SwapEndian_32
 1611               	.LVL127:
 1612 0070 D801      		movw r26,r16
 1613 0072 6D93      		st X+,r22
 1614 0074 7D93      		st X+,r23
 1615 0076 8D93      		st X+,r24
 1616 0078 9C93      		st X,r25
 1617 007a 1397      		sbiw r26,3
 678:Lib/MassStoreCommands.c **** 	CapacityPtr->BlockSize = SwapEndian_32(CapacityPtr->BlockSize);
 1618               		.loc 1 678 0
 1619 007c 1496      		adiw r26,4
 1620 007e 6D91      		ld r22,X+
 1621 0080 7D91      		ld r23,X+
 1622 0082 8D91      		ld r24,X+
 1623 0084 9C91      		ld r25,X
 1624 0086 1797      		sbiw r26,4+3
 1625 0088 0E94 0000 		call SwapEndian_32
 1626               	.LVL128:
 1627 008c F801      		movw r30,r16
 1628 008e 6483      		std Z+4,r22
 1629 0090 7583      		std Z+5,r23
 1630 0092 8683      		std Z+6,r24
 1631 0094 9783      		std Z+7,r25
 679:Lib/MassStoreCommands.c **** 
 680:Lib/MassStoreCommands.c **** 	/* Retrieve status information from the attached device */
 681:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
 1632               		.loc 1 681 0
 1633 0096 CE01      		movw r24,r28
 1634 0098 8096      		adiw r24,32
 1635 009a 0E94 0000 		call MassStore_GetReturnedStatus
 1636               	.LVL129:
 1637 009e 8823      		tst r24
 1638 00a0 01F0      		breq .L80
 1639               	.L81:
 1640               	.LBB278:
 1641               	.LBB279:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 1642               		.loc 3 381 0
 1643 00a2 9091 A900 		lds r25,169
 1644 00a6 9064      		ori r25,lo8(64)
 1645 00a8 9093 A900 		sts 169,r25
 1646               	.LBE279:
 1647               	.LBE278:
 682:Lib/MassStoreCommands.c **** 	{
 683:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 684:Lib/MassStoreCommands.c **** 		return ErrorCode;
 1648               		.loc 1 684 0
 1649 00ac 00C0      		rjmp .L79
 1650               	.L80:
 1651 00ae 80E0      		ldi r24,0
 1652               	.LVL130:
 1653               	.L79:
 1654               	/* epilogue start */
 685:Lib/MassStoreCommands.c **** 	}
 686:Lib/MassStoreCommands.c **** 
 687:Lib/MassStoreCommands.c **** 	return ErrorCode;
 688:Lib/MassStoreCommands.c **** }
 1655               		.loc 1 688 0
 1656 00b0 AC96      		adiw r28,44
 1657 00b2 0FB6      		in __tmp_reg__,__SREG__
 1658 00b4 F894      		cli
 1659 00b6 DEBF      		out __SP_H__,r29
 1660 00b8 0FBE      		out __SREG__,__tmp_reg__
 1661 00ba CDBF      		out __SP_L__,r28
 1662 00bc DF91      		pop r29
 1663 00be CF91      		pop r28
 1664 00c0 1F91      		pop r17
 1665 00c2 0F91      		pop r16
 1666               	.LVL131:
 1667 00c4 0895      		ret
 1668               		.cfi_endproc
 1669               	.LFE160:
 1671               		.section	.text.MassStore_PreventAllowMediumRemoval,"ax",@progbits
 1672               	.global	MassStore_PreventAllowMediumRemoval
 1674               	MassStore_PreventAllowMediumRemoval:
 1675               	.LFB161:
 689:Lib/MassStoreCommands.c **** 
 690:Lib/MassStoreCommands.c **** /** Issues a SCSI Device Prevent/Allow Medium Removal command to the attached device, to lock the p
 691:Lib/MassStoreCommands.c ****  *  being removed. This is a legacy command for SCSI disks with removable storage (such as ZIP disk
 692:Lib/MassStoreCommands.c ****  *  be issued before the first read or write command is sent.
 693:Lib/MassStoreCommands.c ****  *
 694:Lib/MassStoreCommands.c ****  *  \param[in] LUNIndex        Index of the LUN inside the device the command is being addressed to
 695:Lib/MassStoreCommands.c ****  *  \param[in] PreventRemoval  Whether or not the LUN media should be locked to prevent removal or 
 696:Lib/MassStoreCommands.c ****  *
 697:Lib/MassStoreCommands.c ****  *  \return A value from the Pipe_Stream_RW_ErrorCodes_t enum, or MASS_STORE_SCSI_COMMAND_FAILED if
 698:Lib/MassStoreCommands.c ****  */
 699:Lib/MassStoreCommands.c **** uint8_t MassStore_PreventAllowMediumRemoval(const uint8_t LUNIndex,
 700:Lib/MassStoreCommands.c ****                                             const bool PreventRemoval)
 701:Lib/MassStoreCommands.c **** {
 1676               		.loc 1 701 0
 1677               		.cfi_startproc
 1678               	.LVL132:
 1679 0000 0F93      		push r16
 1680               	.LCFI58:
 1681               		.cfi_def_cfa_offset 3
 1682               		.cfi_offset 16, -2
 1683 0002 1F93      		push r17
 1684               	.LCFI59:
 1685               		.cfi_def_cfa_offset 4
 1686               		.cfi_offset 17, -3
 1687 0004 CF93      		push r28
 1688               	.LCFI60:
 1689               		.cfi_def_cfa_offset 5
 1690               		.cfi_offset 28, -4
 1691 0006 DF93      		push r29
 1692               	.LCFI61:
 1693               		.cfi_def_cfa_offset 6
 1694               		.cfi_offset 29, -5
 1695 0008 CDB7      		in r28,__SP_L__
 1696 000a DEB7      		in r29,__SP_H__
 1697               	.LCFI62:
 1698               		.cfi_def_cfa_register 28
 1699 000c AC97      		sbiw r28,44
 1700               	.LCFI63:
 1701               		.cfi_def_cfa_offset 50
 1702 000e 0FB6      		in __tmp_reg__,__SREG__
 1703 0010 F894      		cli
 1704 0012 DEBF      		out __SP_H__,r29
 1705 0014 0FBE      		out __SREG__,__tmp_reg__
 1706 0016 CDBF      		out __SP_L__,r28
 1707               	/* prologue: function */
 1708               	/* frame size = 44 */
 1709               	/* stack size = 48 */
 1710               	.L__stack_usage = 48
 1711               	.LVL133:
 702:Lib/MassStoreCommands.c **** 	uint8_t ErrorCode = PIPE_RWSTREAM_NoError;
 703:Lib/MassStoreCommands.c **** 
 704:Lib/MassStoreCommands.c **** 	/* Create a CBW with a SCSI command to issue PREVENT ALLOW MEDIUM REMOVAL command */
 705:Lib/MassStoreCommands.c **** 	MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t)
 1712               		.loc 1 705 0
 1713 0018 FE01      		movw r30,r28
 1714 001a 3196      		adiw r30,1
 1715 001c 9FE1      		ldi r25,lo8(31)
 1716 001e DF01      		movw r26,r30
 1717               		0:
 1718 0020 1D92      		st X+,__zero_reg__
 1719 0022 9A95      		dec r25
 1720 0024 01F4      		brne 0b
 1721 0026 05E5      		ldi r16,lo8(85)
 1722 0028 13E5      		ldi r17,lo8(83)
 1723 002a 22E4      		ldi r18,lo8(66)
 1724 002c 33E4      		ldi r19,lo8(67)
 1725 002e 0983      		std Y+1,r16
 1726 0030 1A83      		std Y+2,r17
 1727 0032 2B83      		std Y+3,r18
 1728 0034 3C83      		std Y+4,r19
 1729 0036 8E87      		std Y+14,r24
 1730 0038 86E0      		ldi r24,lo8(6)
 1731               	.LVL134:
 1732 003a 8F87      		std Y+15,r24
 1733 003c 8EE1      		ldi r24,lo8(30)
 1734 003e 888B      		std Y+16,r24
 1735 0040 6B8B      		std Y+19,r22
 706:Lib/MassStoreCommands.c **** 		{
 707:Lib/MassStoreCommands.c **** 			.Signature          = MS_CBW_SIGNATURE,
 708:Lib/MassStoreCommands.c **** 			.DataTransferLength = 0,
 709:Lib/MassStoreCommands.c **** 			.Flags              = MS_COMMAND_DIR_DATA_OUT,
 710:Lib/MassStoreCommands.c **** 			.LUN                = LUNIndex,
 711:Lib/MassStoreCommands.c **** 			.SCSICommandLength  = 6,
 712:Lib/MassStoreCommands.c **** 			.SCSICommandData    =
 713:Lib/MassStoreCommands.c **** 				{
 714:Lib/MassStoreCommands.c **** 					SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL,
 715:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 716:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 717:Lib/MassStoreCommands.c **** 					PreventRemoval,         // Prevent flag
 718:Lib/MassStoreCommands.c **** 					0x00,                   // Reserved
 719:Lib/MassStoreCommands.c **** 					0x00                    // Unused (control)
 720:Lib/MassStoreCommands.c **** 				}
 721:Lib/MassStoreCommands.c **** 		};
 722:Lib/MassStoreCommands.c **** 
 723:Lib/MassStoreCommands.c **** 	MS_CommandStatusWrapper_t SCSICommandStatus;
 724:Lib/MassStoreCommands.c **** 
 725:Lib/MassStoreCommands.c **** 	/* Send the command and any data to the attached device */
 726:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, NULL)) != PIPE_RWSTREAM_NoError)
 1736               		.loc 1 726 0
 1737 0042 60E0      		ldi r22,0
 1738 0044 70E0      		ldi r23,0
 1739               	.LVL135:
 1740 0046 CF01      		movw r24,r30
 1741 0048 0E94 0000 		call MassStore_SendCommand.constprop.1
 1742               	.LVL136:
 1743 004c 8111      		cpse r24,__zero_reg__
 1744 004e 00C0      		rjmp .L86
 727:Lib/MassStoreCommands.c **** 	{
 728:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 729:Lib/MassStoreCommands.c **** 		return ErrorCode;
 730:Lib/MassStoreCommands.c **** 	}
 731:Lib/MassStoreCommands.c **** 
 732:Lib/MassStoreCommands.c **** 	/* Retrieve status information from the attached device */
 733:Lib/MassStoreCommands.c **** 	if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
 1745               		.loc 1 733 0
 1746 0050 CE01      		movw r24,r28
 1747               	.LVL137:
 1748 0052 8096      		adiw r24,32
 1749 0054 0E94 0000 		call MassStore_GetReturnedStatus
 1750               	.LVL138:
 1751 0058 8823      		tst r24
 1752 005a 01F0      		breq .L85
 1753               	.L86:
 1754               	.LBB280:
 1755               	.LBB281:
 381:../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/../AVR8/Pipe_AVR8.h **** 			}
 1756               		.loc 3 381 0
 1757 005c 9091 A900 		lds r25,169
 1758 0060 9064      		ori r25,lo8(64)
 1759 0062 9093 A900 		sts 169,r25
 1760               	.LBE281:
 1761               	.LBE280:
 734:Lib/MassStoreCommands.c **** 	{
 735:Lib/MassStoreCommands.c **** 		Pipe_Freeze();
 736:Lib/MassStoreCommands.c **** 		return ErrorCode;
 1762               		.loc 1 736 0
 1763 0066 00C0      		rjmp .L84
 1764               	.L85:
 1765 0068 80E0      		ldi r24,0
 1766               	.LVL139:
 1767               	.L84:
 1768               	/* epilogue start */
 737:Lib/MassStoreCommands.c **** 	}
 738:Lib/MassStoreCommands.c **** 
 739:Lib/MassStoreCommands.c **** 	return ErrorCode;
 740:Lib/MassStoreCommands.c **** }
 1769               		.loc 1 740 0
 1770 006a AC96      		adiw r28,44
 1771 006c 0FB6      		in __tmp_reg__,__SREG__
 1772 006e F894      		cli
 1773 0070 DEBF      		out __SP_H__,r29
 1774 0072 0FBE      		out __SREG__,__tmp_reg__
 1775 0074 CDBF      		out __SP_L__,r28
 1776 0076 DF91      		pop r29
 1777 0078 CF91      		pop r28
 1778 007a 1F91      		pop r17
 1779 007c 0F91      		pop r16
 1780 007e 0895      		ret
 1781               		.cfi_endproc
 1782               	.LFE161:
 1784               		.data
 1787               	MassStore_Tag:
 1788 0000 01        		.byte	1
 1789 0001 00        		.byte	0
 1790 0002 00        		.byte	0
 1791 0003 00        		.byte	0
 1792               		.text
 1793               	.Letext0:
 1794               		.file 5 "/usr/lib/avr/include/stdint.h"
 1795               		.file 6 "/usr/lib/avr/include/stdio.h"
 1796               		.file 7 "../../../../LUFA/Drivers/USB/Core/AVR8/../Host.h"
 1797               		.file 8 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 1798               		.file 9 "../../../../LUFA/Drivers/USB/Core/AVR8/../HostStandardReq.h"
 1799               		.file 10 "../../../../LUFA/Drivers/USB/Core/AVR8/../PipeStream.h"
 1800               		.file 11 "../../../../LUFA/Drivers/USB/Class/Host/../Common/MassStorage.h"
 1801               		.file 12 "../../../../LUFA/Drivers/USB/Class/Host/MassStorage.h"
 1802               		.file 13 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
 1803               		.file 14 "../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h"
 1804               		.file 15 "../../../../LUFA/Drivers/USB/Core/AVR8/../AVR8/PipeStream_AVR8.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 MassStoreCommands.c
     /tmp/ccb1eeh6.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccb1eeh6.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccb1eeh6.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccb1eeh6.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccb1eeh6.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccb1eeh6.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccb1eeh6.s:13     .text.MassStore_WaitForDataReceived:0000000000000000 MassStore_WaitForDataReceived
     /tmp/ccb1eeh6.s:268    .text.MassStore_GetReturnedStatus:0000000000000000 MassStore_GetReturnedStatus
     /tmp/ccb1eeh6.s:354    .text.SwapEndian_32:0000000000000000 SwapEndian_32
     /tmp/ccb1eeh6.s:377    .text.MassStore_SendCommand.constprop.1:0000000000000000 MassStore_SendCommand.constprop.1
     /tmp/ccb1eeh6.s:1787   .data:0000000000000000 MassStore_Tag
     /tmp/ccb1eeh6.s:666    .text.MassStore_MassStorageReset:0000000000000000 MassStore_MassStorageReset
     /tmp/ccb1eeh6.s:790    .text.MassStore_GetMaxLUN:0000000000000000 MassStore_GetMaxLUN
     /tmp/ccb1eeh6.s:863    .text.MassStore_Inquiry:0000000000000000 MassStore_Inquiry
     /tmp/ccb1eeh6.s:984    .text.MassStore_RequestSense:0000000000000000 MassStore_RequestSense
     /tmp/ccb1eeh6.s:1105   .text.MassStore_ReadDeviceBlock:0000000000000000 MassStore_ReadDeviceBlock
     /tmp/ccb1eeh6.s:1265   .text.MassStore_WriteDeviceBlock:0000000000000000 MassStore_WriteDeviceBlock
     /tmp/ccb1eeh6.s:1423   .text.MassStore_TestUnitReady:0000000000000000 MassStore_TestUnitReady
     /tmp/ccb1eeh6.s:1524   .text.MassStore_ReadCapacity:0000000000000000 MassStore_ReadCapacity
     /tmp/ccb1eeh6.s:1674   .text.MassStore_PreventAllowMediumRemoval:0000000000000000 MassStore_PreventAllowMediumRemoval

UNDEFINED SYMBOLS
USB_Host_ClearEndpointStall
USB_HostState
Pipe_Read_Stream_LE
Pipe_Write_Stream_LE
Pipe_WaitUntilReady
USB_ControlRequest
USB_Host_SendControlRequest
__umulhisi3
__do_copy_data
