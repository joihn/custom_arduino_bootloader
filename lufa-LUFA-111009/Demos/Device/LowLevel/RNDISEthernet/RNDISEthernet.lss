
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  0000292e  000029c2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000292e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012af  00800146  00800146  00002a08  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00002a08  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002a1c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000430  00000000  00000000  00002a5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000096b4  00000000  00000000  00002e8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003138  00000000  00000000  0000c540  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000047c3  00000000  00000000  0000f678  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d18  00000000  00000000  00013e3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003314  00000000  00000000  00014b54  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004dff  00000000  00000000  00017e68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004d8  00000000  00000000  0001cc67  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	2f c2       	rjmp	.+1118   	; 0x460 <__ctors_end>
       2:	00 00       	nop
       4:	4b c2       	rjmp	.+1174   	; 0x49c <__bad_interrupt>
       6:	00 00       	nop
       8:	49 c2       	rjmp	.+1170   	; 0x49c <__bad_interrupt>
       a:	00 00       	nop
       c:	47 c2       	rjmp	.+1166   	; 0x49c <__bad_interrupt>
       e:	00 00       	nop
      10:	45 c2       	rjmp	.+1162   	; 0x49c <__bad_interrupt>
      12:	00 00       	nop
      14:	43 c2       	rjmp	.+1158   	; 0x49c <__bad_interrupt>
      16:	00 00       	nop
      18:	41 c2       	rjmp	.+1154   	; 0x49c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	3f c2       	rjmp	.+1150   	; 0x49c <__bad_interrupt>
      1e:	00 00       	nop
      20:	3d c2       	rjmp	.+1146   	; 0x49c <__bad_interrupt>
      22:	00 00       	nop
      24:	3b c2       	rjmp	.+1142   	; 0x49c <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 61 10 	jmp	0x20c2	; 0x20c2 <__vector_10>
      2c:	37 c2       	rjmp	.+1134   	; 0x49c <__bad_interrupt>
      2e:	00 00       	nop
      30:	35 c2       	rjmp	.+1130   	; 0x49c <__bad_interrupt>
      32:	00 00       	nop
      34:	33 c2       	rjmp	.+1126   	; 0x49c <__bad_interrupt>
      36:	00 00       	nop
      38:	31 c2       	rjmp	.+1122   	; 0x49c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	2f c2       	rjmp	.+1118   	; 0x49c <__bad_interrupt>
      3e:	00 00       	nop
      40:	2d c2       	rjmp	.+1114   	; 0x49c <__bad_interrupt>
      42:	00 00       	nop
      44:	2b c2       	rjmp	.+1110   	; 0x49c <__bad_interrupt>
      46:	00 00       	nop
      48:	29 c2       	rjmp	.+1106   	; 0x49c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	27 c2       	rjmp	.+1102   	; 0x49c <__bad_interrupt>
      4e:	00 00       	nop
      50:	25 c2       	rjmp	.+1098   	; 0x49c <__bad_interrupt>
      52:	00 00       	nop
      54:	23 c2       	rjmp	.+1094   	; 0x49c <__bad_interrupt>
      56:	00 00       	nop
      58:	21 c2       	rjmp	.+1090   	; 0x49c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	1f c2       	rjmp	.+1086   	; 0x49c <__bad_interrupt>
      5e:	00 00       	nop
      60:	1d c2       	rjmp	.+1082   	; 0x49c <__bad_interrupt>
      62:	00 00       	nop
      64:	1b c2       	rjmp	.+1078   	; 0x49c <__bad_interrupt>
      66:	00 00       	nop
      68:	19 c2       	rjmp	.+1074   	; 0x49c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	17 c2       	rjmp	.+1070   	; 0x49c <__bad_interrupt>
      6e:	00 00       	nop
      70:	15 c2       	rjmp	.+1066   	; 0x49c <__bad_interrupt>
      72:	00 00       	nop
      74:	13 c2       	rjmp	.+1062   	; 0x49c <__bad_interrupt>
      76:	00 00       	nop
      78:	11 c2       	rjmp	.+1058   	; 0x49c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	0f c2       	rjmp	.+1054   	; 0x49c <__bad_interrupt>
      7e:	00 00       	nop
      80:	0d c2       	rjmp	.+1050   	; 0x49c <__bad_interrupt>
      82:	00 00       	nop
      84:	0b c2       	rjmp	.+1046   	; 0x49c <__bad_interrupt>
      86:	00 00       	nop
      88:	09 c2       	rjmp	.+1042   	; 0x49c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	07 c2       	rjmp	.+1038   	; 0x49c <__bad_interrupt>
      8e:	00 00       	nop
      90:	05 c2       	rjmp	.+1034   	; 0x49c <__bad_interrupt>
      92:	00 00       	nop
      94:	03 c2       	rjmp	.+1030   	; 0x49c <__bad_interrupt>
      96:	00 00       	nop
      98:	54 08       	sbc	r5, r4
      9a:	ae 09       	sbc	r26, r14
      9c:	88 08       	sbc	r8, r8
      9e:	ab 08       	sbc	r10, r11
      a0:	6d 09       	sbc	r22, r13
      a2:	74 09       	sbc	r23, r4
      a4:	a2 09       	sbc	r26, r2
      a6:	55 09       	sbc	r21, r5
      a8:	d7 12       	cpse	r13, r23
      aa:	f9 12       	cpse	r15, r25
      ac:	e8 13       	cpse	r30, r24
      ae:	f9 12       	cpse	r15, r25
      b0:	e8 13       	cpse	r30, r24
      b2:	3e 13       	cpse	r19, r30
      b4:	61 13       	cpse	r22, r17
      b6:	e8 13       	cpse	r30, r24
      b8:	b4 13       	cpse	r27, r20
      ba:	c6 13       	cpse	r28, r22

000000bc <ProductString>:
      bc:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
      cc:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
      dc:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

000000e6 <ManufacturerString>:
      e6:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      f6:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000100 <LanguageString>:
     100:	04 03 09 04                                         ....

00000104 <ConfigurationDescriptor>:
     104:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     114:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
     124:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     134:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

00000142 <DeviceDescriptor>:
     142:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
     152:	00 01                                               ..

00000154 <HTTPPage>:
     154:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     164:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     174:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     184:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     194:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     1a4:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     1b4:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     1c4:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     1d4:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     1e4:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     1f4:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     204:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     214:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     224:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     234:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     244:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     254:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     264:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     274:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     284:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     294:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     2a4:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     2b4:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     2c4:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     2d4:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     2e4:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     2f4:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     304:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     314:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     324:	3c 2f 69 3e 31 31 31 30 30 39 09 09 3c 2f 70 3e     </i>111009..</p>
     334:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

00000344 <HTTP404Header>:
     344:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     354:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     364:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     374:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     384:	0a 00                                               ..

00000386 <HTTP200Header>:
     386:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     396:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     3a6:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     3b6:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     3c6:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     3d6:	0a 0d 0a 00                                         ....

000003da <AdapterSupportedOIDList>:
     3da:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3ea:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3fa:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     40a:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     41a:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     42a:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     43a:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000446 <AdapterVendorDescription>:
     446:	4c 55 46 41 20 52 4e 44 49 53 20 41 64 61 70 74     LUFA RNDIS Adapt
     456:	65 72 00                                            er.

00000459 <AdapterMACAddress>:
     459:	02 00 02 00 02 00 00                                .......

00000460 <__ctors_end>:
     460:	11 24       	eor	r1, r1
     462:	1f be       	out	0x3f, r1	; 63
     464:	cf ef       	ldi	r28, 0xFF	; 255
     466:	d0 e2       	ldi	r29, 0x20	; 32
     468:	de bf       	out	0x3e, r29	; 62
     46a:	cd bf       	out	0x3d, r28	; 61

0000046c <__do_copy_data>:
     46c:	11 e0       	ldi	r17, 0x01	; 1
     46e:	a0 e0       	ldi	r26, 0x00	; 0
     470:	b1 e0       	ldi	r27, 0x01	; 1
     472:	ee e2       	ldi	r30, 0x2E	; 46
     474:	f9 e2       	ldi	r31, 0x29	; 41
     476:	00 e0       	ldi	r16, 0x00	; 0
     478:	0b bf       	out	0x3b, r16	; 59
     47a:	02 c0       	rjmp	.+4      	; 0x480 <__do_copy_data+0x14>
     47c:	07 90       	elpm	r0, Z+
     47e:	0d 92       	st	X+, r0
     480:	a6 34       	cpi	r26, 0x46	; 70
     482:	b1 07       	cpc	r27, r17
     484:	d9 f7       	brne	.-10     	; 0x47c <__do_copy_data+0x10>

00000486 <__do_clear_bss>:
     486:	23 e1       	ldi	r18, 0x13	; 19
     488:	a6 e4       	ldi	r26, 0x46	; 70
     48a:	b1 e0       	ldi	r27, 0x01	; 1
     48c:	01 c0       	rjmp	.+2      	; 0x490 <.do_clear_bss_start>

0000048e <.do_clear_bss_loop>:
     48e:	1d 92       	st	X+, r1

00000490 <.do_clear_bss_start>:
     490:	a5 3f       	cpi	r26, 0xF5	; 245
     492:	b2 07       	cpc	r27, r18
     494:	e1 f7       	brne	.-8      	; 0x48e <.do_clear_bss_loop>
     496:	a6 d1       	rcall	.+844    	; 0x7e4 <main>
     498:	0c 94 95 14 	jmp	0x292a	; 0x292a <_exit>

0000049c <__bad_interrupt>:
     49c:	b1 cd       	rjmp	.-1182   	; 0x0 <__vectors>

0000049e <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     49e:	9b b1       	in	r25, 0x0b	; 11
     4a0:	9f 70       	andi	r25, 0x0F	; 15
     4a2:	89 2b       	or	r24, r25
     4a4:	8b b9       	out	0x0b, r24	; 11
     4a6:	08 95       	ret

000004a8 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     4a8:	84 b7       	in	r24, 0x34	; 52
     4aa:	87 7f       	andi	r24, 0xF7	; 247
     4ac:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     4ae:	0f b6       	in	r0, 0x3f	; 63
     4b0:	f8 94       	cli
     4b2:	a8 95       	wdr
     4b4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     4b8:	88 61       	ori	r24, 0x18	; 24
     4ba:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     4be:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     4c2:	0f be       	out	0x3f, r0	; 63
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	80 e8       	ldi	r24, 0x80	; 128
     4c8:	0f b6       	in	r0, 0x3f	; 63
     4ca:	f8 94       	cli
     4cc:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
     4d0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
     4d4:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4d6:	8a b1       	in	r24, 0x0a	; 10
     4d8:	80 6f       	ori	r24, 0xF0	; 240
     4da:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4dc:	8b b1       	in	r24, 0x0b	; 11
     4de:	8f 70       	andi	r24, 0x0F	; 15
     4e0:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4e2:	83 e3       	ldi	r24, 0x33	; 51
     4e4:	90 e0       	ldi	r25, 0x00	; 0
     4e6:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
     4ea:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4ee:	86 e0       	ldi	r24, 0x06	; 6
     4f0:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4f4:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4f8:	88 e1       	ldi	r24, 0x18	; 24
     4fa:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

				DDRD  |= (1 << 3);
     4fe:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     500:	5a 9a       	sbi	0x0b, 2	; 11
	clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     502:	0e 94 4b 10 	call	0x2096	; 0x2096 <USB_Init>
			static inline void Serial_CreateStream(FILE* Stream)
			{
				if (!(Stream))
				{
					Stream = &USARTSerialStream;
					stdin  = Stream;
     506:	af ee       	ldi	r26, 0xEF	; 239
     508:	b3 e1       	ldi	r27, 0x13	; 19
     50a:	e1 ee       	ldi	r30, 0xE1	; 225
     50c:	f3 e1       	ldi	r31, 0x13	; 19
     50e:	11 96       	adiw	r26, 0x01	; 1
     510:	fc 93       	st	X, r31
     512:	ee 93       	st	-X, r30
					stdout = Stream;
     514:	13 96       	adiw	r26, 0x03	; 3
     516:	fc 93       	st	X, r31
     518:	ee 93       	st	-X, r30
     51a:	12 97       	sbiw	r26, 0x02	; 2
				}
			
				*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
     51c:	8e e0       	ldi	r24, 0x0E	; 14
     51e:	df 01       	movw	r26, r30
     520:	1d 92       	st	X+, r1
     522:	8a 95       	dec	r24
     524:	e9 f7       	brne	.-6      	; 0x520 <SetupHardware+0x78>
     526:	83 e0       	ldi	r24, 0x03	; 3
     528:	83 83       	std	Z+3, r24	; 0x03
     52a:	84 e1       	ldi	r24, 0x14	; 20
     52c:	94 e1       	ldi	r25, 0x14	; 20
     52e:	91 87       	std	Z+9, r25	; 0x09
     530:	80 87       	std	Z+8, r24	; 0x08
     532:	8d e1       	ldi	r24, 0x1D	; 29
     534:	94 e1       	ldi	r25, 0x14	; 20
     536:	93 87       	std	Z+11, r25	; 0x0b
     538:	82 87       	std	Z+10, r24	; 0x0a
     53a:	08 95       	ret

0000053c <EVENT_USB_Device_Connect>:
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Device_Connect(void)
{
	/* Indicate USB enumerating */
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     53c:	80 ea       	ldi	r24, 0xA0	; 160
     53e:	af cf       	rjmp	.-162    	; 0x49e <LEDs_SetAllLEDs>

00000540 <EVENT_USB_Device_Disconnect>:
 *  the status LEDs and stops all the relevant tasks.
 */
void EVENT_USB_Device_Disconnect(void)
{
	/* Indicate USB not ready */
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     540:	80 e1       	ldi	r24, 0x10	; 16
     542:	ad cf       	rjmp	.-166    	; 0x49e <LEDs_SetAllLEDs>

00000544 <EVENT_USB_Device_ConfigurationChanged>:

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the RNDIS device endpoints and starts the relevant tasks.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     544:	cf 93       	push	r28
     546:	df 93       	push	r29
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
     548:	42 e3       	ldi	r20, 0x32	; 50
     54a:	61 e8       	ldi	r22, 0x81	; 129
     54c:	81 e0       	ldi	r24, 0x01	; 1
     54e:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <Endpoint_ConfigureEndpoint_Prv>
     552:	c8 2f       	mov	r28, r24
     554:	42 e3       	ldi	r20, 0x32	; 50
     556:	60 e8       	ldi	r22, 0x80	; 128
     558:	82 e0       	ldi	r24, 0x02	; 2
     55a:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <Endpoint_ConfigureEndpoint_Prv>
     55e:	d8 2f       	mov	r29, r24
     560:	42 e0       	ldi	r20, 0x02	; 2
     562:	61 ec       	ldi	r22, 0xC1	; 193
     564:	83 e0       	ldi	r24, 0x03	; 3
     566:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <Endpoint_ConfigureEndpoint_Prv>
	                                            CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
	                                            CDC_NOTIFICATION_EPSIZE, ENDPOINT_BANK_SINGLE);

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     56a:	cd 23       	and	r28, r29
     56c:	11 f0       	breq	.+4      	; 0x572 <EVENT_USB_Device_ConfigurationChanged+0x2e>
     56e:	81 11       	cpse	r24, r1
     570:	02 c0       	rjmp	.+4      	; 0x576 <EVENT_USB_Device_ConfigurationChanged+0x32>
     572:	80 e9       	ldi	r24, 0x90	; 144
     574:	01 c0       	rjmp	.+2      	; 0x578 <EVENT_USB_Device_ConfigurationChanged+0x34>
     576:	80 e6       	ldi	r24, 0x60	; 96
}
     578:	df 91       	pop	r29
     57a:	cf 91       	pop	r28
	                                            CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
	                                            CDC_NOTIFICATION_EPSIZE, ENDPOINT_BANK_SINGLE);

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     57c:	90 cf       	rjmp	.-224    	; 0x49e <LEDs_SetAllLEDs>

0000057e <EVENT_USB_Device_ControlRequest>:
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
	/* Process RNDIS class commands */
	switch (USB_ControlRequest.bRequest)
     57e:	80 91 da 13 	lds	r24, 0x13DA	; 0x8013da <USB_ControlRequest+0x1>
     582:	88 23       	and	r24, r24
     584:	19 f0       	breq	.+6      	; 0x58c <EVENT_USB_Device_ControlRequest+0xe>
     586:	81 30       	cpi	r24, 0x01	; 1
     588:	d1 f0       	breq	.+52     	; 0x5be <EVENT_USB_Device_ControlRequest+0x40>
     58a:	08 95       	ret
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     58c:	80 91 d9 13 	lds	r24, 0x13D9	; 0x8013d9 <USB_ControlRequest>
     590:	81 32       	cpi	r24, 0x21	; 33
     592:	09 f0       	breq	.+2      	; 0x596 <EVENT_USB_Device_ControlRequest+0x18>
     594:	4a c0       	rjmp	.+148    	; 0x62a <EVENT_USB_Device_ControlRequest+0xac>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     596:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     59a:	87 7f       	andi	r24, 0xF7	; 247
     59c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			{
				Endpoint_ClearSETUP();

				/* Read in the RNDIS message into the message buffer */
				Endpoint_Read_Control_Stream_LE(RNDISMessageBuffer, USB_ControlRequest.wLength);
     5a0:	60 91 df 13 	lds	r22, 0x13DF	; 0x8013df <USB_ControlRequest+0x6>
     5a4:	70 91 e0 13 	lds	r23, 0x13E0	; 0x8013e0 <USB_ControlRequest+0x7>
     5a8:	80 e5       	ldi	r24, 0x50	; 80
     5aa:	93 e1       	ldi	r25, 0x13	; 19
     5ac:	0e 94 17 12 	call	0x242e	; 0x242e <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     5b0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     5b4:	8e 77       	andi	r24, 0x7E	; 126
     5b6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
				Endpoint_ClearIN();

				/* Process the RNDIS message */
				ProcessRNDISControlMessage();
     5ba:	0c 94 ec 0c 	jmp	0x19d8	; 0x19d8 <ProcessRNDISControlMessage>
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     5be:	80 91 d9 13 	lds	r24, 0x13D9	; 0x8013d9 <USB_ControlRequest>
     5c2:	81 3a       	cpi	r24, 0xA1	; 161
     5c4:	91 f5       	brne	.+100    	; 0x62a <EVENT_USB_Device_ControlRequest+0xac>
			{
				/* Check if a response to the last message is ready */
				if (!(MessageHeader->MessageLength))
     5c6:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     5ca:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     5ce:	84 81       	ldd	r24, Z+4	; 0x04
     5d0:	95 81       	ldd	r25, Z+5	; 0x05
     5d2:	a6 81       	ldd	r26, Z+6	; 0x06
     5d4:	b7 81       	ldd	r27, Z+7	; 0x07
     5d6:	89 2b       	or	r24, r25
     5d8:	8a 2b       	or	r24, r26
     5da:	8b 2b       	or	r24, r27
     5dc:	51 f4       	brne	.+20     	; 0x5f2 <EVENT_USB_Device_ControlRequest+0x74>
				{
					/* Set the response to a single 0x00 byte to indicate that no response is ready */
					RNDISMessageBuffer[0] = 0;
     5de:	10 92 50 13 	sts	0x1350, r1	; 0x801350 <RNDISMessageBuffer>
					MessageHeader->MessageLength = 1;
     5e2:	81 e0       	ldi	r24, 0x01	; 1
     5e4:	90 e0       	ldi	r25, 0x00	; 0
     5e6:	a0 e0       	ldi	r26, 0x00	; 0
     5e8:	b0 e0       	ldi	r27, 0x00	; 0
     5ea:	84 83       	std	Z+4, r24	; 0x04
     5ec:	95 83       	std	Z+5, r25	; 0x05
     5ee:	a6 83       	std	Z+6, r26	; 0x06
     5f0:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     5f2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     5f6:	87 7f       	andi	r24, 0xF7	; 247
     5f8:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
				}

				Endpoint_ClearSETUP();

				/* Write the message response data to the endpoint */
				Endpoint_Write_Control_Stream_LE(RNDISMessageBuffer, MessageHeader->MessageLength);
     5fc:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     600:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     604:	64 81       	ldd	r22, Z+4	; 0x04
     606:	75 81       	ldd	r23, Z+5	; 0x05
     608:	80 e5       	ldi	r24, 0x50	; 80
     60a:	93 e1       	ldi	r25, 0x13	; 19
     60c:	0e 94 bf 11 	call	0x237e	; 0x237e <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     610:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     614:	8b 77       	andi	r24, 0x7B	; 123
     616:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
				Endpoint_ClearOUT();

				/* Reset the message header once again after transmission */
				MessageHeader->MessageLength = 0;
     61a:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     61e:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     622:	14 82       	std	Z+4, r1	; 0x04
     624:	15 82       	std	Z+5, r1	; 0x05
     626:	16 82       	std	Z+6, r1	; 0x06
     628:	17 82       	std	Z+7, r1	; 0x07
     62a:	08 95       	ret

0000062c <RNDIS_Task>:
/** Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS
 *  wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper
 *  to a frame in the FrameOUT global before sending the buffer contents to the host.
 */
void RNDIS_Task(void)
{
     62c:	0f 93       	push	r16
     62e:	1f 93       	push	r17
     630:	cf 93       	push	r28
     632:	df 93       	push	r29
     634:	cd b7       	in	r28, 0x3d	; 61
     636:	de b7       	in	r29, 0x3e	; 62
     638:	ac 97       	sbiw	r28, 0x2c	; 44
     63a:	0f b6       	in	r0, 0x3f	; 63
     63c:	f8 94       	cli
     63e:	de bf       	out	0x3e, r29	; 62
     640:	0f be       	out	0x3f, r0	; 63
     642:	cd bf       	out	0x3d, r28	; 61
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     644:	83 e0       	ldi	r24, 0x03	; 3
     646:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     64a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	/* Select the notification endpoint */
	Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

	/* Check if a message response is ready for the host */
	if (Endpoint_IsINReady() && ResponseReady)
     64e:	80 ff       	sbrs	r24, 0
     650:	1c c0       	rjmp	.+56     	; 0x68a <RNDIS_Task+0x5e>
     652:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <ResponseReady>
     656:	88 23       	and	r24, r24
     658:	c1 f0       	breq	.+48     	; 0x68a <RNDIS_Task+0x5e>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
     65a:	88 e0       	ldi	r24, 0x08	; 8
     65c:	e2 e0       	ldi	r30, 0x02	; 2
     65e:	f1 e0       	ldi	r31, 0x01	; 1
     660:	de 01       	movw	r26, r28
     662:	11 96       	adiw	r26, 0x01	; 1
     664:	01 90       	ld	r0, Z+
     666:	0d 92       	st	X+, r0
     668:	8a 95       	dec	r24
     66a:	e1 f7       	brne	.-8      	; 0x664 <RNDIS_Task+0x38>
				.wIndex        = 0,
				.wLength       = 0,
			};

		/* Indicate that a message response is ready for the host */
		Endpoint_Write_Stream_LE(&Notification, sizeof(Notification), NULL);
     66c:	40 e0       	ldi	r20, 0x00	; 0
     66e:	50 e0       	ldi	r21, 0x00	; 0
     670:	68 e0       	ldi	r22, 0x08	; 8
     672:	70 e0       	ldi	r23, 0x00	; 0
     674:	ce 01       	movw	r24, r28
     676:	01 96       	adiw	r24, 0x01	; 1
     678:	0e 94 2b 11 	call	0x2256	; 0x2256 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     67c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     680:	8e 77       	andi	r24, 0x7E	; 126
     682:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();

		/* Indicate a response is no longer ready */
		ResponseReady = false;
     686:	10 92 4c 01 	sts	0x014C, r1	; 0x80014c <ResponseReady>
	}

	/* Don't process the data endpoints until the system is in the data initialized state, and the buffer is free */
	if ((CurrRNDISState == RNDIS_Data_Initialized) && !(MessageHeader->MessageLength))
     68a:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <CurrRNDISState>
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	09 f0       	breq	.+2      	; 0x694 <RNDIS_Task+0x68>
     692:	8d c0       	rjmp	.+282    	; 0x7ae <RNDIS_Task+0x182>
     694:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     698:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     69c:	44 81       	ldd	r20, Z+4	; 0x04
     69e:	55 81       	ldd	r21, Z+5	; 0x05
     6a0:	66 81       	ldd	r22, Z+6	; 0x06
     6a2:	77 81       	ldd	r23, Z+7	; 0x07
     6a4:	45 2b       	or	r20, r21
     6a6:	46 2b       	or	r20, r22
     6a8:	47 2b       	or	r20, r23
     6aa:	09 f0       	breq	.+2      	; 0x6ae <RNDIS_Task+0x82>
     6ac:	80 c0       	rjmp	.+256    	; 0x7ae <RNDIS_Task+0x182>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     6ae:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     6b2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		/* Select the data OUT endpoint */
		Endpoint_SelectEndpoint(CDC_RX_EPNUM);

		/* Check if the data OUT endpoint contains data, and that the IN buffer is empty */
		if (Endpoint_IsOUTReceived() && !(FrameIN.FrameLength))
     6b6:	82 ff       	sbrs	r24, 2
     6b8:	2f c0       	rjmp	.+94     	; 0x718 <RNDIS_Task+0xec>
     6ba:	80 91 29 07 	lds	r24, 0x0729	; 0x800729 <FrameIN+0x5dc>
     6be:	90 91 2a 07 	lds	r25, 0x072A	; 0x80072a <FrameIN+0x5dd>
     6c2:	89 2b       	or	r24, r25
     6c4:	49 f5       	brne	.+82     	; 0x718 <RNDIS_Task+0xec>
		{
			/* Read in the packet message header */
			Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     6c6:	40 e0       	ldi	r20, 0x00	; 0
     6c8:	50 e0       	ldi	r21, 0x00	; 0
     6ca:	6c e2       	ldi	r22, 0x2C	; 44
     6cc:	70 e0       	ldi	r23, 0x00	; 0
     6ce:	ce 01       	movw	r24, r28
     6d0:	01 96       	adiw	r24, 0x01	; 1
     6d2:	0e 94 75 11 	call	0x22ea	; 0x22ea <Endpoint_Read_Stream_LE>

			/* Stall the request if the data is too large */
			if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX)
     6d6:	6d 85       	ldd	r22, Y+13	; 0x0d
     6d8:	7e 85       	ldd	r23, Y+14	; 0x0e
     6da:	8f 85       	ldd	r24, Y+15	; 0x0f
     6dc:	98 89       	ldd	r25, Y+16	; 0x10
     6de:	6d 3d       	cpi	r22, 0xDD	; 221
     6e0:	25 e0       	ldi	r18, 0x05	; 5
     6e2:	72 07       	cpc	r23, r18
     6e4:	81 05       	cpc	r24, r1
     6e6:	91 05       	cpc	r25, r1
     6e8:	30 f0       	brcs	.+12     	; 0x6f6 <RNDIS_Task+0xca>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     6ea:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
     6ee:	80 62       	ori	r24, 0x20	; 32
     6f0:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
     6f4:	5c c0       	rjmp	.+184    	; 0x7ae <RNDIS_Task+0x182>
				Endpoint_StallTransaction();
				return;
			}

			/* Read in the Ethernet frame into the buffer */
			Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength, NULL);
     6f6:	40 e0       	ldi	r20, 0x00	; 0
     6f8:	50 e0       	ldi	r21, 0x00	; 0
     6fa:	8d e4       	ldi	r24, 0x4D	; 77
     6fc:	91 e0       	ldi	r25, 0x01	; 1
     6fe:	0e 94 75 11 	call	0x22ea	; 0x22ea <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     702:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     706:	8b 77       	andi	r24, 0x7B	; 123
     708:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearOUT();

			/* Store the size of the Ethernet frame */
			FrameIN.FrameLength = RNDISPacketHeader.DataLength;
     70c:	8d 85       	ldd	r24, Y+13	; 0x0d
     70e:	9e 85       	ldd	r25, Y+14	; 0x0e
     710:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <FrameIN+0x5dd>
     714:	80 93 29 07 	sts	0x0729, r24	; 0x800729 <FrameIN+0x5dc>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     718:	81 e0       	ldi	r24, 0x01	; 1
     71a:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     71e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		/* Select the data IN endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPNUM);

		/* Check if the data IN endpoint is ready for more data, and that the IN buffer is full */
		if (Endpoint_IsINReady() && FrameOUT.FrameLength)
     722:	80 ff       	sbrs	r24, 0
     724:	44 c0       	rjmp	.+136    	; 0x7ae <RNDIS_Task+0x182>
     726:	40 91 07 0d 	lds	r20, 0x0D07	; 0x800d07 <FrameOUT+0x5dc>
     72a:	50 91 08 0d 	lds	r21, 0x0D08	; 0x800d08 <FrameOUT+0x5dd>
     72e:	41 15       	cp	r20, r1
     730:	51 05       	cpc	r21, r1
     732:	e9 f1       	breq	.+122    	; 0x7ae <RNDIS_Task+0x182>
		{
			/* Clear the packet header with all 0s so that the relevant fields can be filled */
			memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
     734:	ce 01       	movw	r24, r28
     736:	01 96       	adiw	r24, 0x01	; 1
     738:	2c e2       	ldi	r18, 0x2C	; 44
     73a:	fc 01       	movw	r30, r24
     73c:	11 92       	st	Z+, r1
     73e:	2a 95       	dec	r18
     740:	e9 f7       	brne	.-6      	; 0x73c <RNDIS_Task+0x110>

			/* Construct the required packet header fields in the buffer */
			RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
     742:	01 e0       	ldi	r16, 0x01	; 1
     744:	10 e0       	ldi	r17, 0x00	; 0
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	30 e0       	ldi	r19, 0x00	; 0
     74a:	09 83       	std	Y+1, r16	; 0x01
     74c:	1a 83       	std	Y+2, r17	; 0x02
     74e:	2b 83       	std	Y+3, r18	; 0x03
     750:	3c 83       	std	Y+4, r19	; 0x04
			RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
     752:	8a 01       	movw	r16, r20
     754:	04 5d       	subi	r16, 0xD4	; 212
     756:	1f 4f       	sbci	r17, 0xFF	; 255
     758:	20 e0       	ldi	r18, 0x00	; 0
     75a:	30 e0       	ldi	r19, 0x00	; 0
     75c:	0d 83       	std	Y+5, r16	; 0x05
     75e:	1e 83       	std	Y+6, r17	; 0x06
     760:	2f 83       	std	Y+7, r18	; 0x07
     762:	38 87       	std	Y+8, r19	; 0x08
			RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
     764:	04 e2       	ldi	r16, 0x24	; 36
     766:	10 e0       	ldi	r17, 0x00	; 0
     768:	20 e0       	ldi	r18, 0x00	; 0
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	09 87       	std	Y+9, r16	; 0x09
     76e:	1a 87       	std	Y+10, r17	; 0x0a
     770:	2b 87       	std	Y+11, r18	; 0x0b
     772:	3c 87       	std	Y+12, r19	; 0x0c
			RNDISPacketHeader.DataLength    = FrameOUT.FrameLength;
     774:	60 e0       	ldi	r22, 0x00	; 0
     776:	70 e0       	ldi	r23, 0x00	; 0
     778:	4d 87       	std	Y+13, r20	; 0x0d
     77a:	5e 87       	std	Y+14, r21	; 0x0e
     77c:	6f 87       	std	Y+15, r22	; 0x0f
     77e:	78 8b       	std	Y+16, r23	; 0x10

			/* Send the packet header to the host */
			Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     780:	40 e0       	ldi	r20, 0x00	; 0
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	6c e2       	ldi	r22, 0x2C	; 44
     786:	70 e0       	ldi	r23, 0x00	; 0
     788:	0e 94 2b 11 	call	0x2256	; 0x2256 <Endpoint_Write_Stream_LE>

			/* Send the Ethernet frame data to the host */
			Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength, NULL);
     78c:	6d 85       	ldd	r22, Y+13	; 0x0d
     78e:	7e 85       	ldd	r23, Y+14	; 0x0e
     790:	40 e0       	ldi	r20, 0x00	; 0
     792:	50 e0       	ldi	r21, 0x00	; 0
     794:	8b e2       	ldi	r24, 0x2B	; 43
     796:	97 e0       	ldi	r25, 0x07	; 7
     798:	0e 94 2b 11 	call	0x2256	; 0x2256 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     79c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
     7a0:	8e 77       	andi	r24, 0x7E	; 126
     7a2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearIN();

			/* Indicate Ethernet OUT buffer no longer full */
			FrameOUT.FrameLength = 0;
     7a6:	10 92 08 0d 	sts	0x0D08, r1	; 0x800d08 <FrameOUT+0x5dd>
     7aa:	10 92 07 0d 	sts	0x0D07, r1	; 0x800d07 <FrameOUT+0x5dc>
		}
	}
}
     7ae:	ac 96       	adiw	r28, 0x2c	; 44
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	f8 94       	cli
     7b4:	de bf       	out	0x3e, r29	; 62
     7b6:	0f be       	out	0x3f, r0	; 63
     7b8:	cd bf       	out	0x3d, r28	; 61
     7ba:	df 91       	pop	r29
     7bc:	cf 91       	pop	r28
     7be:	1f 91       	pop	r17
     7c0:	0f 91       	pop	r16
     7c2:	08 95       	ret

000007c4 <Ethernet_Task>:
	/* Task for Ethernet processing. Incoming ethernet frames are loaded into the FrameIN structure, and
	   outgoing frames should be loaded into the FrameOUT structure. Both structures can only hold a single
	   Ethernet frame at a time, so the FrameInBuffer bool is used to indicate when the buffers contain data. */

	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
     7c4:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>
     7c8:	84 30       	cpi	r24, 0x04	; 4
     7ca:	59 f4       	brne	.+22     	; 0x7e2 <Ethernet_Task+0x1e>
	  return;

	/* Check if a frame has been written to the IN frame buffer */
	if (FrameIN.FrameLength)
     7cc:	80 91 29 07 	lds	r24, 0x0729	; 0x800729 <FrameIN+0x5dc>
     7d0:	90 91 2a 07 	lds	r25, 0x072A	; 0x80072a <FrameIN+0x5dd>
     7d4:	89 2b       	or	r24, r25
     7d6:	29 f0       	breq	.+10     	; 0x7e2 <Ethernet_Task+0x1e>
	{
		/* Indicate packet processing started */
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     7d8:	80 e2       	ldi	r24, 0x20	; 32
     7da:	61 de       	rcall	.-830    	; 0x49e <LEDs_SetAllLEDs>

		/* Process the ethernet frame - replace this with your own Ethernet handler code as desired */
		Ethernet_ProcessPacket();
     7dc:	40 d0       	rcall	.+128    	; 0x85e <Ethernet_ProcessPacket>

		/* Indicate packet processing complete */
		LEDs_SetAllLEDs(LEDMASK_USB_READY);
     7de:	80 e6       	ldi	r24, 0x60	; 96
     7e0:	5e ce       	rjmp	.-836    	; 0x49e <LEDs_SetAllLEDs>
     7e2:	08 95       	ret

000007e4 <main>:
     7e4:	61 de       	rcall	.-830    	; 0x4a8 <SetupHardware>
int main(void)
{
	SetupHardware();

	/* Webserver Initialization */
	TCP_Init();
     7e6:	ab d2       	rcall	.+1366   	; 0xd3e <TCP_Init>
     7e8:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <Webserver_Init>
	Webserver_Init();

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     7ec:	80 e1       	ldi	r24, 0x10	; 16
     7ee:	57 de       	rcall	.-850    	; 0x49e <LEDs_SetAllLEDs>
	sei();

	for (;;)
	{
		Ethernet_Task();
     7f0:	78 94       	sei
     7f2:	e8 df       	rcall	.-48     	; 0x7c4 <Ethernet_Task>
		TCP_Task();
     7f4:	7c d1       	rcall	.+760    	; 0xaee <TCP_Task>
     7f6:	1a df       	rcall	.-460    	; 0x62c <RNDIS_Task>
		RNDIS_Task();
     7f8:	0e 94 02 14 	call	0x2804	; 0x2804 <USB_USBTask>
		USB_USBTask();
     7fc:	fa cf       	rjmp	.-12     	; 0x7f2 <main+0xe>

000007fe <CALLBACK_USB_GetDescriptor>:
     7fe:	29 2f       	mov	r18, r25
     800:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     802:	22 30       	cpi	r18, 0x02	; 2
     804:	31 05       	cpc	r19, r1
     806:	59 f0       	breq	.+22     	; 0x81e <CALLBACK_USB_GetDescriptor+0x20>
     808:	23 30       	cpi	r18, 0x03	; 3
     80a:	31 05       	cpc	r19, r1
     80c:	69 f0       	breq	.+26     	; 0x828 <CALLBACK_USB_GetDescriptor+0x2a>
     80e:	21 30       	cpi	r18, 0x01	; 1
     810:	31 05       	cpc	r19, r1
     812:	e9 f4       	brne	.+58     	; 0x84e <CALLBACK_USB_GetDescriptor+0x50>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     814:	82 e1       	ldi	r24, 0x12	; 18
     816:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     818:	22 e4       	ldi	r18, 0x42	; 66
     81a:	31 e0       	ldi	r19, 0x01	; 1
     81c:	1c c0       	rjmp	.+56     	; 0x856 <CALLBACK_USB_GetDescriptor+0x58>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     81e:	8e e3       	ldi	r24, 0x3E	; 62
     820:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     822:	24 e0       	ldi	r18, 0x04	; 4
     824:	31 e0       	ldi	r19, 0x01	; 1
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     826:	17 c0       	rjmp	.+46     	; 0x856 <CALLBACK_USB_GetDescriptor+0x58>
		case DTYPE_String:
			switch (DescriptorNumber)
     828:	99 27       	eor	r25, r25
     82a:	81 30       	cpi	r24, 0x01	; 1
     82c:	91 05       	cpc	r25, r1
     82e:	49 f0       	breq	.+18     	; 0x842 <CALLBACK_USB_GetDescriptor+0x44>
     830:	28 f0       	brcs	.+10     	; 0x83c <CALLBACK_USB_GetDescriptor+0x3e>
     832:	02 97       	sbiw	r24, 0x02	; 2
     834:	61 f4       	brne	.+24     	; 0x84e <CALLBACK_USB_GetDescriptor+0x50>
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     836:	ec eb       	ldi	r30, 0xBC	; 188
     838:	f0 e0       	ldi	r31, 0x00	; 0
     83a:	05 c0       	rjmp	.+10     	; 0x846 <CALLBACK_USB_GetDescriptor+0x48>
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     83c:	e0 e0       	ldi	r30, 0x00	; 0
     83e:	f1 e0       	ldi	r31, 0x01	; 1
     840:	02 c0       	rjmp	.+4      	; 0x846 <CALLBACK_USB_GetDescriptor+0x48>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     842:	e6 ee       	ldi	r30, 0xE6	; 230
     844:	f0 e0       	ldi	r31, 0x00	; 0
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     846:	84 91       	lpm	r24, Z
     848:	90 e0       	ldi	r25, 0x00	; 0
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case 0x02:
					Address = &ProductString;
     84a:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     84c:	04 c0       	rjmp	.+8      	; 0x856 <CALLBACK_USB_GetDescriptor+0x58>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     84e:	80 e0       	ldi	r24, 0x00	; 0
     850:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     852:	20 e0       	ldi	r18, 0x00	; 0
     854:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     856:	fa 01       	movw	r30, r20
     858:	31 83       	std	Z+1, r19	; 0x01
     85a:	20 83       	st	Z, r18
	return Size;
}
     85c:	08 95       	ret

0000085e <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(void)
{
	DecodeEthernetFrameHeader(FrameIN.FrameData);
     85e:	8d e4       	ldi	r24, 0x4D	; 77
     860:	91 e0       	ldi	r25, 0x01	; 1
     862:	8d d0       	rcall	.+282    	; 0x97e <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     864:	46 e0       	ldi	r20, 0x06	; 6
     866:	50 e0       	ldi	r21, 0x00	; 0
     868:	6c e1       	ldi	r22, 0x1C	; 28
     86a:	71 e0       	ldi	r23, 0x01	; 1
     86c:	8d e4       	ldi	r24, 0x4D	; 77
     86e:	91 e0       	ldi	r25, 0x01	; 1
     870:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
     874:	89 2b       	or	r24, r25
     876:	59 f0       	breq	.+22     	; 0x88e <Ethernet_ProcessPacket+0x30>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     878:	46 e0       	ldi	r20, 0x06	; 6
     87a:	50 e0       	ldi	r21, 0x00	; 0
     87c:	62 e1       	ldi	r22, 0x12	; 18
     87e:	71 e0       	ldi	r23, 0x01	; 1
     880:	8d e4       	ldi	r24, 0x4D	; 77
     882:	91 e0       	ldi	r25, 0x01	; 1
     884:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     888:	89 2b       	or	r24, r25
     88a:	09 f0       	breq	.+2      	; 0x88e <Ethernet_ProcessPacket+0x30>
     88c:	42 c0       	rjmp	.+132    	; 0x912 <Ethernet_ProcessPacket+0xb4>

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
     88e:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <FrameIN+0x5dd>
     892:	90 91 29 07 	lds	r25, 0x0729	; 0x800729 <FrameIN+0x5dc>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     896:	81 30       	cpi	r24, 0x01	; 1
     898:	96 40       	sbci	r25, 0x06	; 6
     89a:	d8 f1       	brcs	.+118    	; 0x912 <Ethernet_ProcessPacket+0xb4>
     89c:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <FrameIN+0xd>
     8a0:	90 91 59 01 	lds	r25, 0x0159	; 0x800159 <FrameIN+0xc>
		(SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     8a4:	81 15       	cp	r24, r1
     8a6:	28 e0       	ldi	r18, 0x08	; 8
     8a8:	92 07       	cpc	r25, r18
     8aa:	49 f0       	breq	.+18     	; 0x8be <Ethernet_ProcessPacket+0x60>
     8ac:	86 30       	cpi	r24, 0x06	; 6
     8ae:	98 40       	sbci	r25, 0x08	; 8
     8b0:	81 f5       	brne	.+96     	; 0x912 <Ethernet_ProcessPacket+0xb4>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     8b2:	69 e3       	ldi	r22, 0x39	; 57
     8b4:	77 e0       	ldi	r23, 0x07	; 7
     8b6:	8b e5       	ldi	r24, 0x5B	; 91
     8b8:	91 e0       	ldi	r25, 0x01	; 1
     8ba:	c1 d6       	rcall	.+3458   	; 0x163e <ARP_ProcessARPPacket>
				                               &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     8bc:	05 c0       	rjmp	.+10     	; 0x8c8 <Ethernet_ProcessPacket+0x6a>
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     8be:	69 e3       	ldi	r22, 0x39	; 57
     8c0:	77 e0       	ldi	r23, 0x07	; 7
     8c2:	8b e5       	ldi	r24, 0x5B	; 91
     8c4:	91 e0       	ldi	r25, 0x01	; 1
     8c6:	22 d7       	rcall	.+3652   	; 0x170c <IP_ProcessIPPacket>
				                             &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     8c8:	18 16       	cp	r1, r24
     8ca:	19 06       	cpc	r1, r25
     8cc:	04 f5       	brge	.+64     	; 0x90e <Ethernet_ProcessPacket+0xb0>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     8ce:	26 e0       	ldi	r18, 0x06	; 6
     8d0:	ec e1       	ldi	r30, 0x1C	; 28
     8d2:	f1 e0       	ldi	r31, 0x01	; 1
     8d4:	a1 e3       	ldi	r26, 0x31	; 49
     8d6:	b7 e0       	ldi	r27, 0x07	; 7
     8d8:	01 90       	ld	r0, Z+
     8da:	0d 92       	st	X+, r0
     8dc:	2a 95       	dec	r18
     8de:	e1 f7       	brne	.-8      	; 0x8d8 <Ethernet_ProcessPacket+0x7a>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     8e0:	26 e0       	ldi	r18, 0x06	; 6
     8e2:	e3 e5       	ldi	r30, 0x53	; 83
     8e4:	f1 e0       	ldi	r31, 0x01	; 1
     8e6:	ab e2       	ldi	r26, 0x2B	; 43
     8e8:	b7 e0       	ldi	r27, 0x07	; 7
     8ea:	01 90       	ld	r0, Z+
     8ec:	0d 92       	st	X+, r0
     8ee:	2a 95       	dec	r18
     8f0:	e1 f7       	brne	.-8      	; 0x8ea <Ethernet_ProcessPacket+0x8c>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     8f2:	20 91 59 01 	lds	r18, 0x0159	; 0x800159 <FrameIN+0xc>
     8f6:	30 91 5a 01 	lds	r19, 0x015A	; 0x80015a <FrameIN+0xd>
     8fa:	30 93 38 07 	sts	0x0738, r19	; 0x800738 <FrameOUT+0xd>
     8fe:	20 93 37 07 	sts	0x0737, r18	; 0x800737 <FrameOUT+0xc>

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     902:	0e 96       	adiw	r24, 0x0e	; 14
     904:	90 93 08 0d 	sts	0x0D08, r25	; 0x800d08 <FrameOUT+0x5dd>
     908:	80 93 07 0d 	sts	0x0D07, r24	; 0x800d07 <FrameOUT+0x5dc>
     90c:	02 c0       	rjmp	.+4      	; 0x912 <Ethernet_ProcessPacket+0xb4>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     90e:	01 96       	adiw	r24, 0x01	; 1
     910:	21 f0       	breq	.+8      	; 0x91a <Ethernet_ProcessPacket+0xbc>
	{
		/* Clear the frame buffer */
		FrameIN.FrameLength = 0;
     912:	10 92 2a 07 	sts	0x072A, r1	; 0x80072a <FrameIN+0x5dd>
     916:	10 92 29 07 	sts	0x0729, r1	; 0x800729 <FrameIN+0x5dc>
     91a:	08 95       	ret

0000091c <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     91c:	cf 93       	push	r28
     91e:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     920:	9b 01       	movw	r18, r22
     922:	36 95       	lsr	r19
     924:	27 95       	ror	r18
     926:	e0 e0       	ldi	r30, 0x00	; 0
     928:	f0 e0       	ldi	r31, 0x00	; 0
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;
     92a:	40 e0       	ldi	r20, 0x00	; 0
     92c:	50 e0       	ldi	r21, 0x00	; 0
     92e:	ba 01       	movw	r22, r20

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     930:	e2 17       	cp	r30, r18
     932:	f3 07       	cpc	r31, r19
     934:	51 f0       	breq	.+20     	; 0x94a <Ethernet_Checksum16+0x2e>
	  Checksum += Words[CurrWord];
     936:	ec 01       	movw	r28, r24
     938:	a9 91       	ld	r26, Y+
     93a:	b9 91       	ld	r27, Y+
     93c:	ce 01       	movw	r24, r28
     93e:	4a 0f       	add	r20, r26
     940:	5b 1f       	adc	r21, r27
     942:	61 1d       	adc	r22, r1
     944:	71 1d       	adc	r23, r1
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     946:	31 96       	adiw	r30, 0x01	; 1
     948:	f3 cf       	rjmp	.-26     	; 0x930 <Ethernet_Checksum16+0x14>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     94a:	db 01       	movw	r26, r22
     94c:	ca 01       	movw	r24, r20
     94e:	88 27       	eor	r24, r24
     950:	99 27       	eor	r25, r25
     952:	89 2b       	or	r24, r25
     954:	8a 2b       	or	r24, r26
     956:	8b 2b       	or	r24, r27
     958:	61 f0       	breq	.+24     	; 0x972 <Ethernet_Checksum16+0x56>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     95a:	db 01       	movw	r26, r22
     95c:	ca 01       	movw	r24, r20
     95e:	aa 27       	eor	r26, r26
     960:	bb 27       	eor	r27, r27
     962:	ab 01       	movw	r20, r22
     964:	66 27       	eor	r22, r22
     966:	77 27       	eor	r23, r23
     968:	48 0f       	add	r20, r24
     96a:	59 1f       	adc	r21, r25
     96c:	6a 1f       	adc	r22, r26
     96e:	7b 1f       	adc	r23, r27
     970:	ec cf       	rjmp	.-40     	; 0x94a <Ethernet_Checksum16+0x2e>

	return ~Checksum;
     972:	ca 01       	movw	r24, r20
     974:	80 95       	com	r24
     976:	90 95       	com	r25
}
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	08 95       	ret

0000097e <DecodeEthernetFrameHeader>:
     97e:	08 95       	ret

00000980 <DecodeARPHeader>:
     980:	08 95       	ret

00000982 <DecodeIPHeader>:
     982:	08 95       	ret

00000984 <DecodeICMPHeader>:
     984:	08 95       	ret

00000986 <DecodeTCPHeader>:
     986:	08 95       	ret

00000988 <DecodeUDPHeader>:
     988:	08 95       	ret

0000098a <DecodeDHCPHeader>:
/** Decodes an DHCP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of a DHCP packet header
 */
void DecodeDHCPHeader(void* InDataStart)
{
     98a:	08 95       	ret

0000098c <ICMP_ProcessICMPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(void* InDataStart,
                               void* OutDataStart)
{
     98c:	ef 92       	push	r14
     98e:	ff 92       	push	r15
     990:	0f 93       	push	r16
     992:	1f 93       	push	r17
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	7c 01       	movw	r14, r24
     99a:	8b 01       	movw	r16, r22
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     99c:	f3 df       	rcall	.-26     	; 0x984 <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     99e:	f7 01       	movw	r30, r14
     9a0:	80 81       	ld	r24, Z
     9a2:	88 30       	cpi	r24, 0x08	; 8
     9a4:	51 f5       	brne	.+84     	; 0x9fa <ICMP_ProcessICMPPacket+0x6e>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     9a6:	f8 01       	movw	r30, r16
     9a8:	10 82       	st	Z, r1
		ICMPHeaderOUT->Code     = 0;
     9aa:	11 82       	std	Z+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     9ac:	13 82       	std	Z+3, r1	; 0x03
     9ae:	12 82       	std	Z+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     9b0:	f7 01       	movw	r30, r14
     9b2:	84 81       	ldd	r24, Z+4	; 0x04
     9b4:	95 81       	ldd	r25, Z+5	; 0x05
     9b6:	f8 01       	movw	r30, r16
     9b8:	95 83       	std	Z+5, r25	; 0x05
     9ba:	84 83       	std	Z+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     9bc:	f7 01       	movw	r30, r14
     9be:	86 81       	ldd	r24, Z+6	; 0x06
     9c0:	97 81       	ldd	r25, Z+7	; 0x07
     9c2:	f8 01       	movw	r30, r16
     9c4:	97 83       	std	Z+7, r25	; 0x07
     9c6:	86 83       	std	Z+6, r24	; 0x06

		intptr_t DataSize = FrameIN.FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN.FrameData));
     9c8:	c0 91 29 07 	lds	r28, 0x0729	; 0x800729 <FrameIN+0x5dc>
     9cc:	d0 91 2a 07 	lds	r29, 0x072A	; 0x80072a <FrameIN+0x5dd>
     9d0:	cb 5b       	subi	r28, 0xBB	; 187
     9d2:	de 4f       	sbci	r29, 0xFE	; 254
     9d4:	ce 19       	sub	r28, r14
     9d6:	df 09       	sbc	r29, r15

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     9d8:	b7 01       	movw	r22, r14
     9da:	68 5f       	subi	r22, 0xF8	; 248
     9dc:	7f 4f       	sbci	r23, 0xFF	; 255
     9de:	ae 01       	movw	r20, r28
     9e0:	c8 01       	movw	r24, r16
     9e2:	08 96       	adiw	r24, 0x08	; 8
     9e4:	0e 94 76 14 	call	0x28ec	; 0x28ec <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     9e8:	28 96       	adiw	r28, 0x08	; 8
     9ea:	be 01       	movw	r22, r28
     9ec:	c8 01       	movw	r24, r16
     9ee:	96 df       	rcall	.-212    	; 0x91c <Ethernet_Checksum16>
     9f0:	f8 01       	movw	r30, r16
     9f2:	93 83       	std	Z+3, r25	; 0x03
     9f4:	82 83       	std	Z+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     9f6:	ce 01       	movw	r24, r28
     9f8:	02 c0       	rjmp	.+4      	; 0x9fe <ICMP_ProcessICMPPacket+0x72>
	}

	return NO_RESPONSE;
     9fa:	80 e0       	ldi	r24, 0x00	; 0
     9fc:	90 e0       	ldi	r25, 0x00	; 0
}
     9fe:	df 91       	pop	r29
     a00:	cf 91       	pop	r28
     a02:	1f 91       	pop	r17
     a04:	0f 91       	pop	r16
     a06:	ff 90       	pop	r15
     a08:	ef 90       	pop	r14
     a0a:	08 95       	ret

00000a0c <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     a0c:	9b 01       	movw	r18, r22
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     a0e:	69 2f       	mov	r22, r25
     a10:	78 2f       	mov	r23, r24
     a12:	83 2f       	mov	r24, r19
     a14:	92 2f       	mov	r25, r18
     a16:	08 95       	ret

00000a18 <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     a18:	28 2f       	mov	r18, r24
     a1a:	89 2f       	mov	r24, r25
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     a1c:	92 2f       	mov	r25, r18
     a1e:	08 95       	ret

00000a20 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               uint16_t TCPOutSize)
{
     a20:	8f 92       	push	r8
     a22:	9f 92       	push	r9
     a24:	af 92       	push	r10
     a26:	bf 92       	push	r11
     a28:	ef 92       	push	r14
     a2a:	ff 92       	push	r15
     a2c:	0f 93       	push	r16
     a2e:	1f 93       	push	r17
     a30:	cf 93       	push	r28
     a32:	df 93       	push	r29
     a34:	ec 01       	movw	r28, r24
     a36:	cb 01       	movw	r24, r22
     a38:	a0 e0       	ldi	r26, 0x00	; 0
     a3a:	b0 e0       	ldi	r27, 0x00	; 0
     a3c:	84 0f       	add	r24, r20
     a3e:	95 1f       	adc	r25, r21
     a40:	a1 1d       	adc	r26, r1
     a42:	b1 1d       	adc	r27, r1
     a44:	9a 5f       	subi	r25, 0xFA	; 250
     a46:	af 4f       	sbci	r26, 0xFF	; 255
     a48:	bf 4f       	sbci	r27, 0xFF	; 255
     a4a:	80 0f       	add	r24, r16
     a4c:	91 1f       	adc	r25, r17
     a4e:	a1 1d       	adc	r26, r1
     a50:	b1 1d       	adc	r27, r1

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     a52:	4c 01       	movw	r8, r24
     a54:	5d 01       	movw	r10, r26
     a56:	82 0e       	add	r8, r18
     a58:	93 1e       	adc	r9, r19
     a5a:	a1 1c       	adc	r10, r1
     a5c:	b1 1c       	adc	r11, r1
	Checksum += SwapEndian_16(TCPOutSize);
     a5e:	c7 01       	movw	r24, r14
     a60:	db df       	rcall	.-74     	; 0xa18 <SwapEndian_16>
     a62:	a5 01       	movw	r20, r10
     a64:	94 01       	movw	r18, r8
     a66:	28 0f       	add	r18, r24
     a68:	39 1f       	adc	r19, r25
     a6a:	41 1d       	adc	r20, r1
     a6c:	51 1d       	adc	r21, r1
     a6e:	da 01       	movw	r26, r20
     a70:	c9 01       	movw	r24, r18

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     a72:	a7 01       	movw	r20, r14
     a74:	56 95       	lsr	r21
     a76:	47 95       	ror	r20
     a78:	fe 01       	movw	r30, r28
     a7a:	20 e0       	ldi	r18, 0x00	; 0
     a7c:	30 e0       	ldi	r19, 0x00	; 0
     a7e:	24 17       	cp	r18, r20
     a80:	35 07       	cpc	r19, r21
     a82:	49 f0       	breq	.+18     	; 0xa96 <TCP_Checksum16+0x76>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     a84:	61 91       	ld	r22, Z+
     a86:	71 91       	ld	r23, Z+
     a88:	86 0f       	add	r24, r22
     a8a:	97 1f       	adc	r25, r23
     a8c:	a1 1d       	adc	r26, r1
     a8e:	b1 1d       	adc	r27, r1
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     a90:	2f 5f       	subi	r18, 0xFF	; 255
     a92:	3f 4f       	sbci	r19, 0xFF	; 255
     a94:	f4 cf       	rjmp	.-24     	; 0xa7e <TCP_Checksum16+0x5e>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     a96:	e0 fe       	sbrs	r14, 0
     a98:	09 c0       	rjmp	.+18     	; 0xaac <TCP_Checksum16+0x8c>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     a9a:	22 0f       	add	r18, r18
     a9c:	33 1f       	adc	r19, r19
     a9e:	c2 0f       	add	r28, r18
     aa0:	d3 1f       	adc	r29, r19
     aa2:	28 81       	ld	r18, Y
     aa4:	82 0f       	add	r24, r18
     aa6:	91 1d       	adc	r25, r1
     aa8:	a1 1d       	adc	r26, r1
     aaa:	b1 1d       	adc	r27, r1

	while (Checksum & 0xFFFF0000)
     aac:	ac 01       	movw	r20, r24
     aae:	bd 01       	movw	r22, r26
     ab0:	44 27       	eor	r20, r20
     ab2:	55 27       	eor	r21, r21
     ab4:	45 2b       	or	r20, r21
     ab6:	46 2b       	or	r20, r22
     ab8:	47 2b       	or	r20, r23
     aba:	61 f0       	breq	.+24     	; 0xad4 <TCP_Checksum16+0xb4>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     abc:	ac 01       	movw	r20, r24
     abe:	bd 01       	movw	r22, r26
     ac0:	66 27       	eor	r22, r22
     ac2:	77 27       	eor	r23, r23
     ac4:	cd 01       	movw	r24, r26
     ac6:	aa 27       	eor	r26, r26
     ac8:	bb 27       	eor	r27, r27
     aca:	84 0f       	add	r24, r20
     acc:	95 1f       	adc	r25, r21
     ace:	a6 1f       	adc	r26, r22
     ad0:	b7 1f       	adc	r27, r23
     ad2:	ec cf       	rjmp	.-40     	; 0xaac <TCP_Checksum16+0x8c>

	return ~Checksum;
     ad4:	80 95       	com	r24
     ad6:	90 95       	com	r25
}
     ad8:	df 91       	pop	r29
     ada:	cf 91       	pop	r28
     adc:	1f 91       	pop	r17
     ade:	0f 91       	pop	r16
     ae0:	ff 90       	pop	r15
     ae2:	ef 90       	pop	r14
     ae4:	bf 90       	pop	r11
     ae6:	af 90       	pop	r10
     ae8:	9f 90       	pop	r9
     aea:	8f 90       	pop	r8
     aec:	08 95       	ret

00000aee <TCP_Task>:
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
     aee:	4f 92       	push	r4
     af0:	5f 92       	push	r5
     af2:	6f 92       	push	r6
     af4:	7f 92       	push	r7
     af6:	8f 92       	push	r8
     af8:	9f 92       	push	r9
     afa:	af 92       	push	r10
     afc:	bf 92       	push	r11
     afe:	cf 92       	push	r12
     b00:	df 92       	push	r13
     b02:	ef 92       	push	r14
     b04:	ff 92       	push	r15
     b06:	0f 93       	push	r16
     b08:	1f 93       	push	r17
     b0a:	cf 93       	push	r28
     b0c:	df 93       	push	r29
     b0e:	c9 e0       	ldi	r28, 0x09	; 9
     b10:	dd e0       	ldi	r29, 0x0D	; 13
     b12:	0b e4       	ldi	r16, 0x4B	; 75
     b14:	13 e1       	ldi	r17, 0x13	; 19
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     b16:	20 91 4b 13 	lds	r18, 0x134B	; 0x80134b <PortStateTable>
     b1a:	30 91 4c 13 	lds	r19, 0x134C	; 0x80134c <PortStateTable+0x1>
     b1e:	88 81       	ld	r24, Y
     b20:	99 81       	ldd	r25, Y+1	; 0x01
     b22:	28 17       	cp	r18, r24
     b24:	39 07       	cpc	r19, r25
     b26:	69 f4       	brne	.+26     	; 0xb42 <TCP_Task+0x54>
     b28:	80 91 4d 13 	lds	r24, 0x134D	; 0x80134d <PortStateTable+0x2>
     b2c:	81 30       	cpi	r24, 0x01	; 1
     b2e:	49 f4       	brne	.+18     	; 0xb42 <TCP_Task+0x54>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
     b30:	e0 91 4e 13 	lds	r30, 0x134E	; 0x80134e <PortStateTable+0x3>
     b34:	f0 91 4f 13 	lds	r31, 0x134F	; 0x80134f <PortStateTable+0x4>
     b38:	be 01       	movw	r22, r28
     b3a:	60 5f       	subi	r22, 0xF0	; 240
     b3c:	7f 4f       	sbci	r23, 0xFF	; 255
     b3e:	ce 01       	movw	r24, r28
     b40:	09 95       	icall
     b42:	ca 5e       	subi	r28, 0xEA	; 234
     b44:	dd 4f       	sbci	r29, 0xFD	; 253
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     b46:	0c 17       	cp	r16, r28
     b48:	1d 07       	cpc	r17, r29
     b4a:	29 f7       	brne	.-54     	; 0xb16 <TCP_Task+0x28>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
     b4c:	80 91 07 0d 	lds	r24, 0x0D07	; 0x800d07 <FrameOUT+0x5dc>
     b50:	90 91 08 0d 	lds	r25, 0x0D08	; 0x800d08 <FrameOUT+0x5dd>
     b54:	89 2b       	or	r24, r25
     b56:	09 f0       	breq	.+2      	; 0xb5a <TCP_Task+0x6c>
     b58:	e1 c0       	rjmp	.+450    	; 0xd1c <TCP_Task+0x22e>
     b5a:	eb e1       	ldi	r30, 0x1B	; 27
     b5c:	ff e0       	ldi	r31, 0x0F	; 15
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	90 e0       	ldi	r25, 0x00	; 0

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
     b62:	20 81       	ld	r18, Z
     b64:	22 23       	and	r18, r18
     b66:	09 f4       	brne	.+2      	; 0xb6a <TCP_Task+0x7c>
     b68:	d2 c0       	rjmp	.+420    	; 0xd0e <TCP_Task+0x220>
     b6a:	21 81       	ldd	r18, Z+1	; 0x01
     b6c:	22 23       	and	r18, r18
     b6e:	09 f4       	brne	.+2      	; 0xb72 <TCP_Task+0x84>
     b70:	ce c0       	rjmp	.+412    	; 0xd0e <TCP_Task+0x220>
			                                                                             sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                              sizeof(IP_Header_t) +
			                                                              sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
     b72:	26 e1       	ldi	r18, 0x16	; 22
     b74:	32 e0       	ldi	r19, 0x02	; 2
     b76:	82 9f       	mul	r24, r18
     b78:	80 01       	movw	r16, r0
     b7a:	83 9f       	mul	r24, r19
     b7c:	10 0d       	add	r17, r0
     b7e:	92 9f       	mul	r25, r18
     b80:	10 0d       	add	r17, r0
     b82:	11 24       	eor	r1, r1
     b84:	e8 01       	movw	r28, r16
     b86:	c7 5f       	subi	r28, 0xF7	; 247
     b88:	d2 4f       	sbci	r29, 0xF2	; 242
     b8a:	c8 88       	ldd	r12, Y+16	; 0x10
     b8c:	d9 88       	ldd	r13, Y+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
     b8e:	88 81       	ld	r24, Y
     b90:	99 81       	ldd	r25, Y+1	; 0x01
     b92:	90 93 4e 07 	sts	0x074E, r25	; 0x80074e <FrameOUT+0x23>
     b96:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <FrameOUT+0x22>
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
     b9a:	8a 81       	ldd	r24, Y+2	; 0x02
     b9c:	9b 81       	ldd	r25, Y+3	; 0x03
     b9e:	90 93 50 07 	sts	0x0750, r25	; 0x800750 <FrameOUT+0x25>
     ba2:	80 93 4f 07 	sts	0x074F, r24	; 0x80074f <FrameOUT+0x24>
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
     ba6:	8c 84       	ldd	r8, Y+12	; 0x0c
     ba8:	9d 84       	ldd	r9, Y+13	; 0x0d
     baa:	ae 84       	ldd	r10, Y+14	; 0x0e
     bac:	bf 84       	ldd	r11, Y+15	; 0x0f
     bae:	c5 01       	movw	r24, r10
     bb0:	b4 01       	movw	r22, r8
     bb2:	2c df       	rcall	.-424    	; 0xa0c <SwapEndian_32>
     bb4:	60 93 51 07 	sts	0x0751, r22	; 0x800751 <FrameOUT+0x26>
     bb8:	70 93 52 07 	sts	0x0752, r23	; 0x800752 <FrameOUT+0x27>
     bbc:	80 93 53 07 	sts	0x0753, r24	; 0x800753 <FrameOUT+0x28>
     bc0:	90 93 54 07 	sts	0x0754, r25	; 0x800754 <FrameOUT+0x29>
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
     bc4:	68 85       	ldd	r22, Y+8	; 0x08
     bc6:	79 85       	ldd	r23, Y+9	; 0x09
     bc8:	8a 85       	ldd	r24, Y+10	; 0x0a
     bca:	9b 85       	ldd	r25, Y+11	; 0x0b
     bcc:	1f df       	rcall	.-450    	; 0xa0c <SwapEndian_32>
     bce:	60 93 55 07 	sts	0x0755, r22	; 0x800755 <FrameOUT+0x2a>
     bd2:	70 93 56 07 	sts	0x0756, r23	; 0x800756 <FrameOUT+0x2b>
     bd6:	80 93 57 07 	sts	0x0757, r24	; 0x800757 <FrameOUT+0x2c>
     bda:	90 93 58 07 	sts	0x0758, r25	; 0x800758 <FrameOUT+0x2d>
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
     bde:	82 e0       	ldi	r24, 0x02	; 2
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	90 93 5c 07 	sts	0x075C, r25	; 0x80075c <FrameOUT+0x31>
     be6:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <FrameOUT+0x30>

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
     bea:	80 e1       	ldi	r24, 0x10	; 16
     bec:	80 93 5a 07 	sts	0x075A, r24	; 0x80075a <FrameOUT+0x2f>
			TCPHeaderOUT->UrgentPointer        = 0;
     bf0:	10 92 60 07 	sts	0x0760, r1	; 0x800760 <FrameOUT+0x35>
     bf4:	10 92 5f 07 	sts	0x075F, r1	; 0x80075f <FrameOUT+0x34>
			TCPHeaderOUT->Checksum             = 0;
     bf8:	10 92 5e 07 	sts	0x075E, r1	; 0x80075e <FrameOUT+0x33>
     bfc:	10 92 5d 07 	sts	0x075D, r1	; 0x80075d <FrameOUT+0x32>
			TCPHeaderOUT->Reserved             = 0;
     c00:	80 e5       	ldi	r24, 0x50	; 80
     c02:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <FrameOUT+0x2e>

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
     c06:	b8 01       	movw	r22, r16
     c08:	65 5e       	subi	r22, 0xE5	; 229
     c0a:	72 4f       	sbci	r23, 0xF2	; 242
     c0c:	a6 01       	movw	r20, r12
     c0e:	81 e6       	ldi	r24, 0x61	; 97
     c10:	97 e0       	ldi	r25, 0x07	; 7
     c12:	0e 94 6d 14 	call	0x28da	; 0x28da <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
     c16:	8c 0c       	add	r8, r12
     c18:	9d 1c       	adc	r9, r13
     c1a:	a1 1c       	adc	r10, r1
     c1c:	b1 1c       	adc	r11, r1
     c1e:	8c 86       	std	Y+12, r8	; 0x0c
     c20:	9d 86       	std	Y+13, r9	; 0x0d
     c22:	ae 86       	std	Y+14, r10	; 0x0e
     c24:	bf 86       	std	Y+15, r11	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
     c26:	76 01       	movw	r14, r12
     c28:	84 e1       	ldi	r24, 0x14	; 20
     c2a:	e8 0e       	add	r14, r24
     c2c:	f1 1c       	adc	r15, r1
     c2e:	4c 80       	ldd	r4, Y+4	; 0x04
     c30:	5d 80       	ldd	r5, Y+5	; 0x05
     c32:	6e 80       	ldd	r6, Y+6	; 0x06
     c34:	7f 80       	ldd	r7, Y+7	; 0x07
     c36:	80 90 18 01 	lds	r8, 0x0118	; 0x800118 <ServerIPAddress>
     c3a:	90 90 19 01 	lds	r9, 0x0119	; 0x800119 <ServerIPAddress+0x1>
     c3e:	a0 90 1a 01 	lds	r10, 0x011A	; 0x80011a <ServerIPAddress+0x2>
     c42:	b0 90 1b 01 	lds	r11, 0x011B	; 0x80011b <ServerIPAddress+0x3>
     c46:	93 01       	movw	r18, r6
     c48:	82 01       	movw	r16, r4
     c4a:	b5 01       	movw	r22, r10
     c4c:	a4 01       	movw	r20, r8
     c4e:	8d e4       	ldi	r24, 0x4D	; 77
     c50:	97 e0       	ldi	r25, 0x07	; 7
     c52:	e6 de       	rcall	.-564    	; 0xa20 <TCP_Checksum16>
     c54:	90 93 5e 07 	sts	0x075E, r25	; 0x80075e <FrameOUT+0x33>
     c58:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <FrameOUT+0x32>
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
     c5c:	c6 01       	movw	r24, r12
     c5e:	88 96       	adiw	r24, 0x28	; 40
     c60:	db de       	rcall	.-586    	; 0xa18 <SwapEndian_16>
     c62:	90 93 3c 07 	sts	0x073C, r25	; 0x80073c <FrameOUT+0x11>
     c66:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <FrameOUT+0x10>
     c6a:	10 92 3a 07 	sts	0x073A, r1	; 0x80073a <FrameOUT+0xf>
			IPHeaderOUT->TypeOfService      = 0;
     c6e:	85 e4       	ldi	r24, 0x45	; 69
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
     c70:	80 93 39 07 	sts	0x0739, r24	; 0x800739 <FrameOUT+0xe>
     c74:	10 92 3f 07 	sts	0x073F, r1	; 0x80073f <FrameOUT+0x14>
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
     c78:	10 92 40 07 	sts	0x0740, r1	; 0x800740 <FrameOUT+0x15>
     c7c:	10 92 3e 07 	sts	0x073E, r1	; 0x80073e <FrameOUT+0x13>
			IPHeaderOUT->Identification     = 0;
     c80:	10 92 3d 07 	sts	0x073D, r1	; 0x80073d <FrameOUT+0x12>
     c84:	10 92 44 07 	sts	0x0744, r1	; 0x800744 <FrameOUT+0x19>
			IPHeaderOUT->HeaderChecksum     = 0;
     c88:	10 92 43 07 	sts	0x0743, r1	; 0x800743 <FrameOUT+0x18>
     c8c:	16 e0       	ldi	r17, 0x06	; 6
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
     c8e:	10 93 42 07 	sts	0x0742, r17	; 0x800742 <FrameOUT+0x17>
     c92:	80 e8       	ldi	r24, 0x80	; 128
			IPHeaderOUT->TTL                = DEFAULT_TTL;
     c94:	80 93 41 07 	sts	0x0741, r24	; 0x800741 <FrameOUT+0x16>
     c98:	80 92 45 07 	sts	0x0745, r8	; 0x800745 <FrameOUT+0x1a>
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
     c9c:	90 92 46 07 	sts	0x0746, r9	; 0x800746 <FrameOUT+0x1b>
     ca0:	a0 92 47 07 	sts	0x0747, r10	; 0x800747 <FrameOUT+0x1c>
     ca4:	b0 92 48 07 	sts	0x0748, r11	; 0x800748 <FrameOUT+0x1d>
     ca8:	40 92 49 07 	sts	0x0749, r4	; 0x800749 <FrameOUT+0x1e>
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
     cac:	50 92 4a 07 	sts	0x074A, r5	; 0x80074a <FrameOUT+0x1f>
     cb0:	60 92 4b 07 	sts	0x074B, r6	; 0x80074b <FrameOUT+0x20>
     cb4:	70 92 4c 07 	sts	0x074C, r7	; 0x80074c <FrameOUT+0x21>
     cb8:	64 e1       	ldi	r22, 0x14	; 20

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
     cba:	70 e0       	ldi	r23, 0x00	; 0
     cbc:	89 e3       	ldi	r24, 0x39	; 57
     cbe:	97 e0       	ldi	r25, 0x07	; 7
     cc0:	2d de       	rcall	.-934    	; 0x91c <Ethernet_Checksum16>
     cc2:	90 93 44 07 	sts	0x0744, r25	; 0x800744 <FrameOUT+0x19>
     cc6:	80 93 43 07 	sts	0x0743, r24	; 0x800743 <FrameOUT+0x18>
     cca:	ec e1       	ldi	r30, 0x1C	; 28

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     ccc:	f1 e0       	ldi	r31, 0x01	; 1
     cce:	a1 e3       	ldi	r26, 0x31	; 49
     cd0:	b7 e0       	ldi	r27, 0x07	; 7
     cd2:	81 2f       	mov	r24, r17
     cd4:	01 90       	ld	r0, Z+
     cd6:	0d 92       	st	X+, r0
     cd8:	8a 95       	dec	r24
     cda:	e1 f7       	brne	.-8      	; 0xcd4 <TCP_Task+0x1e6>
     cdc:	e2 e2       	ldi	r30, 0x22	; 34
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
     cde:	f1 e0       	ldi	r31, 0x01	; 1
     ce0:	ab e2       	ldi	r26, 0x2B	; 43
     ce2:	b7 e0       	ldi	r27, 0x07	; 7
     ce4:	01 90       	ld	r0, Z+
     ce6:	0d 92       	st	X+, r0
     ce8:	1a 95       	dec	r17
     cea:	e1 f7       	brne	.-8      	; 0xce4 <TCP_Task+0x1f6>
     cec:	88 e0       	ldi	r24, 0x08	; 8
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	90 93 38 07 	sts	0x0738, r25	; 0x800738 <FrameOUT+0xd>
     cf4:	80 93 37 07 	sts	0x0737, r24	; 0x800737 <FrameOUT+0xc>
     cf8:	86 e3       	ldi	r24, 0x36	; 54

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = PacketSize;
     cfa:	c8 0e       	add	r12, r24
     cfc:	d1 1c       	adc	r13, r1
     cfe:	d0 92 08 0d 	sts	0x0D08, r13	; 0x800d08 <FrameOUT+0x5dd>
     d02:	c0 92 07 0d 	sts	0x0D07, r12	; 0x800d07 <FrameOUT+0x5dc>
     d06:	cd 5e       	subi	r28, 0xED	; 237

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
     d08:	dd 4f       	sbci	r29, 0xFD	; 253
     d0a:	18 82       	st	Y, r1
     d0c:	07 c0       	rjmp	.+14     	; 0xd1c <TCP_Task+0x22e>

			break;
     d0e:	01 96       	adiw	r24, 0x01	; 1
     d10:	ea 5e       	subi	r30, 0xEA	; 234
     d12:	fd 4f       	sbci	r31, 0xFD	; 253
     d14:	83 30       	cpi	r24, 0x03	; 3
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     d16:	91 05       	cpc	r25, r1
     d18:	09 f0       	breq	.+2      	; 0xd1c <TCP_Task+0x22e>
     d1a:	23 cf       	rjmp	.-442    	; 0xb62 <TCP_Task+0x74>
     d1c:	df 91       	pop	r29
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
     d1e:	cf 91       	pop	r28
     d20:	1f 91       	pop	r17
     d22:	0f 91       	pop	r16
     d24:	ff 90       	pop	r15
     d26:	ef 90       	pop	r14
     d28:	df 90       	pop	r13
     d2a:	cf 90       	pop	r12
     d2c:	bf 90       	pop	r11
     d2e:	af 90       	pop	r10
     d30:	9f 90       	pop	r9
     d32:	8f 90       	pop	r8
     d34:	7f 90       	pop	r7
     d36:	6f 90       	pop	r6
     d38:	5f 90       	pop	r5
     d3a:	4f 90       	pop	r4
     d3c:	08 95       	ret

00000d3e <TCP_Init>:
     d3e:	10 92 4d 13 	sts	0x134D, r1	; 0x80134d <PortStateTable+0x2>
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     d42:	8a e0       	ldi	r24, 0x0A	; 10
     d44:	80 93 1e 0f 	sts	0x0F1E, r24	; 0x800f1e <ConnectionStateTable+0x215>
     d48:	80 93 34 11 	sts	0x1134, r24	; 0x801134 <ConnectionStateTable+0x42b>
     d4c:	80 93 4a 13 	sts	0x134A, r24	; 0x80134a <ConnectionStateTable+0x641>
     d50:	08 95       	ret

00000d52 <TCP_SetPortState>:

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     d52:	20 91 4b 13 	lds	r18, 0x134B	; 0x80134b <PortStateTable>
     d56:	30 91 4c 13 	lds	r19, 0x134C	; 0x80134c <PortStateTable+0x1>
     d5a:	28 17       	cp	r18, r24
     d5c:	39 07       	cpc	r19, r25
     d5e:	51 f0       	breq	.+20     	; 0xd74 <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     d60:	61 30       	cpi	r22, 0x01	; 1
     d62:	71 f4       	brne	.+28     	; 0xd80 <TCP_SetPortState+0x2e>
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     d64:	20 91 4d 13 	lds	r18, 0x134D	; 0x80134d <PortStateTable+0x2>
     d68:	21 11       	cpse	r18, r1
     d6a:	0c c0       	rjmp	.+24     	; 0xd84 <TCP_SetPortState+0x32>
			{
				PortStateTable[PTableEntry].Port  = Port;
     d6c:	90 93 4c 13 	sts	0x134C, r25	; 0x80134c <PortStateTable+0x1>
     d70:	80 93 4b 13 	sts	0x134B, r24	; 0x80134b <PortStateTable>
				PortStateTable[PTableEntry].State = State;
     d74:	60 93 4d 13 	sts	0x134D, r22	; 0x80134d <PortStateTable+0x2>
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     d78:	50 93 4f 13 	sts	0x134F, r21	; 0x80134f <PortStateTable+0x4>
     d7c:	40 93 4e 13 	sts	0x134E, r20	; 0x80134e <PortStateTable+0x3>
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
     d80:	81 e0       	ldi	r24, 0x01	; 1
     d82:	08 95       	ret
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
     d84:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     d86:	08 95       	ret

00000d88 <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     d88:	20 91 4b 13 	lds	r18, 0x134B	; 0x80134b <PortStateTable>
     d8c:	30 91 4c 13 	lds	r19, 0x134C	; 0x80134c <PortStateTable+0x1>
     d90:	28 17       	cp	r18, r24
     d92:	39 07       	cpc	r19, r25
     d94:	19 f4       	brne	.+6      	; 0xd9c <TCP_GetPortState+0x14>
		  return PortStateTable[PTableEntry].State;
     d96:	80 91 4d 13 	lds	r24, 0x134D	; 0x80134d <PortStateTable+0x2>
     d9a:	08 95       	ret
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
     d9c:	80 e0       	ldi	r24, 0x00	; 0
}
     d9e:	08 95       	ret

00000da0 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     da0:	9f 92       	push	r9
     da2:	af 92       	push	r10
     da4:	bf 92       	push	r11
     da6:	cf 92       	push	r12
     da8:	df 92       	push	r13
     daa:	ef 92       	push	r14
     dac:	ff 92       	push	r15
     dae:	0f 93       	push	r16
     db0:	1f 93       	push	r17
     db2:	cf 93       	push	r28
     db4:	df 93       	push	r29
     db6:	00 d0       	rcall	.+0      	; 0xdb8 <TCP_SetConnectionState+0x18>
     db8:	00 d0       	rcall	.+0      	; 0xdba <TCP_SetConnectionState+0x1a>
     dba:	cd b7       	in	r28, 0x3d	; 61
     dbc:	de b7       	in	r29, 0x3e	; 62
     dbe:	6c 01       	movw	r12, r24
     dc0:	49 83       	std	Y+1, r20	; 0x01
     dc2:	5a 83       	std	Y+2, r21	; 0x02
     dc4:	6b 83       	std	Y+3, r22	; 0x03
     dc6:	7c 83       	std	Y+4, r23	; 0x04
     dc8:	79 01       	movw	r14, r18
     dca:	90 2e       	mov	r9, r16
     dcc:	09 e0       	ldi	r16, 0x09	; 9
     dce:	1d e0       	ldi	r17, 0x0D	; 13
     dd0:	a1 2c       	mov	r10, r1
     dd2:	b1 2c       	mov	r11, r1
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     dd4:	f8 01       	movw	r30, r16
     dd6:	80 81       	ld	r24, Z
     dd8:	91 81       	ldd	r25, Z+1	; 0x01
     dda:	8c 15       	cp	r24, r12
     ddc:	9d 05       	cpc	r25, r13
     dde:	e9 f4       	brne	.+58     	; 0xe1a <TCP_SetConnectionState+0x7a>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     de0:	44 e0       	ldi	r20, 0x04	; 4
     de2:	50 e0       	ldi	r21, 0x00	; 0
     de4:	be 01       	movw	r22, r28
     de6:	6f 5f       	subi	r22, 0xFF	; 255
     de8:	7f 4f       	sbci	r23, 0xFF	; 255
     dea:	c8 01       	movw	r24, r16
     dec:	04 96       	adiw	r24, 0x04	; 4
     dee:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     df2:	89 2b       	or	r24, r25
     df4:	91 f4       	brne	.+36     	; 0xe1a <TCP_SetConnectionState+0x7a>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     df6:	f8 01       	movw	r30, r16
     df8:	82 81       	ldd	r24, Z+2	; 0x02
     dfa:	93 81       	ldd	r25, Z+3	; 0x03
     dfc:	8e 15       	cp	r24, r14
     dfe:	9f 05       	cpc	r25, r15
     e00:	61 f4       	brne	.+24     	; 0xe1a <TCP_SetConnectionState+0x7a>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     e02:	86 e1       	ldi	r24, 0x16	; 22
     e04:	92 e0       	ldi	r25, 0x02	; 2
     e06:	a8 9e       	mul	r10, r24
     e08:	f0 01       	movw	r30, r0
     e0a:	a9 9e       	mul	r10, r25
     e0c:	f0 0d       	add	r31, r0
     e0e:	b8 9e       	mul	r11, r24
     e10:	f0 0d       	add	r31, r0
     e12:	11 24       	eor	r1, r1
     e14:	e2 5e       	subi	r30, 0xE2	; 226
     e16:	f0 4f       	sbci	r31, 0xF0	; 240
     e18:	36 c0       	rjmp	.+108    	; 0xe86 <TCP_SetConnectionState+0xe6>
     e1a:	ff ef       	ldi	r31, 0xFF	; 255
     e1c:	af 1a       	sub	r10, r31
     e1e:	bf 0a       	sbc	r11, r31
     e20:	0a 5e       	subi	r16, 0xEA	; 234
     e22:	1d 4f       	sbci	r17, 0xFD	; 253
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     e24:	83 e0       	ldi	r24, 0x03	; 3
     e26:	a8 16       	cp	r10, r24
     e28:	b1 04       	cpc	r11, r1
     e2a:	a1 f6       	brne	.-88     	; 0xdd4 <TCP_SetConnectionState+0x34>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     e2c:	80 91 1e 0f 	lds	r24, 0x0F1E	; 0x800f1e <ConnectionStateTable+0x215>
     e30:	8a 30       	cpi	r24, 0x0A	; 10
     e32:	59 f0       	breq	.+22     	; 0xe4a <TCP_SetConnectionState+0xaa>
     e34:	80 91 34 11 	lds	r24, 0x1134	; 0x801134 <ConnectionStateTable+0x42b>
     e38:	8a 30       	cpi	r24, 0x0A	; 10
     e3a:	51 f0       	breq	.+20     	; 0xe50 <TCP_SetConnectionState+0xb0>
     e3c:	80 91 4a 13 	lds	r24, 0x134A	; 0x80134a <ConnectionStateTable+0x641>
     e40:	8a 30       	cpi	r24, 0x0A	; 10
     e42:	21 f5       	brne	.+72     	; 0xe8c <TCP_SetConnectionState+0xec>
     e44:	82 e0       	ldi	r24, 0x02	; 2
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	05 c0       	rjmp	.+10     	; 0xe54 <TCP_SetConnectionState+0xb4>
     e4a:	80 e0       	ldi	r24, 0x00	; 0
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	02 c0       	rjmp	.+4      	; 0xe54 <TCP_SetConnectionState+0xb4>
     e50:	81 e0       	ldi	r24, 0x01	; 1
     e52:	90 e0       	ldi	r25, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     e54:	26 e1       	ldi	r18, 0x16	; 22
     e56:	32 e0       	ldi	r19, 0x02	; 2
     e58:	82 9f       	mul	r24, r18
     e5a:	f0 01       	movw	r30, r0
     e5c:	83 9f       	mul	r24, r19
     e5e:	f0 0d       	add	r31, r0
     e60:	92 9f       	mul	r25, r18
     e62:	f0 0d       	add	r31, r0
     e64:	11 24       	eor	r1, r1
     e66:	e7 5f       	subi	r30, 0xF7	; 247
     e68:	f2 4f       	sbci	r31, 0xF2	; 242
     e6a:	d1 82       	std	Z+1, r13	; 0x01
     e6c:	c0 82       	st	Z, r12
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     e6e:	89 81       	ldd	r24, Y+1	; 0x01
     e70:	9a 81       	ldd	r25, Y+2	; 0x02
     e72:	ab 81       	ldd	r26, Y+3	; 0x03
     e74:	bc 81       	ldd	r27, Y+4	; 0x04
     e76:	84 83       	std	Z+4, r24	; 0x04
     e78:	95 83       	std	Z+5, r25	; 0x05
     e7a:	a6 83       	std	Z+6, r26	; 0x06
     e7c:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     e7e:	f3 82       	std	Z+3, r15	; 0x03
     e80:	e2 82       	std	Z+2, r14	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
     e82:	eb 5e       	subi	r30, 0xEB	; 235
     e84:	fd 4f       	sbci	r31, 0xFD	; 253
     e86:	90 82       	st	Z, r9
			return true;
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	01 c0       	rjmp	.+2      	; 0xe8e <TCP_SetConnectionState+0xee>
		}
	}

	return false;
     e8c:	80 e0       	ldi	r24, 0x00	; 0
}
     e8e:	0f 90       	pop	r0
     e90:	0f 90       	pop	r0
     e92:	0f 90       	pop	r0
     e94:	0f 90       	pop	r0
     e96:	df 91       	pop	r29
     e98:	cf 91       	pop	r28
     e9a:	1f 91       	pop	r17
     e9c:	0f 91       	pop	r16
     e9e:	ff 90       	pop	r15
     ea0:	ef 90       	pop	r14
     ea2:	df 90       	pop	r13
     ea4:	cf 90       	pop	r12
     ea6:	bf 90       	pop	r11
     ea8:	af 90       	pop	r10
     eaa:	9f 90       	pop	r9
     eac:	08 95       	ret

00000eae <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     eae:	af 92       	push	r10
     eb0:	bf 92       	push	r11
     eb2:	cf 92       	push	r12
     eb4:	df 92       	push	r13
     eb6:	ef 92       	push	r14
     eb8:	ff 92       	push	r15
     eba:	0f 93       	push	r16
     ebc:	1f 93       	push	r17
     ebe:	cf 93       	push	r28
     ec0:	df 93       	push	r29
     ec2:	00 d0       	rcall	.+0      	; 0xec4 <TCP_GetConnectionState+0x16>
     ec4:	00 d0       	rcall	.+0      	; 0xec6 <TCP_GetConnectionState+0x18>
     ec6:	cd b7       	in	r28, 0x3d	; 61
     ec8:	de b7       	in	r29, 0x3e	; 62
     eca:	6c 01       	movw	r12, r24
     ecc:	49 83       	std	Y+1, r20	; 0x01
     ece:	5a 83       	std	Y+2, r21	; 0x02
     ed0:	6b 83       	std	Y+3, r22	; 0x03
     ed2:	7c 83       	std	Y+4, r23	; 0x04
     ed4:	59 01       	movw	r10, r18
     ed6:	09 e0       	ldi	r16, 0x09	; 9
     ed8:	1d e0       	ldi	r17, 0x0D	; 13
     eda:	e1 2c       	mov	r14, r1
     edc:	f1 2c       	mov	r15, r1
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     ede:	f8 01       	movw	r30, r16
     ee0:	80 81       	ld	r24, Z
     ee2:	91 81       	ldd	r25, Z+1	; 0x01
     ee4:	8c 15       	cp	r24, r12
     ee6:	9d 05       	cpc	r25, r13
     ee8:	f1 f4       	brne	.+60     	; 0xf26 <TCP_GetConnectionState+0x78>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     eea:	44 e0       	ldi	r20, 0x04	; 4
     eec:	50 e0       	ldi	r21, 0x00	; 0
     eee:	be 01       	movw	r22, r28
     ef0:	6f 5f       	subi	r22, 0xFF	; 255
     ef2:	7f 4f       	sbci	r23, 0xFF	; 255
     ef4:	c8 01       	movw	r24, r16
     ef6:	04 96       	adiw	r24, 0x04	; 4
     ef8:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     efc:	89 2b       	or	r24, r25
     efe:	99 f4       	brne	.+38     	; 0xf26 <TCP_GetConnectionState+0x78>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     f00:	f8 01       	movw	r30, r16
     f02:	82 81       	ldd	r24, Z+2	; 0x02
     f04:	93 81       	ldd	r25, Z+3	; 0x03
     f06:	8a 15       	cp	r24, r10
     f08:	9b 05       	cpc	r25, r11
     f0a:	69 f4       	brne	.+26     	; 0xf26 <TCP_GetConnectionState+0x78>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     f0c:	86 e1       	ldi	r24, 0x16	; 22
     f0e:	92 e0       	ldi	r25, 0x02	; 2
     f10:	e8 9e       	mul	r14, r24
     f12:	f0 01       	movw	r30, r0
     f14:	e9 9e       	mul	r14, r25
     f16:	f0 0d       	add	r31, r0
     f18:	f8 9e       	mul	r15, r24
     f1a:	f0 0d       	add	r31, r0
     f1c:	11 24       	eor	r1, r1
     f1e:	e2 5e       	subi	r30, 0xE2	; 226
     f20:	f0 4f       	sbci	r31, 0xF0	; 240
     f22:	80 81       	ld	r24, Z
     f24:	0a c0       	rjmp	.+20     	; 0xf3a <TCP_GetConnectionState+0x8c>
     f26:	ff ef       	ldi	r31, 0xFF	; 255
     f28:	ef 1a       	sub	r14, r31
     f2a:	ff 0a       	sbc	r15, r31
     f2c:	0a 5e       	subi	r16, 0xEA	; 234
     f2e:	1d 4f       	sbci	r17, 0xFD	; 253
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     f30:	83 e0       	ldi	r24, 0x03	; 3
     f32:	e8 16       	cp	r14, r24
     f34:	f1 04       	cpc	r15, r1
     f36:	99 f6       	brne	.-90     	; 0xede <TCP_GetConnectionState+0x30>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
     f38:	8a e0       	ldi	r24, 0x0A	; 10
}
     f3a:	0f 90       	pop	r0
     f3c:	0f 90       	pop	r0
     f3e:	0f 90       	pop	r0
     f40:	0f 90       	pop	r0
     f42:	df 91       	pop	r29
     f44:	cf 91       	pop	r28
     f46:	1f 91       	pop	r17
     f48:	0f 91       	pop	r16
     f4a:	ff 90       	pop	r15
     f4c:	ef 90       	pop	r14
     f4e:	df 90       	pop	r13
     f50:	cf 90       	pop	r12
     f52:	bf 90       	pop	r11
     f54:	af 90       	pop	r10
     f56:	08 95       	ret

00000f58 <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     f58:	af 92       	push	r10
     f5a:	bf 92       	push	r11
     f5c:	cf 92       	push	r12
     f5e:	df 92       	push	r13
     f60:	ef 92       	push	r14
     f62:	ff 92       	push	r15
     f64:	0f 93       	push	r16
     f66:	1f 93       	push	r17
     f68:	cf 93       	push	r28
     f6a:	df 93       	push	r29
     f6c:	00 d0       	rcall	.+0      	; 0xf6e <TCP_GetConnectionInfo+0x16>
     f6e:	00 d0       	rcall	.+0      	; 0xf70 <TCP_GetConnectionInfo+0x18>
     f70:	cd b7       	in	r28, 0x3d	; 61
     f72:	de b7       	in	r29, 0x3e	; 62
     f74:	6c 01       	movw	r12, r24
     f76:	49 83       	std	Y+1, r20	; 0x01
     f78:	5a 83       	std	Y+2, r21	; 0x02
     f7a:	6b 83       	std	Y+3, r22	; 0x03
     f7c:	7c 83       	std	Y+4, r23	; 0x04
     f7e:	59 01       	movw	r10, r18
     f80:	09 e0       	ldi	r16, 0x09	; 9
     f82:	1d e0       	ldi	r17, 0x0D	; 13
     f84:	e1 2c       	mov	r14, r1
     f86:	f1 2c       	mov	r15, r1
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     f88:	f8 01       	movw	r30, r16
     f8a:	80 81       	ld	r24, Z
     f8c:	91 81       	ldd	r25, Z+1	; 0x01
     f8e:	8c 15       	cp	r24, r12
     f90:	9d 05       	cpc	r25, r13
     f92:	e9 f4       	brne	.+58     	; 0xfce <TCP_GetConnectionInfo+0x76>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     f94:	44 e0       	ldi	r20, 0x04	; 4
     f96:	50 e0       	ldi	r21, 0x00	; 0
     f98:	be 01       	movw	r22, r28
     f9a:	6f 5f       	subi	r22, 0xFF	; 255
     f9c:	7f 4f       	sbci	r23, 0xFF	; 255
     f9e:	c8 01       	movw	r24, r16
     fa0:	04 96       	adiw	r24, 0x04	; 4
     fa2:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     fa6:	89 2b       	or	r24, r25
     fa8:	91 f4       	brne	.+36     	; 0xfce <TCP_GetConnectionInfo+0x76>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     faa:	f8 01       	movw	r30, r16
     fac:	82 81       	ldd	r24, Z+2	; 0x02
     fae:	93 81       	ldd	r25, Z+3	; 0x03
     fb0:	8a 15       	cp	r24, r10
     fb2:	9b 05       	cpc	r25, r11
     fb4:	61 f4       	brne	.+24     	; 0xfce <TCP_GetConnectionInfo+0x76>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     fb6:	26 e1       	ldi	r18, 0x16	; 22
     fb8:	32 e0       	ldi	r19, 0x02	; 2
     fba:	e2 9e       	mul	r14, r18
     fbc:	c0 01       	movw	r24, r0
     fbe:	e3 9e       	mul	r14, r19
     fc0:	90 0d       	add	r25, r0
     fc2:	f2 9e       	mul	r15, r18
     fc4:	90 0d       	add	r25, r0
     fc6:	11 24       	eor	r1, r1
     fc8:	8f 5e       	subi	r24, 0xEF	; 239
     fca:	92 4f       	sbci	r25, 0xF2	; 242
     fcc:	0b c0       	rjmp	.+22     	; 0xfe4 <TCP_GetConnectionInfo+0x8c>
     fce:	ff ef       	ldi	r31, 0xFF	; 255
     fd0:	ef 1a       	sub	r14, r31
     fd2:	ff 0a       	sbc	r15, r31
     fd4:	0a 5e       	subi	r16, 0xEA	; 234
     fd6:	1d 4f       	sbci	r17, 0xFD	; 253
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     fd8:	83 e0       	ldi	r24, 0x03	; 3
     fda:	e8 16       	cp	r14, r24
     fdc:	f1 04       	cpc	r15, r1
     fde:	a1 f6       	brne	.-88     	; 0xf88 <TCP_GetConnectionInfo+0x30>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	90 e0       	ldi	r25, 0x00	; 0
}
     fe4:	0f 90       	pop	r0
     fe6:	0f 90       	pop	r0
     fe8:	0f 90       	pop	r0
     fea:	0f 90       	pop	r0
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	1f 91       	pop	r17
     ff2:	0f 91       	pop	r16
     ff4:	ff 90       	pop	r15
     ff6:	ef 90       	pop	r14
     ff8:	df 90       	pop	r13
     ffa:	cf 90       	pop	r12
     ffc:	bf 90       	pop	r11
     ffe:	af 90       	pop	r10
    1000:	08 95       	ret

00001002 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
    1002:	4f 92       	push	r4
    1004:	5f 92       	push	r5
    1006:	6f 92       	push	r6
    1008:	7f 92       	push	r7
    100a:	8f 92       	push	r8
    100c:	9f 92       	push	r9
    100e:	af 92       	push	r10
    1010:	bf 92       	push	r11
    1012:	cf 92       	push	r12
    1014:	df 92       	push	r13
    1016:	ef 92       	push	r14
    1018:	ff 92       	push	r15
    101a:	0f 93       	push	r16
    101c:	1f 93       	push	r17
    101e:	cf 93       	push	r28
    1020:	df 93       	push	r29
    1022:	7c 01       	movw	r14, r24
    1024:	eb 01       	movw	r28, r22
    1026:	6a 01       	movw	r12, r20
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
    1028:	cb 01       	movw	r24, r22
    102a:	ad dc       	rcall	.-1702   	; 0x986 <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
    102c:	aa 80       	ldd	r10, Y+2	; 0x02
    102e:	bb 80       	ldd	r11, Y+3	; 0x03
    1030:	c5 01       	movw	r24, r10
    1032:	aa de       	rcall	.-684    	; 0xd88 <TCP_GetPortState>
    1034:	81 30       	cpi	r24, 0x01	; 1
    1036:	21 f5       	brne	.+72     	; 0x1080 <TCP_ProcessTCPPacket+0x7e>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
    1038:	8d 85       	ldd	r24, Y+13	; 0x0d
    103a:	81 ff       	sbrs	r24, 1
    103c:	0c c0       	rjmp	.+24     	; 0x1056 <TCP_ProcessTCPPacket+0x54>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
    103e:	28 81       	ld	r18, Y
    1040:	39 81       	ldd	r19, Y+1	; 0x01
    1042:	d7 01       	movw	r26, r14
    1044:	1c 96       	adiw	r26, 0x0c	; 12
    1046:	4d 91       	ld	r20, X+
    1048:	5d 91       	ld	r21, X+
    104a:	6d 91       	ld	r22, X+
    104c:	7c 91       	ld	r23, X
    104e:	1f 97       	sbiw	r26, 0x0f	; 15
    1050:	00 e0       	ldi	r16, 0x00	; 0
    1052:	c5 01       	movw	r24, r10
    1054:	a5 de       	rcall	.-694    	; 0xda0 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
    1056:	1d 85       	ldd	r17, Y+13	; 0x0d
    1058:	aa 80       	ldd	r10, Y+2	; 0x02
    105a:	bb 80       	ldd	r11, Y+3	; 0x03
    105c:	88 80       	ld	r8, Y
    105e:	99 80       	ldd	r9, Y+1	; 0x01
    1060:	f7 01       	movw	r30, r14
    1062:	44 84       	ldd	r4, Z+12	; 0x0c
    1064:	55 84       	ldd	r5, Z+13	; 0x0d
    1066:	66 84       	ldd	r6, Z+14	; 0x0e
    1068:	77 84       	ldd	r7, Z+15	; 0x0f
    106a:	12 ff       	sbrs	r17, 2
    106c:	0e c0       	rjmp	.+28     	; 0x108a <TCP_ProcessTCPPacket+0x88>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    106e:	0a e0       	ldi	r16, 0x0A	; 10
    1070:	94 01       	movw	r18, r8
    1072:	b3 01       	movw	r22, r6
    1074:	a2 01       	movw	r20, r4
    1076:	c5 01       	movw	r24, r10
    1078:	93 de       	rcall	.-730    	; 0xda0 <TCP_SetConnectionState>
    107a:	88 23       	and	r24, r24
    107c:	09 f4       	brne	.+2      	; 0x1080 <TCP_ProcessTCPPacket+0x7e>
    107e:	6e c1       	rjmp	.+732    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1080:	84 e1       	ldi	r24, 0x14	; 20
    1082:	d6 01       	movw	r26, r12
    1084:	1d 96       	adiw	r26, 0x0d	; 13
    1086:	8c 93       	st	X, r24
    1088:	6c c1       	rjmp	.+728    	; 0x1362 <TCP_ProcessTCPPacket+0x360>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
    108a:	94 01       	movw	r18, r8
    108c:	b3 01       	movw	r22, r6
    108e:	a2 01       	movw	r20, r4
    1090:	c5 01       	movw	r24, r10
    1092:	0d df       	rcall	.-486    	; 0xeae <TCP_GetConnectionState>
    1094:	90 e0       	ldi	r25, 0x00	; 0
    1096:	88 30       	cpi	r24, 0x08	; 8
    1098:	91 05       	cpc	r25, r1
    109a:	08 f0       	brcs	.+2      	; 0x109e <TCP_ProcessTCPPacket+0x9c>
    109c:	5f c1       	rjmp	.+702    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
    109e:	fc 01       	movw	r30, r24
    10a0:	e4 5b       	subi	r30, 0xB4	; 180
    10a2:	ff 4f       	sbci	r31, 0xFF	; 255
    10a4:	0c 94 2f 14 	jmp	0x285e	; 0x285e <__tablejump2__>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
    10a8:	12 30       	cpi	r17, 0x02	; 2
    10aa:	09 f0       	breq	.+2      	; 0x10ae <TCP_ProcessTCPPacket+0xac>
    10ac:	57 c1       	rjmp	.+686    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10ae:	02 e0       	ldi	r16, 0x02	; 2
    10b0:	94 01       	movw	r18, r8
    10b2:	b3 01       	movw	r22, r6
    10b4:	a2 01       	movw	r20, r4
    10b6:	c5 01       	movw	r24, r10
    10b8:	73 de       	rcall	.-794    	; 0xda0 <TCP_SetConnectionState>
    10ba:	88 23       	and	r24, r24
    10bc:	39 f1       	breq	.+78     	; 0x110c <TCP_ProcessTCPPacket+0x10a>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
    10be:	82 e1       	ldi	r24, 0x12	; 18
    10c0:	f6 01       	movw	r30, r12
    10c2:	85 87       	std	Z+13, r24	; 0x0d

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
    10c4:	28 81       	ld	r18, Y
    10c6:	39 81       	ldd	r19, Y+1	; 0x01
    10c8:	d7 01       	movw	r26, r14
    10ca:	1c 96       	adiw	r26, 0x0c	; 12
    10cc:	4d 91       	ld	r20, X+
    10ce:	5d 91       	ld	r21, X+
    10d0:	6d 91       	ld	r22, X+
    10d2:	7c 91       	ld	r23, X
    10d4:	1f 97       	sbiw	r26, 0x0f	; 15
    10d6:	8a 81       	ldd	r24, Y+2	; 0x02
    10d8:	9b 81       	ldd	r25, Y+3	; 0x03
    10da:	3e df       	rcall	.-388    	; 0xf58 <TCP_GetConnectionInfo>

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
    10dc:	8c 01       	movw	r16, r24
    10de:	6c 81       	ldd	r22, Y+4	; 0x04
    10e0:	7d 81       	ldd	r23, Y+5	; 0x05
    10e2:	8e 81       	ldd	r24, Y+6	; 0x06
    10e4:	9f 81       	ldd	r25, Y+7	; 0x07
    10e6:	92 dc       	rcall	.-1756   	; 0xa0c <SwapEndian_32>
    10e8:	dc 01       	movw	r26, r24
    10ea:	cb 01       	movw	r24, r22
    10ec:	01 96       	adiw	r24, 0x01	; 1
    10ee:	a1 1d       	adc	r26, r1
    10f0:	b1 1d       	adc	r27, r1
    10f2:	f8 01       	movw	r30, r16
    10f4:	80 83       	st	Z, r24
    10f6:	91 83       	std	Z+1, r25	; 0x01
    10f8:	a2 83       	std	Z+2, r26	; 0x02
    10fa:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
    10fc:	14 82       	std	Z+4, r1	; 0x04
    10fe:	15 82       	std	Z+5, r1	; 0x05
    1100:	16 82       	std	Z+6, r1	; 0x06
    1102:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
    1104:	e4 5f       	subi	r30, 0xF4	; 244
    1106:	fd 4f       	sbci	r31, 0xFD	; 253
    1108:	10 82       	st	Z, r1
    110a:	2b c1       	rjmp	.+598    	; 0x1362 <TCP_ProcessTCPPacket+0x360>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
    110c:	84 e0       	ldi	r24, 0x04	; 4
    110e:	ca c0       	rjmp	.+404    	; 0x12a4 <TCP_ProcessTCPPacket+0x2a2>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1110:	10 31       	cpi	r17, 0x10	; 16
    1112:	09 f0       	breq	.+2      	; 0x1116 <TCP_ProcessTCPPacket+0x114>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1114:	23 c1       	rjmp	.+582    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
    1116:	03 e0       	ldi	r16, 0x03	; 3
    1118:	94 01       	movw	r18, r8
    111a:	b3 01       	movw	r22, r6
    111c:	a2 01       	movw	r20, r4
    111e:	c5 01       	movw	r24, r10
    1120:	3f de       	rcall	.-898    	; 0xda0 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1122:	28 81       	ld	r18, Y
    1124:	39 81       	ldd	r19, Y+1	; 0x01
    1126:	d7 01       	movw	r26, r14
    1128:	1c 96       	adiw	r26, 0x0c	; 12
    112a:	4d 91       	ld	r20, X+
    112c:	5d 91       	ld	r21, X+
    112e:	6d 91       	ld	r22, X+
    1130:	7c 91       	ld	r23, X
    1132:	1f 97       	sbiw	r26, 0x0f	; 15
    1134:	8a 81       	ldd	r24, Y+2	; 0x02
    1136:	9b 81       	ldd	r25, Y+3	; 0x03
    1138:	0f df       	rcall	.-482    	; 0xf58 <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
    113a:	fc 01       	movw	r30, r24
    113c:	44 81       	ldd	r20, Z+4	; 0x04
    113e:	55 81       	ldd	r21, Z+5	; 0x05
    1140:	66 81       	ldd	r22, Z+6	; 0x06
    1142:	77 81       	ldd	r23, Z+7	; 0x07
    1144:	4f 5f       	subi	r20, 0xFF	; 255
    1146:	5f 4f       	sbci	r21, 0xFF	; 255
    1148:	6f 4f       	sbci	r22, 0xFF	; 255
    114a:	7f 4f       	sbci	r23, 0xFF	; 255
    114c:	44 83       	std	Z+4, r20	; 0x04
    114e:	55 83       	std	Z+5, r21	; 0x05
    1150:	66 83       	std	Z+6, r22	; 0x06
    1152:	77 83       	std	Z+7, r23	; 0x07
    1154:	03 c1       	rjmp	.+518    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1156:	11 31       	cpi	r17, 0x11	; 17
    1158:	89 f5       	brne	.+98     	; 0x11bc <TCP_ProcessTCPPacket+0x1ba>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
    115a:	f6 01       	movw	r30, r12
    115c:	15 87       	std	Z+13, r17	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    115e:	28 81       	ld	r18, Y
    1160:	39 81       	ldd	r19, Y+1	; 0x01
    1162:	d7 01       	movw	r26, r14
    1164:	1c 96       	adiw	r26, 0x0c	; 12
    1166:	4d 91       	ld	r20, X+
    1168:	5d 91       	ld	r21, X+
    116a:	6d 91       	ld	r22, X+
    116c:	7c 91       	ld	r23, X
    116e:	1f 97       	sbiw	r26, 0x0f	; 15
    1170:	06 e0       	ldi	r16, 0x06	; 6
    1172:	8a 81       	ldd	r24, Y+2	; 0x02
    1174:	9b 81       	ldd	r25, Y+3	; 0x03
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1176:	14 de       	rcall	.-984    	; 0xda0 <TCP_SetConnectionState>
    1178:	28 81       	ld	r18, Y
    117a:	39 81       	ldd	r19, Y+1	; 0x01
    117c:	f7 01       	movw	r30, r14
    117e:	44 85       	ldd	r20, Z+12	; 0x0c
    1180:	55 85       	ldd	r21, Z+13	; 0x0d
    1182:	66 85       	ldd	r22, Z+14	; 0x0e
    1184:	77 85       	ldd	r23, Z+15	; 0x0f
    1186:	8a 81       	ldd	r24, Y+2	; 0x02
    1188:	9b 81       	ldd	r25, Y+3	; 0x03
    118a:	e6 de       	rcall	.-564    	; 0xf58 <TCP_GetConnectionInfo>
    118c:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
    118e:	80 81       	ld	r24, Z
    1190:	91 81       	ldd	r25, Z+1	; 0x01
    1192:	a2 81       	ldd	r26, Z+2	; 0x02
    1194:	b3 81       	ldd	r27, Z+3	; 0x03
    1196:	01 96       	adiw	r24, 0x01	; 1
    1198:	a1 1d       	adc	r26, r1
    119a:	b1 1d       	adc	r27, r1
    119c:	80 83       	st	Z, r24
    119e:	91 83       	std	Z+1, r25	; 0x01
    11a0:	a2 83       	std	Z+2, r26	; 0x02
    11a2:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    11a4:	84 81       	ldd	r24, Z+4	; 0x04
    11a6:	95 81       	ldd	r25, Z+5	; 0x05
    11a8:	a6 81       	ldd	r26, Z+6	; 0x06
    11aa:	b7 81       	ldd	r27, Z+7	; 0x07
    11ac:	01 96       	adiw	r24, 0x01	; 1
    11ae:	a1 1d       	adc	r26, r1
    11b0:	b1 1d       	adc	r27, r1
    11b2:	84 83       	std	Z+4, r24	; 0x04
    11b4:	95 83       	std	Z+5, r25	; 0x05
    11b6:	a6 83       	std	Z+6, r26	; 0x06
    11b8:	b7 83       	std	Z+7, r27	; 0x07
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
    11ba:	d3 c0       	rjmp	.+422    	; 0x1362 <TCP_ProcessTCPPacket+0x360>
    11bc:	17 7f       	andi	r17, 0xF7	; 247
    11be:	10 31       	cpi	r17, 0x10	; 16
    11c0:	09 f0       	breq	.+2      	; 0x11c4 <TCP_ProcessTCPPacket+0x1c2>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    11c2:	cc c0       	rjmp	.+408    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
    11c4:	94 01       	movw	r18, r8
    11c6:	b3 01       	movw	r22, r6
    11c8:	a2 01       	movw	r20, r4
    11ca:	c5 01       	movw	r24, r10
    11cc:	c5 de       	rcall	.-630    	; 0xf58 <TCP_GetConnectionInfo>
    11ce:	8c 01       	movw	r16, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
    11d0:	4c 01       	movw	r8, r24
    11d2:	f4 ef       	ldi	r31, 0xF4	; 244
    11d4:	8f 1a       	sub	r8, r31
    11d6:	fd ef       	ldi	r31, 0xFD	; 253
    11d8:	9f 0a       	sbc	r9, r31
    11da:	d4 01       	movw	r26, r8
    11dc:	8c 91       	ld	r24, X
    11de:	f8 01       	movw	r30, r16
    11e0:	e6 5f       	subi	r30, 0xF6	; 246
    11e2:	fd 4f       	sbci	r31, 0xFD	; 253
    11e4:	81 11       	cpse	r24, r1
    11e6:	0d c0       	rjmp	.+26     	; 0x1202 <TCP_ProcessTCPPacket+0x200>
    11e8:	11 97       	sbiw	r26, 0x01	; 1
    11ea:	8c 91       	ld	r24, X
    11ec:	81 11       	cpse	r24, r1
    11ee:	09 c0       	rjmp	.+18     	; 0x1202 <TCP_ProcessTCPPacket+0x200>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
    11f0:	10 82       	st	Z, r1
							ConnectionInfo->Buffer.InUse     = true;
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	d4 01       	movw	r26, r8
    11f6:	8c 93       	st	X, r24
							ConnectionInfo->Buffer.Length    = 0;
    11f8:	d8 01       	movw	r26, r16
    11fa:	19 96       	adiw	r26, 0x09	; 9
    11fc:	1c 92       	st	X, r1
    11fe:	1e 92       	st	-X, r1
    1200:	18 97       	sbiw	r26, 0x08	; 8
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    1202:	80 81       	ld	r24, Z
    1204:	81 11       	cpse	r24, r1
    1206:	a7 c0       	rjmp	.+334    	; 0x1356 <TCP_ProcessTCPPacket+0x354>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
    1208:	f8 01       	movw	r30, r16
    120a:	60 84       	ldd	r6, Z+8	; 0x08
    120c:	71 84       	ldd	r7, Z+9	; 0x09
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    120e:	61 14       	cp	r6, r1
    1210:	f2 e0       	ldi	r31, 0x02	; 2
    1212:	7f 06       	cpc	r7, r31
    1214:	09 f4       	brne	.+2      	; 0x1218 <TCP_ProcessTCPPacket+0x216>
    1216:	9f c0       	rjmp	.+318    	; 0x1356 <TCP_ProcessTCPPacket+0x354>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1218:	d7 01       	movw	r26, r14
    121a:	8c 91       	ld	r24, X
    121c:	8f 70       	andi	r24, 0x0F	; 15
    121e:	b4 e0       	ldi	r27, 0x04	; 4
    1220:	8b 9f       	mul	r24, r27
    1222:	50 01       	movw	r10, r0
    1224:	11 24       	eor	r1, r1
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    1226:	4c 84       	ldd	r4, Y+12	; 0x0c
    1228:	42 94       	swap	r4
    122a:	9f e0       	ldi	r25, 0x0F	; 15
    122c:	49 22       	and	r4, r25
    122e:	e4 e0       	ldi	r30, 0x04	; 4
    1230:	4e 9e       	mul	r4, r30
    1232:	20 01       	movw	r4, r0
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    1234:	11 24       	eor	r1, r1
    1236:	d7 01       	movw	r26, r14
    1238:	12 96       	adiw	r26, 0x02	; 2
    123a:	8d 91       	ld	r24, X+
    123c:	9c 91       	ld	r25, X
    123e:	13 97       	sbiw	r26, 0x03	; 3
    1240:	eb db       	rcall	.-2090   	; 0xa18 <SwapEndian_16>
    1242:	8a 19       	sub	r24, r10
    1244:	9b 09       	sbc	r25, r11
    1246:	5c 01       	movw	r10, r24
    1248:	a4 18       	sub	r10, r4
    124a:	b5 08       	sbc	r11, r5

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    124c:	c3 01       	movw	r24, r6
    124e:	0a 96       	adiw	r24, 0x0a	; 10
    1250:	be 01       	movw	r22, r28
    1252:	64 0d       	add	r22, r4
    1254:	75 1d       	adc	r23, r5
    1256:	a5 01       	movw	r20, r10
    1258:	80 0f       	add	r24, r16
    125a:	91 1f       	adc	r25, r17
    125c:	0e 94 6d 14 	call	0x28da	; 0x28da <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1260:	f8 01       	movw	r30, r16
    1262:	80 81       	ld	r24, Z
    1264:	91 81       	ldd	r25, Z+1	; 0x01
    1266:	a2 81       	ldd	r26, Z+2	; 0x02
    1268:	b3 81       	ldd	r27, Z+3	; 0x03
    126a:	8a 0d       	add	r24, r10
    126c:	9b 1d       	adc	r25, r11
    126e:	a1 1d       	adc	r26, r1
    1270:	b1 1d       	adc	r27, r1
    1272:	80 83       	st	Z, r24
    1274:	91 83       	std	Z+1, r25	; 0x01
    1276:	a2 83       	std	Z+2, r26	; 0x02
    1278:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    127a:	80 85       	ldd	r24, Z+8	; 0x08
    127c:	91 85       	ldd	r25, Z+9	; 0x09
    127e:	a8 0e       	add	r10, r24
    1280:	b9 1e       	adc	r11, r25
    1282:	b1 86       	std	Z+9, r11	; 0x09
    1284:	a0 86       	std	Z+8, r10	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    1286:	a1 14       	cp	r10, r1
    1288:	f2 e0       	ldi	r31, 0x02	; 2
    128a:	bf 06       	cpc	r11, r31
    128c:	19 f0       	breq	.+6      	; 0x1294 <TCP_ProcessTCPPacket+0x292>
    128e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1290:	83 ff       	sbrs	r24, 3
    1292:	64 c0       	rjmp	.+200    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
							{
								ConnectionInfo->Buffer.InUse = false;
    1294:	d4 01       	movw	r26, r8
								ConnectionInfo->Buffer.Ready = true;
    1296:	1c 92       	st	X, r1
    1298:	f8 01       	movw	r30, r16
    129a:	e5 5f       	subi	r30, 0xF5	; 245
    129c:	fd 4f       	sbci	r31, 0xFD	; 253
    129e:	81 e0       	ldi	r24, 0x01	; 1

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    12a0:	80 83       	st	Z, r24
    12a2:	80 e1       	ldi	r24, 0x10	; 16
    12a4:	f6 01       	movw	r30, r12
    12a6:	85 87       	std	Z+13, r24	; 0x0d
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12a8:	5c c0       	rjmp	.+184    	; 0x1362 <TCP_ProcessTCPPacket+0x360>
    12aa:	94 01       	movw	r18, r8
    12ac:	b3 01       	movw	r22, r6
    12ae:	a2 01       	movw	r20, r4
    12b0:	c5 01       	movw	r24, r10
    12b2:	52 de       	rcall	.-860    	; 0xf58 <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    12b4:	21 e1       	ldi	r18, 0x11	; 17
    12b6:	d6 01       	movw	r26, r12
    12b8:	1d 96       	adiw	r26, 0x0d	; 13
    12ba:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    12bc:	84 5f       	subi	r24, 0xF4	; 244
    12be:	9d 4f       	sbci	r25, 0xFD	; 253
    12c0:	fc 01       	movw	r30, r24
    12c2:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12c4:	28 81       	ld	r18, Y
    12c6:	39 81       	ldd	r19, Y+1	; 0x01
    12c8:	d7 01       	movw	r26, r14
    12ca:	1c 96       	adiw	r26, 0x0c	; 12
    12cc:	4d 91       	ld	r20, X+
    12ce:	5d 91       	ld	r21, X+
    12d0:	6d 91       	ld	r22, X+
    12d2:	7c 91       	ld	r23, X
    12d4:	1f 97       	sbiw	r26, 0x0f	; 15
    12d6:	04 e0       	ldi	r16, 0x04	; 4
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    12d8:	31 c0       	rjmp	.+98     	; 0x133c <TCP_ProcessTCPPacket+0x33a>
    12da:	11 31       	cpi	r17, 0x11	; 17
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    12dc:	39 f0       	breq	.+14     	; 0x12ec <TCP_ProcessTCPPacket+0x2ea>
    12de:	10 31       	cpi	r17, 0x10	; 16
    12e0:	09 f0       	breq	.+2      	; 0x12e4 <TCP_ProcessTCPPacket+0x2e2>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12e2:	3c c0       	rjmp	.+120    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
    12e4:	05 e0       	ldi	r16, 0x05	; 5
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    12e6:	31 c0       	rjmp	.+98     	; 0x134a <TCP_ProcessTCPPacket+0x348>
    12e8:	11 31       	cpi	r17, 0x11	; 17
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12ea:	c1 f5       	brne	.+112    	; 0x135c <TCP_ProcessTCPPacket+0x35a>
    12ec:	94 01       	movw	r18, r8
    12ee:	b3 01       	movw	r22, r6
    12f0:	a2 01       	movw	r20, r4
    12f2:	c5 01       	movw	r24, r10
    12f4:	31 de       	rcall	.-926    	; 0xf58 <TCP_GetConnectionInfo>
    12f6:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    12f8:	80 e1       	ldi	r24, 0x10	; 16
    12fa:	d6 01       	movw	r26, r12
    12fc:	1d 96       	adiw	r26, 0x0d	; 13
    12fe:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1300:	80 81       	ld	r24, Z
    1302:	91 81       	ldd	r25, Z+1	; 0x01
    1304:	a2 81       	ldd	r26, Z+2	; 0x02
    1306:	b3 81       	ldd	r27, Z+3	; 0x03
    1308:	01 96       	adiw	r24, 0x01	; 1
    130a:	a1 1d       	adc	r26, r1
    130c:	b1 1d       	adc	r27, r1
    130e:	80 83       	st	Z, r24
    1310:	91 83       	std	Z+1, r25	; 0x01
    1312:	a2 83       	std	Z+2, r26	; 0x02
    1314:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1316:	84 81       	ldd	r24, Z+4	; 0x04
    1318:	95 81       	ldd	r25, Z+5	; 0x05
    131a:	a6 81       	ldd	r26, Z+6	; 0x06
    131c:	b7 81       	ldd	r27, Z+7	; 0x07
    131e:	01 96       	adiw	r24, 0x01	; 1
    1320:	a1 1d       	adc	r26, r1
    1322:	b1 1d       	adc	r27, r1
    1324:	84 83       	std	Z+4, r24	; 0x04
    1326:	95 83       	std	Z+5, r25	; 0x05
    1328:	a6 83       	std	Z+6, r26	; 0x06

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    132a:	b7 83       	std	Z+7, r27	; 0x07
    132c:	28 81       	ld	r18, Y
    132e:	39 81       	ldd	r19, Y+1	; 0x01
    1330:	f7 01       	movw	r30, r14
    1332:	44 85       	ldd	r20, Z+12	; 0x0c
    1334:	55 85       	ldd	r21, Z+13	; 0x0d
    1336:	66 85       	ldd	r22, Z+14	; 0x0e
    1338:	77 85       	ldd	r23, Z+15	; 0x0f
    133a:	0a e0       	ldi	r16, 0x0A	; 10
    133c:	8a 81       	ldd	r24, Y+2	; 0x02
    133e:	9b 81       	ldd	r25, Y+3	; 0x03
    1340:	2f dd       	rcall	.-1442   	; 0xda0 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1342:	0f c0       	rjmp	.+30     	; 0x1362 <TCP_ProcessTCPPacket+0x360>
    1344:	10 31       	cpi	r17, 0x10	; 16
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1346:	51 f4       	brne	.+20     	; 0x135c <TCP_ProcessTCPPacket+0x35a>
    1348:	0a e0       	ldi	r16, 0x0A	; 10
    134a:	94 01       	movw	r18, r8
    134c:	b3 01       	movw	r22, r6
    134e:	a2 01       	movw	r20, r4
    1350:	c5 01       	movw	r24, r10
    1352:	26 dd       	rcall	.-1460   	; 0xda0 <TCP_SetConnectionState>
    1354:	03 c0       	rjmp	.+6      	; 0x135c <TCP_ProcessTCPPacket+0x35a>
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    1356:	8f ef       	ldi	r24, 0xFF	; 255
    1358:	9f ef       	ldi	r25, 0xFF	; 255
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
	}

	return NO_RESPONSE;
    135a:	69 c0       	rjmp	.+210    	; 0x142e <TCP_ProcessTCPPacket+0x42c>
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	90 e0       	ldi	r25, 0x00	; 0
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1360:	66 c0       	rjmp	.+204    	; 0x142e <TCP_ProcessTCPPacket+0x42c>
    1362:	aa 80       	ldd	r10, Y+2	; 0x02
    1364:	bb 80       	ldd	r11, Y+3	; 0x03
    1366:	28 81       	ld	r18, Y
    1368:	39 81       	ldd	r19, Y+1	; 0x01
    136a:	d7 01       	movw	r26, r14
    136c:	1c 96       	adiw	r26, 0x0c	; 12
    136e:	4d 91       	ld	r20, X+
    1370:	5d 91       	ld	r21, X+
    1372:	6d 91       	ld	r22, X+
    1374:	7c 91       	ld	r23, X
    1376:	1f 97       	sbiw	r26, 0x0f	; 15
    1378:	c5 01       	movw	r24, r10
    137a:	ee dd       	rcall	.-1060   	; 0xf58 <TCP_GetConnectionInfo>
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    137c:	8c 01       	movw	r16, r24
    137e:	f6 01       	movw	r30, r12
    1380:	b1 82       	std	Z+1, r11	; 0x01
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1382:	a0 82       	st	Z, r10
    1384:	88 81       	ld	r24, Y
    1386:	99 81       	ldd	r25, Y+1	; 0x01
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1388:	93 83       	std	Z+3, r25	; 0x03
    138a:	82 83       	std	Z+2, r24	; 0x02
    138c:	d8 01       	movw	r26, r16
    138e:	14 96       	adiw	r26, 0x04	; 4
    1390:	6d 91       	ld	r22, X+
    1392:	7d 91       	ld	r23, X+
    1394:	8d 91       	ld	r24, X+
    1396:	9c 91       	ld	r25, X
    1398:	17 97       	sbiw	r26, 0x07	; 7
    139a:	38 db       	rcall	.-2448   	; 0xa0c <SwapEndian_32>
    139c:	f6 01       	movw	r30, r12
    139e:	64 83       	std	Z+4, r22	; 0x04
    13a0:	75 83       	std	Z+5, r23	; 0x05
    13a2:	86 83       	std	Z+6, r24	; 0x06
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    13a4:	97 83       	std	Z+7, r25	; 0x07
    13a6:	d8 01       	movw	r26, r16
    13a8:	6d 91       	ld	r22, X+
    13aa:	7d 91       	ld	r23, X+
    13ac:	8d 91       	ld	r24, X+
    13ae:	9c 91       	ld	r25, X
    13b0:	2d db       	rcall	.-2470   	; 0xa0c <SwapEndian_32>
    13b2:	f6 01       	movw	r30, r12
    13b4:	60 87       	std	Z+8, r22	; 0x08
    13b6:	71 87       	std	Z+9, r23	; 0x09
    13b8:	82 87       	std	Z+10, r24	; 0x0a
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    13ba:	93 87       	std	Z+11, r25	; 0x0b
    13bc:	84 85       	ldd	r24, Z+12	; 0x0c
    13be:	8f 70       	andi	r24, 0x0F	; 15
    13c0:	80 65       	ori	r24, 0x50	; 80

		if (!(ConnectionInfo->Buffer.InUse))
    13c2:	84 87       	std	Z+12, r24	; 0x0c
    13c4:	f8 01       	movw	r30, r16
    13c6:	e4 5f       	subi	r30, 0xF4	; 244
    13c8:	fd 4f       	sbci	r31, 0xFD	; 253
    13ca:	80 81       	ld	r24, Z
    13cc:	81 11       	cpse	r24, r1
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    13ce:	03 c0       	rjmp	.+6      	; 0x13d6 <TCP_ProcessTCPPacket+0x3d4>
    13d0:	82 e0       	ldi	r24, 0x02	; 2
    13d2:	90 e0       	ldi	r25, 0x00	; 0
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    13d4:	08 c0       	rjmp	.+16     	; 0x13e6 <TCP_ProcessTCPPacket+0x3e4>
    13d6:	f8 01       	movw	r30, r16
    13d8:	20 85       	ldd	r18, Z+8	; 0x08
    13da:	31 85       	ldd	r19, Z+9	; 0x09
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	92 e0       	ldi	r25, 0x02	; 2
    13e0:	82 1b       	sub	r24, r18
    13e2:	93 0b       	sbc	r25, r19
    13e4:	19 db       	rcall	.-2510   	; 0xa18 <SwapEndian_16>
    13e6:	d6 01       	movw	r26, r12
    13e8:	1f 96       	adiw	r26, 0x0f	; 15
    13ea:	9c 93       	st	X, r25
    13ec:	8e 93       	st	-X, r24
    13ee:	1e 97       	sbiw	r26, 0x0e	; 14

		TCPHeaderOUT->UrgentPointer        = 0;
    13f0:	f6 01       	movw	r30, r12
    13f2:	13 8a       	std	Z+19, r1	; 0x13
    13f4:	12 8a       	std	Z+18, r1	; 0x12
		TCPHeaderOUT->Checksum             = 0;
    13f6:	11 8a       	std	Z+17, r1	; 0x11
		TCPHeaderOUT->Reserved             = 0;
    13f8:	10 8a       	std	Z+16, r1	; 0x10
    13fa:	84 85       	ldd	r24, Z+12	; 0x0c
    13fc:	80 7f       	andi	r24, 0xF0	; 240

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    13fe:	84 87       	std	Z+12, r24	; 0x0c
    1400:	d7 01       	movw	r26, r14
    1402:	1c 96       	adiw	r26, 0x0c	; 12
    1404:	0d 91       	ld	r16, X+
    1406:	1d 91       	ld	r17, X+
    1408:	2d 91       	ld	r18, X+
    140a:	3c 91       	ld	r19, X
    140c:	1f 97       	sbiw	r26, 0x0f	; 15
    140e:	50 96       	adiw	r26, 0x10	; 16
    1410:	4d 91       	ld	r20, X+
    1412:	5d 91       	ld	r21, X+
    1414:	6d 91       	ld	r22, X+
    1416:	7c 91       	ld	r23, X
    1418:	53 97       	sbiw	r26, 0x13	; 19
    141a:	84 e1       	ldi	r24, 0x14	; 20
    141c:	e8 2e       	mov	r14, r24
    141e:	f1 2c       	mov	r15, r1
    1420:	c6 01       	movw	r24, r12
    1422:	fe da       	rcall	.-2564   	; 0xa20 <TCP_Checksum16>
    1424:	f6 01       	movw	r30, r12
    1426:	91 8b       	std	Z+17, r25	; 0x11
    1428:	80 8b       	std	Z+16, r24	; 0x10
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    142a:	84 e1       	ldi	r24, 0x14	; 20
    142c:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
}
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	1f 91       	pop	r17
    1434:	0f 91       	pop	r16
    1436:	ff 90       	pop	r15
    1438:	ef 90       	pop	r14
    143a:	df 90       	pop	r13
    143c:	cf 90       	pop	r12
    143e:	bf 90       	pop	r11
    1440:	af 90       	pop	r10
    1442:	9f 90       	pop	r9
    1444:	8f 90       	pop	r8
    1446:	7f 90       	pop	r7
    1448:	6f 90       	pop	r6
    144a:	5f 90       	pop	r5
    144c:	4f 90       	pop	r4
    144e:	08 95       	ret

00001450 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    1450:	ef 92       	push	r14
    1452:	ff 92       	push	r15
    1454:	0f 93       	push	r16
    1456:	1f 93       	push	r17
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	7c 01       	movw	r14, r24
    145e:	8b 01       	movw	r16, r22
    1460:	ea 01       	movw	r28, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    1462:	cb 01       	movw	r24, r22
    1464:	91 da       	rcall	.-2782   	; 0x988 <DecodeUDPHeader>

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    1466:	f8 01       	movw	r30, r16
    1468:	83 81       	ldd	r24, Z+3	; 0x03
    146a:	92 81       	ldd	r25, Z+2	; 0x02

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    146c:	83 34       	cpi	r24, 0x43	; 67
    146e:	91 05       	cpc	r25, r1
    1470:	e9 f4       	brne	.+58     	; 0x14ac <UDP_ProcessUDPPacket+0x5c>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1472:	ae 01       	movw	r20, r28
    1474:	48 5f       	subi	r20, 0xF8	; 248
    1476:	5f 4f       	sbci	r21, 0xFF	; 255
    1478:	b8 01       	movw	r22, r16
    147a:	68 5f       	subi	r22, 0xF8	; 248
    147c:	7f 4f       	sbci	r23, 0xFF	; 255
    147e:	c7 01       	movw	r24, r14
    1480:	1e d0       	rcall	.+60     	; 0x14be <DHCP_ProcessDHCPPacket>
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1482:	18 16       	cp	r1, r24
    1484:	19 06       	cpc	r1, r25
    1486:	94 f4       	brge	.+36     	; 0x14ac <UDP_ProcessUDPPacket+0x5c>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    1488:	f8 01       	movw	r30, r16
    148a:	22 81       	ldd	r18, Z+2	; 0x02
    148c:	33 81       	ldd	r19, Z+3	; 0x03
    148e:	39 83       	std	Y+1, r19	; 0x01
    1490:	28 83       	st	Y, r18
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1492:	20 81       	ld	r18, Z
    1494:	31 81       	ldd	r19, Z+1	; 0x01
    1496:	3b 83       	std	Y+3, r19	; 0x03
    1498:	2a 83       	std	Y+2, r18	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    149a:	1f 82       	std	Y+7, r1	; 0x07
    149c:	1e 82       	std	Y+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    149e:	9c 01       	movw	r18, r24
    14a0:	28 5f       	subi	r18, 0xF8	; 248
    14a2:	3f 4f       	sbci	r19, 0xFF	; 255
    14a4:	3c 83       	std	Y+4, r19	; 0x04
    14a6:	2d 83       	std	Y+5, r18	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    14a8:	c9 01       	movw	r24, r18
    14aa:	02 c0       	rjmp	.+4      	; 0x14b0 <UDP_ProcessUDPPacket+0x60>
	}

	return NO_RESPONSE;
    14ac:	80 e0       	ldi	r24, 0x00	; 0
    14ae:	90 e0       	ldi	r25, 0x00	; 0
}
    14b0:	df 91       	pop	r29
    14b2:	cf 91       	pop	r28
    14b4:	1f 91       	pop	r17
    14b6:	0f 91       	pop	r16
    14b8:	ff 90       	pop	r15
    14ba:	ef 90       	pop	r14
    14bc:	08 95       	ret

000014be <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    14be:	8f 92       	push	r8
    14c0:	9f 92       	push	r9
    14c2:	af 92       	push	r10
    14c4:	bf 92       	push	r11
    14c6:	cf 92       	push	r12
    14c8:	df 92       	push	r13
    14ca:	ef 92       	push	r14
    14cc:	ff 92       	push	r15
    14ce:	0f 93       	push	r16
    14d0:	1f 93       	push	r17
    14d2:	cf 93       	push	r28
    14d4:	df 93       	push	r29
    14d6:	6c 01       	movw	r12, r24
    14d8:	8b 01       	movw	r16, r22
    14da:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    14dc:	7b 01       	movw	r14, r22
    14de:	80 ef       	ldi	r24, 0xF0	; 240
    14e0:	e8 0e       	add	r14, r24
    14e2:	f1 1c       	adc	r15, r1
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    14e4:	cb 01       	movw	r24, r22
    14e6:	51 da       	rcall	.-2910   	; 0x98a <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    14e8:	80 ef       	ldi	r24, 0xF0	; 240
    14ea:	fe 01       	movw	r30, r28
    14ec:	11 92       	st	Z+, r1
    14ee:	8a 95       	dec	r24
    14f0:	e9 f7       	brne	.-6      	; 0x14ec <DHCP_ProcessDHCPPacket+0x2e>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    14f2:	f8 01       	movw	r30, r16
    14f4:	81 81       	ldd	r24, Z+1	; 0x01
    14f6:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    14f8:	82 e0       	ldi	r24, 0x02	; 2
    14fa:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    14fc:	82 81       	ldd	r24, Z+2	; 0x02
    14fe:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    1500:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    1502:	84 81       	ldd	r24, Z+4	; 0x04
    1504:	95 81       	ldd	r25, Z+5	; 0x05
    1506:	a6 81       	ldd	r26, Z+6	; 0x06
    1508:	b7 81       	ldd	r27, Z+7	; 0x07
    150a:	8c 83       	std	Y+4, r24	; 0x04
    150c:	9d 83       	std	Y+5, r25	; 0x05
    150e:	ae 83       	std	Y+6, r26	; 0x06
    1510:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    1512:	19 86       	std	Y+9, r1	; 0x09
    1514:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    1516:	82 85       	ldd	r24, Z+10	; 0x0a
    1518:	93 85       	ldd	r25, Z+11	; 0x0b
    151a:	9b 87       	std	Y+11, r25	; 0x0b
    151c:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    151e:	80 90 0a 01 	lds	r8, 0x010A	; 0x80010a <ClientIPAddress>
    1522:	90 90 0b 01 	lds	r9, 0x010B	; 0x80010b <ClientIPAddress+0x1>
    1526:	a0 90 0c 01 	lds	r10, 0x010C	; 0x80010c <ClientIPAddress+0x2>
    152a:	b0 90 0d 01 	lds	r11, 0x010D	; 0x80010d <ClientIPAddress+0x3>
    152e:	88 8a       	std	Y+16, r8	; 0x10
    1530:	99 8a       	std	Y+17, r9	; 0x11
    1532:	aa 8a       	std	Y+18, r10	; 0x12
    1534:	bb 8a       	std	Y+19, r11	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    1536:	b8 01       	movw	r22, r16
    1538:	64 5e       	subi	r22, 0xE4	; 228
    153a:	7f 4f       	sbci	r23, 0xFF	; 255
    153c:	46 e0       	ldi	r20, 0x06	; 6
    153e:	50 e0       	ldi	r21, 0x00	; 0
    1540:	ce 01       	movw	r24, r28
    1542:	4c 96       	adiw	r24, 0x1c	; 28
    1544:	0e 94 76 14 	call	0x28ec	; 0x28ec <memmove>
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    1548:	fe 01       	movw	r30, r28
    154a:	e4 51       	subi	r30, 0x14	; 20
    154c:	ff 4f       	sbci	r31, 0xFF	; 255
    154e:	83 e6       	ldi	r24, 0x63	; 99
    1550:	92 e8       	ldi	r25, 0x82	; 130
    1552:	a3 e5       	ldi	r26, 0x53	; 83
    1554:	b3 e6       	ldi	r27, 0x63	; 99
    1556:	80 83       	st	Z, r24
    1558:	91 83       	std	Z+1, r25	; 0x01
    155a:	a2 83       	std	Z+2, r26	; 0x02
    155c:	b3 83       	std	Z+3, r27	; 0x03

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    155e:	f6 01       	movw	r30, r12
    1560:	84 86       	std	Z+12, r8	; 0x0c
    1562:	95 86       	std	Z+13, r9	; 0x0d
    1564:	a6 86       	std	Z+14, r10	; 0x0e
    1566:	b7 86       	std	Z+15, r11	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1568:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <ServerIPAddress>
    156c:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <ServerIPAddress+0x1>
    1570:	a0 91 1a 01 	lds	r26, 0x011A	; 0x80011a <ServerIPAddress+0x2>
    1574:	b0 91 1b 01 	lds	r27, 0x011B	; 0x80011b <ServerIPAddress+0x3>
    1578:	80 8b       	std	Z+16, r24	; 0x10
    157a:	91 8b       	std	Z+17, r25	; 0x11
    157c:	a2 8b       	std	Z+18, r26	; 0x12
    157e:	b3 8b       	std	Z+19, r27	; 0x13

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1580:	f7 01       	movw	r30, r14
    1582:	80 81       	ld	r24, Z
    1584:	8f 3f       	cpi	r24, 0xFF	; 255
    1586:	09 f4       	brne	.+2      	; 0x158a <DHCP_ProcessDHCPPacket+0xcc>
    1588:	4b c0       	rjmp	.+150    	; 0x1620 <DHCP_ProcessDHCPPacket+0x162>
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    158a:	85 33       	cpi	r24, 0x35	; 53
    158c:	e9 f5       	brne	.+122    	; 0x1608 <DHCP_ProcessDHCPPacket+0x14a>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    158e:	f7 01       	movw	r30, r14
    1590:	92 81       	ldd	r25, Z+2	; 0x02
    1592:	9d 7f       	andi	r25, 0xFD	; 253
    1594:	91 30       	cpi	r25, 0x01	; 1
    1596:	d1 f5       	brne	.+116    	; 0x160c <DHCP_ProcessDHCPPacket+0x14e>
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1598:	fe 01       	movw	r30, r28
    159a:	e0 51       	subi	r30, 0x10	; 16
    159c:	ff 4f       	sbci	r31, 0xFF	; 255
    159e:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 1;
    15a0:	31 96       	adiw	r30, 0x01	; 1
    15a2:	90 83       	st	Z, r25
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    15a4:	f7 01       	movw	r30, r14
    15a6:	82 81       	ldd	r24, Z+2	; 0x02
    15a8:	81 30       	cpi	r24, 0x01	; 1
    15aa:	11 f0       	breq	.+4      	; 0x15b0 <DHCP_ProcessDHCPPacket+0xf2>
    15ac:	85 e0       	ldi	r24, 0x05	; 5
    15ae:	01 c0       	rjmp	.+2      	; 0x15b2 <DHCP_ProcessDHCPPacket+0xf4>
    15b0:	82 e0       	ldi	r24, 0x02	; 2
    15b2:	fe 01       	movw	r30, r28
    15b4:	ee 50       	subi	r30, 0x0E	; 14
    15b6:	ff 4f       	sbci	r31, 0xFF	; 255
    15b8:	80 83       	st	Z, r24
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    15ba:	31 96       	adiw	r30, 0x01	; 1
    15bc:	81 e0       	ldi	r24, 0x01	; 1
    15be:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 4;
    15c0:	31 96       	adiw	r30, 0x01	; 1
    15c2:	94 e0       	ldi	r25, 0x04	; 4
    15c4:	90 83       	st	Z, r25
				*(DHCPOptionsOUTStart++) = 0xFF;
    15c6:	31 96       	adiw	r30, 0x01	; 1
    15c8:	8f ef       	ldi	r24, 0xFF	; 255
    15ca:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0xFF;
    15cc:	31 96       	adiw	r30, 0x01	; 1
    15ce:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0xFF;
    15d0:	31 96       	adiw	r30, 0x01	; 1
    15d2:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0x00;
    15d4:	31 96       	adiw	r30, 0x01	; 1
    15d6:	10 82       	st	Z, r1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    15d8:	31 96       	adiw	r30, 0x01	; 1
    15da:	26 e3       	ldi	r18, 0x36	; 54
    15dc:	20 83       	st	Z, r18
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    15de:	31 96       	adiw	r30, 0x01	; 1
    15e0:	90 83       	st	Z, r25
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    15e2:	31 96       	adiw	r30, 0x01	; 1
    15e4:	40 91 18 01 	lds	r20, 0x0118	; 0x800118 <ServerIPAddress>
    15e8:	50 91 19 01 	lds	r21, 0x0119	; 0x800119 <ServerIPAddress+0x1>
    15ec:	60 91 1a 01 	lds	r22, 0x011A	; 0x80011a <ServerIPAddress+0x2>
    15f0:	70 91 1b 01 	lds	r23, 0x011B	; 0x80011b <ServerIPAddress+0x3>
    15f4:	40 83       	st	Z, r20
    15f6:	51 83       	std	Z+1, r21	; 0x01
    15f8:	62 83       	std	Z+2, r22	; 0x02
    15fa:	73 83       	std	Z+3, r23	; 0x03
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    15fc:	c1 50       	subi	r28, 0x01	; 1
    15fe:	df 4f       	sbci	r29, 0xFF	; 255
    1600:	88 83       	st	Y, r24

				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
    1602:	80 e0       	ldi	r24, 0x00	; 0
    1604:	91 e0       	ldi	r25, 0x01	; 1
    1606:	0e c0       	rjmp	.+28     	; 0x1624 <DHCP_ProcessDHCPPacket+0x166>
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    1608:	88 23       	and	r24, r24
    160a:	29 f0       	breq	.+10     	; 0x1616 <DHCP_ProcessDHCPPacket+0x158>
    160c:	f7 01       	movw	r30, r14
    160e:	81 81       	ldd	r24, Z+1	; 0x01
    1610:	90 e0       	ldi	r25, 0x00	; 0
    1612:	02 96       	adiw	r24, 0x02	; 2
    1614:	02 c0       	rjmp	.+4      	; 0x161a <DHCP_ProcessDHCPPacket+0x15c>
    1616:	81 e0       	ldi	r24, 0x01	; 1
    1618:	90 e0       	ldi	r25, 0x00	; 0
    161a:	e8 0e       	add	r14, r24
    161c:	f9 1e       	adc	r15, r25
    161e:	b0 cf       	rjmp	.-160    	; 0x1580 <DHCP_ProcessDHCPPacket+0xc2>
	}

	return NO_RESPONSE;
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	90 e0       	ldi	r25, 0x00	; 0
}
    1624:	df 91       	pop	r29
    1626:	cf 91       	pop	r28
    1628:	1f 91       	pop	r17
    162a:	0f 91       	pop	r16
    162c:	ff 90       	pop	r15
    162e:	ef 90       	pop	r14
    1630:	df 90       	pop	r13
    1632:	cf 90       	pop	r12
    1634:	bf 90       	pop	r11
    1636:	af 90       	pop	r10
    1638:	9f 90       	pop	r9
    163a:	8f 90       	pop	r8
    163c:	08 95       	ret

0000163e <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    163e:	0f 93       	push	r16
    1640:	1f 93       	push	r17
    1642:	cf 93       	push	r28
    1644:	df 93       	push	r29
    1646:	ec 01       	movw	r28, r24
    1648:	8b 01       	movw	r16, r22
	DecodeARPHeader(InDataStart);
    164a:	9a d9       	rcall	.-3276   	; 0x980 <DecodeARPHeader>

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    164c:	8b 81       	ldd	r24, Y+3	; 0x03
    164e:	9a 81       	ldd	r25, Y+2	; 0x02

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1650:	81 15       	cp	r24, r1
    1652:	98 40       	sbci	r25, 0x08	; 8
    1654:	19 f0       	breq	.+6      	; 0x165c <ARP_ProcessARPPacket+0x1e>
			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
		}
	}

	return NO_RESPONSE;
    1656:	80 e0       	ldi	r24, 0x00	; 0
    1658:	90 e0       	ldi	r25, 0x00	; 0
    165a:	53 c0       	rjmp	.+166    	; 0x1702 <ARP_ProcessARPPacket+0xc4>
    165c:	8f 81       	ldd	r24, Y+7	; 0x07
    165e:	9e 81       	ldd	r25, Y+6	; 0x06

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1660:	01 97       	sbiw	r24, 0x01	; 1
    1662:	c9 f7       	brne	.-14     	; 0x1656 <ARP_ProcessARPPacket+0x18>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1664:	44 e0       	ldi	r20, 0x04	; 4
    1666:	50 e0       	ldi	r21, 0x00	; 0
    1668:	68 e1       	ldi	r22, 0x18	; 24
    166a:	71 e0       	ldi	r23, 0x01	; 1
    166c:	ce 01       	movw	r24, r28
    166e:	48 96       	adiw	r24, 0x18	; 24
    1670:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
    1674:	89 2b       	or	r24, r25
    1676:	51 f0       	breq	.+20     	; 0x168c <ARP_ProcessARPPacket+0x4e>
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
    1678:	46 e0       	ldi	r20, 0x06	; 6
    167a:	50 e0       	ldi	r21, 0x00	; 0
    167c:	6c e1       	ldi	r22, 0x1C	; 28
    167e:	71 e0       	ldi	r23, 0x01	; 1
    1680:	ce 01       	movw	r24, r28
    1682:	42 96       	adiw	r24, 0x12	; 18
    1684:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1688:	89 2b       	or	r24, r25
    168a:	29 f7       	brne	.-54     	; 0x1656 <ARP_ProcessARPPacket+0x18>
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    168c:	88 81       	ld	r24, Y
    168e:	99 81       	ldd	r25, Y+1	; 0x01
    1690:	f8 01       	movw	r30, r16
    1692:	91 83       	std	Z+1, r25	; 0x01
    1694:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1696:	8a 81       	ldd	r24, Y+2	; 0x02
    1698:	9b 81       	ldd	r25, Y+3	; 0x03
    169a:	93 83       	std	Z+3, r25	; 0x03
    169c:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    169e:	8c 81       	ldd	r24, Y+4	; 0x04
    16a0:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    16a2:	8d 81       	ldd	r24, Y+5	; 0x05
    16a4:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    16a6:	80 e0       	ldi	r24, 0x00	; 0
    16a8:	92 e0       	ldi	r25, 0x02	; 2
    16aa:	97 83       	std	Z+7, r25	; 0x07
    16ac:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    16ae:	86 e0       	ldi	r24, 0x06	; 6
    16b0:	fe 01       	movw	r30, r28
    16b2:	38 96       	adiw	r30, 0x08	; 8
    16b4:	d8 01       	movw	r26, r16
    16b6:	52 96       	adiw	r26, 0x12	; 18
    16b8:	01 90       	ld	r0, Z+
    16ba:	0d 92       	st	X+, r0
    16bc:	8a 95       	dec	r24
    16be:	e1 f7       	brne	.-8      	; 0x16b8 <ARP_ProcessARPPacket+0x7a>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    16c0:	8e 85       	ldd	r24, Y+14	; 0x0e
    16c2:	9f 85       	ldd	r25, Y+15	; 0x0f
    16c4:	a8 89       	ldd	r26, Y+16	; 0x10
    16c6:	b9 89       	ldd	r27, Y+17	; 0x11
    16c8:	f8 01       	movw	r30, r16
    16ca:	80 8f       	std	Z+24, r24	; 0x18
    16cc:	91 8f       	std	Z+25, r25	; 0x19
    16ce:	a2 8f       	std	Z+26, r26	; 0x1a
    16d0:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    16d2:	86 e0       	ldi	r24, 0x06	; 6
    16d4:	ec e1       	ldi	r30, 0x1C	; 28
    16d6:	f1 e0       	ldi	r31, 0x01	; 1
    16d8:	d8 01       	movw	r26, r16
    16da:	18 96       	adiw	r26, 0x08	; 8
    16dc:	01 90       	ld	r0, Z+
    16de:	0d 92       	st	X+, r0
    16e0:	8a 95       	dec	r24
    16e2:	e1 f7       	brne	.-8      	; 0x16dc <ARP_ProcessARPPacket+0x9e>
			ARPHeaderOUT->SPA = ServerIPAddress;
    16e4:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <ServerIPAddress>
    16e8:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <ServerIPAddress+0x1>
    16ec:	a0 91 1a 01 	lds	r26, 0x011A	; 0x80011a <ServerIPAddress+0x2>
    16f0:	b0 91 1b 01 	lds	r27, 0x011B	; 0x80011b <ServerIPAddress+0x3>
    16f4:	f8 01       	movw	r30, r16
    16f6:	86 87       	std	Z+14, r24	; 0x0e
    16f8:	97 87       	std	Z+15, r25	; 0x0f
    16fa:	a0 8b       	std	Z+16, r26	; 0x10
    16fc:	b1 8b       	std	Z+17, r27	; 0x11

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    16fe:	8c e1       	ldi	r24, 0x1C	; 28
    1700:	90 e0       	ldi	r25, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    1702:	df 91       	pop	r29
    1704:	cf 91       	pop	r28
    1706:	1f 91       	pop	r17
    1708:	0f 91       	pop	r16
    170a:	08 95       	ret

0000170c <IP_ProcessIPPacket>:
 *           response was generated, NO_PROCESS if the packet processing was deferred until the
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(void* InDataStart,
                           void* OutDataStart)
{
    170c:	cf 92       	push	r12
    170e:	df 92       	push	r13
    1710:	ef 92       	push	r14
    1712:	ff 92       	push	r15
    1714:	0f 93       	push	r16
    1716:	1f 93       	push	r17
    1718:	cf 93       	push	r28
    171a:	df 93       	push	r29
    171c:	8c 01       	movw	r16, r24
    171e:	eb 01       	movw	r28, r22
	DecodeIPHeader(InDataStart);
    1720:	30 d9       	rcall	.-3488   	; 0x982 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1722:	f8 01       	movw	r30, r16
    1724:	60 81       	ld	r22, Z
    1726:	6f 70       	andi	r22, 0x0F	; 15
    1728:	f4 e0       	ldi	r31, 0x04	; 4
    172a:	6f 9f       	mul	r22, r31
    172c:	70 01       	movw	r14, r0
    172e:	11 24       	eor	r1, r1

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1730:	68 01       	movw	r12, r16
    1732:	20 e1       	ldi	r18, 0x10	; 16
    1734:	c2 0e       	add	r12, r18
    1736:	d1 1c       	adc	r13, r1
    1738:	44 e0       	ldi	r20, 0x04	; 4
    173a:	50 e0       	ldi	r21, 0x00	; 0
    173c:	68 e1       	ldi	r22, 0x18	; 24
    173e:	71 e0       	ldi	r23, 0x01	; 1
    1740:	c6 01       	movw	r24, r12
    1742:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
    1746:	89 2b       	or	r24, r25
    1748:	51 f0       	breq	.+20     	; 0x175e <IP_ProcessIPPacket+0x52>
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
    174a:	44 e0       	ldi	r20, 0x04	; 4
    174c:	50 e0       	ldi	r21, 0x00	; 0
    174e:	6e e0       	ldi	r22, 0x0E	; 14
    1750:	71 e0       	ldi	r23, 0x01	; 1
    1752:	c6 01       	movw	r24, r12
    1754:	0e 94 60 14 	call	0x28c0	; 0x28c0 <memcmp>
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1758:	89 2b       	or	r24, r25
    175a:	09 f0       	breq	.+2      	; 0x175e <IP_ProcessIPPacket+0x52>
    175c:	51 c0       	rjmp	.+162    	; 0x1800 <IP_ProcessIPPacket+0xf4>
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    175e:	f8 01       	movw	r30, r16
    1760:	81 85       	ldd	r24, Z+9	; 0x09
    1762:	86 30       	cpi	r24, 0x06	; 6
    1764:	69 f0       	breq	.+26     	; 0x1780 <IP_ProcessIPPacket+0x74>
    1766:	81 31       	cpi	r24, 0x11	; 17
    1768:	a1 f0       	breq	.+40     	; 0x1792 <IP_ProcessIPPacket+0x86>
    176a:	81 30       	cpi	r24, 0x01	; 1
    176c:	09 f0       	breq	.+2      	; 0x1770 <IP_ProcessIPPacket+0x64>
    176e:	48 c0       	rjmp	.+144    	; 0x1800 <IP_ProcessIPPacket+0xf4>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(&((uint8_t*)InDataStart)[HeaderLengthBytes],
    1770:	be 01       	movw	r22, r28
    1772:	6c 5e       	subi	r22, 0xEC	; 236
    1774:	7f 4f       	sbci	r23, 0xFF	; 255
    1776:	c8 01       	movw	r24, r16
    1778:	8e 0d       	add	r24, r14
    177a:	9f 1d       	adc	r25, r15
    177c:	07 d9       	rcall	.-3570   	; 0x98c <ICMP_ProcessICMPPacket>
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    177e:	11 c0       	rjmp	.+34     	; 0x17a2 <IP_ProcessIPPacket+0x96>
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1780:	b8 01       	movw	r22, r16
    1782:	6e 0d       	add	r22, r14
    1784:	7f 1d       	adc	r23, r15
    1786:	ae 01       	movw	r20, r28
    1788:	4c 5e       	subi	r20, 0xEC	; 236
    178a:	5f 4f       	sbci	r21, 0xFF	; 255
    178c:	c8 01       	movw	r24, r16
    178e:	39 dc       	rcall	.-1934   	; 0x1002 <TCP_ProcessTCPPacket>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    1790:	08 c0       	rjmp	.+16     	; 0x17a2 <IP_ProcessIPPacket+0x96>
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    1792:	b8 01       	movw	r22, r16
    1794:	6e 0d       	add	r22, r14
    1796:	7f 1d       	adc	r23, r15
    1798:	ae 01       	movw	r20, r28
    179a:	4c 5e       	subi	r20, 0xEC	; 236
    179c:	5f 4f       	sbci	r21, 0xFF	; 255
    179e:	c8 01       	movw	r24, r16
    17a0:	57 de       	rcall	.-850    	; 0x1450 <UDP_ProcessUDPPacket>
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    17a2:	18 16       	cp	r1, r24
    17a4:	19 06       	cpc	r1, r25
    17a6:	74 f5       	brge	.+92     	; 0x1804 <IP_ProcessIPPacket+0xf8>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    17a8:	7c 01       	movw	r14, r24
    17aa:	f4 e1       	ldi	r31, 0x14	; 20
    17ac:	ef 0e       	add	r14, r31
    17ae:	f1 1c       	adc	r15, r1
    17b0:	fa 82       	std	Y+2, r15	; 0x02
    17b2:	eb 82       	std	Y+3, r14	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    17b4:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    17b6:	85 e4       	ldi	r24, 0x45	; 69
    17b8:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    17ba:	1e 82       	std	Y+6, r1	; 0x06
    17bc:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    17be:	1d 82       	std	Y+5, r1	; 0x05
    17c0:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    17c2:	1b 86       	std	Y+11, r1	; 0x0b
    17c4:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    17c6:	f8 01       	movw	r30, r16
    17c8:	81 85       	ldd	r24, Z+9	; 0x09
    17ca:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    17cc:	80 e8       	ldi	r24, 0x80	; 128
    17ce:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    17d0:	80 89       	ldd	r24, Z+16	; 0x10
    17d2:	91 89       	ldd	r25, Z+17	; 0x11
    17d4:	a2 89       	ldd	r26, Z+18	; 0x12
    17d6:	b3 89       	ldd	r27, Z+19	; 0x13
    17d8:	8c 87       	std	Y+12, r24	; 0x0c
    17da:	9d 87       	std	Y+13, r25	; 0x0d
    17dc:	ae 87       	std	Y+14, r26	; 0x0e
    17de:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    17e0:	84 85       	ldd	r24, Z+12	; 0x0c
    17e2:	95 85       	ldd	r25, Z+13	; 0x0d
    17e4:	a6 85       	ldd	r26, Z+14	; 0x0e
    17e6:	b7 85       	ldd	r27, Z+15	; 0x0f
    17e8:	88 8b       	std	Y+16, r24	; 0x10
    17ea:	99 8b       	std	Y+17, r25	; 0x11
    17ec:	aa 8b       	std	Y+18, r26	; 0x12

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    17ee:	bb 8b       	std	Y+19, r27	; 0x13
    17f0:	64 e1       	ldi	r22, 0x14	; 20
    17f2:	70 e0       	ldi	r23, 0x00	; 0
    17f4:	ce 01       	movw	r24, r28
    17f6:	92 d8       	rcall	.-3804   	; 0x91c <Ethernet_Checksum16>
    17f8:	9b 87       	std	Y+11, r25	; 0x0b
    17fa:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    17fc:	c7 01       	movw	r24, r14
    17fe:	02 c0       	rjmp	.+4      	; 0x1804 <IP_ProcessIPPacket+0xf8>
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
    1800:	80 e0       	ldi	r24, 0x00	; 0
    1802:	90 e0       	ldi	r25, 0x00	; 0
		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
}
    1804:	df 91       	pop	r29
    1806:	cf 91       	pop	r28
    1808:	1f 91       	pop	r17
    180a:	0f 91       	pop	r16
    180c:	ff 90       	pop	r15
    180e:	ef 90       	pop	r14
    1810:	df 90       	pop	r13
    1812:	cf 90       	pop	r12
    1814:	08 95       	ret

00001816 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1816:	fb 01       	movw	r30, r22
    1818:	01 90       	ld	r0, Z+
    181a:	00 20       	and	r0, r0
    181c:	e9 f7       	brne	.-6      	; 0x1818 <IsHTTPCommand+0x2>
    181e:	31 97       	sbiw	r30, 0x01	; 1
    1820:	af 01       	movw	r20, r30
    1822:	46 1b       	sub	r20, r22
    1824:	57 0b       	sbc	r21, r23
    1826:	0e 94 87 14 	call	0x290e	; 0x290e <strncmp>
    182a:	21 e0       	ldi	r18, 0x01	; 1
    182c:	89 2b       	or	r24, r25
    182e:	09 f0       	breq	.+2      	; 0x1832 <IsHTTPCommand+0x1c>
    1830:	20 e0       	ldi	r18, 0x00	; 0
}
    1832:	82 2f       	mov	r24, r18
    1834:	08 95       	ret

00001836 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1836:	4f 92       	push	r4
    1838:	5f 92       	push	r5
    183a:	6f 92       	push	r6
    183c:	7f 92       	push	r7
    183e:	8f 92       	push	r8
    1840:	9f 92       	push	r9
    1842:	af 92       	push	r10
    1844:	bf 92       	push	r11
    1846:	cf 92       	push	r12
    1848:	df 92       	push	r13
    184a:	ef 92       	push	r14
    184c:	ff 92       	push	r15
    184e:	0f 93       	push	r16
    1850:	1f 93       	push	r17
    1852:	cf 93       	push	r28
    1854:	df 93       	push	r29
    1856:	7c 01       	movw	r14, r24
    1858:	8b 01       	movw	r16, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    185a:	eb 01       	movw	r28, r22
    185c:	22 96       	adiw	r28, 0x02	; 2
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    185e:	6b 01       	movw	r12, r22
    1860:	2d ef       	ldi	r18, 0xFD	; 253
    1862:	c2 1a       	sub	r12, r18
    1864:	d2 0a       	sbc	r13, r18
    1866:	d6 01       	movw	r26, r12
    1868:	8c 91       	ld	r24, X
    186a:	88 23       	and	r24, r24
    186c:	09 f4       	brne	.+2      	; 0x1870 <Webserver_ApplicationCallback+0x3a>
    186e:	5e c0       	rjmp	.+188    	; 0x192c <Webserver_ApplicationCallback+0xf6>
    1870:	5b 01       	movw	r10, r22
    1872:	b2 e0       	ldi	r27, 0x02	; 2
    1874:	ab 0e       	add	r10, r27
    1876:	bb 1e       	adc	r11, r27
    1878:	f5 01       	movw	r30, r10
    187a:	80 81       	ld	r24, Z
    187c:	81 11       	cpse	r24, r1
    187e:	95 c0       	rjmp	.+298    	; 0x19aa <Webserver_ApplicationCallback+0x174>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1880:	68 e2       	ldi	r22, 0x28	; 40
    1882:	71 e0       	ldi	r23, 0x01	; 1
    1884:	ce 01       	movw	r24, r28
    1886:	c7 df       	rcall	.-114    	; 0x1816 <IsHTTPCommand>
    1888:	88 23       	and	r24, r24
    188a:	e9 f0       	breq	.+58     	; 0x18c6 <Webserver_ApplicationCallback+0x90>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    188c:	6c e2       	ldi	r22, 0x2C	; 44
    188e:	71 e0       	ldi	r23, 0x01	; 1
    1890:	ce 01       	movw	r24, r28
    1892:	c1 df       	rcall	.-126    	; 0x1816 <IsHTTPCommand>
    1894:	88 23       	and	r24, r24
    1896:	31 f1       	breq	.+76     	; 0x18e4 <Webserver_ApplicationCallback+0xae>
			{
				PageBlock = 0;
    1898:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <__data_end>

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    189c:	66 e8       	ldi	r22, 0x86	; 134
    189e:	73 e0       	ldi	r23, 0x03	; 3
    18a0:	ce 01       	movw	r24, r28
    18a2:	ef d7       	rcall	.+4062   	; 0x2882 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    18a4:	81 e0       	ldi	r24, 0x01	; 1
    18a6:	d5 01       	movw	r26, r10
    18a8:	8c 93       	st	X, r24
    18aa:	fe 01       	movw	r30, r28
    18ac:	01 90       	ld	r0, Z+
    18ae:	00 20       	and	r0, r0
    18b0:	e9 f7       	brne	.-6      	; 0x18ac <Webserver_ApplicationCallback+0x76>
    18b2:	31 97       	sbiw	r30, 0x01	; 1
    18b4:	ec 1b       	sub	r30, r28
    18b6:	fd 0b       	sbc	r31, r29
    18b8:	d8 01       	movw	r26, r16
    18ba:	ed 93       	st	X+, r30
    18bc:	fc 93       	st	X, r31
    18be:	f6 01       	movw	r30, r12
    18c0:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    18c2:	31 96       	adiw	r30, 0x01	; 1
    18c4:	71 c0       	rjmp	.+226    	; 0x19a8 <Webserver_ApplicationCallback+0x172>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    18c6:	63 e3       	ldi	r22, 0x33	; 51
    18c8:	71 e0       	ldi	r23, 0x01	; 1
    18ca:	ce 01       	movw	r24, r28
    18cc:	a4 df       	rcall	.-184    	; 0x1816 <IsHTTPCommand>
    18ce:	88 23       	and	r24, r24
    18d0:	e9 f0       	breq	.+58     	; 0x190c <Webserver_ApplicationCallback+0xd6>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    18d2:	68 e3       	ldi	r22, 0x38	; 56
    18d4:	71 e0       	ldi	r23, 0x01	; 1
    18d6:	ce 01       	movw	r24, r28
    18d8:	9e df       	rcall	.-196    	; 0x1816 <IsHTTPCommand>
    18da:	88 23       	and	r24, r24
    18dc:	19 f0       	breq	.+6      	; 0x18e4 <Webserver_ApplicationCallback+0xae>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    18de:	66 e8       	ldi	r22, 0x86	; 134
    18e0:	73 e0       	ldi	r23, 0x03	; 3
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    18e2:	02 c0       	rjmp	.+4      	; 0x18e8 <Webserver_ApplicationCallback+0xb2>
    18e4:	64 e4       	ldi	r22, 0x44	; 68
    18e6:	73 e0       	ldi	r23, 0x03	; 3
    18e8:	ce 01       	movw	r24, r28
    18ea:	cb d7       	rcall	.+3990   	; 0x2882 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	d5 01       	movw	r26, r10
    18f0:	8c 93       	st	X, r24
    18f2:	fe 01       	movw	r30, r28
    18f4:	01 90       	ld	r0, Z+
    18f6:	00 20       	and	r0, r0
    18f8:	e9 f7       	brne	.-6      	; 0x18f4 <Webserver_ApplicationCallback+0xbe>
    18fa:	31 97       	sbiw	r30, 0x01	; 1
    18fc:	ec 1b       	sub	r30, r28
    18fe:	fd 0b       	sbc	r31, r29
    1900:	d8 01       	movw	r26, r16
    1902:	ed 93       	st	X+, r30
    1904:	fc 93       	st	X, r31
    1906:	f6 01       	movw	r30, r12
    1908:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    190a:	4a c0       	rjmp	.+148    	; 0x19a0 <Webserver_ApplicationCallback+0x16a>
    190c:	60 e4       	ldi	r22, 0x40	; 64
    190e:	71 e0       	ldi	r23, 0x01	; 1
    1910:	ce 01       	movw	r24, r28
    1912:	81 df       	rcall	.-254    	; 0x1816 <IsHTTPCommand>
    1914:	88 23       	and	r24, r24
    1916:	21 f0       	breq	.+8      	; 0x1920 <Webserver_ApplicationCallback+0xea>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1918:	81 e0       	ldi	r24, 0x01	; 1
    191a:	d5 01       	movw	r26, r10
    191c:	8c 93       	st	X, r24
    191e:	f3 cf       	rjmp	.-26     	; 0x1906 <Webserver_ApplicationCallback+0xd0>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1920:	d6 01       	movw	r26, r12
    1922:	1c 92       	st	X, r1
    1924:	f8 01       	movw	r30, r16
    1926:	11 82       	std	Z+1, r1	; 0x01
    1928:	10 82       	st	Z, r1
    192a:	3f c0       	rjmp	.+126    	; 0x19aa <Webserver_ApplicationCallback+0x174>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    192c:	2b 01       	movw	r4, r22
    192e:	fc ef       	ldi	r31, 0xFC	; 252
    1930:	4f 1a       	sub	r4, r31
    1932:	fd ef       	ldi	r31, 0xFD	; 253
    1934:	5f 0a       	sbc	r5, r31
    1936:	d2 01       	movw	r26, r4
    1938:	8c 91       	ld	r24, X
    193a:	88 23       	and	r24, r24
    193c:	b1 f1       	breq	.+108    	; 0x19aa <Webserver_ApplicationCallback+0x174>
    193e:	3b 01       	movw	r6, r22
    1940:	b2 e0       	ldi	r27, 0x02	; 2
    1942:	6b 0e       	add	r6, r27
    1944:	7b 1e       	adc	r7, r27
    1946:	f3 01       	movw	r30, r6
    1948:	80 81       	ld	r24, Z
    194a:	88 23       	and	r24, r24
    194c:	71 f1       	breq	.+92     	; 0x19aa <Webserver_ApplicationCallback+0x174>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    194e:	a0 90 46 01 	lds	r10, 0x0146	; 0x800146 <__data_end>
    1952:	f0 e8       	ldi	r31, 0x80	; 128
    1954:	af 9e       	mul	r10, r31
    1956:	c0 01       	movw	r24, r0
    1958:	11 24       	eor	r1, r1
    195a:	9c 01       	movw	r18, r24
    195c:	2c 5a       	subi	r18, 0xAC	; 172
    195e:	3e 4f       	sbci	r19, 0xFE	; 254
#else
extern size_t __strlen_P(const char *) __ATTR_CONST__;  /* internal helper function */
__attribute__((__always_inline__)) static __inline__ size_t strlen_P(const char * s);
static __inline__ size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    1960:	59 01       	movw	r10, r18
    1962:	c9 01       	movw	r24, r18
    1964:	95 d7       	rcall	.+3882   	; 0x2890 <__strlen_P>
    1966:	4c 01       	movw	r8, r24
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = MIN(RemLength, HTTP_REPLY_BLOCK_SIZE);
    1968:	81 38       	cpi	r24, 0x81	; 129
    196a:	91 05       	cpc	r25, r1
    196c:	18 f0       	brcs	.+6      	; 0x1974 <Webserver_ApplicationCallback+0x13e>
    196e:	80 e8       	ldi	r24, 0x80	; 128
    1970:	88 2e       	mov	r8, r24

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1972:	91 2c       	mov	r9, r1
    1974:	a4 01       	movw	r20, r8
    1976:	b5 01       	movw	r22, r10
    1978:	ce 01       	movw	r24, r28
    197a:	93 d7       	rcall	.+3878   	; 0x28a2 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    197c:	81 e0       	ldi	r24, 0x01	; 1
    197e:	d3 01       	movw	r26, r6
    1980:	8c 93       	st	X, r24
    1982:	f8 01       	movw	r30, r16
    1984:	91 82       	std	Z+1, r9	; 0x01
    1986:	80 82       	st	Z, r8
    1988:	d6 01       	movw	r26, r12
    198a:	8c 93       	st	X, r24

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    198c:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <__data_end>
    1990:	91 e0       	ldi	r25, 0x01	; 1
    1992:	98 0f       	add	r25, r24
    1994:	90 93 46 01 	sts	0x0146, r25	; 0x800146 <__data_end>
    1998:	83 30       	cpi	r24, 0x03	; 3
    199a:	39 f4       	brne	.+14     	; 0x19aa <Webserver_ApplicationCallback+0x174>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    199c:	f2 01       	movw	r30, r4
    199e:	10 82       	st	Z, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    19a0:	f7 01       	movw	r30, r14
    19a2:	eb 5e       	subi	r30, 0xEB	; 235
    19a4:	fd 4f       	sbci	r31, 0xFD	; 253
    19a6:	87 e0       	ldi	r24, 0x07	; 7
    19a8:	80 83       	st	Z, r24
		}
	}
}
    19aa:	df 91       	pop	r29
    19ac:	cf 91       	pop	r28
    19ae:	1f 91       	pop	r17
    19b0:	0f 91       	pop	r16
    19b2:	ff 90       	pop	r15
    19b4:	ef 90       	pop	r14
    19b6:	df 90       	pop	r13
    19b8:	cf 90       	pop	r12
    19ba:	bf 90       	pop	r11
    19bc:	af 90       	pop	r10
    19be:	9f 90       	pop	r9
    19c0:	8f 90       	pop	r8
    19c2:	7f 90       	pop	r7
    19c4:	6f 90       	pop	r6
    19c6:	5f 90       	pop	r5
    19c8:	4f 90       	pop	r4
    19ca:	08 95       	ret

000019cc <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    19cc:	4b e1       	ldi	r20, 0x1B	; 27
    19ce:	5c e0       	ldi	r21, 0x0C	; 12
    19d0:	61 e0       	ldi	r22, 0x01	; 1
    19d2:	80 e0       	ldi	r24, 0x00	; 0
    19d4:	90 e5       	ldi	r25, 0x50	; 80
    19d6:	bd c9       	rjmp	.-3206   	; 0xd52 <TCP_SetPortState>

000019d8 <ProcessRNDISControlMessage>:
void ProcessRNDISControlMessage(void)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	switch (MessageHeader->MessageType)
    19d8:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    19dc:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    19e0:	80 81       	ld	r24, Z
    19e2:	91 81       	ldd	r25, Z+1	; 0x01
    19e4:	a2 81       	ldd	r26, Z+2	; 0x02
    19e6:	b3 81       	ldd	r27, Z+3	; 0x03
    19e8:	84 30       	cpi	r24, 0x04	; 4
    19ea:	91 05       	cpc	r25, r1
    19ec:	a1 05       	cpc	r26, r1
    19ee:	b1 05       	cpc	r27, r1
    19f0:	09 f4       	brne	.+2      	; 0x19f4 <ProcessRNDISControlMessage+0x1c>
    19f2:	99 c0       	rjmp	.+306    	; 0x1b26 <ProcessRNDISControlMessage+0x14e>
    19f4:	58 f4       	brcc	.+22     	; 0x1a0c <ProcessRNDISControlMessage+0x34>
    19f6:	82 30       	cpi	r24, 0x02	; 2
    19f8:	91 05       	cpc	r25, r1
    19fa:	a1 05       	cpc	r26, r1
    19fc:	b1 05       	cpc	r27, r1
    19fe:	a1 f0       	breq	.+40     	; 0x1a28 <ProcessRNDISControlMessage+0x50>
    1a00:	03 97       	sbiw	r24, 0x03	; 3
    1a02:	a1 05       	cpc	r26, r1
    1a04:	b1 05       	cpc	r27, r1
    1a06:	09 f4       	brne	.+2      	; 0x1a0a <ProcessRNDISControlMessage+0x32>
    1a08:	85 c0       	rjmp	.+266    	; 0x1b14 <ProcessRNDISControlMessage+0x13c>
    1a0a:	08 95       	ret
    1a0c:	86 30       	cpi	r24, 0x06	; 6
    1a0e:	91 05       	cpc	r25, r1
    1a10:	a1 05       	cpc	r26, r1
    1a12:	b1 05       	cpc	r27, r1
    1a14:	09 f4       	brne	.+2      	; 0x1a18 <ProcessRNDISControlMessage+0x40>
    1a16:	db c1       	rjmp	.+950    	; 0x1dce <ProcessRNDISControlMessage+0x3f6>
    1a18:	08 f4       	brcc	.+2      	; 0x1a1c <ProcessRNDISControlMessage+0x44>
    1a1a:	7f c1       	rjmp	.+766    	; 0x1d1a <ProcessRNDISControlMessage+0x342>
    1a1c:	08 97       	sbiw	r24, 0x08	; 8
    1a1e:	a1 05       	cpc	r26, r1
    1a20:	b1 05       	cpc	r27, r1
    1a22:	09 f4       	brne	.+2      	; 0x1a26 <ProcessRNDISControlMessage+0x4e>
    1a24:	f8 c1       	rjmp	.+1008   	; 0x1e16 <ProcessRNDISControlMessage+0x43e>
    1a26:	08 95       	ret
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			/* Initialize the adapter - return information about the supported RNDIS version and buffer sizes */

			ResponseReady = true;
    1a28:	21 e0       	ldi	r18, 0x01	; 1
    1a2a:	20 93 4c 01 	sts	0x014C, r18	; 0x80014c <ResponseReady>

			RNDIS_Initialize_Message_t*  INITIALIZE_Message  = (RNDIS_Initialize_Message_t*)&RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response = (RNDIS_Initialize_Complete_t*)&RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
    1a2e:	82 e0       	ldi	r24, 0x02	; 2
    1a30:	90 e0       	ldi	r25, 0x00	; 0
    1a32:	a0 e0       	ldi	r26, 0x00	; 0
    1a34:	b0 e8       	ldi	r27, 0x80	; 128
    1a36:	80 93 50 13 	sts	0x1350, r24	; 0x801350 <RNDISMessageBuffer>
    1a3a:	90 93 51 13 	sts	0x1351, r25	; 0x801351 <RNDISMessageBuffer+0x1>
    1a3e:	a0 93 52 13 	sts	0x1352, r26	; 0x801352 <RNDISMessageBuffer+0x2>
    1a42:	b0 93 53 13 	sts	0x1353, r27	; 0x801353 <RNDISMessageBuffer+0x3>
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
    1a46:	84 e3       	ldi	r24, 0x34	; 52
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	a0 e0       	ldi	r26, 0x00	; 0
    1a4c:	b0 e0       	ldi	r27, 0x00	; 0
    1a4e:	80 93 54 13 	sts	0x1354, r24	; 0x801354 <RNDISMessageBuffer+0x4>
    1a52:	90 93 55 13 	sts	0x1355, r25	; 0x801355 <RNDISMessageBuffer+0x5>
    1a56:	a0 93 56 13 	sts	0x1356, r26	; 0x801356 <RNDISMessageBuffer+0x6>
    1a5a:	b0 93 57 13 	sts	0x1357, r27	; 0x801357 <RNDISMessageBuffer+0x7>
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
    1a5e:	10 92 5c 13 	sts	0x135C, r1	; 0x80135c <RNDISMessageBuffer+0xc>
    1a62:	10 92 5d 13 	sts	0x135D, r1	; 0x80135d <RNDISMessageBuffer+0xd>
    1a66:	10 92 5e 13 	sts	0x135E, r1	; 0x80135e <RNDISMessageBuffer+0xe>
    1a6a:	10 92 5f 13 	sts	0x135F, r1	; 0x80135f <RNDISMessageBuffer+0xf>

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
    1a6e:	81 e0       	ldi	r24, 0x01	; 1
    1a70:	90 e0       	ldi	r25, 0x00	; 0
    1a72:	a0 e0       	ldi	r26, 0x00	; 0
    1a74:	b0 e0       	ldi	r27, 0x00	; 0
    1a76:	80 93 60 13 	sts	0x1360, r24	; 0x801360 <RNDISMessageBuffer+0x10>
    1a7a:	90 93 61 13 	sts	0x1361, r25	; 0x801361 <RNDISMessageBuffer+0x11>
    1a7e:	a0 93 62 13 	sts	0x1362, r26	; 0x801362 <RNDISMessageBuffer+0x12>
    1a82:	b0 93 63 13 	sts	0x1363, r27	; 0x801363 <RNDISMessageBuffer+0x13>
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
    1a86:	10 92 64 13 	sts	0x1364, r1	; 0x801364 <RNDISMessageBuffer+0x14>
    1a8a:	10 92 65 13 	sts	0x1365, r1	; 0x801365 <RNDISMessageBuffer+0x15>
    1a8e:	10 92 66 13 	sts	0x1366, r1	; 0x801366 <RNDISMessageBuffer+0x16>
    1a92:	10 92 67 13 	sts	0x1367, r1	; 0x801367 <RNDISMessageBuffer+0x17>
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
    1a96:	80 93 68 13 	sts	0x1368, r24	; 0x801368 <RNDISMessageBuffer+0x18>
    1a9a:	90 93 69 13 	sts	0x1369, r25	; 0x801369 <RNDISMessageBuffer+0x19>
    1a9e:	a0 93 6a 13 	sts	0x136A, r26	; 0x80136a <RNDISMessageBuffer+0x1a>
    1aa2:	b0 93 6b 13 	sts	0x136B, r27	; 0x80136b <RNDISMessageBuffer+0x1b>
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
    1aa6:	10 92 6c 13 	sts	0x136C, r1	; 0x80136c <RNDISMessageBuffer+0x1c>
    1aaa:	10 92 6d 13 	sts	0x136D, r1	; 0x80136d <RNDISMessageBuffer+0x1d>
    1aae:	10 92 6e 13 	sts	0x136E, r1	; 0x80136e <RNDISMessageBuffer+0x1e>
    1ab2:	10 92 6f 13 	sts	0x136F, r1	; 0x80136f <RNDISMessageBuffer+0x1f>
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
    1ab6:	80 93 70 13 	sts	0x1370, r24	; 0x801370 <RNDISMessageBuffer+0x20>
    1aba:	90 93 71 13 	sts	0x1371, r25	; 0x801371 <RNDISMessageBuffer+0x21>
    1abe:	a0 93 72 13 	sts	0x1372, r26	; 0x801372 <RNDISMessageBuffer+0x22>
    1ac2:	b0 93 73 13 	sts	0x1373, r27	; 0x801373 <RNDISMessageBuffer+0x23>
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    1ac6:	88 e0       	ldi	r24, 0x08	; 8
    1ac8:	96 e0       	ldi	r25, 0x06	; 6
    1aca:	a0 e0       	ldi	r26, 0x00	; 0
    1acc:	b0 e0       	ldi	r27, 0x00	; 0
    1ace:	80 93 74 13 	sts	0x1374, r24	; 0x801374 <RNDISMessageBuffer+0x24>
    1ad2:	90 93 75 13 	sts	0x1375, r25	; 0x801375 <RNDISMessageBuffer+0x25>
    1ad6:	a0 93 76 13 	sts	0x1376, r26	; 0x801376 <RNDISMessageBuffer+0x26>
    1ada:	b0 93 77 13 	sts	0x1377, r27	; 0x801377 <RNDISMessageBuffer+0x27>
			INITIALIZE_Response->PacketAlignmentFactor = 0;
    1ade:	10 92 78 13 	sts	0x1378, r1	; 0x801378 <RNDISMessageBuffer+0x28>
    1ae2:	10 92 79 13 	sts	0x1379, r1	; 0x801379 <RNDISMessageBuffer+0x29>
    1ae6:	10 92 7a 13 	sts	0x137A, r1	; 0x80137a <RNDISMessageBuffer+0x2a>
    1aea:	10 92 7b 13 	sts	0x137B, r1	; 0x80137b <RNDISMessageBuffer+0x2b>
			INITIALIZE_Response->AFListOffset          = 0;
    1aee:	10 92 7c 13 	sts	0x137C, r1	; 0x80137c <RNDISMessageBuffer+0x2c>
    1af2:	10 92 7d 13 	sts	0x137D, r1	; 0x80137d <RNDISMessageBuffer+0x2d>
    1af6:	10 92 7e 13 	sts	0x137E, r1	; 0x80137e <RNDISMessageBuffer+0x2e>
    1afa:	10 92 7f 13 	sts	0x137F, r1	; 0x80137f <RNDISMessageBuffer+0x2f>
			INITIALIZE_Response->AFListSize            = 0;
    1afe:	10 92 80 13 	sts	0x1380, r1	; 0x801380 <RNDISMessageBuffer+0x30>
    1b02:	10 92 81 13 	sts	0x1381, r1	; 0x801381 <RNDISMessageBuffer+0x31>
    1b06:	10 92 82 13 	sts	0x1382, r1	; 0x801382 <RNDISMessageBuffer+0x32>
    1b0a:	10 92 83 13 	sts	0x1383, r1	; 0x801383 <RNDISMessageBuffer+0x33>

			CurrRNDISState = RNDIS_Initialized;
    1b0e:	20 93 4b 01 	sts	0x014B, r18	; 0x80014b <CurrRNDISState>

			break;
    1b12:	08 95       	ret
		case REMOTE_NDIS_HALT_MSG:
			/* Halt the adapter, reset the adapter state - note that no response should be returned when completed */

			ResponseReady = false;
    1b14:	10 92 4c 01 	sts	0x014C, r1	; 0x80014c <ResponseReady>
			MessageHeader->MessageLength = 0;
    1b18:	14 82       	std	Z+4, r1	; 0x04
    1b1a:	15 82       	std	Z+5, r1	; 0x05
    1b1c:	16 82       	std	Z+6, r1	; 0x06
    1b1e:	17 82       	std	Z+7, r1	; 0x07

			CurrRNDISState = RNDIS_Uninitialized;
    1b20:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <CurrRNDISState>

			break;
    1b24:	08 95       	ret
		case REMOTE_NDIS_QUERY_MSG:
			/* Request for information about a parameter about the adapter, specified as an OID token */

			ResponseReady = true;
    1b26:	81 e0       	ldi	r24, 0x01	; 1
    1b28:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <ResponseReady>

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISMessageBuffer;
			uint32_t                Query_Oid      = QUERY_Message->Oid;
    1b2c:	80 91 5c 13 	lds	r24, 0x135C	; 0x80135c <RNDISMessageBuffer+0xc>
    1b30:	90 91 5d 13 	lds	r25, 0x135D	; 0x80135d <RNDISMessageBuffer+0xd>
    1b34:	a0 91 5e 13 	lds	r26, 0x135E	; 0x80135e <RNDISMessageBuffer+0xe>
    1b38:	b0 91 5f 13 	lds	r27, 0x135F	; 0x80135f <RNDISMessageBuffer+0xf>
			void*     QueryData                 = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                          QUERY_Message->InformationBufferOffset];
			void*     ResponseData              = &RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
			uint16_t  ResponseSize;

			QUERY_Response->MessageType         = REMOTE_NDIS_QUERY_CMPLT;
    1b3c:	44 e0       	ldi	r20, 0x04	; 4
    1b3e:	50 e0       	ldi	r21, 0x00	; 0
    1b40:	60 e0       	ldi	r22, 0x00	; 0
    1b42:	70 e8       	ldi	r23, 0x80	; 128
    1b44:	40 93 50 13 	sts	0x1350, r20	; 0x801350 <RNDISMessageBuffer>
    1b48:	50 93 51 13 	sts	0x1351, r21	; 0x801351 <RNDISMessageBuffer+0x1>
    1b4c:	60 93 52 13 	sts	0x1352, r22	; 0x801352 <RNDISMessageBuffer+0x2>
    1b50:	70 93 53 13 	sts	0x1353, r23	; 0x801353 <RNDISMessageBuffer+0x3>
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);
    1b54:	48 e1       	ldi	r20, 0x18	; 24
    1b56:	50 e0       	ldi	r21, 0x00	; 0
    1b58:	60 e0       	ldi	r22, 0x00	; 0
    1b5a:	70 e0       	ldi	r23, 0x00	; 0
    1b5c:	40 93 54 13 	sts	0x1354, r20	; 0x801354 <RNDISMessageBuffer+0x4>
    1b60:	50 93 55 13 	sts	0x1355, r21	; 0x801355 <RNDISMessageBuffer+0x5>
    1b64:	60 93 56 13 	sts	0x1356, r22	; 0x801356 <RNDISMessageBuffer+0x6>
    1b68:	70 93 57 13 	sts	0x1357, r23	; 0x801357 <RNDISMessageBuffer+0x7>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1b6c:	8e 30       	cpi	r24, 0x0E	; 14
    1b6e:	21 e0       	ldi	r18, 0x01	; 1
    1b70:	92 07       	cpc	r25, r18
    1b72:	a2 07       	cpc	r26, r18
    1b74:	b1 05       	cpc	r27, r1
    1b76:	09 f4       	brne	.+2      	; 0x1b7a <ProcessRNDISControlMessage+0x1a2>
    1b78:	b3 c0       	rjmp	.+358    	; 0x1ce0 <ProcessRNDISControlMessage+0x308>
    1b7a:	08 f0       	brcs	.+2      	; 0x1b7e <ProcessRNDISControlMessage+0x1a6>
    1b7c:	56 c0       	rjmp	.+172    	; 0x1c2a <ProcessRNDISControlMessage+0x252>
    1b7e:	86 30       	cpi	r24, 0x06	; 6
    1b80:	21 e0       	ldi	r18, 0x01	; 1
    1b82:	92 07       	cpc	r25, r18
    1b84:	a2 07       	cpc	r26, r18
    1b86:	b1 05       	cpc	r27, r1
    1b88:	09 f4       	brne	.+2      	; 0x1b8c <ProcessRNDISControlMessage+0x1b4>
    1b8a:	a0 c0       	rjmp	.+320    	; 0x1ccc <ProcessRNDISControlMessage+0x2f4>
    1b8c:	f8 f4       	brcc	.+62     	; 0x1bcc <ProcessRNDISControlMessage+0x1f4>
    1b8e:	82 30       	cpi	r24, 0x02	; 2
    1b90:	21 e0       	ldi	r18, 0x01	; 1
    1b92:	92 07       	cpc	r25, r18
    1b94:	a2 07       	cpc	r26, r18
    1b96:	b1 05       	cpc	r27, r1
    1b98:	09 f4       	brne	.+2      	; 0x1b9c <ProcessRNDISControlMessage+0x1c4>
    1b9a:	ab c0       	rjmp	.+342    	; 0x1cf2 <ProcessRNDISControlMessage+0x31a>
    1b9c:	80 f4       	brcc	.+32     	; 0x1bbe <ProcessRNDISControlMessage+0x1e6>
    1b9e:	81 30       	cpi	r24, 0x01	; 1
    1ba0:	91 40       	sbci	r25, 0x01	; 1
    1ba2:	a1 40       	sbci	r26, 0x01	; 1
    1ba4:	b1 05       	cpc	r27, r1
    1ba6:	09 f0       	breq	.+2      	; 0x1baa <ProcessRNDISControlMessage+0x1d2>
    1ba8:	85 c1       	rjmp	.+778    	; 0x1eb4 <ProcessRNDISControlMessage+0x4dc>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			/* Copy the list of supported NDIS OID tokens to the response buffer */
			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    1baa:	4c e6       	ldi	r20, 0x6C	; 108
    1bac:	50 e0       	ldi	r21, 0x00	; 0
    1bae:	6a ed       	ldi	r22, 0xDA	; 218
    1bb0:	73 e0       	ldi	r23, 0x03	; 3
    1bb2:	88 e6       	ldi	r24, 0x68	; 104
    1bb4:	93 e1       	ldi	r25, 0x13	; 19
    1bb6:	5c d6       	rcall	.+3256   	; 0x2870 <memcpy_P>
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    1bb8:	8c e6       	ldi	r24, 0x6C	; 108
    1bba:	90 e0       	ldi	r25, 0x00	; 0
    1bbc:	48 c1       	rjmp	.+656    	; 0x1e4e <ProcessRNDISControlMessage+0x476>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1bbe:	85 30       	cpi	r24, 0x05	; 5
    1bc0:	91 40       	sbci	r25, 0x01	; 1
    1bc2:	a1 40       	sbci	r26, 0x01	; 1
    1bc4:	b1 05       	cpc	r27, r1
    1bc6:	08 f4       	brcc	.+2      	; 0x1bca <ProcessRNDISControlMessage+0x1f2>
    1bc8:	94 c0       	rjmp	.+296    	; 0x1cf2 <ProcessRNDISControlMessage+0x31a>
    1bca:	74 c1       	rjmp	.+744    	; 0x1eb4 <ProcessRNDISControlMessage+0x4dc>
    1bcc:	8c 30       	cpi	r24, 0x0C	; 12
    1bce:	21 e0       	ldi	r18, 0x01	; 1
    1bd0:	92 07       	cpc	r25, r18
    1bd2:	a2 07       	cpc	r26, r18
    1bd4:	b1 05       	cpc	r27, r1
    1bd6:	90 f4       	brcc	.+36     	; 0x1bfc <ProcessRNDISControlMessage+0x224>
    1bd8:	8a 30       	cpi	r24, 0x0A	; 10
    1bda:	21 e0       	ldi	r18, 0x01	; 1
    1bdc:	92 07       	cpc	r25, r18
    1bde:	a2 07       	cpc	r26, r18
    1be0:	b1 05       	cpc	r27, r1
    1be2:	08 f0       	brcs	.+2      	; 0x1be6 <ProcessRNDISControlMessage+0x20e>
    1be4:	73 c0       	rjmp	.+230    	; 0x1ccc <ProcessRNDISControlMessage+0x2f4>
    1be6:	87 30       	cpi	r24, 0x07	; 7
    1be8:	91 40       	sbci	r25, 0x01	; 1
    1bea:	a1 40       	sbci	r26, 0x01	; 1
    1bec:	b1 05       	cpc	r27, r1
    1bee:	09 f0       	breq	.+2      	; 0x1bf2 <ProcessRNDISControlMessage+0x21a>
    1bf0:	61 c1       	rjmp	.+706    	; 0x1eb4 <ProcessRNDISControlMessage+0x4dc>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
    1bf2:	80 ea       	ldi	r24, 0xA0	; 160
    1bf4:	96 e8       	ldi	r25, 0x86	; 134
    1bf6:	a1 e0       	ldi	r26, 0x01	; 1
    1bf8:	b0 e0       	ldi	r27, 0x00	; 0
    1bfa:	84 c0       	rjmp	.+264    	; 0x1d04 <ProcessRNDISControlMessage+0x32c>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1bfc:	8c 30       	cpi	r24, 0x0C	; 12
    1bfe:	21 e0       	ldi	r18, 0x01	; 1
    1c00:	92 07       	cpc	r25, r18
    1c02:	a2 07       	cpc	r26, r18
    1c04:	b1 05       	cpc	r27, r1
    1c06:	09 f4       	brne	.+2      	; 0x1c0a <ProcessRNDISControlMessage+0x232>
    1c08:	5c c0       	rjmp	.+184    	; 0x1cc2 <ProcessRNDISControlMessage+0x2ea>
    1c0a:	8d 30       	cpi	r24, 0x0D	; 13
    1c0c:	91 40       	sbci	r25, 0x01	; 1
    1c0e:	a1 40       	sbci	r26, 0x01	; 1
    1c10:	b1 05       	cpc	r27, r1
    1c12:	09 f0       	breq	.+2      	; 0x1c16 <ProcessRNDISControlMessage+0x23e>
    1c14:	4f c1       	rjmp	.+670    	; 0x1eb4 <ProcessRNDISControlMessage+0x4dc>
			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);

			/* Copy vendor description string to the response buffer */
			memcpy_P(ResponseData, AdapterVendorDescription, sizeof(AdapterVendorDescription));
    1c16:	43 e1       	ldi	r20, 0x13	; 19
    1c18:	50 e0       	ldi	r21, 0x00	; 0
    1c1a:	66 e4       	ldi	r22, 0x46	; 70
    1c1c:	74 e0       	ldi	r23, 0x04	; 4
    1c1e:	88 e6       	ldi	r24, 0x68	; 104
    1c20:	93 e1       	ldi	r25, 0x13	; 19
    1c22:	26 d6       	rcall	.+3148   	; 0x2870 <memcpy_P>
			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);
    1c24:	83 e1       	ldi	r24, 0x13	; 19
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	12 c1       	rjmp	.+548    	; 0x1e4e <ProcessRNDISControlMessage+0x476>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1c2a:	86 30       	cpi	r24, 0x06	; 6
    1c2c:	21 e0       	ldi	r18, 0x01	; 1
    1c2e:	92 07       	cpc	r25, r18
    1c30:	22 e0       	ldi	r18, 0x02	; 2
    1c32:	a2 07       	cpc	r26, r18
    1c34:	b1 05       	cpc	r27, r1
    1c36:	10 f5       	brcc	.+68     	; 0x1c7c <ProcessRNDISControlMessage+0x2a4>
    1c38:	81 30       	cpi	r24, 0x01	; 1
    1c3a:	21 e0       	ldi	r18, 0x01	; 1
    1c3c:	92 07       	cpc	r25, r18
    1c3e:	22 e0       	ldi	r18, 0x02	; 2
    1c40:	a2 07       	cpc	r26, r18
    1c42:	b1 05       	cpc	r27, r1
    1c44:	08 f0       	brcs	.+2      	; 0x1c48 <ProcessRNDISControlMessage+0x270>
    1c46:	55 c0       	rjmp	.+170    	; 0x1cf2 <ProcessRNDISControlMessage+0x31a>
    1c48:	84 31       	cpi	r24, 0x14	; 20
    1c4a:	21 e0       	ldi	r18, 0x01	; 1
    1c4c:	92 07       	cpc	r25, r18
    1c4e:	a2 07       	cpc	r26, r18
    1c50:	b1 05       	cpc	r27, r1
    1c52:	09 f4       	brne	.+2      	; 0x1c56 <ProcessRNDISControlMessage+0x27e>
    1c54:	4e c0       	rjmp	.+156    	; 0x1cf2 <ProcessRNDISControlMessage+0x31a>
    1c56:	82 30       	cpi	r24, 0x02	; 2
    1c58:	22 e0       	ldi	r18, 0x02	; 2
    1c5a:	92 07       	cpc	r25, r18
    1c5c:	21 e0       	ldi	r18, 0x01	; 1
    1c5e:	a2 07       	cpc	r26, r18
    1c60:	b1 05       	cpc	r27, r1
    1c62:	09 f4       	brne	.+2      	; 0x1c66 <ProcessRNDISControlMessage+0x28e>
    1c64:	46 c0       	rjmp	.+140    	; 0x1cf2 <ProcessRNDISControlMessage+0x31a>
    1c66:	81 31       	cpi	r24, 0x11	; 17
    1c68:	91 40       	sbci	r25, 0x01	; 1
    1c6a:	a1 40       	sbci	r26, 0x01	; 1
    1c6c:	b1 05       	cpc	r27, r1
    1c6e:	09 f0       	breq	.+2      	; 0x1c72 <ProcessRNDISControlMessage+0x29a>
    1c70:	21 c1       	rjmp	.+578    	; 0x1eb4 <ProcessRNDISControlMessage+0x4dc>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
    1c72:	80 e6       	ldi	r24, 0x60	; 96
    1c74:	96 e0       	ldi	r25, 0x06	; 6
    1c76:	a0 e0       	ldi	r26, 0x00	; 0
    1c78:	b0 e0       	ldi	r27, 0x00	; 0
    1c7a:	44 c0       	rjmp	.+136    	; 0x1d04 <ProcessRNDISControlMessage+0x32c>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1c7c:	84 30       	cpi	r24, 0x04	; 4
    1c7e:	21 e0       	ldi	r18, 0x01	; 1
    1c80:	92 07       	cpc	r25, r18
    1c82:	a2 07       	cpc	r26, r18
    1c84:	b2 07       	cpc	r27, r18
    1c86:	39 f1       	breq	.+78     	; 0x1cd6 <ProcessRNDISControlMessage+0x2fe>
    1c88:	98 f4       	brcc	.+38     	; 0x1cb0 <ProcessRNDISControlMessage+0x2d8>
    1c8a:	81 50       	subi	r24, 0x01	; 1
    1c8c:	91 40       	sbci	r25, 0x01	; 1
    1c8e:	a1 40       	sbci	r26, 0x01	; 1
    1c90:	b1 40       	sbci	r27, 0x01	; 1
    1c92:	02 97       	sbiw	r24, 0x02	; 2
    1c94:	a1 05       	cpc	r26, r1
    1c96:	b1 05       	cpc	r27, r1
    1c98:	08 f0       	brcs	.+2      	; 0x1c9c <ProcessRNDISControlMessage+0x2c4>
    1c9a:	0c c1       	rjmp	.+536    	; 0x1eb4 <ProcessRNDISControlMessage+0x4dc>
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			/* Copy over the fixed adapter MAC to the response buffer */
			memcpy_P(ResponseData, &AdapterMACAddress, sizeof(MAC_Address_t));
    1c9c:	46 e0       	ldi	r20, 0x06	; 6
    1c9e:	50 e0       	ldi	r21, 0x00	; 0
    1ca0:	69 e5       	ldi	r22, 0x59	; 89
    1ca2:	74 e0       	ldi	r23, 0x04	; 4
    1ca4:	88 e6       	ldi	r24, 0x68	; 104
    1ca6:	93 e1       	ldi	r25, 0x13	; 19
    1ca8:	e3 d5       	rcall	.+3014   	; 0x2870 <memcpy_P>
			*((uint32_t*)ResponseData) = 100000;

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    1caa:	86 e0       	ldi	r24, 0x06	; 6
    1cac:	90 e0       	ldi	r25, 0x00	; 0
    1cae:	cf c0       	rjmp	.+414    	; 0x1e4e <ProcessRNDISControlMessage+0x476>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1cb0:	81 50       	subi	r24, 0x01	; 1
    1cb2:	91 40       	sbci	r25, 0x01	; 1
    1cb4:	a2 40       	sbci	r26, 0x02	; 2
    1cb6:	b1 40       	sbci	r27, 0x01	; 1
    1cb8:	03 97       	sbiw	r24, 0x03	; 3
    1cba:	a1 05       	cpc	r26, r1
    1cbc:	b1 05       	cpc	r27, r1
    1cbe:	c8 f0       	brcs	.+50     	; 0x1cf2 <ProcessRNDISControlMessage+0x31a>
    1cc0:	f9 c0       	rjmp	.+498    	; 0x1eb4 <ProcessRNDISControlMessage+0x4dc>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
    1cc2:	8f ef       	ldi	r24, 0xFF	; 255
    1cc4:	9f ef       	ldi	r25, 0xFF	; 255
    1cc6:	af ef       	ldi	r26, 0xFF	; 255
    1cc8:	b0 e0       	ldi	r27, 0x00	; 0
    1cca:	1c c0       	rjmp	.+56     	; 0x1d04 <ProcessRNDISControlMessage+0x32c>
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
    1ccc:	8c ed       	ldi	r24, 0xDC	; 220
    1cce:	95 e0       	ldi	r25, 0x05	; 5
    1cd0:	a0 e0       	ldi	r26, 0x00	; 0
    1cd2:	b0 e0       	ldi	r27, 0x00	; 0
    1cd4:	17 c0       	rjmp	.+46     	; 0x1d04 <ProcessRNDISControlMessage+0x32c>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
    1cd6:	81 e0       	ldi	r24, 0x01	; 1
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	a0 e0       	ldi	r26, 0x00	; 0
    1cdc:	b0 e0       	ldi	r27, 0x00	; 0
    1cde:	12 c0       	rjmp	.+36     	; 0x1d04 <ProcessRNDISControlMessage+0x32c>
			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate the current packet filter mask */
			*((uint32_t*)ResponseData) = CurrPacketFilter;
    1ce0:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <CurrPacketFilter>
    1ce4:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <CurrPacketFilter+0x1>
    1ce8:	a0 91 49 01 	lds	r26, 0x0149	; 0x800149 <CurrPacketFilter+0x2>
    1cec:	b0 91 4a 01 	lds	r27, 0x014A	; 0x80014a <CurrPacketFilter+0x3>
    1cf0:	09 c0       	rjmp	.+18     	; 0x1d04 <ProcessRNDISControlMessage+0x32c>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
    1cf2:	10 92 68 13 	sts	0x1368, r1	; 0x801368 <RNDISMessageBuffer+0x18>
    1cf6:	10 92 69 13 	sts	0x1369, r1	; 0x801369 <RNDISMessageBuffer+0x19>
    1cfa:	10 92 6a 13 	sts	0x136A, r1	; 0x80136a <RNDISMessageBuffer+0x1a>
    1cfe:	10 92 6b 13 	sts	0x136B, r1	; 0x80136b <RNDISMessageBuffer+0x1b>
    1d02:	08 c0       	rjmp	.+16     	; 0x1d14 <ProcessRNDISControlMessage+0x33c>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
    1d04:	80 93 68 13 	sts	0x1368, r24	; 0x801368 <RNDISMessageBuffer+0x18>
    1d08:	90 93 69 13 	sts	0x1369, r25	; 0x801369 <RNDISMessageBuffer+0x19>
    1d0c:	a0 93 6a 13 	sts	0x136A, r26	; 0x80136a <RNDISMessageBuffer+0x1a>
    1d10:	b0 93 6b 13 	sts	0x136B, r27	; 0x80136b <RNDISMessageBuffer+0x1b>
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    1d14:	84 e0       	ldi	r24, 0x04	; 4
    1d16:	90 e0       	ldi	r25, 0x00	; 0
    1d18:	9a c0       	rjmp	.+308    	; 0x1e4e <ProcessRNDISControlMessage+0x476>

			break;
		case REMOTE_NDIS_SET_MSG:
			/* Request to set a parameter of the adapter, specified as an OID token */

			ResponseReady = true;
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
    1d1c:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <ResponseReady>

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
    1d20:	80 91 5c 13 	lds	r24, 0x135C	; 0x80135c <RNDISMessageBuffer+0xc>
    1d24:	90 91 5d 13 	lds	r25, 0x135D	; 0x80135d <RNDISMessageBuffer+0xd>
    1d28:	a0 91 5e 13 	lds	r26, 0x135E	; 0x80135e <RNDISMessageBuffer+0xe>
    1d2c:	b0 91 5f 13 	lds	r27, 0x135F	; 0x80135f <RNDISMessageBuffer+0xf>

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
    1d30:	45 e0       	ldi	r20, 0x05	; 5
    1d32:	50 e0       	ldi	r21, 0x00	; 0
    1d34:	60 e0       	ldi	r22, 0x00	; 0
    1d36:	70 e8       	ldi	r23, 0x80	; 128
    1d38:	40 93 50 13 	sts	0x1350, r20	; 0x801350 <RNDISMessageBuffer>
    1d3c:	50 93 51 13 	sts	0x1351, r21	; 0x801351 <RNDISMessageBuffer+0x1>
    1d40:	60 93 52 13 	sts	0x1352, r22	; 0x801352 <RNDISMessageBuffer+0x2>
    1d44:	70 93 53 13 	sts	0x1353, r23	; 0x801353 <RNDISMessageBuffer+0x3>
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
    1d48:	40 e1       	ldi	r20, 0x10	; 16
    1d4a:	50 e0       	ldi	r21, 0x00	; 0
    1d4c:	60 e0       	ldi	r22, 0x00	; 0
    1d4e:	70 e0       	ldi	r23, 0x00	; 0
    1d50:	40 93 54 13 	sts	0x1354, r20	; 0x801354 <RNDISMessageBuffer+0x4>
    1d54:	50 93 55 13 	sts	0x1355, r21	; 0x801355 <RNDISMessageBuffer+0x5>
    1d58:	60 93 56 13 	sts	0x1356, r22	; 0x801356 <RNDISMessageBuffer+0x6>
    1d5c:	70 93 57 13 	sts	0x1357, r23	; 0x801357 <RNDISMessageBuffer+0x7>
 */
static bool ProcessNDISSet(uint32_t OId, void* SetData, uint16_t SetSize)
{
	/* Handler for REMOTE_NDIS_SET_MSG messages */

	switch (OId)
    1d60:	8e 30       	cpi	r24, 0x0E	; 14
    1d62:	21 e0       	ldi	r18, 0x01	; 1
    1d64:	92 07       	cpc	r25, r18
    1d66:	a2 07       	cpc	r26, r18
    1d68:	b1 05       	cpc	r27, r1
    1d6a:	99 f0       	breq	.+38     	; 0x1d92 <ProcessRNDISControlMessage+0x3ba>
    1d6c:	83 30       	cpi	r24, 0x03	; 3
    1d6e:	91 40       	sbci	r25, 0x01	; 1
    1d70:	a1 40       	sbci	r26, 0x01	; 1
    1d72:	b1 40       	sbci	r27, 0x01	; 1
    1d74:	09 f4       	brne	.+2      	; 0x1d78 <ProcessRNDISControlMessage+0x3a0>
    1d76:	bb c0       	rjmp	.+374    	; 0x1eee <ProcessRNDISControlMessage+0x516>
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
			else
			  SET_Response->Status        = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    1d78:	8b eb       	ldi	r24, 0xBB	; 187
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	a0 e0       	ldi	r26, 0x00	; 0
    1d7e:	b0 ec       	ldi	r27, 0xC0	; 192
    1d80:	80 93 5c 13 	sts	0x135C, r24	; 0x80135c <RNDISMessageBuffer+0xc>
    1d84:	90 93 5d 13 	sts	0x135D, r25	; 0x80135d <RNDISMessageBuffer+0xd>
    1d88:	a0 93 5e 13 	sts	0x135E, r26	; 0x80135e <RNDISMessageBuffer+0xe>
    1d8c:	b0 93 5f 13 	sts	0x135F, r27	; 0x80135f <RNDISMessageBuffer+0xf>
    1d90:	08 95       	ret

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
    1d92:	80 91 64 13 	lds	r24, 0x1364	; 0x801364 <RNDISMessageBuffer+0x14>
    1d96:	90 91 65 13 	lds	r25, 0x1365	; 0x801365 <RNDISMessageBuffer+0x15>
    1d9a:	a0 91 66 13 	lds	r26, 0x1366	; 0x801366 <RNDISMessageBuffer+0x16>
    1d9e:	b0 91 67 13 	lds	r27, 0x1367	; 0x801367 <RNDISMessageBuffer+0x17>
    1da2:	08 96       	adiw	r24, 0x08	; 8
    1da4:	a1 1d       	adc	r26, r1
    1da6:	b1 1d       	adc	r27, r1

	switch (OId)
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			/* Save the packet filter mask in case the host queries it again later */
			CurrPacketFilter = *((uint32_t*)SetData);
    1da8:	fc 01       	movw	r30, r24
    1daa:	e0 5b       	subi	r30, 0xB0	; 176
    1dac:	fc 4e       	sbci	r31, 0xEC	; 236
    1dae:	80 81       	ld	r24, Z
    1db0:	91 81       	ldd	r25, Z+1	; 0x01
    1db2:	a2 81       	ldd	r26, Z+2	; 0x02
    1db4:	b3 81       	ldd	r27, Z+3	; 0x03
    1db6:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <CurrPacketFilter>
    1dba:	90 93 48 01 	sts	0x0148, r25	; 0x800148 <CurrPacketFilter+0x1>
    1dbe:	a0 93 49 01 	sts	0x0149, r26	; 0x800149 <CurrPacketFilter+0x2>
    1dc2:	b0 93 4a 01 	sts	0x014A, r27	; 0x80014a <CurrPacketFilter+0x3>

			/* Set the RNDIS state to initialized if the packet filter is non-zero */
			CurrRNDISState = ((CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Data_Initialized);
    1dc6:	82 e0       	ldi	r24, 0x02	; 2
    1dc8:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <CurrRNDISState>
    1dcc:	90 c0       	rjmp	.+288    	; 0x1eee <ProcessRNDISControlMessage+0x516>

			break;
		case REMOTE_NDIS_RESET_MSG:
			/* Soft reset the adapter */

			ResponseReady = true;
    1dce:	81 e0       	ldi	r24, 0x01	; 1
    1dd0:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <ResponseReady>

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISMessageBuffer;

			RESET_Response->MessageType         = REMOTE_NDIS_RESET_CMPLT;
    1dd4:	86 e0       	ldi	r24, 0x06	; 6
    1dd6:	90 e0       	ldi	r25, 0x00	; 0
    1dd8:	a0 e0       	ldi	r26, 0x00	; 0
    1dda:	b0 e8       	ldi	r27, 0x80	; 128
    1ddc:	80 93 50 13 	sts	0x1350, r24	; 0x801350 <RNDISMessageBuffer>
    1de0:	90 93 51 13 	sts	0x1351, r25	; 0x801351 <RNDISMessageBuffer+0x1>
    1de4:	a0 93 52 13 	sts	0x1352, r26	; 0x801352 <RNDISMessageBuffer+0x2>
    1de8:	b0 93 53 13 	sts	0x1353, r27	; 0x801353 <RNDISMessageBuffer+0x3>
			RESET_Response->MessageLength       = sizeof(RNDIS_Reset_Complete_t);
    1dec:	80 e1       	ldi	r24, 0x10	; 16
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	a0 e0       	ldi	r26, 0x00	; 0
    1df2:	b0 e0       	ldi	r27, 0x00	; 0
    1df4:	80 93 54 13 	sts	0x1354, r24	; 0x801354 <RNDISMessageBuffer+0x4>
    1df8:	90 93 55 13 	sts	0x1355, r25	; 0x801355 <RNDISMessageBuffer+0x5>
    1dfc:	a0 93 56 13 	sts	0x1356, r26	; 0x801356 <RNDISMessageBuffer+0x6>
    1e00:	b0 93 57 13 	sts	0x1357, r27	; 0x801357 <RNDISMessageBuffer+0x7>
			RESET_Response->Status              = REMOTE_NDIS_STATUS_SUCCESS;
    1e04:	10 92 58 13 	sts	0x1358, r1	; 0x801358 <RNDISMessageBuffer+0x8>
    1e08:	10 92 59 13 	sts	0x1359, r1	; 0x801359 <RNDISMessageBuffer+0x9>
    1e0c:	10 92 5a 13 	sts	0x135A, r1	; 0x80135a <RNDISMessageBuffer+0xa>
    1e10:	10 92 5b 13 	sts	0x135B, r1	; 0x80135b <RNDISMessageBuffer+0xb>
    1e14:	6c c0       	rjmp	.+216    	; 0x1eee <ProcessRNDISControlMessage+0x516>

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			/* Keep alive message sent to the adapter every 5 seconds when idle to ensure it is still responding */

			ResponseReady = true;
    1e16:	81 e0       	ldi	r24, 0x01	; 1
    1e18:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <ResponseReady>

			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  = (RNDIS_KeepAlive_Message_t*)&RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response = (RNDIS_KeepAlive_Complete_t*)&RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType     = REMOTE_NDIS_KEEPALIVE_CMPLT;
    1e1c:	88 e0       	ldi	r24, 0x08	; 8
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	a0 e0       	ldi	r26, 0x00	; 0
    1e22:	b0 e8       	ldi	r27, 0x80	; 128
    1e24:	80 93 50 13 	sts	0x1350, r24	; 0x801350 <RNDISMessageBuffer>
    1e28:	90 93 51 13 	sts	0x1351, r25	; 0x801351 <RNDISMessageBuffer+0x1>
    1e2c:	a0 93 52 13 	sts	0x1352, r26	; 0x801352 <RNDISMessageBuffer+0x2>
    1e30:	b0 93 53 13 	sts	0x1353, r27	; 0x801353 <RNDISMessageBuffer+0x3>
			KEEPALIVE_Response->MessageLength   = sizeof(RNDIS_KeepAlive_Complete_t);
    1e34:	80 e1       	ldi	r24, 0x10	; 16
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	a0 e0       	ldi	r26, 0x00	; 0
    1e3a:	b0 e0       	ldi	r27, 0x00	; 0
    1e3c:	80 93 54 13 	sts	0x1354, r24	; 0x801354 <RNDISMessageBuffer+0x4>
    1e40:	90 93 55 13 	sts	0x1355, r25	; 0x801355 <RNDISMessageBuffer+0x5>
    1e44:	a0 93 56 13 	sts	0x1356, r26	; 0x801356 <RNDISMessageBuffer+0x6>
    1e48:	b0 93 57 13 	sts	0x1357, r27	; 0x801357 <RNDISMessageBuffer+0x7>
    1e4c:	50 c0       	rjmp	.+160    	; 0x1eee <ProcessRNDISControlMessage+0x516>
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);

			if (ProcessNDISQuery(Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                     ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
    1e4e:	10 92 5c 13 	sts	0x135C, r1	; 0x80135c <RNDISMessageBuffer+0xc>
    1e52:	10 92 5d 13 	sts	0x135D, r1	; 0x80135d <RNDISMessageBuffer+0xd>
    1e56:	10 92 5e 13 	sts	0x135E, r1	; 0x80135e <RNDISMessageBuffer+0xe>
    1e5a:	10 92 5f 13 	sts	0x135F, r1	; 0x80135f <RNDISMessageBuffer+0xf>
				QUERY_Response->MessageLength          += ResponseSize;
    1e5e:	a0 e0       	ldi	r26, 0x00	; 0
    1e60:	b0 e0       	ldi	r27, 0x00	; 0
    1e62:	40 91 54 13 	lds	r20, 0x1354	; 0x801354 <RNDISMessageBuffer+0x4>
    1e66:	50 91 55 13 	lds	r21, 0x1355	; 0x801355 <RNDISMessageBuffer+0x5>
    1e6a:	60 91 56 13 	lds	r22, 0x1356	; 0x801356 <RNDISMessageBuffer+0x6>
    1e6e:	70 91 57 13 	lds	r23, 0x1357	; 0x801357 <RNDISMessageBuffer+0x7>
    1e72:	48 0f       	add	r20, r24
    1e74:	59 1f       	adc	r21, r25
    1e76:	6a 1f       	adc	r22, r26
    1e78:	7b 1f       	adc	r23, r27
    1e7a:	40 93 54 13 	sts	0x1354, r20	; 0x801354 <RNDISMessageBuffer+0x4>
    1e7e:	50 93 55 13 	sts	0x1355, r21	; 0x801355 <RNDISMessageBuffer+0x5>
    1e82:	60 93 56 13 	sts	0x1356, r22	; 0x801356 <RNDISMessageBuffer+0x6>
    1e86:	70 93 57 13 	sts	0x1357, r23	; 0x801357 <RNDISMessageBuffer+0x7>

				QUERY_Response->InformationBufferLength = ResponseSize;
    1e8a:	80 93 60 13 	sts	0x1360, r24	; 0x801360 <RNDISMessageBuffer+0x10>
    1e8e:	90 93 61 13 	sts	0x1361, r25	; 0x801361 <RNDISMessageBuffer+0x11>
    1e92:	a0 93 62 13 	sts	0x1362, r26	; 0x801362 <RNDISMessageBuffer+0x12>
    1e96:	b0 93 63 13 	sts	0x1363, r27	; 0x801363 <RNDISMessageBuffer+0x13>
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    1e9a:	80 e1       	ldi	r24, 0x10	; 16
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	a0 e0       	ldi	r26, 0x00	; 0
    1ea0:	b0 e0       	ldi	r27, 0x00	; 0
    1ea2:	80 93 64 13 	sts	0x1364, r24	; 0x801364 <RNDISMessageBuffer+0x14>
    1ea6:	90 93 65 13 	sts	0x1365, r25	; 0x801365 <RNDISMessageBuffer+0x15>
    1eaa:	a0 93 66 13 	sts	0x1366, r26	; 0x801366 <RNDISMessageBuffer+0x16>
    1eae:	b0 93 67 13 	sts	0x1367, r27	; 0x801367 <RNDISMessageBuffer+0x17>
    1eb2:	08 95       	ret
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    1eb4:	8b eb       	ldi	r24, 0xBB	; 187
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	a0 e0       	ldi	r26, 0x00	; 0
    1eba:	b0 ec       	ldi	r27, 0xC0	; 192
    1ebc:	80 93 5c 13 	sts	0x135C, r24	; 0x80135c <RNDISMessageBuffer+0xc>
    1ec0:	90 93 5d 13 	sts	0x135D, r25	; 0x80135d <RNDISMessageBuffer+0xd>
    1ec4:	a0 93 5e 13 	sts	0x135E, r26	; 0x80135e <RNDISMessageBuffer+0xe>
    1ec8:	b0 93 5f 13 	sts	0x135F, r27	; 0x80135f <RNDISMessageBuffer+0xf>

				QUERY_Response->InformationBufferLength = 0;
    1ecc:	10 92 60 13 	sts	0x1360, r1	; 0x801360 <RNDISMessageBuffer+0x10>
    1ed0:	10 92 61 13 	sts	0x1361, r1	; 0x801361 <RNDISMessageBuffer+0x11>
    1ed4:	10 92 62 13 	sts	0x1362, r1	; 0x801362 <RNDISMessageBuffer+0x12>
    1ed8:	10 92 63 13 	sts	0x1363, r1	; 0x801363 <RNDISMessageBuffer+0x13>
				QUERY_Response->InformationBufferOffset = 0;
    1edc:	10 92 64 13 	sts	0x1364, r1	; 0x801364 <RNDISMessageBuffer+0x14>
    1ee0:	10 92 65 13 	sts	0x1365, r1	; 0x801365 <RNDISMessageBuffer+0x15>
    1ee4:	10 92 66 13 	sts	0x1366, r1	; 0x801366 <RNDISMessageBuffer+0x16>
    1ee8:	10 92 67 13 	sts	0x1367, r1	; 0x801367 <RNDISMessageBuffer+0x17>
    1eec:	08 95       	ret

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
    1eee:	10 92 5c 13 	sts	0x135C, r1	; 0x80135c <RNDISMessageBuffer+0xc>
    1ef2:	10 92 5d 13 	sts	0x135D, r1	; 0x80135d <RNDISMessageBuffer+0xd>
    1ef6:	10 92 5e 13 	sts	0x135E, r1	; 0x80135e <RNDISMessageBuffer+0xe>
    1efa:	10 92 5f 13 	sts	0x135F, r1	; 0x80135f <RNDISMessageBuffer+0xf>
    1efe:	08 95       	ret

00001f00 <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    1f00:	98 2f       	mov	r25, r24
    1f02:	97 30       	cpi	r25, 0x07	; 7
    1f04:	68 f5       	brcc	.+90     	; 0x1f60 <Endpoint_ConfigureEndpoint_Prv+0x60>
    1f06:	90 93 e9 00 	sts	0x00E9, r25	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1f0a:	98 17       	cp	r25, r24
    1f0c:	39 f0       	breq	.+14     	; 0x1f1c <Endpoint_ConfigureEndpoint_Prv+0x1c>
    1f0e:	70 91 ec 00 	lds	r23, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    1f12:	20 91 ed 00 	lds	r18, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    1f16:	50 91 f0 00 	lds	r21, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1f1a:	03 c0       	rjmp	.+6      	; 0x1f22 <Endpoint_ConfigureEndpoint_Prv+0x22>
    1f1c:	24 2f       	mov	r18, r20
    1f1e:	76 2f       	mov	r23, r22
    1f20:	50 e0       	ldi	r21, 0x00	; 0
    1f22:	21 fd       	sbrc	r18, 1
    1f24:	02 c0       	rjmp	.+4      	; 0x1f2a <Endpoint_ConfigureEndpoint_Prv+0x2a>
    1f26:	9f 5f       	subi	r25, 0xFF	; 255
    1f28:	ec cf       	rjmp	.-40     	; 0x1f02 <Endpoint_ConfigureEndpoint_Prv+0x2>
    1f2a:	30 91 eb 00 	lds	r19, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    1f2e:	3e 7f       	andi	r19, 0xFE	; 254
    1f30:	30 93 eb 00 	sts	0x00EB, r19	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    1f34:	30 91 ed 00 	lds	r19, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    1f38:	3d 7f       	andi	r19, 0xFD	; 253
    1f3a:	30 93 ed 00 	sts	0x00ED, r19	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    1f3e:	30 91 eb 00 	lds	r19, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    1f42:	31 60       	ori	r19, 0x01	; 1
    1f44:	30 93 eb 00 	sts	0x00EB, r19	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    1f48:	70 93 ec 00 	sts	0x00EC, r23	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    1f4c:	20 93 ed 00 	sts	0x00ED, r18	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    1f50:	50 93 f0 00 	sts	0x00F0, r21	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1f54:	20 91 ee 00 	lds	r18, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
    1f58:	27 fd       	sbrc	r18, 7
    1f5a:	e5 cf       	rjmp	.-54     	; 0x1f26 <Endpoint_ConfigureEndpoint_Prv+0x26>
    1f5c:	80 e0       	ldi	r24, 0x00	; 0
    1f5e:	08 95       	ret
    1f60:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1f64:	81 e0       	ldi	r24, 0x01	; 1
    1f66:	08 95       	ret

00001f68 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1f68:	80 91 d9 13 	lds	r24, 0x13D9	; 0x8013d9 <USB_ControlRequest>
    1f6c:	87 ff       	sbrs	r24, 7
    1f6e:	11 c0       	rjmp	.+34     	; 0x1f92 <Endpoint_ClearStatusStage+0x2a>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1f70:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		while (!(Endpoint_IsOUTReceived()))
    1f74:	82 fd       	sbrc	r24, 2
    1f76:	05 c0       	rjmp	.+10     	; 0x1f82 <Endpoint_ClearStatusStage+0x1a>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1f78:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>
    1f7c:	81 11       	cpse	r24, r1
    1f7e:	f8 cf       	rjmp	.-16     	; 0x1f70 <Endpoint_ClearStatusStage+0x8>
    1f80:	11 c0       	rjmp	.+34     	; 0x1fa4 <Endpoint_ClearStatusStage+0x3c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1f82:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1f86:	8b 77       	andi	r24, 0x7B	; 123
    1f88:	0b c0       	rjmp	.+22     	; 0x1fa0 <Endpoint_ClearStatusStage+0x38>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1f8a:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>
    1f8e:	88 23       	and	r24, r24
    1f90:	49 f0       	breq	.+18     	; 0x1fa4 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1f92:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1f96:	80 ff       	sbrs	r24, 0
    1f98:	f8 cf       	rjmp	.-16     	; 0x1f8a <Endpoint_ClearStatusStage+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1f9a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1f9e:	8e 77       	andi	r24, 0x7E	; 126
    1fa0:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1fa4:	08 95       	ret

00001fa6 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1fa6:	20 91 e4 00 	lds	r18, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    1faa:	30 91 e5 00 	lds	r19, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
    1fae:	95 e6       	ldi	r25, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    1fb0:	40 91 ec 00 	lds	r20, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    1fb4:	84 2f       	mov	r24, r20
    1fb6:	81 70       	andi	r24, 0x01	; 1
    1fb8:	40 ff       	sbrs	r20, 0
    1fba:	23 c0       	rjmp	.+70     	; 0x2002 <__DATA_REGION_LENGTH__+0x2>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1fbc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    1fc0:	80 fd       	sbrc	r24, 0
    1fc2:	1d c0       	rjmp	.+58     	; 0x1ffe <Endpoint_WaitUntilReady+0x58>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1fc4:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1fc8:	88 23       	and	r24, r24
    1fca:	99 f0       	breq	.+38     	; 0x1ff2 <Endpoint_WaitUntilReady+0x4c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1fcc:	85 30       	cpi	r24, 0x05	; 5
    1fce:	99 f0       	breq	.+38     	; 0x1ff6 <Endpoint_WaitUntilReady+0x50>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1fd0:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1fd4:	85 fd       	sbrc	r24, 5
    1fd6:	11 c0       	rjmp	.+34     	; 0x1ffa <Endpoint_WaitUntilReady+0x54>
    1fd8:	40 91 e4 00 	lds	r20, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    1fdc:	50 91 e5 00 	lds	r21, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1fe0:	24 17       	cp	r18, r20
    1fe2:	35 07       	cpc	r19, r21
    1fe4:	29 f3       	breq	.-54     	; 0x1fb0 <Endpoint_WaitUntilReady+0xa>
    1fe6:	91 50       	subi	r25, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1fe8:	11 f0       	breq	.+4      	; 0x1fee <Endpoint_WaitUntilReady+0x48>
    1fea:	9a 01       	movw	r18, r20
    1fec:	e1 cf       	rjmp	.-62     	; 0x1fb0 <Endpoint_WaitUntilReady+0xa>
			  return ENDPOINT_READYWAIT_Timeout;
    1fee:	84 e0       	ldi	r24, 0x04	; 4
    1ff0:	08 95       	ret
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    1ff2:	82 e0       	ldi	r24, 0x02	; 2
    1ff4:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1ff6:	83 e0       	ldi	r24, 0x03	; 3
    1ff8:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1ffa:	81 e0       	ldi	r24, 0x01	; 1
    1ffc:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    1ffe:	80 e0       	ldi	r24, 0x00	; 0
    2000:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2002:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    2006:	42 ff       	sbrs	r20, 2
    2008:	dd cf       	rjmp	.-70     	; 0x1fc4 <Endpoint_WaitUntilReady+0x1e>

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    200a:	08 95       	ret

0000200c <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    200c:	0f 93       	push	r16
    200e:	1f 93       	push	r17
    2010:	cf 93       	push	r28
    2012:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    2014:	49 d0       	rcall	.+146    	; 0x20a8 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    2016:	50 d0       	rcall	.+160    	; 0x20b8 <USB_INT_ClearAllInterrupts>
    2018:	c8 ed       	ldi	r28, 0xD8	; 216
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    201a:	d0 e0       	ldi	r29, 0x00	; 0
    201c:	88 81       	ld	r24, Y
    201e:	8f 77       	andi	r24, 0x7F	; 127
    2020:	88 83       	st	Y, r24
    2022:	88 81       	ld	r24, Y
				USBCON |=  (1 << USBE);
    2024:	80 68       	ori	r24, 0x80	; 128
    2026:	88 83       	st	Y, r24
    2028:	88 81       	ld	r24, Y
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    202a:	8f 7d       	andi	r24, 0xDF	; 223
    202c:	88 83       	st	Y, r24
    202e:	e7 ed       	ldi	r30, 0xD7	; 215

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    2030:	f0 e0       	ldi	r31, 0x00	; 0
    2032:	80 81       	ld	r24, Z
    2034:	80 68       	ori	r24, 0x80	; 128
    2036:	80 83       	st	Z, r24
    2038:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    203a:	10 92 d8 13 	sts	0x13D8, r1	; 0x8013d8 <USB_DeviceState>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    203e:	10 92 d4 13 	sts	0x13D4, r1	; 0x8013d4 <USB_Device_ConfigurationNumber>
	USB_Device_ConfigurationNumber  = 0;
    2042:	10 92 d6 13 	sts	0x13D6, r1	; 0x8013d6 <USB_Device_RemoteWakeupEnabled>

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    2046:	10 92 d5 13 	sts	0x13D5, r1	; 0x8013d5 <USB_Device_CurrentlySelfPowered>
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    204a:	00 ee       	ldi	r16, 0xE0	; 224
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    204c:	10 e0       	ldi	r17, 0x00	; 0
    204e:	f8 01       	movw	r30, r16
    2050:	80 81       	ld	r24, Z
    2052:	8b 7f       	andi	r24, 0xFB	; 251
    2054:	80 83       	st	Z, r24
    2056:	88 81       	ld	r24, Y
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    2058:	81 60       	ori	r24, 0x01	; 1
    205a:	88 83       	st	Y, r24
    205c:	42 e0       	ldi	r20, 0x02	; 2
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    205e:	60 e0       	ldi	r22, 0x00	; 0
    2060:	80 e0       	ldi	r24, 0x00	; 0
    2062:	4e df       	rcall	.-356    	; 0x1f00 <Endpoint_ConfigureEndpoint_Prv>
    2064:	e1 ee       	ldi	r30, 0xE1	; 225
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    2066:	f0 e0       	ldi	r31, 0x00	; 0
    2068:	80 81       	ld	r24, Z
    206a:	8e 7f       	andi	r24, 0xFE	; 254
    206c:	80 83       	st	Z, r24
    206e:	e2 ee       	ldi	r30, 0xE2	; 226
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    2070:	f0 e0       	ldi	r31, 0x00	; 0
    2072:	80 81       	ld	r24, Z
    2074:	81 60       	ori	r24, 0x01	; 1
    2076:	80 83       	st	Z, r24
    2078:	80 81       	ld	r24, Z
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    207a:	88 60       	ori	r24, 0x08	; 8
    207c:	80 83       	st	Z, r24
    207e:	f8 01       	movw	r30, r16
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    2080:	80 81       	ld	r24, Z
    2082:	8e 7f       	andi	r24, 0xFE	; 254
    2084:	80 83       	st	Z, r24
    2086:	88 81       	ld	r24, Y

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    2088:	80 61       	ori	r24, 0x10	; 16
    208a:	88 83       	st	Y, r24
    208c:	df 91       	pop	r29
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    208e:	cf 91       	pop	r28
    2090:	1f 91       	pop	r17
    2092:	0f 91       	pop	r16
    2094:	08 95       	ret

00002096 <USB_Init>:
    2096:	e7 ed       	ldi	r30, 0xD7	; 215

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    2098:	f0 e0       	ldi	r31, 0x00	; 0
    209a:	80 81       	ld	r24, Z
    209c:	81 60       	ori	r24, 0x01	; 1
    209e:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    20a0:	81 e0       	ldi	r24, 0x01	; 1
    20a2:	80 93 d7 13 	sts	0x13D7, r24	; 0x8013d7 <USB_IsInitialized>

	USB_ResetInterface();
    20a6:	b2 cf       	rjmp	.-156    	; 0x200c <USB_ResetInterface>

000020a8 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    20a8:	e8 ed       	ldi	r30, 0xD8	; 216
    20aa:	f0 e0       	ldi	r31, 0x00	; 0
    20ac:	80 81       	ld	r24, Z
    20ae:	8c 7f       	andi	r24, 0xFC	; 252
    20b0:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    20b2:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    20b6:	08 95       	ret

000020b8 <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    20b8:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    20bc:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    20c0:	08 95       	ret

000020c2 <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    20c2:	1f 92       	push	r1
    20c4:	0f 92       	push	r0
    20c6:	0f b6       	in	r0, 0x3f	; 63
    20c8:	0f 92       	push	r0
    20ca:	11 24       	eor	r1, r1
    20cc:	0b b6       	in	r0, 0x3b	; 59
    20ce:	0f 92       	push	r0
    20d0:	2f 93       	push	r18
    20d2:	3f 93       	push	r19
    20d4:	4f 93       	push	r20
    20d6:	5f 93       	push	r21
    20d8:	6f 93       	push	r22
    20da:	7f 93       	push	r23
    20dc:	8f 93       	push	r24
    20de:	9f 93       	push	r25
    20e0:	af 93       	push	r26
    20e2:	bf 93       	push	r27
    20e4:	ef 93       	push	r30
    20e6:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    20e8:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    20ec:	82 ff       	sbrs	r24, 2
    20ee:	0a c0       	rjmp	.+20     	; 0x2104 <__stack+0x5>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    20f0:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    20f4:	82 ff       	sbrs	r24, 2
    20f6:	06 c0       	rjmp	.+12     	; 0x2104 <__stack+0x5>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    20f8:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    20fc:	8b 7f       	andi	r24, 0xFB	; 251
    20fe:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    2102:	7f d3       	rcall	.+1790   	; 0x2802 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    2104:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    2108:	80 ff       	sbrs	r24, 0
    210a:	1f c0       	rjmp	.+62     	; 0x214a <__stack+0x4b>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    210c:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    2110:	80 ff       	sbrs	r24, 0
    2112:	1b c0       	rjmp	.+54     	; 0x214a <__stack+0x4b>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    2114:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
    2118:	8e 7f       	andi	r24, 0xFE	; 254
    211a:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    211e:	80 91 d9 00 	lds	r24, 0x00D9	; 0x8000d9 <__TEXT_REGION_LENGTH__+0x7e00d9>
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    2122:	80 ff       	sbrs	r24, 0
    2124:	0d c0       	rjmp	.+26     	; 0x2140 <__stack+0x41>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2126:	8c e0       	ldi	r24, 0x0C	; 12
    2128:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    212a:	8e e0       	ldi	r24, 0x0E	; 14
    212c:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    212e:	09 b4       	in	r0, 0x29	; 41
    2130:	00 fe       	sbrs	r0, 0
    2132:	fd cf       	rjmp	.-6      	; 0x212e <__stack+0x2f>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    2134:	81 e0       	ldi	r24, 0x01	; 1
    2136:	80 93 d8 13 	sts	0x13D8, r24	; 0x8013d8 <USB_DeviceState>
			EVENT_USB_Device_Connect();
    213a:	0e 94 9e 02 	call	0x53c	; 0x53c <EVENT_USB_Device_Connect>
    213e:	05 c0       	rjmp	.+10     	; 0x214a <__stack+0x4b>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2140:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    2142:	10 92 d8 13 	sts	0x13D8, r1	; 0x8013d8 <USB_DeviceState>
			EVENT_USB_Device_Disconnect();
    2146:	0e 94 a0 02 	call	0x540	; 0x540 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    214a:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    214e:	80 ff       	sbrs	r24, 0
    2150:	18 c0       	rjmp	.+48     	; 0x2182 <__stack+0x83>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    2152:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    2156:	80 ff       	sbrs	r24, 0
    2158:	14 c0       	rjmp	.+40     	; 0x2182 <__stack+0x83>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    215a:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    215e:	8e 7f       	andi	r24, 0xFE	; 254
    2160:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    2164:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    2168:	80 61       	ori	r24, 0x10	; 16
    216a:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    216e:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    2172:	80 62       	ori	r24, 0x20	; 32
    2174:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2178:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    217a:	85 e0       	ldi	r24, 0x05	; 5
    217c:	80 93 d8 13 	sts	0x13D8, r24	; 0x8013d8 <USB_DeviceState>
		EVENT_USB_Device_Suspend();
    2180:	40 d3       	rcall	.+1664   	; 0x2802 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    2182:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    2186:	84 ff       	sbrs	r24, 4
    2188:	2d c0       	rjmp	.+90     	; 0x21e4 <__stack+0xe5>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    218a:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    218e:	84 ff       	sbrs	r24, 4
    2190:	29 c0       	rjmp	.+82     	; 0x21e4 <__stack+0xe5>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2192:	8c e0       	ldi	r24, 0x0C	; 12
    2194:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    2196:	8e e0       	ldi	r24, 0x0E	; 14
    2198:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    219a:	09 b4       	in	r0, 0x29	; 41
    219c:	00 fe       	sbrs	r0, 0
    219e:	fd cf       	rjmp	.-6      	; 0x219a <__stack+0x9b>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    21a0:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    21a4:	8f 7d       	andi	r24, 0xDF	; 223
    21a6:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    21aa:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    21ae:	8f 7e       	andi	r24, 0xEF	; 239
    21b0:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    21b4:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    21b8:	8f 7e       	andi	r24, 0xEF	; 239
    21ba:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    21be:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    21c2:	81 60       	ori	r24, 0x01	; 1
    21c4:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    21c8:	80 91 d4 13 	lds	r24, 0x13D4	; 0x8013d4 <USB_Device_ConfigurationNumber>
    21cc:	81 11       	cpse	r24, r1
    21ce:	06 c0       	rjmp	.+12     	; 0x21dc <__stack+0xdd>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    21d0:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    21d4:	87 fd       	sbrc	r24, 7
    21d6:	02 c0       	rjmp	.+4      	; 0x21dc <__stack+0xdd>
    21d8:	81 e0       	ldi	r24, 0x01	; 1
    21da:	01 c0       	rjmp	.+2      	; 0x21de <__stack+0xdf>
    21dc:	84 e0       	ldi	r24, 0x04	; 4
    21de:	80 93 d8 13 	sts	0x13D8, r24	; 0x8013d8 <USB_DeviceState>

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    21e2:	0f d3       	rcall	.+1566   	; 0x2802 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    21e4:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    21e8:	83 ff       	sbrs	r24, 3
    21ea:	22 c0       	rjmp	.+68     	; 0x2230 <__stack+0x131>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    21ec:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    21f0:	83 ff       	sbrs	r24, 3
    21f2:	1e c0       	rjmp	.+60     	; 0x2230 <__stack+0x131>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    21f4:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    21f8:	87 7f       	andi	r24, 0xF7	; 247
    21fa:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    21fe:	82 e0       	ldi	r24, 0x02	; 2
    2200:	80 93 d8 13 	sts	0x13D8, r24	; 0x8013d8 <USB_DeviceState>
		USB_Device_ConfigurationNumber = 0;
    2204:	10 92 d4 13 	sts	0x13D4, r1	; 0x8013d4 <USB_Device_ConfigurationNumber>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    2208:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    220c:	8e 7f       	andi	r24, 0xFE	; 254
    220e:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    2212:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    2216:	8e 7f       	andi	r24, 0xFE	; 254
    2218:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    221c:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    2220:	80 61       	ori	r24, 0x10	; 16
    2222:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    2226:	42 e0       	ldi	r20, 0x02	; 2
    2228:	60 e0       	ldi	r22, 0x00	; 0
    222a:	80 e0       	ldi	r24, 0x00	; 0

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    222c:	69 de       	rcall	.-814    	; 0x1f00 <Endpoint_ConfigureEndpoint_Prv>
    222e:	e9 d2       	rcall	.+1490   	; 0x2802 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    2230:	ff 91       	pop	r31
    2232:	ef 91       	pop	r30
    2234:	bf 91       	pop	r27
    2236:	af 91       	pop	r26
    2238:	9f 91       	pop	r25
    223a:	8f 91       	pop	r24
    223c:	7f 91       	pop	r23
    223e:	6f 91       	pop	r22
    2240:	5f 91       	pop	r21
    2242:	4f 91       	pop	r20
    2244:	3f 91       	pop	r19
    2246:	2f 91       	pop	r18
    2248:	0f 90       	pop	r0
    224a:	0b be       	out	0x3b, r0	; 59
    224c:	0f 90       	pop	r0
    224e:	0f be       	out	0x3f, r0	; 63
    2250:	0f 90       	pop	r0
    2252:	1f 90       	pop	r1
    2254:	18 95       	reti

00002256 <Endpoint_Write_Stream_LE>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2256:	cf 92       	push	r12
    2258:	df 92       	push	r13
    225a:	ef 92       	push	r14
    225c:	ff 92       	push	r15
    225e:	0f 93       	push	r16
    2260:	1f 93       	push	r17
    2262:	cf 93       	push	r28
    2264:	df 93       	push	r29
    2266:	ec 01       	movw	r28, r24
    2268:	8b 01       	movw	r16, r22
    226a:	7a 01       	movw	r14, r20
    226c:	9c de       	rcall	.-712    	; 0x1fa6 <Endpoint_WaitUntilReady>
    226e:	81 11       	cpse	r24, r1
    2270:	33 c0       	rjmp	.+102    	; 0x22d8 <Endpoint_Write_Stream_LE+0x82>
    2272:	e1 14       	cp	r14, r1
    2274:	f1 04       	cpc	r15, r1
    2276:	39 f0       	breq	.+14     	; 0x2286 <Endpoint_Write_Stream_LE+0x30>
    2278:	f7 01       	movw	r30, r14
    227a:	80 81       	ld	r24, Z
    227c:	91 81       	ldd	r25, Z+1	; 0x01
    227e:	08 1b       	sub	r16, r24
    2280:	19 0b       	sbc	r17, r25
    2282:	c8 0f       	add	r28, r24
    2284:	d9 1f       	adc	r29, r25
    2286:	c1 2c       	mov	r12, r1
    2288:	d1 2c       	mov	r13, r1
    228a:	01 15       	cp	r16, r1
    228c:	11 05       	cpc	r17, r1
    228e:	19 f1       	breq	.+70     	; 0x22d6 <Endpoint_Write_Stream_LE+0x80>
    2290:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2294:	85 fd       	sbrc	r24, 5
    2296:	16 c0       	rjmp	.+44     	; 0x22c4 <Endpoint_Write_Stream_LE+0x6e>
    2298:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    229c:	8e 77       	andi	r24, 0x7E	; 126
    229e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    22a2:	b0 d2       	rcall	.+1376   	; 0x2804 <USB_USBTask>
    22a4:	e1 14       	cp	r14, r1
    22a6:	f1 04       	cpc	r15, r1
    22a8:	49 f0       	breq	.+18     	; 0x22bc <Endpoint_Write_Stream_LE+0x66>
    22aa:	f7 01       	movw	r30, r14
    22ac:	80 81       	ld	r24, Z
    22ae:	91 81       	ldd	r25, Z+1	; 0x01
    22b0:	c8 0e       	add	r12, r24
    22b2:	d9 1e       	adc	r13, r25
    22b4:	d1 82       	std	Z+1, r13	; 0x01
    22b6:	c0 82       	st	Z, r12
    22b8:	85 e0       	ldi	r24, 0x05	; 5
    22ba:	0e c0       	rjmp	.+28     	; 0x22d8 <Endpoint_Write_Stream_LE+0x82>
    22bc:	74 de       	rcall	.-792    	; 0x1fa6 <Endpoint_WaitUntilReady>
    22be:	88 23       	and	r24, r24
    22c0:	21 f3       	breq	.-56     	; 0x228a <Endpoint_Write_Stream_LE+0x34>
    22c2:	0a c0       	rjmp	.+20     	; 0x22d8 <Endpoint_Write_Stream_LE+0x82>
    22c4:	89 91       	ld	r24, Y+
    22c6:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    22ca:	01 50       	subi	r16, 0x01	; 1
    22cc:	11 09       	sbc	r17, r1
    22ce:	ff ef       	ldi	r31, 0xFF	; 255
    22d0:	cf 1a       	sub	r12, r31
    22d2:	df 0a       	sbc	r13, r31
    22d4:	da cf       	rjmp	.-76     	; 0x228a <Endpoint_Write_Stream_LE+0x34>
    22d6:	80 e0       	ldi	r24, 0x00	; 0
    22d8:	df 91       	pop	r29
    22da:	cf 91       	pop	r28
    22dc:	1f 91       	pop	r17
    22de:	0f 91       	pop	r16
    22e0:	ff 90       	pop	r15
    22e2:	ef 90       	pop	r14
    22e4:	df 90       	pop	r13
    22e6:	cf 90       	pop	r12
    22e8:	08 95       	ret

000022ea <Endpoint_Read_Stream_LE>:
    22ea:	cf 92       	push	r12
    22ec:	df 92       	push	r13
    22ee:	ef 92       	push	r14
    22f0:	ff 92       	push	r15
    22f2:	0f 93       	push	r16
    22f4:	1f 93       	push	r17
    22f6:	cf 93       	push	r28
    22f8:	df 93       	push	r29
    22fa:	ec 01       	movw	r28, r24
    22fc:	8b 01       	movw	r16, r22
    22fe:	7a 01       	movw	r14, r20
    2300:	52 de       	rcall	.-860    	; 0x1fa6 <Endpoint_WaitUntilReady>
    2302:	81 11       	cpse	r24, r1
    2304:	33 c0       	rjmp	.+102    	; 0x236c <Endpoint_Read_Stream_LE+0x82>
    2306:	e1 14       	cp	r14, r1
    2308:	f1 04       	cpc	r15, r1
    230a:	39 f0       	breq	.+14     	; 0x231a <Endpoint_Read_Stream_LE+0x30>
    230c:	f7 01       	movw	r30, r14
    230e:	80 81       	ld	r24, Z
    2310:	91 81       	ldd	r25, Z+1	; 0x01
    2312:	08 1b       	sub	r16, r24
    2314:	19 0b       	sbc	r17, r25
    2316:	c8 0f       	add	r28, r24
    2318:	d9 1f       	adc	r29, r25
    231a:	c1 2c       	mov	r12, r1
    231c:	d1 2c       	mov	r13, r1
    231e:	01 15       	cp	r16, r1
    2320:	11 05       	cpc	r17, r1
    2322:	19 f1       	breq	.+70     	; 0x236a <Endpoint_Read_Stream_LE+0x80>
    2324:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2328:	85 fd       	sbrc	r24, 5
    232a:	16 c0       	rjmp	.+44     	; 0x2358 <Endpoint_Read_Stream_LE+0x6e>
    232c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2330:	8b 77       	andi	r24, 0x7B	; 123
    2332:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2336:	66 d2       	rcall	.+1228   	; 0x2804 <USB_USBTask>
    2338:	e1 14       	cp	r14, r1
    233a:	f1 04       	cpc	r15, r1
    233c:	49 f0       	breq	.+18     	; 0x2350 <Endpoint_Read_Stream_LE+0x66>
    233e:	f7 01       	movw	r30, r14
    2340:	80 81       	ld	r24, Z
    2342:	91 81       	ldd	r25, Z+1	; 0x01
    2344:	c8 0e       	add	r12, r24
    2346:	d9 1e       	adc	r13, r25
    2348:	d1 82       	std	Z+1, r13	; 0x01
    234a:	c0 82       	st	Z, r12
    234c:	85 e0       	ldi	r24, 0x05	; 5
    234e:	0e c0       	rjmp	.+28     	; 0x236c <Endpoint_Read_Stream_LE+0x82>
    2350:	2a de       	rcall	.-940    	; 0x1fa6 <Endpoint_WaitUntilReady>
    2352:	88 23       	and	r24, r24
    2354:	21 f3       	breq	.-56     	; 0x231e <Endpoint_Read_Stream_LE+0x34>
    2356:	0a c0       	rjmp	.+20     	; 0x236c <Endpoint_Read_Stream_LE+0x82>
    2358:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    235c:	89 93       	st	Y+, r24
    235e:	01 50       	subi	r16, 0x01	; 1
    2360:	11 09       	sbc	r17, r1
    2362:	ff ef       	ldi	r31, 0xFF	; 255
    2364:	cf 1a       	sub	r12, r31
    2366:	df 0a       	sbc	r13, r31
    2368:	da cf       	rjmp	.-76     	; 0x231e <Endpoint_Read_Stream_LE+0x34>
    236a:	80 e0       	ldi	r24, 0x00	; 0
    236c:	df 91       	pop	r29
    236e:	cf 91       	pop	r28
    2370:	1f 91       	pop	r17
    2372:	0f 91       	pop	r16
    2374:	ff 90       	pop	r15
    2376:	ef 90       	pop	r14
    2378:	df 90       	pop	r13
    237a:	cf 90       	pop	r12
    237c:	08 95       	ret

0000237e <Endpoint_Write_Control_Stream_LE>:
    237e:	20 91 df 13 	lds	r18, 0x13DF	; 0x8013df <USB_ControlRequest+0x6>
    2382:	30 91 e0 13 	lds	r19, 0x13E0	; 0x8013e0 <USB_ControlRequest+0x7>
    2386:	26 17       	cp	r18, r22
    2388:	37 07       	cpc	r19, r23
    238a:	48 f0       	brcs	.+18     	; 0x239e <Endpoint_Write_Control_Stream_LE+0x20>
    238c:	61 15       	cp	r22, r1
    238e:	71 05       	cpc	r23, r1
    2390:	39 f4       	brne	.+14     	; 0x23a0 <Endpoint_Write_Control_Stream_LE+0x22>
    2392:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2396:	2e 77       	andi	r18, 0x7E	; 126
    2398:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    239c:	01 c0       	rjmp	.+2      	; 0x23a0 <Endpoint_Write_Control_Stream_LE+0x22>
    239e:	b9 01       	movw	r22, r18
    23a0:	fc 01       	movw	r30, r24
    23a2:	20 e0       	ldi	r18, 0x00	; 0
    23a4:	61 15       	cp	r22, r1
    23a6:	71 05       	cpc	r23, r1
    23a8:	69 f1       	breq	.+90     	; 0x2404 <Endpoint_Write_Control_Stream_LE+0x86>
    23aa:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>
    23ae:	88 23       	and	r24, r24
    23b0:	d1 f1       	breq	.+116    	; 0x2426 <Endpoint_Write_Control_Stream_LE+0xa8>
    23b2:	85 30       	cpi	r24, 0x05	; 5
    23b4:	d1 f1       	breq	.+116    	; 0x242a <Endpoint_Write_Control_Stream_LE+0xac>
    23b6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    23ba:	83 fd       	sbrc	r24, 3
    23bc:	32 c0       	rjmp	.+100    	; 0x2422 <Endpoint_Write_Control_Stream_LE+0xa4>
    23be:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    23c2:	82 fd       	sbrc	r24, 2
    23c4:	28 c0       	rjmp	.+80     	; 0x2416 <Endpoint_Write_Control_Stream_LE+0x98>
    23c6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    23ca:	80 ff       	sbrs	r24, 0
    23cc:	eb cf       	rjmp	.-42     	; 0x23a4 <Endpoint_Write_Control_Stream_LE+0x26>
    23ce:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    23d2:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    23d6:	61 15       	cp	r22, r1
    23d8:	71 05       	cpc	r23, r1
    23da:	51 f0       	breq	.+20     	; 0x23f0 <Endpoint_Write_Control_Stream_LE+0x72>
    23dc:	88 30       	cpi	r24, 0x08	; 8
    23de:	91 05       	cpc	r25, r1
    23e0:	38 f4       	brcc	.+14     	; 0x23f0 <Endpoint_Write_Control_Stream_LE+0x72>
    23e2:	21 91       	ld	r18, Z+
    23e4:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    23e8:	61 50       	subi	r22, 0x01	; 1
    23ea:	71 09       	sbc	r23, r1
    23ec:	01 96       	adiw	r24, 0x01	; 1
    23ee:	f3 cf       	rjmp	.-26     	; 0x23d6 <Endpoint_Write_Control_Stream_LE+0x58>
    23f0:	21 e0       	ldi	r18, 0x01	; 1
    23f2:	08 97       	sbiw	r24, 0x08	; 8
    23f4:	09 f0       	breq	.+2      	; 0x23f8 <Endpoint_Write_Control_Stream_LE+0x7a>
    23f6:	20 e0       	ldi	r18, 0x00	; 0
    23f8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    23fc:	8e 77       	andi	r24, 0x7E	; 126
    23fe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2402:	d0 cf       	rjmp	.-96     	; 0x23a4 <Endpoint_Write_Control_Stream_LE+0x26>
    2404:	21 11       	cpse	r18, r1
    2406:	d1 cf       	rjmp	.-94     	; 0x23aa <Endpoint_Write_Control_Stream_LE+0x2c>
    2408:	06 c0       	rjmp	.+12     	; 0x2416 <Endpoint_Write_Control_Stream_LE+0x98>
    240a:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>
    240e:	88 23       	and	r24, r24
    2410:	51 f0       	breq	.+20     	; 0x2426 <Endpoint_Write_Control_Stream_LE+0xa8>
    2412:	85 30       	cpi	r24, 0x05	; 5
    2414:	51 f0       	breq	.+20     	; 0x242a <Endpoint_Write_Control_Stream_LE+0xac>
    2416:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    241a:	82 ff       	sbrs	r24, 2
    241c:	f6 cf       	rjmp	.-20     	; 0x240a <Endpoint_Write_Control_Stream_LE+0x8c>
    241e:	80 e0       	ldi	r24, 0x00	; 0
    2420:	08 95       	ret
    2422:	81 e0       	ldi	r24, 0x01	; 1
    2424:	08 95       	ret
    2426:	82 e0       	ldi	r24, 0x02	; 2
    2428:	08 95       	ret
    242a:	83 e0       	ldi	r24, 0x03	; 3
    242c:	08 95       	ret

0000242e <Endpoint_Read_Control_Stream_LE>:
    242e:	61 15       	cp	r22, r1
    2430:	71 05       	cpc	r23, r1
    2432:	29 f4       	brne	.+10     	; 0x243e <Endpoint_Read_Control_Stream_LE+0x10>
    2434:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2438:	2b 77       	andi	r18, 0x7B	; 123
    243a:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    243e:	fc 01       	movw	r30, r24
    2440:	61 15       	cp	r22, r1
    2442:	71 05       	cpc	r23, r1
    2444:	31 f1       	breq	.+76     	; 0x2492 <Endpoint_Read_Control_Stream_LE+0x64>
    2446:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>
    244a:	88 23       	and	r24, r24
    244c:	51 f1       	breq	.+84     	; 0x24a2 <Endpoint_Read_Control_Stream_LE+0x74>
    244e:	85 30       	cpi	r24, 0x05	; 5
    2450:	51 f1       	breq	.+84     	; 0x24a6 <Endpoint_Read_Control_Stream_LE+0x78>
    2452:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2456:	83 fd       	sbrc	r24, 3
    2458:	22 c0       	rjmp	.+68     	; 0x249e <Endpoint_Read_Control_Stream_LE+0x70>
    245a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    245e:	82 ff       	sbrs	r24, 2
    2460:	ef cf       	rjmp	.-34     	; 0x2440 <Endpoint_Read_Control_Stream_LE+0x12>
    2462:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    2466:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    246a:	89 2b       	or	r24, r25
    246c:	31 f0       	breq	.+12     	; 0x247a <Endpoint_Read_Control_Stream_LE+0x4c>
    246e:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    2472:	81 93       	st	Z+, r24
    2474:	61 50       	subi	r22, 0x01	; 1
    2476:	71 09       	sbc	r23, r1
    2478:	a1 f7       	brne	.-24     	; 0x2462 <Endpoint_Read_Control_Stream_LE+0x34>
    247a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    247e:	8b 77       	andi	r24, 0x7B	; 123
    2480:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2484:	dd cf       	rjmp	.-70     	; 0x2440 <Endpoint_Read_Control_Stream_LE+0x12>
    2486:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>
    248a:	88 23       	and	r24, r24
    248c:	51 f0       	breq	.+20     	; 0x24a2 <Endpoint_Read_Control_Stream_LE+0x74>
    248e:	85 30       	cpi	r24, 0x05	; 5
    2490:	51 f0       	breq	.+20     	; 0x24a6 <Endpoint_Read_Control_Stream_LE+0x78>
    2492:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2496:	80 ff       	sbrs	r24, 0
    2498:	f6 cf       	rjmp	.-20     	; 0x2486 <Endpoint_Read_Control_Stream_LE+0x58>
    249a:	80 e0       	ldi	r24, 0x00	; 0
    249c:	08 95       	ret
    249e:	81 e0       	ldi	r24, 0x01	; 1
    24a0:	08 95       	ret
    24a2:	82 e0       	ldi	r24, 0x02	; 2
    24a4:	08 95       	ret
    24a6:	83 e0       	ldi	r24, 0x03	; 3
    24a8:	08 95       	ret

000024aa <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    24aa:	20 91 df 13 	lds	r18, 0x13DF	; 0x8013df <USB_ControlRequest+0x6>
    24ae:	30 91 e0 13 	lds	r19, 0x13E0	; 0x8013e0 <USB_ControlRequest+0x7>
    24b2:	26 17       	cp	r18, r22
    24b4:	37 07       	cpc	r19, r23
    24b6:	48 f0       	brcs	.+18     	; 0x24ca <Endpoint_Write_Control_PStream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    24b8:	61 15       	cp	r22, r1
    24ba:	71 05       	cpc	r23, r1
    24bc:	39 f4       	brne	.+14     	; 0x24cc <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    24be:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    24c2:	2e 77       	andi	r18, 0x7E	; 126
    24c4:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    24c8:	01 c0       	rjmp	.+2      	; 0x24cc <Endpoint_Write_Control_PStream_LE+0x22>
    24ca:	b9 01       	movw	r22, r18
    24cc:	fc 01       	movw	r30, r24
    24ce:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    24d0:	61 15       	cp	r22, r1
    24d2:	71 05       	cpc	r23, r1
    24d4:	71 f1       	breq	.+92     	; 0x2532 <Endpoint_Write_Control_PStream_LE+0x88>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    24d6:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    24da:	88 23       	and	r24, r24
    24dc:	d9 f1       	breq	.+118    	; 0x2554 <Endpoint_Write_Control_PStream_LE+0xaa>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    24de:	85 30       	cpi	r24, 0x05	; 5
    24e0:	d9 f1       	breq	.+118    	; 0x2558 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    24e2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    24e6:	83 fd       	sbrc	r24, 3
    24e8:	33 c0       	rjmp	.+102    	; 0x2550 <Endpoint_Write_Control_PStream_LE+0xa6>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    24ea:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    24ee:	82 fd       	sbrc	r24, 2
    24f0:	29 c0       	rjmp	.+82     	; 0x2544 <Endpoint_Write_Control_PStream_LE+0x9a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    24f2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  break;

		if (Endpoint_IsINReady())
    24f6:	80 ff       	sbrs	r24, 0
    24f8:	eb cf       	rjmp	.-42     	; 0x24d0 <Endpoint_Write_Control_PStream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    24fa:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    24fe:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    2502:	61 15       	cp	r22, r1
    2504:	71 05       	cpc	r23, r1
    2506:	59 f0       	breq	.+22     	; 0x251e <Endpoint_Write_Control_PStream_LE+0x74>
    2508:	88 30       	cpi	r24, 0x08	; 8
    250a:	91 05       	cpc	r25, r1
    250c:	40 f4       	brcc	.+16     	; 0x251e <Endpoint_Write_Control_PStream_LE+0x74>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    250e:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2510:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    2514:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    2516:	61 50       	subi	r22, 0x01	; 1
    2518:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    251a:	01 96       	adiw	r24, 0x01	; 1
    251c:	f2 cf       	rjmp	.-28     	; 0x2502 <Endpoint_Write_Control_PStream_LE+0x58>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    251e:	21 e0       	ldi	r18, 0x01	; 1
    2520:	08 97       	sbiw	r24, 0x08	; 8
    2522:	09 f0       	breq	.+2      	; 0x2526 <Endpoint_Write_Control_PStream_LE+0x7c>
    2524:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2526:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    252a:	8e 77       	andi	r24, 0x7E	; 126
    252c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2530:	cf cf       	rjmp	.-98     	; 0x24d0 <Endpoint_Write_Control_PStream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2532:	21 11       	cpse	r18, r1
    2534:	d0 cf       	rjmp	.-96     	; 0x24d6 <Endpoint_Write_Control_PStream_LE+0x2c>
    2536:	06 c0       	rjmp	.+12     	; 0x2544 <Endpoint_Write_Control_PStream_LE+0x9a>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2538:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    253c:	88 23       	and	r24, r24
    253e:	51 f0       	breq	.+20     	; 0x2554 <Endpoint_Write_Control_PStream_LE+0xaa>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2540:	85 30       	cpi	r24, 0x05	; 5
    2542:	51 f0       	breq	.+20     	; 0x2558 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2544:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2548:	82 ff       	sbrs	r24, 2
    254a:	f6 cf       	rjmp	.-20     	; 0x2538 <Endpoint_Write_Control_PStream_LE+0x8e>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    254c:	80 e0       	ldi	r24, 0x00	; 0
    254e:	08 95       	ret
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    2550:	81 e0       	ldi	r24, 0x01	; 1
    2552:	08 95       	ret
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    2554:	82 e0       	ldi	r24, 0x02	; 2
    2556:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    2558:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    255a:	08 95       	ret

0000255c <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    255c:	0f 93       	push	r16
    255e:	1f 93       	push	r17
    2560:	cf 93       	push	r28
    2562:	df 93       	push	r29
    2564:	cd b7       	in	r28, 0x3d	; 61
    2566:	de b7       	in	r29, 0x3e	; 62
    2568:	aa 97       	sbiw	r28, 0x2a	; 42
    256a:	0f b6       	in	r0, 0x3f	; 63
    256c:	f8 94       	cli
    256e:	de bf       	out	0x3e, r29	; 62
    2570:	0f be       	out	0x3f, r0	; 63
    2572:	cd bf       	out	0x3d, r28	; 61
    2574:	e9 ed       	ldi	r30, 0xD9	; 217
    2576:	f3 e1       	ldi	r31, 0x13	; 19
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2578:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    257c:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    257e:	23 e1       	ldi	r18, 0x13	; 19
    2580:	e1 3e       	cpi	r30, 0xE1	; 225
    2582:	f2 07       	cpc	r31, r18
    2584:	c9 f7       	brne	.-14     	; 0x2578 <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    2586:	0e 94 bf 02 	call	0x57e	; 0x57e <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    258a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsSETUPReceived())
    258e:	83 ff       	sbrs	r24, 3
    2590:	1f c1       	rjmp	.+574    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    2592:	80 91 d9 13 	lds	r24, 0x13D9	; 0x8013d9 <USB_ControlRequest>

		switch (USB_ControlRequest.bRequest)
    2596:	90 91 da 13 	lds	r25, 0x13DA	; 0x8013da <USB_ControlRequest+0x1>
    259a:	49 2f       	mov	r20, r25
    259c:	50 e0       	ldi	r21, 0x00	; 0
    259e:	4a 30       	cpi	r20, 0x0A	; 10
    25a0:	51 05       	cpc	r21, r1
    25a2:	08 f0       	brcs	.+2      	; 0x25a6 <USB_Device_ProcessControlRequest+0x4a>
    25a4:	15 c1       	rjmp	.+554    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
    25a6:	fa 01       	movw	r30, r20
    25a8:	ec 5a       	subi	r30, 0xAC	; 172
    25aa:	ff 4f       	sbci	r31, 0xFF	; 255
    25ac:	58 c1       	rjmp	.+688    	; 0x285e <__tablejump2__>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    25ae:	80 38       	cpi	r24, 0x80	; 128
    25b0:	81 f0       	breq	.+32     	; 0x25d2 <USB_Device_ProcessControlRequest+0x76>
    25b2:	82 38       	cpi	r24, 0x82	; 130
    25b4:	09 f0       	breq	.+2      	; 0x25b8 <USB_Device_ProcessControlRequest+0x5c>
    25b6:	0c c1       	rjmp	.+536    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    25b8:	80 91 dd 13 	lds	r24, 0x13DD	; 0x8013dd <USB_ControlRequest+0x4>
    25bc:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25be:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    25c2:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>

			CurrentStatus = Endpoint_IsStalled();
    25c6:	85 fb       	bst	r24, 5
    25c8:	88 27       	eor	r24, r24
    25ca:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25cc:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    25d0:	06 c0       	rjmp	.+12     	; 0x25de <USB_Device_ProcessControlRequest+0x82>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    25d2:	80 91 d5 13 	lds	r24, 0x13D5	; 0x8013d5 <USB_Device_CurrentlySelfPowered>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    25d6:	90 91 d6 13 	lds	r25, 0x13D6	; 0x8013d6 <USB_Device_RemoteWakeupEnabled>
    25da:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    25dc:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    25de:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    25e2:	97 7f       	andi	r25, 0xF7	; 247
    25e4:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    25e8:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
				UEDATX = (Data >> 8);
    25ec:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    25f0:	c6 c0       	rjmp	.+396    	; 0x277e <USB_Device_ProcessControlRequest+0x222>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    25f2:	28 2f       	mov	r18, r24
    25f4:	2d 7f       	andi	r18, 0xFD	; 253
    25f6:	09 f0       	breq	.+2      	; 0x25fa <USB_Device_ProcessControlRequest+0x9e>
    25f8:	eb c0       	rjmp	.+470    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    25fa:	88 23       	and	r24, r24
    25fc:	19 f0       	breq	.+6      	; 0x2604 <USB_Device_ProcessControlRequest+0xa8>
    25fe:	82 30       	cpi	r24, 0x02	; 2
    2600:	61 f0       	breq	.+24     	; 0x261a <USB_Device_ProcessControlRequest+0xbe>
    2602:	e6 c0       	rjmp	.+460    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    2604:	80 91 db 13 	lds	r24, 0x13DB	; 0x8013db <USB_ControlRequest+0x2>
    2608:	81 30       	cpi	r24, 0x01	; 1
    260a:	09 f0       	breq	.+2      	; 0x260e <USB_Device_ProcessControlRequest+0xb2>
    260c:	e1 c0       	rjmp	.+450    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    260e:	93 30       	cpi	r25, 0x03	; 3
    2610:	09 f0       	breq	.+2      	; 0x2614 <USB_Device_ProcessControlRequest+0xb8>
    2612:	80 e0       	ldi	r24, 0x00	; 0
    2614:	80 93 d6 13 	sts	0x13D6, r24	; 0x8013d6 <USB_Device_RemoteWakeupEnabled>
    2618:	2b c0       	rjmp	.+86     	; 0x2670 <USB_Device_ProcessControlRequest+0x114>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    261a:	80 91 db 13 	lds	r24, 0x13DB	; 0x8013db <USB_ControlRequest+0x2>
    261e:	81 11       	cpse	r24, r1
    2620:	27 c0       	rjmp	.+78     	; 0x2670 <USB_Device_ProcessControlRequest+0x114>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2622:	80 91 dd 13 	lds	r24, 0x13DD	; 0x8013dd <USB_ControlRequest+0x4>
    2626:	87 70       	andi	r24, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    2628:	09 f4       	brne	.+2      	; 0x262c <USB_Device_ProcessControlRequest+0xd0>
    262a:	d2 c0       	rjmp	.+420    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    262c:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    2630:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    2634:	20 ff       	sbrs	r18, 0
    2636:	1c c0       	rjmp	.+56     	; 0x2670 <USB_Device_ProcessControlRequest+0x114>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    2638:	93 30       	cpi	r25, 0x03	; 3
    263a:	21 f4       	brne	.+8      	; 0x2644 <USB_Device_ProcessControlRequest+0xe8>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    263c:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    2640:	80 62       	ori	r24, 0x20	; 32
    2642:	14 c0       	rjmp	.+40     	; 0x266c <USB_Device_ProcessControlRequest+0x110>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    2644:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    2648:	90 61       	ori	r25, 0x10	; 16
    264a:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    264e:	21 e0       	ldi	r18, 0x01	; 1
    2650:	30 e0       	ldi	r19, 0x00	; 0
    2652:	a9 01       	movw	r20, r18
    2654:	02 c0       	rjmp	.+4      	; 0x265a <USB_Device_ProcessControlRequest+0xfe>
    2656:	44 0f       	add	r20, r20
    2658:	55 1f       	adc	r21, r21
    265a:	8a 95       	dec	r24
    265c:	e2 f7       	brpl	.-8      	; 0x2656 <USB_Device_ProcessControlRequest+0xfa>
    265e:	40 93 ea 00 	sts	0x00EA, r20	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>
				UERST = 0;
    2662:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2666:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    266a:	88 60       	ori	r24, 0x08	; 8
    266c:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2670:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2674:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2678:	87 7f       	andi	r24, 0xF7	; 247
    267a:	84 c0       	rjmp	.+264    	; 0x2784 <USB_Device_ProcessControlRequest+0x228>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    267c:	81 11       	cpse	r24, r1
    267e:	a8 c0       	rjmp	.+336    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    2680:	10 91 db 13 	lds	r17, 0x13DB	; 0x8013db <USB_ControlRequest+0x2>
    2684:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2686:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2688:	f8 94       	cli
    268a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    268e:	87 7f       	andi	r24, 0xF7	; 247
    2690:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    2694:	69 dc       	rcall	.-1838   	; 0x1f68 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2696:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	while (!(Endpoint_IsINReady()));
    269a:	80 ff       	sbrs	r24, 0
    269c:	fc cf       	rjmp	.-8      	; 0x2696 <USB_Device_ProcessControlRequest+0x13a>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    269e:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
    26a2:	80 78       	andi	r24, 0x80	; 128
    26a4:	81 2b       	or	r24, r17

				UDADDR = Temp;
    26a6:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
				UDADDR = Temp | (1 << ADDEN);
    26aa:	80 68       	ori	r24, 0x80	; 128
    26ac:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    26b0:	11 11       	cpse	r17, r1
    26b2:	02 c0       	rjmp	.+4      	; 0x26b8 <USB_Device_ProcessControlRequest+0x15c>
    26b4:	82 e0       	ldi	r24, 0x02	; 2
    26b6:	01 c0       	rjmp	.+2      	; 0x26ba <USB_Device_ProcessControlRequest+0x15e>
    26b8:	83 e0       	ldi	r24, 0x03	; 3
    26ba:	80 93 d8 13 	sts	0x13D8, r24	; 0x8013d8 <USB_DeviceState>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    26be:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    26c0:	87 c0       	rjmp	.+270    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    26c2:	80 58       	subi	r24, 0x80	; 128
    26c4:	82 30       	cpi	r24, 0x02	; 2
    26c6:	08 f0       	brcs	.+2      	; 0x26ca <USB_Device_ProcessControlRequest+0x16e>
    26c8:	83 c0       	rjmp	.+262    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    26ca:	80 91 db 13 	lds	r24, 0x13DB	; 0x8013db <USB_ControlRequest+0x2>
    26ce:	90 91 dc 13 	lds	r25, 0x13DC	; 0x8013dc <USB_ControlRequest+0x3>
    26d2:	8c 3d       	cpi	r24, 0xDC	; 220
    26d4:	53 e0       	ldi	r21, 0x03	; 3
    26d6:	95 07       	cpc	r25, r21
    26d8:	71 f5       	brne	.+92     	; 0x2736 <USB_Device_ProcessControlRequest+0x1da>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    26da:	83 e0       	ldi	r24, 0x03	; 3
    26dc:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    26de:	8a e2       	ldi	r24, 0x2A	; 42
    26e0:	89 83       	std	Y+1, r24	; 0x01
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    26e2:	4f b7       	in	r20, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    26e4:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    26e6:	de 01       	movw	r26, r28
    26e8:	13 96       	adiw	r26, 0x03	; 3
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    26ea:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    26ec:	3e e0       	ldi	r19, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    26ee:	51 e2       	ldi	r21, 0x21	; 33
    26f0:	e3 2f       	mov	r30, r19
    26f2:	f0 e0       	ldi	r31, 0x00	; 0
    26f4:	50 93 57 00 	sts	0x0057, r21	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    26f8:	e4 91       	lpm	r30, Z

					if (SerialCharNum & 0x01)
    26fa:	20 ff       	sbrs	r18, 0
    26fc:	03 c0       	rjmp	.+6      	; 0x2704 <USB_Device_ProcessControlRequest+0x1a8>
					{
						SerialByte >>= 4;
    26fe:	e2 95       	swap	r30
    2700:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    2702:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    2704:	ef 70       	andi	r30, 0x0F	; 15
    2706:	8e 2f       	mov	r24, r30
    2708:	90 e0       	ldi	r25, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    270a:	ea 30       	cpi	r30, 0x0A	; 10
    270c:	10 f0       	brcs	.+4      	; 0x2712 <USB_Device_ProcessControlRequest+0x1b6>
    270e:	c7 96       	adiw	r24, 0x37	; 55
    2710:	01 c0       	rjmp	.+2      	; 0x2714 <USB_Device_ProcessControlRequest+0x1b8>
    2712:	c0 96       	adiw	r24, 0x30	; 48
    2714:	8d 93       	st	X+, r24
    2716:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    2718:	2f 5f       	subi	r18, 0xFF	; 255
    271a:	24 31       	cpi	r18, 0x14	; 20
    271c:	49 f7       	brne	.-46     	; 0x26f0 <USB_Device_ProcessControlRequest+0x194>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    271e:	4f bf       	out	0x3f, r20	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2720:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2724:	87 7f       	andi	r24, 0xF7	; 247
    2726:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    272a:	6a e2       	ldi	r22, 0x2A	; 42
    272c:	70 e0       	ldi	r23, 0x00	; 0
    272e:	ce 01       	movw	r24, r28
    2730:	01 96       	adiw	r24, 0x01	; 1
    2732:	25 de       	rcall	.-950    	; 0x237e <Endpoint_Write_Control_Stream_LE>
    2734:	13 c0       	rjmp	.+38     	; 0x275c <USB_Device_ProcessControlRequest+0x200>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    2736:	ae 01       	movw	r20, r28
    2738:	4f 5f       	subi	r20, 0xFF	; 255
    273a:	5f 4f       	sbci	r21, 0xFF	; 255
    273c:	60 91 dd 13 	lds	r22, 0x13DD	; 0x8013dd <USB_ControlRequest+0x4>
    2740:	0e 94 ff 03 	call	0x7fe	; 0x7fe <CALLBACK_USB_GetDescriptor>
    2744:	bc 01       	movw	r22, r24
    2746:	89 2b       	or	r24, r25
    2748:	09 f4       	brne	.+2      	; 0x274c <USB_Device_ProcessControlRequest+0x1f0>
    274a:	42 c0       	rjmp	.+132    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
    274c:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2750:	97 7f       	andi	r25, 0xF7	; 247
    2752:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2756:	89 81       	ldd	r24, Y+1	; 0x01
    2758:	9a 81       	ldd	r25, Y+2	; 0x02
    275a:	a7 de       	rcall	.-690    	; 0x24aa <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    275c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2760:	8b 77       	andi	r24, 0x7B	; 123
    2762:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2766:	34 c0       	rjmp	.+104    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    2768:	80 38       	cpi	r24, 0x80	; 128
    276a:	91 f5       	brne	.+100    	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    276c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2770:	87 7f       	andi	r24, 0xF7	; 247
    2772:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2776:	80 91 d4 13 	lds	r24, 0x13D4	; 0x8013d4 <USB_Device_ConfigurationNumber>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    277a:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    277e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2782:	8e 77       	andi	r24, 0x7E	; 126
    2784:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2788:	ef db       	rcall	.-2082   	; 0x1f68 <Endpoint_ClearStatusStage>
    278a:	22 c0       	rjmp	.+68     	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    278c:	81 11       	cpse	r24, r1
    278e:	20 c0       	rjmp	.+64     	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2790:	80 91 db 13 	lds	r24, 0x13DB	; 0x8013db <USB_ControlRequest+0x2>
    2794:	90 91 dc 13 	lds	r25, 0x13DC	; 0x8013dc <USB_ControlRequest+0x3>
    2798:	99 27       	eor	r25, r25
    279a:	02 97       	sbiw	r24, 0x02	; 2
    279c:	cc f4       	brge	.+50     	; 0x27d0 <USB_Device_ProcessControlRequest+0x274>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    279e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    27a2:	87 7f       	andi	r24, 0xF7	; 247
    27a4:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    27a8:	80 91 db 13 	lds	r24, 0x13DB	; 0x8013db <USB_ControlRequest+0x2>
    27ac:	80 93 d4 13 	sts	0x13D4, r24	; 0x8013d4 <USB_Device_ConfigurationNumber>

	Endpoint_ClearStatusStage();
    27b0:	db db       	rcall	.-2122   	; 0x1f68 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    27b2:	80 91 d4 13 	lds	r24, 0x13D4	; 0x8013d4 <USB_Device_ConfigurationNumber>
    27b6:	81 11       	cpse	r24, r1
    27b8:	06 c0       	rjmp	.+12     	; 0x27c6 <USB_Device_ProcessControlRequest+0x26a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    27ba:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    27be:	87 fd       	sbrc	r24, 7
    27c0:	02 c0       	rjmp	.+4      	; 0x27c6 <USB_Device_ProcessControlRequest+0x26a>
    27c2:	81 e0       	ldi	r24, 0x01	; 1
    27c4:	01 c0       	rjmp	.+2      	; 0x27c8 <USB_Device_ProcessControlRequest+0x26c>
    27c6:	84 e0       	ldi	r24, 0x04	; 4
    27c8:	80 93 d8 13 	sts	0x13D8, r24	; 0x8013d8 <USB_DeviceState>

	EVENT_USB_Device_ConfigurationChanged();
    27cc:	0e 94 a2 02 	call	0x544	; 0x544 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    27d0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    27d4:	83 ff       	sbrs	r24, 3
    27d6:	0a c0       	rjmp	.+20     	; 0x27ec <USB_Device_ProcessControlRequest+0x290>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    27d8:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    27dc:	80 62       	ori	r24, 0x20	; 32
    27de:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    27e2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    27e6:	87 7f       	andi	r24, 0xF7	; 247
    27e8:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    27ec:	aa 96       	adiw	r28, 0x2a	; 42
    27ee:	0f b6       	in	r0, 0x3f	; 63
    27f0:	f8 94       	cli
    27f2:	de bf       	out	0x3e, r29	; 62
    27f4:	0f be       	out	0x3f, r0	; 63
    27f6:	cd bf       	out	0x3d, r28	; 61
    27f8:	df 91       	pop	r29
    27fa:	cf 91       	pop	r28
    27fc:	1f 91       	pop	r17
    27fe:	0f 91       	pop	r16
    2800:	08 95       	ret

00002802 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    2802:	08 95       	ret

00002804 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    2804:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    2806:	80 91 d8 13 	lds	r24, 0x13D8	; 0x8013d8 <USB_DeviceState>
    280a:	88 23       	and	r24, r24
    280c:	59 f0       	breq	.+22     	; 0x2824 <USB_USBTask+0x20>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    280e:	c0 91 e9 00 	lds	r28, 0x00E9	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    2812:	c7 70       	andi	r28, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2814:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2818:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    281c:	83 fd       	sbrc	r24, 3
		  USB_Device_ProcessControlRequest();
    281e:	9e de       	rcall	.-708    	; 0x255c <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2820:	c0 93 e9 00 	sts	0x00E9, r28	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    2824:	cf 91       	pop	r28
    2826:	08 95       	ret

00002828 <Serial_putchar>:
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2828:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
    282c:	95 ff       	sbrs	r25, 5
    282e:	fc cf       	rjmp	.-8      	; 0x2828 <Serial_putchar>
				UDR1 = DataByte;
    2830:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
{
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2834:	80 e0       	ldi	r24, 0x00	; 0
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	08 95       	ret

0000283a <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    283a:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    283e:	87 ff       	sbrs	r24, 7
    2840:	08 c0       	rjmp	.+16     	; 0x2852 <Serial_getchar+0x18>
    2842:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2846:	87 ff       	sbrs	r24, 7
    2848:	07 c0       	rjmp	.+14     	; 0x2858 <Serial_getchar+0x1e>
				  return -1;
				
				return UDR1;
    284a:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    284e:	90 e0       	ldi	r25, 0x00	; 0
    2850:	08 95       	ret
	  return _FDEV_EOF;
    2852:	8e ef       	ldi	r24, 0xFE	; 254
    2854:	9f ef       	ldi	r25, 0xFF	; 255
    2856:	08 95       	ret
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
				  return -1;
    2858:	8f ef       	ldi	r24, 0xFF	; 255
    285a:	9f ef       	ldi	r25, 0xFF	; 255

	return Serial_ReceiveByte();
}
    285c:	08 95       	ret

0000285e <__tablejump2__>:
    285e:	ee 0f       	add	r30, r30
    2860:	ff 1f       	adc	r31, r31
    2862:	00 24       	eor	r0, r0
    2864:	00 1c       	adc	r0, r0
    2866:	0b be       	out	0x3b, r0	; 59
    2868:	07 90       	elpm	r0, Z+
    286a:	f6 91       	elpm	r31, Z
    286c:	e0 2d       	mov	r30, r0
    286e:	09 94       	ijmp

00002870 <memcpy_P>:
    2870:	fb 01       	movw	r30, r22
    2872:	dc 01       	movw	r26, r24
    2874:	02 c0       	rjmp	.+4      	; 0x287a <memcpy_P+0xa>
    2876:	05 90       	lpm	r0, Z+
    2878:	0d 92       	st	X+, r0
    287a:	41 50       	subi	r20, 0x01	; 1
    287c:	50 40       	sbci	r21, 0x00	; 0
    287e:	d8 f7       	brcc	.-10     	; 0x2876 <memcpy_P+0x6>
    2880:	08 95       	ret

00002882 <strcpy_P>:
    2882:	fb 01       	movw	r30, r22
    2884:	dc 01       	movw	r26, r24
    2886:	05 90       	lpm	r0, Z+
    2888:	0d 92       	st	X+, r0
    288a:	00 20       	and	r0, r0
    288c:	e1 f7       	brne	.-8      	; 0x2886 <strcpy_P+0x4>
    288e:	08 95       	ret

00002890 <__strlen_P>:
    2890:	fc 01       	movw	r30, r24
    2892:	05 90       	lpm	r0, Z+
    2894:	00 20       	and	r0, r0
    2896:	e9 f7       	brne	.-6      	; 0x2892 <__strlen_P+0x2>
    2898:	80 95       	com	r24
    289a:	90 95       	com	r25
    289c:	8e 0f       	add	r24, r30
    289e:	9f 1f       	adc	r25, r31
    28a0:	08 95       	ret

000028a2 <strncpy_P>:
    28a2:	fb 01       	movw	r30, r22
    28a4:	dc 01       	movw	r26, r24
    28a6:	41 50       	subi	r20, 0x01	; 1
    28a8:	50 40       	sbci	r21, 0x00	; 0
    28aa:	48 f0       	brcs	.+18     	; 0x28be <strncpy_P+0x1c>
    28ac:	05 90       	lpm	r0, Z+
    28ae:	0d 92       	st	X+, r0
    28b0:	00 20       	and	r0, r0
    28b2:	c9 f7       	brne	.-14     	; 0x28a6 <strncpy_P+0x4>
    28b4:	01 c0       	rjmp	.+2      	; 0x28b8 <strncpy_P+0x16>
    28b6:	1d 92       	st	X+, r1
    28b8:	41 50       	subi	r20, 0x01	; 1
    28ba:	50 40       	sbci	r21, 0x00	; 0
    28bc:	e0 f7       	brcc	.-8      	; 0x28b6 <strncpy_P+0x14>
    28be:	08 95       	ret

000028c0 <memcmp>:
    28c0:	fb 01       	movw	r30, r22
    28c2:	dc 01       	movw	r26, r24
    28c4:	04 c0       	rjmp	.+8      	; 0x28ce <memcmp+0xe>
    28c6:	8d 91       	ld	r24, X+
    28c8:	01 90       	ld	r0, Z+
    28ca:	80 19       	sub	r24, r0
    28cc:	21 f4       	brne	.+8      	; 0x28d6 <memcmp+0x16>
    28ce:	41 50       	subi	r20, 0x01	; 1
    28d0:	50 40       	sbci	r21, 0x00	; 0
    28d2:	c8 f7       	brcc	.-14     	; 0x28c6 <memcmp+0x6>
    28d4:	88 1b       	sub	r24, r24
    28d6:	99 0b       	sbc	r25, r25
    28d8:	08 95       	ret

000028da <memcpy>:
    28da:	fb 01       	movw	r30, r22
    28dc:	dc 01       	movw	r26, r24
    28de:	02 c0       	rjmp	.+4      	; 0x28e4 <memcpy+0xa>
    28e0:	01 90       	ld	r0, Z+
    28e2:	0d 92       	st	X+, r0
    28e4:	41 50       	subi	r20, 0x01	; 1
    28e6:	50 40       	sbci	r21, 0x00	; 0
    28e8:	d8 f7       	brcc	.-10     	; 0x28e0 <memcpy+0x6>
    28ea:	08 95       	ret

000028ec <memmove>:
    28ec:	68 17       	cp	r22, r24
    28ee:	79 07       	cpc	r23, r25
    28f0:	68 f4       	brcc	.+26     	; 0x290c <memmove+0x20>
    28f2:	fb 01       	movw	r30, r22
    28f4:	dc 01       	movw	r26, r24
    28f6:	e4 0f       	add	r30, r20
    28f8:	f5 1f       	adc	r31, r21
    28fa:	a4 0f       	add	r26, r20
    28fc:	b5 1f       	adc	r27, r21
    28fe:	02 c0       	rjmp	.+4      	; 0x2904 <memmove+0x18>
    2900:	02 90       	ld	r0, -Z
    2902:	0e 92       	st	-X, r0
    2904:	41 50       	subi	r20, 0x01	; 1
    2906:	50 40       	sbci	r21, 0x00	; 0
    2908:	d8 f7       	brcc	.-10     	; 0x2900 <memmove+0x14>
    290a:	08 95       	ret
    290c:	e6 cf       	rjmp	.-52     	; 0x28da <memcpy>

0000290e <strncmp>:
    290e:	fb 01       	movw	r30, r22
    2910:	dc 01       	movw	r26, r24
    2912:	41 50       	subi	r20, 0x01	; 1
    2914:	50 40       	sbci	r21, 0x00	; 0
    2916:	30 f0       	brcs	.+12     	; 0x2924 <strncmp+0x16>
    2918:	8d 91       	ld	r24, X+
    291a:	01 90       	ld	r0, Z+
    291c:	80 19       	sub	r24, r0
    291e:	19 f4       	brne	.+6      	; 0x2926 <strncmp+0x18>
    2920:	00 20       	and	r0, r0
    2922:	b9 f7       	brne	.-18     	; 0x2912 <strncmp+0x4>
    2924:	88 1b       	sub	r24, r24
    2926:	99 0b       	sbc	r25, r25
    2928:	08 95       	ret

0000292a <_exit>:
    292a:	f8 94       	cli

0000292c <__stop_program>:
    292c:	ff cf       	rjmp	.-2      	; 0x292c <__stop_program>
