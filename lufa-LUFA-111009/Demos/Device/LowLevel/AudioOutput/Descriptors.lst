   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  12               	.global	CALLBACK_USB_GetDescriptor
  14               	CALLBACK_USB_GetDescriptor:
  15               	.LFB97:
  16               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  41:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  42:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  43:Descriptors.c ****  *  process begins.
  44:Descriptors.c ****  */
  45:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  46:Descriptors.c **** {
  47:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  48:Descriptors.c **** 
  49:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  50:Descriptors.c **** 	.Class                  = USB_CSCP_NoDeviceClass,
  51:Descriptors.c **** 	.SubClass               = USB_CSCP_NoDeviceSubclass,
  52:Descriptors.c **** 	.Protocol               = USB_CSCP_NoDeviceProtocol,
  53:Descriptors.c **** 
  54:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  55:Descriptors.c **** 
  56:Descriptors.c **** 	.VendorID               = 0x03EB,
  57:Descriptors.c **** 	.ProductID              = 0x2046,
  58:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.02),
  59:Descriptors.c **** 
  60:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
  61:Descriptors.c **** 	.ProductStrIndex        = 0x02,
  62:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
  63:Descriptors.c **** 
  64:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  65:Descriptors.c **** };
  66:Descriptors.c **** 
  67:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
  68:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
  69:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
  70:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
  71:Descriptors.c ****  */
  72:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
  73:Descriptors.c **** {
  74:Descriptors.c **** 	.Config =
  75:Descriptors.c **** 		{
  76:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYP
  77:Descriptors.c **** 
  78:Descriptors.c **** 			.TotalConfigurationSize   = sizeof(USB_Descriptor_Configuration_t),
  79:Descriptors.c **** 			.TotalInterfaces          = 2,
  80:Descriptors.c **** 
  81:Descriptors.c **** 			.ConfigurationNumber      = 1,
  82:Descriptors.c **** 			.ConfigurationStrIndex    = NO_DESCRIPTOR,
  83:Descriptors.c **** 
  84:Descriptors.c **** 			.ConfigAttributes         = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
  85:Descriptors.c **** 
  86:Descriptors.c **** 			.MaxPowerConsumption      = USB_CONFIG_POWER_MA(100)
  87:Descriptors.c **** 		},
  88:Descriptors.c **** 
  89:Descriptors.c **** 	.Audio_ControlInterface =
  90:Descriptors.c **** 		{
  91:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface
  92:Descriptors.c **** 
  93:Descriptors.c **** 			.InterfaceNumber          = 0,
  94:Descriptors.c **** 			.AlternateSetting         = 0,
  95:Descriptors.c **** 
  96:Descriptors.c **** 			.TotalEndpoints           = 0,
  97:Descriptors.c **** 
  98:Descriptors.c **** 			.Class                    = AUDIO_CSCP_AudioClass,
  99:Descriptors.c **** 			.SubClass                 = AUDIO_CSCP_ControlSubclass,
 100:Descriptors.c **** 			.Protocol                 = AUDIO_CSCP_ControlProtocol,
 101:Descriptors.c **** 
 102:Descriptors.c **** 			.InterfaceStrIndex        = NO_DESCRIPTOR
 103:Descriptors.c **** 		},
 104:Descriptors.c **** 
 105:Descriptors.c **** 	.Audio_ControlInterface_SPC =
 106:Descriptors.c **** 		{
 107:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Audio_Descriptor_Interface_AC_t), .Type = DTYPE_
 108:Descriptors.c **** 			.Subtype                  = AUDIO_DSUBTYPE_CSInterface_Header,
 109:Descriptors.c **** 
 110:Descriptors.c **** 			.ACSpecification          = VERSION_BCD(01.00),
 111:Descriptors.c **** 			.TotalLength              = (sizeof(USB_Audio_Descriptor_Interface_AC_t) +
 112:Descriptors.c **** 			                             sizeof(USB_Audio_Descriptor_InputTerminal_t) +
 113:Descriptors.c **** 			                             sizeof(USB_Audio_Descriptor_OutputTerminal_t)),
 114:Descriptors.c **** 
 115:Descriptors.c **** 			.InCollection             = 1,
 116:Descriptors.c **** 			.InterfaceNumber          = 1,
 117:Descriptors.c **** 		},
 118:Descriptors.c **** 
 119:Descriptors.c **** 	.Audio_InputTerminal =
 120:Descriptors.c **** 		{
 121:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Audio_Descriptor_InputTerminal_t), .Type = DTYPE
 122:Descriptors.c **** 			.Subtype                  = AUDIO_DSUBTYPE_CSInterface_InputTerminal,
 123:Descriptors.c **** 
 124:Descriptors.c **** 			.TerminalID               = 0x01,
 125:Descriptors.c **** 			.TerminalType             = AUDIO_TERMINAL_STREAMING,
 126:Descriptors.c **** 			.AssociatedOutputTerminal = 0x00,
 127:Descriptors.c **** 
 128:Descriptors.c **** 			.TotalChannels            = 2,
 129:Descriptors.c **** 			.ChannelConfig            = (AUDIO_CHANNEL_LEFT_FRONT | AUDIO_CHANNEL_RIGHT_FRONT),
 130:Descriptors.c **** 
 131:Descriptors.c **** 			.ChannelStrIndex          = NO_DESCRIPTOR,
 132:Descriptors.c **** 			.TerminalStrIndex         = NO_DESCRIPTOR
 133:Descriptors.c **** 		},
 134:Descriptors.c **** 
 135:Descriptors.c **** 	.Audio_OutputTerminal =
 136:Descriptors.c **** 		{
 137:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Audio_Descriptor_OutputTerminal_t), .Type = DTYP
 138:Descriptors.c **** 			.Subtype                  = AUDIO_DSUBTYPE_CSInterface_OutputTerminal,
 139:Descriptors.c **** 
 140:Descriptors.c **** 			.TerminalID               = 0x02,
 141:Descriptors.c **** 			.TerminalType             = AUDIO_TERMINAL_OUT_SPEAKER,
 142:Descriptors.c **** 			.AssociatedInputTerminal  = 0x00,
 143:Descriptors.c **** 
 144:Descriptors.c **** 			.SourceID                 = 0x01,
 145:Descriptors.c **** 
 146:Descriptors.c **** 			.TerminalStrIndex         = NO_DESCRIPTOR
 147:Descriptors.c **** 		},
 148:Descriptors.c **** 
 149:Descriptors.c **** 	.Audio_StreamInterface_Alt0 =
 150:Descriptors.c **** 		{
 151:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface
 152:Descriptors.c **** 
 153:Descriptors.c **** 			.InterfaceNumber          = 1,
 154:Descriptors.c **** 			.AlternateSetting         = 0,
 155:Descriptors.c **** 
 156:Descriptors.c **** 			.TotalEndpoints           = 0,
 157:Descriptors.c **** 
 158:Descriptors.c **** 			.Class                    = AUDIO_CSCP_AudioClass,
 159:Descriptors.c **** 			.SubClass                 = AUDIO_CSCP_AudioStreamingSubclass,
 160:Descriptors.c **** 			.Protocol                 = AUDIO_CSCP_StreamingProtocol,
 161:Descriptors.c **** 
 162:Descriptors.c **** 			.InterfaceStrIndex        = NO_DESCRIPTOR
 163:Descriptors.c **** 		},
 164:Descriptors.c **** 
 165:Descriptors.c **** 	.Audio_StreamInterface_Alt1 =
 166:Descriptors.c **** 		{
 167:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface
 168:Descriptors.c **** 
 169:Descriptors.c **** 			.InterfaceNumber          = 1,
 170:Descriptors.c **** 			.AlternateSetting         = 1,
 171:Descriptors.c **** 
 172:Descriptors.c **** 			.TotalEndpoints           = 1,
 173:Descriptors.c **** 
 174:Descriptors.c **** 			.Class                    = AUDIO_CSCP_AudioClass,
 175:Descriptors.c **** 			.SubClass                 = AUDIO_CSCP_AudioStreamingSubclass,
 176:Descriptors.c **** 			.Protocol                 = AUDIO_CSCP_StreamingProtocol,
 177:Descriptors.c **** 
 178:Descriptors.c **** 			.InterfaceStrIndex        = NO_DESCRIPTOR
 179:Descriptors.c **** 		},
 180:Descriptors.c **** 
 181:Descriptors.c **** 	.Audio_StreamInterface_SPC =
 182:Descriptors.c **** 		{
 183:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Audio_Descriptor_Interface_AS_t), .Type = DTYPE_
 184:Descriptors.c **** 			.Subtype                  = AUDIO_DSUBTYPE_CSInterface_General,
 185:Descriptors.c **** 
 186:Descriptors.c **** 			.TerminalLink             = 0x01,
 187:Descriptors.c **** 
 188:Descriptors.c **** 			.FrameDelay               = 1,
 189:Descriptors.c **** 			.AudioFormat              = 0x0001
 190:Descriptors.c **** 		},
 191:Descriptors.c **** 
 192:Descriptors.c **** 	.Audio_AudioFormat =
 193:Descriptors.c **** 		{
 194:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Audio_Descriptor_Format_t) +
 195:Descriptors.c **** 			                                     sizeof(ConfigurationDescriptor.Audio_AudioFormatSampleRates
 196:Descriptors.c **** 			                             .Type = DTYPE_CSInterface},
 197:Descriptors.c **** 			.Subtype                  = AUDIO_DSUBTYPE_CSInterface_FormatType,
 198:Descriptors.c **** 
 199:Descriptors.c **** 			.FormatType               = 0x01,
 200:Descriptors.c **** 			.Channels                 = 0x02,
 201:Descriptors.c **** 
 202:Descriptors.c **** 			.SubFrameSize             = 0x02,
 203:Descriptors.c **** 			.BitResolution            = 16,
 204:Descriptors.c **** 
 205:Descriptors.c **** 			.TotalDiscreteSampleRates = (sizeof(ConfigurationDescriptor.Audio_AudioFormatSampleRates) / size
 206:Descriptors.c **** 		},
 207:Descriptors.c **** 	
 208:Descriptors.c **** 	.Audio_AudioFormatSampleRates =
 209:Descriptors.c **** 		{
 210:Descriptors.c **** 			AUDIO_SAMPLE_FREQ(8000),
 211:Descriptors.c **** 			AUDIO_SAMPLE_FREQ(11025),
 212:Descriptors.c **** 			AUDIO_SAMPLE_FREQ(22050),
 213:Descriptors.c **** 			AUDIO_SAMPLE_FREQ(44100),
 214:Descriptors.c **** 			AUDIO_SAMPLE_FREQ(48000),
 215:Descriptors.c **** 		},
 216:Descriptors.c **** 
 217:Descriptors.c **** 	.Audio_StreamEndpoint =
 218:Descriptors.c **** 		{
 219:Descriptors.c **** 			.Endpoint =
 220:Descriptors.c **** 				{
 221:Descriptors.c **** 					.Header              = {.Size = sizeof(USB_Audio_Descriptor_StreamEndpoint_Std_t), .Type = DTY
 222:Descriptors.c **** 
 223:Descriptors.c **** 					.EndpointAddress     = (ENDPOINT_DIR_OUT | AUDIO_STREAM_EPNUM),
 224:Descriptors.c **** 					.Attributes          = (EP_TYPE_ISOCHRONOUS | ENDPOINT_ATTR_SYNC | ENDPOINT_USAGE_DATA),
 225:Descriptors.c **** 					.EndpointSize        = AUDIO_STREAM_EPSIZE,
 226:Descriptors.c **** 					.PollingIntervalMS   = 0x01
 227:Descriptors.c **** 				},
 228:Descriptors.c **** 
 229:Descriptors.c **** 			.Refresh                  = 0,
 230:Descriptors.c **** 			.SyncEndpointNumber       = 0
 231:Descriptors.c **** 		},
 232:Descriptors.c **** 
 233:Descriptors.c **** 	.Audio_StreamEndpoint_SPC =
 234:Descriptors.c **** 		{
 235:Descriptors.c **** 			.Header                   = {.Size = sizeof(USB_Audio_Descriptor_StreamEndpoint_Spc_t), .Type = 
 236:Descriptors.c **** 			.Subtype                  = AUDIO_DSUBTYPE_CSEndpoint_General,
 237:Descriptors.c **** 
 238:Descriptors.c **** 			.Attributes               = (AUDIO_EP_ACCEPTS_SMALL_PACKETS | AUDIO_EP_SAMPLE_FREQ_CONTROL),
 239:Descriptors.c **** 
 240:Descriptors.c **** 			.LockDelayUnits           = 0x00,
 241:Descriptors.c **** 			.LockDelay                = 0x0000
 242:Descriptors.c **** 		}
 243:Descriptors.c **** };
 244:Descriptors.c **** 
 245:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 246:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 247:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 248:Descriptors.c ****  */
 249:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 250:Descriptors.c **** {
 251:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 252:Descriptors.c **** 
 253:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 254:Descriptors.c **** };
 255:Descriptors.c **** 
 256:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 257:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 258:Descriptors.c ****  *  Descriptor.
 259:Descriptors.c ****  */
 260:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 261:Descriptors.c **** {
 262:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(11), .Type = DTYPE_String},
 263:Descriptors.c **** 
 264:Descriptors.c **** 	.UnicodeString          = L"Dean Camera"
 265:Descriptors.c **** };
 266:Descriptors.c **** 
 267:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 268:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 269:Descriptors.c ****  *  Descriptor.
 270:Descriptors.c ****  */
 271:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 272:Descriptors.c **** {
 273:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(19), .Type = DTYPE_String},
 274:Descriptors.c **** 
 275:Descriptors.c **** 	.UnicodeString          = L"LUFA Audio Out Demo"
 276:Descriptors.c **** };
 277:Descriptors.c **** 
 278:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 279:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 280:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 281:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 282:Descriptors.c ****  *  USB host.
 283:Descriptors.c ****  */
 284:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 285:Descriptors.c ****                                     const uint8_t wIndex,
 286:Descriptors.c ****                                     const void** const DescriptorAddress)
 287:Descriptors.c **** {
  17               		.loc 1 287 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 288:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 289:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 290:Descriptors.c **** 
 291:Descriptors.c **** 	const void* Address = NULL;
 292:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 293:Descriptors.c **** 
 294:Descriptors.c **** 	switch (DescriptorType)
  24               		.loc 1 294 0
  25 0000 292F      		mov r18,r25
  26 0002 3327      		clr r19
  27 0004 2230      		cpi r18,2
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 2330      		cpi r18,3
  31 000c 3105      		cpc r19,__zero_reg__
  32 000e 01F0      		breq .L4
  33 0010 2130      		cpi r18,1
  34 0012 3105      		cpc r19,__zero_reg__
  35 0014 01F4      		brne .L12
 295:Descriptors.c **** 	{
 296:Descriptors.c **** 		case DTYPE_Device:
 297:Descriptors.c **** 			Address = &DeviceDescriptor;
 298:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  36               		.loc 1 298 0
  37 0016 82E1      		ldi r24,lo8(18)
  38 0018 90E0      		ldi r25,0
  39               	.LVL1:
 297:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  40               		.loc 1 297 0
  41 001a 20E0      		ldi r18,lo8(DeviceDescriptor)
  42 001c 30E0      		ldi r19,hi8(DeviceDescriptor)
  43 001e 00C0      		rjmp .L2
  44               	.LVL2:
  45               	.L3:
 299:Descriptors.c **** 			break;
 300:Descriptors.c **** 		case DTYPE_Configuration:
 301:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 302:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  46               		.loc 1 302 0
  47 0020 80E7      		ldi r24,lo8(112)
  48 0022 90E0      		ldi r25,0
  49               	.LVL3:
 301:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  50               		.loc 1 301 0
  51 0024 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  52 0026 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 303:Descriptors.c **** 			break;
  53               		.loc 1 303 0
  54 0028 00C0      		rjmp .L2
  55               	.LVL4:
  56               	.L4:
 304:Descriptors.c **** 		case DTYPE_String:
 305:Descriptors.c **** 			switch (DescriptorNumber)
  57               		.loc 1 305 0
  58 002a 9927      		clr r25
  59               	.LVL5:
  60 002c 8130      		cpi r24,1
  61 002e 9105      		cpc r25,__zero_reg__
  62 0030 01F0      		breq .L6
  63 0032 00F0      		brlo .L7
  64 0034 0297      		sbiw r24,2
  65 0036 01F4      		brne .L12
  66               	.LVL6:
  67               	.LBB2:
 306:Descriptors.c **** 			{
 307:Descriptors.c **** 				case 0x00:
 308:Descriptors.c **** 					Address = &LanguageString;
 309:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 310:Descriptors.c **** 					break;
 311:Descriptors.c **** 				case 0x01:
 312:Descriptors.c **** 					Address = &ManufacturerString;
 313:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 314:Descriptors.c **** 					break;
 315:Descriptors.c **** 				case 0x02:
 316:Descriptors.c **** 					Address = &ProductString;
 317:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
  68               		.loc 1 317 0
  69 0038 E0E0      		ldi r30,lo8(ProductString)
  70 003a F0E0      		ldi r31,hi8(ProductString)
  71 003c 00C0      		rjmp .L13
  72               	.LVL7:
  73               	.L7:
  74               	.LBE2:
  75               	.LBB3:
 309:Descriptors.c **** 					break;
  76               		.loc 1 309 0
  77 003e E0E0      		ldi r30,lo8(LanguageString)
  78 0040 F0E0      		ldi r31,hi8(LanguageString)
  79 0042 00C0      		rjmp .L13
  80               	.LVL8:
  81               	.L6:
  82               	.LBE3:
  83               	.LBB4:
 313:Descriptors.c **** 					break;
  84               		.loc 1 313 0
  85 0044 E0E0      		ldi r30,lo8(ManufacturerString)
  86 0046 F0E0      		ldi r31,hi8(ManufacturerString)
  87               	.LVL9:
  88               	.L13:
  89               	.LBE4:
  90               	.LBB5:
  91               		.loc 1 317 0
  92               	/* #APP */
  93               	 ;  317 "Descriptors.c" 1
  94 0048 8491      		lpm r24, Z
  95               		
  96               	 ;  0 "" 2
  97               	.LVL10:
  98               	/* #NOAPP */
  99               	.LBE5:
 100 004a 90E0      		ldi r25,0
 101               	.LVL11:
 316:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 102               		.loc 1 316 0
 103 004c 9F01      		movw r18,r30
 318:Descriptors.c **** 					break;
 104               		.loc 1 318 0
 105 004e 00C0      		rjmp .L2
 106               	.LVL12:
 107               	.L12:
 292:Descriptors.c **** 
 108               		.loc 1 292 0
 109 0050 80E0      		ldi r24,0
 110 0052 90E0      		ldi r25,0
 291:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 111               		.loc 1 291 0
 112 0054 20E0      		ldi r18,0
 113 0056 30E0      		ldi r19,0
 114               	.LVL13:
 115               	.L2:
 319:Descriptors.c **** 			}
 320:Descriptors.c **** 
 321:Descriptors.c **** 			break;
 322:Descriptors.c **** 	}
 323:Descriptors.c **** 
 324:Descriptors.c **** 	*DescriptorAddress = Address;
 116               		.loc 1 324 0
 117 0058 FA01      		movw r30,r20
 118 005a 3183      		std Z+1,r19
 119 005c 2083      		st Z,r18
 325:Descriptors.c **** 	return Size;
 326:Descriptors.c **** }
 120               		.loc 1 326 0
 121 005e 0895      		ret
 122               		.cfi_endproc
 123               	.LFE97:
 125               	.global	ProductString
 126               		.section	.progmem.data,"a",@progbits
 129               	ProductString:
 130 0000 28        		.byte	40
 131 0001 03        		.byte	3
 132 0002 4C00      		.string	"L"
 133 0004 5500      		.string	"U"
 134 0006 4600      		.string	"F"
 135 0008 4100      		.string	"A"
 136 000a 2000      		.string	" "
 137 000c 4100      		.string	"A"
 138 000e 7500      		.string	"u"
 139 0010 6400      		.string	"d"
 140 0012 6900      		.string	"i"
 141 0014 6F00      		.string	"o"
 142 0016 2000      		.string	" "
 143 0018 4F00      		.string	"O"
 144 001a 7500      		.string	"u"
 145 001c 7400      		.string	"t"
 146 001e 2000      		.string	" "
 147 0020 4400      		.string	"D"
 148 0022 6500      		.string	"e"
 149 0024 6D00      		.string	"m"
 150 0026 6F00      		.string	"o"
 151 0028 00        		.string	""
 152 0029 00        		.string	""
 153               	.global	ManufacturerString
 156               	ManufacturerString:
 157 002a 18        		.byte	24
 158 002b 03        		.byte	3
 159 002c 4400      		.string	"D"
 160 002e 6500      		.string	"e"
 161 0030 6100      		.string	"a"
 162 0032 6E00      		.string	"n"
 163 0034 2000      		.string	" "
 164 0036 4300      		.string	"C"
 165 0038 6100      		.string	"a"
 166 003a 6D00      		.string	"m"
 167 003c 6500      		.string	"e"
 168 003e 7200      		.string	"r"
 169 0040 6100      		.string	"a"
 170 0042 00        		.string	""
 171 0043 00        		.string	""
 172               	.global	LanguageString
 175               	LanguageString:
 176 0044 04        		.byte	4
 177 0045 03        		.byte	3
 178 0046 0904      		.word	1033
 179               	.global	ConfigurationDescriptor
 182               	ConfigurationDescriptor:
 183 0048 09        		.byte	9
 184 0049 02        		.byte	2
 185 004a 7000      		.word	112
 186 004c 02        		.byte	2
 187 004d 01        		.byte	1
 188 004e 00        		.byte	0
 189 004f C0        		.byte	-64
 190 0050 32        		.byte	50
 191 0051 09        		.byte	9
 192 0052 04        		.byte	4
 193 0053 00        		.byte	0
 194 0054 00        		.byte	0
 195 0055 00        		.byte	0
 196 0056 01        		.byte	1
 197 0057 01        		.byte	1
 198 0058 00        		.byte	0
 199 0059 00        		.byte	0
 200 005a 09        		.byte	9
 201 005b 24        		.byte	36
 202 005c 01        		.byte	1
 203 005d 0001      		.word	256
 204 005f 1E00      		.word	30
 205 0061 01        		.byte	1
 206 0062 01        		.byte	1
 207 0063 0C        		.byte	12
 208 0064 24        		.byte	36
 209 0065 02        		.byte	2
 210 0066 01        		.byte	1
 211 0067 0101      		.word	257
 212 0069 00        		.byte	0
 213 006a 02        		.byte	2
 214 006b 0300      		.word	3
 215 006d 00        		.byte	0
 216 006e 00        		.byte	0
 217 006f 09        		.byte	9
 218 0070 24        		.byte	36
 219 0071 03        		.byte	3
 220 0072 02        		.byte	2
 221 0073 0103      		.word	769
 222 0075 00        		.byte	0
 223 0076 01        		.byte	1
 224 0077 00        		.byte	0
 225 0078 09        		.byte	9
 226 0079 04        		.byte	4
 227 007a 01        		.byte	1
 228 007b 00        		.byte	0
 229 007c 00        		.byte	0
 230 007d 01        		.byte	1
 231 007e 02        		.byte	2
 232 007f 00        		.byte	0
 233 0080 00        		.byte	0
 234 0081 09        		.byte	9
 235 0082 04        		.byte	4
 236 0083 01        		.byte	1
 237 0084 01        		.byte	1
 238 0085 01        		.byte	1
 239 0086 01        		.byte	1
 240 0087 02        		.byte	2
 241 0088 00        		.byte	0
 242 0089 00        		.byte	0
 243 008a 07        		.byte	7
 244 008b 24        		.byte	36
 245 008c 01        		.byte	1
 246 008d 01        		.byte	1
 247 008e 01        		.byte	1
 248 008f 0100      		.word	1
 249 0091 17        		.byte	23
 250 0092 24        		.byte	36
 251 0093 02        		.byte	2
 252 0094 01        		.byte	1
 253 0095 02        		.byte	2
 254 0096 02        		.byte	2
 255 0097 10        		.byte	16
 256 0098 05        		.byte	5
 257 0099 40        		.byte	64
 258 009a 1F        		.byte	31
 259 009b 00        		.byte	0
 260 009c 11        		.byte	17
 261 009d 2B        		.byte	43
 262 009e 00        		.byte	0
 263 009f 22        		.byte	34
 264 00a0 56        		.byte	86
 265 00a1 00        		.byte	0
 266 00a2 44        		.byte	68
 267 00a3 AC        		.byte	-84
 268 00a4 00        		.byte	0
 269 00a5 80        		.byte	-128
 270 00a6 BB        		.byte	-69
 271 00a7 00        		.byte	0
 272 00a8 09        		.byte	9
 273 00a9 05        		.byte	5
 274 00aa 01        		.byte	1
 275 00ab 0D        		.byte	13
 276 00ac 0001      		.word	256
 277 00ae 01        		.byte	1
 278 00af 00        		.byte	0
 279 00b0 00        		.byte	0
 280 00b1 07        		.byte	7
 281 00b2 25        		.byte	37
 282 00b3 01        		.byte	1
 283 00b4 01        		.byte	1
 284 00b5 00        		.byte	0
 285 00b6 0000      		.word	0
 286               	.global	DeviceDescriptor
 289               	DeviceDescriptor:
 290 00b8 12        		.byte	18
 291 00b9 01        		.byte	1
 292 00ba 1001      		.word	272
 293 00bc 00        		.byte	0
 294 00bd 00        		.byte	0
 295 00be 00        		.byte	0
 296 00bf 08        		.byte	8
 297 00c0 EB03      		.word	1003
 298 00c2 4620      		.word	8262
 299 00c4 0200      		.word	2
 300 00c6 01        		.byte	1
 301 00c7 02        		.byte	2
 302 00c8 00        		.byte	0
 303 00c9 01        		.byte	1
 304               		.text
 305               	.Letext0:
 306               		.file 2 "/usr/lib/avr/include/stdint.h"
 307               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 308               		.file 4 "../../../../LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 309               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/Audio.h"
 310               		.file 6 "Descriptors.h"
 311               		.file 7 "../../../../LUFA/Drivers/USB/Core/USBTask.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccenJCYG.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccenJCYG.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccenJCYG.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccenJCYG.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccenJCYG.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccenJCYG.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccenJCYG.s:14     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccenJCYG.s:289    .progmem.data:00000000000000b8 DeviceDescriptor
     /tmp/ccenJCYG.s:182    .progmem.data:0000000000000048 ConfigurationDescriptor
     /tmp/ccenJCYG.s:129    .progmem.data:0000000000000000 ProductString
     /tmp/ccenJCYG.s:175    .progmem.data:0000000000000044 LanguageString
     /tmp/ccenJCYG.s:156    .progmem.data:000000000000002a ManufacturerString

NO UNDEFINED SYMBOLS
