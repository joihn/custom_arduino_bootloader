   1               		.file	"TCP.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.SwapEndian_32,"ax",@progbits
  13               	SwapEndian_32:
  14               	.LFB8:
  15               		.file 1 "../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h"
   1:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /*
   2:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****              LUFA Library
   3:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****      Copyright (C) Dean Camera, 2011.
   4:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
   5:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****            www.lufa-lib.org
   7:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** */
   8:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
   9:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /*
  10:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  12:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   software and its documentation for any purpose is hereby granted
  14:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   without fee, provided that the above copyright notice appear in
  15:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   all copies and that both that the copyright notice and this
  16:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   documentation, and that the name of the author not be used in
  18:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   advertising or publicity pertaining to distribution of the
  19:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   software without specific, written prior permission.
  20:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  21:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   The author disclaim all warranties with regard to this
  22:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   software, including all implied warranties of merchantability
  23:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   and fitness.  In no event shall the author be liable for any
  24:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   special, indirect or consequential damages or any damages
  25:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   in an action of contract, negligence or other tortious action,
  27:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   arising out of or in connection with the use or performance of
  28:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****   this software.
  29:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** */
  30:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  31:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /** \file
  32:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \brief Endianness and Byte Ordering macros and functions.
  33:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *
  34:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \copydetails Group_Endianness
  35:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  */
  36:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  37:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /** \ingroup Group_Endianness
  38:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \defgroup Group_ByteSwapping Byte Reordering
  39:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \brief Macros and functions for forced byte reordering.
  40:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  */
  41:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  42:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /** \ingroup Group_Endianness
  43:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \defgroup Group_EndianConversion Endianness Conversion
  44:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \brief Macros and functions for automatic endianness conversion.
  45:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  */
  46:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  47:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** /** \ingroup Group_Common
  48:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \defgroup Group_Endianness Endianness and Byte Ordering
  49:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  \brief Convenience macros and functions relating to byte (re-)ordering
  50:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *
  51:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  Common library convenience macros and functions relating to byte (re-)ordering.
  52:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *
  53:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  *  @{
  54:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h ****  */
  55:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  56:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** #ifndef __LUFA_ENDIANNESS_H__
  57:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** #define __LUFA_ENDIANNESS_H__
  58:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  59:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 	/* Enable C linkage for C++ Compilers: */
  60:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#if defined(__cplusplus)
  61:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			extern "C" {
  62:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#endif
  63:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  64:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 	/* Preprocessor Checks: */
  65:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#if !defined(__INCLUDE_FROM_COMMON_H)
  66:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#error Do not include this file directly. Include LUFA/Common/Common.h instead to gain this func
  67:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#endif
  68:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		
  69:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#if !(defined(ARCH_BIG_ENDIAN) || defined(ARCH_LITTLE_ENDIAN))
  70:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#error ARCH_BIG_ENDIAN or ARCH_LITTLE_ENDIAN not set for the specified architecture.
  71:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		#endif
  72:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  73:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 	/* Public Interface - May be used in end-application: */
  74:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		/* Macros: */
  75:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			/** Swaps the byte ordering of a 16-bit value at compile-time. Do not use this macro for swappin
  76:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  of dynamic values computed at runtime, use \ref SwapEndian_16() instead. The result of this 
  77:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  inside struct or other variable initializers outside of a function, something that is not po
  78:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  inline function variant.
  79:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  80:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
  81:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  82:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \param[in] x  16-bit value whose byte ordering is to be swapped.
  83:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  84:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \return Input value with the byte ordering reversed.
  85:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 */
  86:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#define SWAPENDIAN_16(x)            (uint16_t)((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))
  87:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  88:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			/** Swaps the byte ordering of a 32-bit value at compile-time. Do not use this macro for swappin
  89:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  of dynamic values computed at runtime- use \ref SwapEndian_32() instead. The result of this 
  90:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  inside struct or other variable initializers outside of a function, something that is not po
  91:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  inline function variant.
  92:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  93:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
  94:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  95:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \param[in] x  32-bit value whose byte ordering is to be swapped.
  96:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
  97:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \return Input value with the byte ordering reversed.
  98:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 */
  99:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#define SWAPENDIAN_32(x)            (uint32_t)((((x) & 0xFF000000UL) >> 24UL) | (((x) & 0x00FF00
 100:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			                                               (((x) & 0x0000FF00UL) << 8UL)  | (((x) & 0x000000
 101:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 102:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#if defined(ARCH_BIG_ENDIAN) && !defined(le16_to_cpu)
 103:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define le16_to_cpu(x)           SwapEndian_16(x)
 104:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define le32_to_cpu(x)           SwapEndian_32(x)
 105:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define be16_to_cpu(x)           (x)
 106:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define be32_to_cpu(x)           (x)
 107:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_le16(x)           SwapEndian_16(x)
 108:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_le32(x)           SwapEndian_32(x)
 109:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_be16(x)           (x)
 110:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_be32(x)           (x)
 111:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define LE16_TO_CPU(x)           SWAPENDIAN_16(x)
 112:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define LE32_TO_CPU(x)           SWAPENDIAN_32(x)
 113:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define BE16_TO_CPU(x)           (x)
 114:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define BE32_TO_CPU(x)           (x)
 115:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_LE16(x)           SWAPENDIAN_16(x)
 116:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_LE32(x)           SWAPENDIAN_32(x)
 117:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_BE16(x)           (x)
 118:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_BE32(x)           (x)			
 119:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#elif !defined(le16_to_cpu)
 120:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** \name Run-time endianness conversion */
 121:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				//@{
 122:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			
 123:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 16-bit piece of data and the
 124:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 125:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 126:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 127:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 128:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 129:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref LE16_TO_CPU instead.
 130:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 131:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 132:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 133:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 134:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 135:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 136:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 137:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define le16_to_cpu(x)           (x)
 138:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 139:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 32-bit piece of data and the
 140:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 141:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 142:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 143:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 144:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 145:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref LE32_TO_CPU instead.
 146:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 147:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 148:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 149:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 150:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 151:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 152:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 153:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define le32_to_cpu(x)           (x)
 154:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 155:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 16-bit piece of data and the
 156:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 157:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 158:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 159:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 160:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 161:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref BE16_TO_CPU instead.
 162:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 163:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 164:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 165:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 166:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 167:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 168:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 169:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define be16_to_cpu(x)           SwapEndian_16(x)
 170:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 171:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 32-bit piece of data and the
 172:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 173:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 174:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 175:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 176:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 177:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref BE32_TO_CPU instead.
 178:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 179:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 180:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 181:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 182:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 183:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 184:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 185:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define be32_to_cpu(x)           SwapEndian_32(x)
 186:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 187:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 188:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 189:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 190:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 191:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 192:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 193:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_LE16 instead.
 194:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 195:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 196:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 197:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 198:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 199:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 200:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 201:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_le16(x)           (x)
 202:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 203:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 204:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 205:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 206:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 207:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 208:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 209:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_LE32 instead.
 210:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 211:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 212:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 213:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 214:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 215:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 216:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 217:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_le32(x)           (x)
 218:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 219:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 220:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 221:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 222:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 223:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 224:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 225:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_BE16 instead.
 226:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 227:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 228:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 229:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 230:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 231:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 232:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 233:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_be16(x)           SwapEndian_16(x)
 234:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 235:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 236:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 237:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 238:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 239:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 240:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for run-time conversion of data - for compile-time endianness
 241:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref CPU_TO_BE32 instead.
 242:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 243:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 244:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 245:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 246:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 247:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 248:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 249:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define cpu_to_be32(x)           SwapEndian_32(x)
 250:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 251:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				//@}
 252:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 253:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** \name Compile-time endianness conversion */
 254:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				//@{
 255:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 256:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 16-bit piece of data and the
 257:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 258:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 259:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 260:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 261:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run time endianness
 262:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref le16_to_cpu instead.
 263:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 264:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 265:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 266:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 267:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 268:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 269:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 270:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define LE16_TO_CPU(x)           (x)
 271:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 272:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Little Endian encoded 32-bit piece of data and the
 273:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 274:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 275:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 276:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 277:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run time endianness
 278:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref le32_to_cpu instead.
 279:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 280:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 281:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 282:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 283:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 284:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 285:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 286:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define LE32_TO_CPU(x)           (x)
 287:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 288:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 16-bit piece of data and the
 289:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 290:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 291:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 292:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 293:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 294:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref be16_to_cpu instead.
 295:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 296:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 297:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 298:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 299:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 300:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 301:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 302:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define BE16_TO_CPU(x)           SWAPENDIAN_16(x)
 303:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 304:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion between a Big Endian encoded 32-bit piece of data and the
 305:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  Endianness of the currently selected CPU architecture.
 306:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 307:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 308:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 309:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 310:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref be32_to_cpu instead.
 311:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 312:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 313:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 314:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 315:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 316:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 317:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 318:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define BE32_TO_CPU(x)           SWAPENDIAN_32(x)
 319:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 320:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 321:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 322:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 323:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 324:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 325:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 326:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_le16 instead.
 327:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 328:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 329:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 330:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 331:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 332:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 333:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 334:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_LE16(x)           (x)
 335:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 336:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 337:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Little Endian format regardless of the currently selected CPU architecture.
 338:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 339:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On little endian architectures, this macro does nothing.
 340:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 341:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 342:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_le32 instead.
 343:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 344:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 345:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 346:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 347:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 348:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 349:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 350:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_LE32(x)           (x)
 351:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 352:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 16-bit piece of data to ensure that it
 353:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 354:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 355:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 356:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 357:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 358:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_be16 instead.
 359:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 360:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 361:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 362:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 363:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 364:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 365:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 366:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_BE16(x)           SWAPENDIAN_16(x)
 367:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 368:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				/** Performs a conversion on a natively encoded 32-bit piece of data to ensure that it
 369:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  is in Big Endian format regardless of the currently selected CPU architecture.
 370:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 371:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  On big endian architectures, this macro does nothing.
 372:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 373:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \note This macro is designed for compile-time conversion of data - for run-time endianness
 374:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *        conversion, use \ref cpu_to_be32 instead.
 375:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 376:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \ingroup Group_EndianConversion
 377:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 378:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \param[in] x  Data to perform the endianness conversion on.
 379:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *
 380:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 *  \return Endian corrected version of the input value.
 381:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				 */
 382:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				#define CPU_TO_BE32(x)           SWAPENDIAN_32(x)
 383:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 384:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				//! @}
 385:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			#endif
 386:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 387:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 		/* Inline Functions: */
 388:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			/** Function to reverse the byte ordering of the individual bytes in a 16 bit value.
 389:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 390:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
 391:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 392:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \param[in] Word  Word of data whose bytes are to be swapped.
 393:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 394:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \return Input data with the individual bytes reversed.
 395:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 */
 396:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
 397:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			static inline uint16_t SwapEndian_16(const uint16_t Word)
 398:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			{
 399:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				if (GCC_IS_COMPILE_CONST(Word))
 400:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				  return SWAPENDIAN_16(Word);
 401:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			
 402:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				uint8_t Temp;
 403:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 404:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				union
 405:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				{
 406:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 					uint16_t Word;
 407:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 					uint8_t  Bytes[2];
 408:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				} Data;
 409:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 410:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Word = Word;
 411:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 412:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Temp = Data.Bytes[0];
 413:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Bytes[0] = Data.Bytes[1];
 414:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Bytes[1] = Temp;
 415:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 416:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				return Data.Word;
 417:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			}
 418:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 419:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			/** Function to reverse the byte ordering of the individual bytes in a 32 bit value.
 420:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 421:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \ingroup Group_ByteSwapping
 422:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 423:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \param[in] DWord  Double word of data whose bytes are to be swapped.
 424:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *
 425:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 *  \return Input data with the individual bytes reversed.
 426:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			 */
 427:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
 428:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			static inline uint32_t SwapEndian_32(const uint32_t DWord)
 429:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			{
  16               		.loc 1 429 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23 0000 9B01      		movw r18,r22
 430:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				if (GCC_IS_COMPILE_CONST(DWord))
 431:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				  return SWAPENDIAN_32(DWord);
 432:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 433:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				uint8_t Temp;
 434:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 435:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				union
 436:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				{
 437:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 					uint32_t DWord;
 438:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 					uint8_t  Bytes[4];
 439:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				} Data;
 440:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 441:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.DWord = DWord;
 442:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 443:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Temp = Data.Bytes[0];
 444:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Bytes[0] = Data.Bytes[3];
 445:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Bytes[3] = Temp;
 446:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 447:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Temp = Data.Bytes[1];
 448:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Bytes[1] = Data.Bytes[2];
 449:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				Data.Bytes[2] = Temp;
 450:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
 451:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				return Data.DWord;
 452:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 			}
  24               		.loc 1 452 0
  25 0002 692F      		mov r22,r25
  26               	.LVL1:
  27 0004 782F      		mov r23,r24
  28 0006 832F      		mov r24,r19
  29 0008 922F      		mov r25,r18
  30 000a 0895      		ret
  31               		.cfi_endproc
  32               	.LFE8:
  34               		.section	.text.SwapEndian_16,"ax",@progbits
  36               	SwapEndian_16:
  37               	.LFB7:
 398:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 				if (GCC_IS_COMPILE_CONST(Word))
  38               		.loc 1 398 0
  39               		.cfi_startproc
  40               	.LVL2:
  41               	/* prologue: function */
  42               	/* frame size = 0 */
  43               	/* stack size = 0 */
  44               	.L__stack_usage = 0
  45 0000 282F      		mov r18,r24
  46 0002 892F      		mov r24,r25
  47               	.LVL3:
 417:../../../../LUFA/Drivers/USB/Class/Device/../../../../Common/Endianness.h **** 
  48               		.loc 1 417 0
  49 0004 922F      		mov r25,r18
  50 0006 0895      		ret
  51               		.cfi_endproc
  52               	.LFE7:
  54               		.section	.text.TCP_Checksum16,"ax",@progbits
  56               	TCP_Checksum16:
  57               	.LFB112:
  58               		.file 2 "Lib/TCP.c"
   1:Lib/TCP.c     **** /*
   2:Lib/TCP.c     ****              LUFA Library
   3:Lib/TCP.c     ****      Copyright (C) Dean Camera, 2011.
   4:Lib/TCP.c     **** 
   5:Lib/TCP.c     ****   dean [at] fourwalledcubicle [dot] com
   6:Lib/TCP.c     ****            www.lufa-lib.org
   7:Lib/TCP.c     **** */
   8:Lib/TCP.c     **** 
   9:Lib/TCP.c     **** /*
  10:Lib/TCP.c     ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Lib/TCP.c     **** 
  12:Lib/TCP.c     ****   Permission to use, copy, modify, distribute, and sell this
  13:Lib/TCP.c     ****   software and its documentation for any purpose is hereby granted
  14:Lib/TCP.c     ****   without fee, provided that the above copyright notice appear in
  15:Lib/TCP.c     ****   all copies and that both that the copyright notice and this
  16:Lib/TCP.c     ****   permission notice and warranty disclaimer appear in supporting
  17:Lib/TCP.c     ****   documentation, and that the name of the author not be used in
  18:Lib/TCP.c     ****   advertising or publicity pertaining to distribution of the
  19:Lib/TCP.c     ****   software without specific, written prior permission.
  20:Lib/TCP.c     **** 
  21:Lib/TCP.c     ****   The author disclaim all warranties with regard to this
  22:Lib/TCP.c     ****   software, including all implied warranties of merchantability
  23:Lib/TCP.c     ****   and fitness.  In no event shall the author be liable for any
  24:Lib/TCP.c     ****   special, indirect or consequential damages or any damages
  25:Lib/TCP.c     ****   whatsoever resulting from loss of use, data or profits, whether
  26:Lib/TCP.c     ****   in an action of contract, negligence or other tortious action,
  27:Lib/TCP.c     ****   arising out of or in connection with the use or performance of
  28:Lib/TCP.c     ****   this software.
  29:Lib/TCP.c     **** */
  30:Lib/TCP.c     **** 
  31:Lib/TCP.c     **** /** \file
  32:Lib/TCP.c     ****  *
  33:Lib/TCP.c     ****  *  Transmission Control Protocol (TCP) packet handling routines. This protocol handles the reliabl
  34:Lib/TCP.c     ****  *  and reception of packets to and from devices on a network, to "ports" on the device. It is used
  35:Lib/TCP.c     ****  *  delivery must be reliable and correct, e.g. HTTP, TELNET and most other non-streaming protocols
  36:Lib/TCP.c     ****  */
  37:Lib/TCP.c     **** 
  38:Lib/TCP.c     **** #define  INCLUDE_FROM_TCP_C
  39:Lib/TCP.c     **** #include "TCP.h"
  40:Lib/TCP.c     **** 
  41:Lib/TCP.c     **** /** Port state table array. This contains the current status of TCP ports in the device. To save on
  42:Lib/TCP.c     ****  *  stored - closed ports may be overwritten at any time, and the system will assume any ports not 
  43:Lib/TCP.c     ****  *  allows for MAX_OPEN_TCP_PORTS to be less than the number of ports used by the application if de
  44:Lib/TCP.c     ****  */
  45:Lib/TCP.c     **** TCP_PortState_t        PortStateTable[MAX_OPEN_TCP_PORTS];
  46:Lib/TCP.c     **** 
  47:Lib/TCP.c     **** /** Connection state table array. This contains the current status of TCP connections in the device
  48:Lib/TCP.c     ****  *  (non-closed) connections are stored - closed connections may be overwritten at any time, and th
  49:Lib/TCP.c     ****  *  not present in the array are closed.
  50:Lib/TCP.c     ****  */
  51:Lib/TCP.c     **** TCP_ConnectionState_t  ConnectionStateTable[MAX_TCP_CONNECTIONS];
  52:Lib/TCP.c     **** 
  53:Lib/TCP.c     **** 
  54:Lib/TCP.c     **** /** Task to handle the calling of each registered application's callback function, to process and g
  55:Lib/TCP.c     ****  *  level. If an application produces a response, this task constructs the appropriate Ethernet fra
  56:Lib/TCP.c     ****  *  buffer for later transmission.
  57:Lib/TCP.c     ****  */
  58:Lib/TCP.c     **** void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
  59:Lib/TCP.c     **** 		         Ethernet_Frame_Info_t* const FrameOUT)
  60:Lib/TCP.c     **** {
  61:Lib/TCP.c     **** 	/* Run each application in sequence, to process incoming and generate outgoing packets */
  62:Lib/TCP.c     **** 	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
  63:Lib/TCP.c     **** 	{
  64:Lib/TCP.c     **** 		/* Find the corresponding port entry in the port table */
  65:Lib/TCP.c     **** 		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
  66:Lib/TCP.c     **** 		{
  67:Lib/TCP.c     **** 			/* Run the application handler for the port */
  68:Lib/TCP.c     **** 			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
  69:Lib/TCP.c     **** 			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
  70:Lib/TCP.c     **** 			{
  71:Lib/TCP.c     **** 				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
  72:Lib/TCP.c     **** 				                                               &ConnectionStateTable[CSTableEntry].Info.Buffer)
  73:Lib/TCP.c     **** 			}
  74:Lib/TCP.c     **** 		}
  75:Lib/TCP.c     **** 	}
  76:Lib/TCP.c     **** 
  77:Lib/TCP.c     **** 	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
  78:Lib/TCP.c     **** 	if (FrameOUT->FrameLength)
  79:Lib/TCP.c     **** 	  return;
  80:Lib/TCP.c     **** 
  81:Lib/TCP.c     **** 	/* Send response packets from each application as the TCP packet buffers are filled by the applica
  82:Lib/TCP.c     **** 	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
  83:Lib/TCP.c     **** 	{
  84:Lib/TCP.c     **** 		/* For each completely received packet, pass it along to the listening application */
  85:Lib/TCP.c     **** 		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
  86:Lib/TCP.c     **** 		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
  87:Lib/TCP.c     **** 		{
  88:Lib/TCP.c     **** 			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
  89:Lib/TCP.c     **** 			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Fra
  90:Lib/TCP.c     **** 			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Fr
  91:Lib/TCP.c     **** 			                                                                              sizeof(IP_Header_t
  92:Lib/TCP.c     **** 			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
  93:Lib/TCP.c     **** 			                                                               sizeof(IP_Header_t) +
  94:Lib/TCP.c     **** 			                                                               sizeof(TCP_Header_t)];
  95:Lib/TCP.c     **** 
  96:Lib/TCP.c     **** 			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
  97:Lib/TCP.c     **** 
  98:Lib/TCP.c     **** 			/* Fill out the TCP data */
  99:Lib/TCP.c     **** 			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
 100:Lib/TCP.c     **** 			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
 101:Lib/TCP.c     **** 			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.Seque
 102:Lib/TCP.c     **** 			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.Seque
 103:Lib/TCP.c     **** 			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
 104:Lib/TCP.c     **** 			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
 105:Lib/TCP.c     **** 
 106:Lib/TCP.c     **** 			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
 107:Lib/TCP.c     **** 			TCPHeaderOUT->UrgentPointer        = 0;
 108:Lib/TCP.c     **** 			TCPHeaderOUT->Checksum             = 0;
 109:Lib/TCP.c     **** 			TCPHeaderOUT->Reserved             = 0;
 110:Lib/TCP.c     **** 
 111:Lib/TCP.c     **** 			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
 112:Lib/TCP.c     **** 
 113:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
 114:Lib/TCP.c     **** 
 115:Lib/TCP.c     **** 			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
 116:Lib/TCP.c     **** 			                                                    ConnectionStateTable[CSTableEntry].RemoteAdd
 117:Lib/TCP.c     **** 			                                                    (sizeof(TCP_Header_t) + PacketSize));
 118:Lib/TCP.c     **** 
 119:Lib/TCP.c     **** 			PacketSize += sizeof(TCP_Header_t);
 120:Lib/TCP.c     **** 
 121:Lib/TCP.c     **** 			/* Fill out the response IP header */
 122:Lib/TCP.c     **** 			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
 123:Lib/TCP.c     **** 			IPHeaderOUT->TypeOfService      = 0;
 124:Lib/TCP.c     **** 			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
 125:Lib/TCP.c     **** 			IPHeaderOUT->Version            = 4;
 126:Lib/TCP.c     **** 			IPHeaderOUT->Flags              = 0;
 127:Lib/TCP.c     **** 			IPHeaderOUT->FragmentOffset     = 0;
 128:Lib/TCP.c     **** 			IPHeaderOUT->Identification     = 0;
 129:Lib/TCP.c     **** 			IPHeaderOUT->HeaderChecksum     = 0;
 130:Lib/TCP.c     **** 			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
 131:Lib/TCP.c     **** 			IPHeaderOUT->TTL                = DEFAULT_TTL;
 132:Lib/TCP.c     **** 			IPHeaderOUT->SourceAddress      = ServerIPAddress;
 133:Lib/TCP.c     **** 			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
 134:Lib/TCP.c     **** 
 135:Lib/TCP.c     **** 			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
 136:Lib/TCP.c     **** 
 137:Lib/TCP.c     **** 			PacketSize += sizeof(IP_Header_t);
 138:Lib/TCP.c     **** 
 139:Lib/TCP.c     **** 			/* Fill out the response Ethernet frame header */
 140:Lib/TCP.c     **** 			FrameOUTHeader->Source          = ServerMACAddress;
 141:Lib/TCP.c     **** 			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
 142:Lib/TCP.c     **** 			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
 143:Lib/TCP.c     **** 
 144:Lib/TCP.c     **** 			PacketSize += sizeof(Ethernet_Frame_Header_t);
 145:Lib/TCP.c     **** 
 146:Lib/TCP.c     **** 			/* Set the response length in the buffer and indicate that a response is ready to be sent */
 147:Lib/TCP.c     **** 			FrameOUT->FrameLength           = PacketSize;
 148:Lib/TCP.c     **** 
 149:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
 150:Lib/TCP.c     **** 
 151:Lib/TCP.c     **** 			break;
 152:Lib/TCP.c     **** 		}
 153:Lib/TCP.c     **** 	}
 154:Lib/TCP.c     **** }
 155:Lib/TCP.c     **** 
 156:Lib/TCP.c     **** /** Initializes the TCP protocol handler, clearing the port and connection state tables. This must 
 157:Lib/TCP.c     ****  *  processed.
 158:Lib/TCP.c     ****  */
 159:Lib/TCP.c     **** void TCP_Init(void)
 160:Lib/TCP.c     **** {
 161:Lib/TCP.c     **** 	/* Initialize the port state table with all CLOSED entries */
 162:Lib/TCP.c     **** 	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
 163:Lib/TCP.c     **** 	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
 164:Lib/TCP.c     **** 
 165:Lib/TCP.c     **** 	/* Initialize the connection table with all CLOSED entries */
 166:Lib/TCP.c     **** 	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
 167:Lib/TCP.c     **** 	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
 168:Lib/TCP.c     **** }
 169:Lib/TCP.c     **** 
 170:Lib/TCP.c     **** /** Sets the state and callback handler of the given port, specified in big endian to the given sta
 171:Lib/TCP.c     ****  *
 172:Lib/TCP.c     ****  *  \param[in] Port     Port whose state and callback function to set, specified in big endian
 173:Lib/TCP.c     ****  *  \param[in] State    New state of the port, a value from the \ref TCP_PortStates_t enum
 174:Lib/TCP.c     ****  *  \param[in] Handler  Application callback handler for the port
 175:Lib/TCP.c     ****  *
 176:Lib/TCP.c     ****  *  \return Boolean true if the port state was set, false otherwise (no more space in the port stat
 177:Lib/TCP.c     ****  */
 178:Lib/TCP.c     **** bool TCP_SetPortState(const uint16_t Port,
 179:Lib/TCP.c     ****                       const uint8_t State,
 180:Lib/TCP.c     ****                       void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
 181:Lib/TCP.c     **** {
 182:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 183:Lib/TCP.c     **** 
 184:Lib/TCP.c     **** 	/* Check to see if the port entry is already in the port state table */
 185:Lib/TCP.c     **** 	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
 186:Lib/TCP.c     **** 	{
 187:Lib/TCP.c     **** 		/* Find existing entry for the port in the table, update it if found */
 188:Lib/TCP.c     **** 		if (PortStateTable[PTableEntry].Port == Port)
 189:Lib/TCP.c     **** 		{
 190:Lib/TCP.c     **** 			PortStateTable[PTableEntry].State = State;
 191:Lib/TCP.c     **** 			PortStateTable[PTableEntry].ApplicationHandler = Handler;
 192:Lib/TCP.c     **** 			return true;
 193:Lib/TCP.c     **** 		}
 194:Lib/TCP.c     **** 	}
 195:Lib/TCP.c     **** 
 196:Lib/TCP.c     **** 	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace 
 197:Lib/TCP.c     **** 	if (State == TCP_Port_Open)
 198:Lib/TCP.c     **** 	{
 199:Lib/TCP.c     **** 		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
 200:Lib/TCP.c     **** 		{
 201:Lib/TCP.c     **** 			/* Find a closed port entry in the table, change it to the given port and state */
 202:Lib/TCP.c     **** 			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
 203:Lib/TCP.c     **** 			{
 204:Lib/TCP.c     **** 				PortStateTable[PTableEntry].Port  = Port;
 205:Lib/TCP.c     **** 				PortStateTable[PTableEntry].State = State;
 206:Lib/TCP.c     **** 				PortStateTable[PTableEntry].ApplicationHandler = Handler;
 207:Lib/TCP.c     **** 				return true;
 208:Lib/TCP.c     **** 			}
 209:Lib/TCP.c     **** 		}
 210:Lib/TCP.c     **** 
 211:Lib/TCP.c     **** 		/* Port not in table and no room to add it, return failure */
 212:Lib/TCP.c     **** 		return false;
 213:Lib/TCP.c     **** 	}
 214:Lib/TCP.c     **** 	else
 215:Lib/TCP.c     **** 	{
 216:Lib/TCP.c     **** 		/* Port not in table but trying to close it, so operation successful */
 217:Lib/TCP.c     **** 		return true;
 218:Lib/TCP.c     **** 	}
 219:Lib/TCP.c     **** }
 220:Lib/TCP.c     **** 
 221:Lib/TCP.c     **** /** Retrieves the current state of a given TCP port, specified in big endian.
 222:Lib/TCP.c     ****  *
 223:Lib/TCP.c     ****  *  \param[in] Port  TCP port whose state is to be retrieved, given in big-endian
 224:Lib/TCP.c     ****  *
 225:Lib/TCP.c     ****  *  \return A value from the \ref TCP_PortStates_t enum
 226:Lib/TCP.c     ****  */
 227:Lib/TCP.c     **** uint8_t TCP_GetPortState(const uint16_t Port)
 228:Lib/TCP.c     **** {
 229:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 230:Lib/TCP.c     **** 
 231:Lib/TCP.c     **** 	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
 232:Lib/TCP.c     **** 	{
 233:Lib/TCP.c     **** 		/* Find existing entry for the port in the table, return the port status if found */
 234:Lib/TCP.c     **** 		if (PortStateTable[PTableEntry].Port == Port)
 235:Lib/TCP.c     **** 		  return PortStateTable[PTableEntry].State;
 236:Lib/TCP.c     **** 	}
 237:Lib/TCP.c     **** 
 238:Lib/TCP.c     **** 	/* Port not in table, assume closed */
 239:Lib/TCP.c     **** 	return TCP_Port_Closed;
 240:Lib/TCP.c     **** }
 241:Lib/TCP.c     **** 
 242:Lib/TCP.c     **** /** Sets the connection state of the given port, remote address and remote port to the given TCP co
 243:Lib/TCP.c     ****  *  connection exists in the connection state table it is updated, otherwise it is created if possi
 244:Lib/TCP.c     ****  *
 245:Lib/TCP.c     ****  *  \param[in] Port           TCP port of the connection on the device, specified in big endian
 246:Lib/TCP.c     ****  *  \param[in] RemoteAddress  Remote protocol IP address of the connected device
 247:Lib/TCP.c     ****  *  \param[in] RemotePort     TCP port of the remote device in the connection, specified in big end
 248:Lib/TCP.c     ****  *  \param[in] State          TCP connection state, a value from the \ref TCP_ConnectionStates_t en
 249:Lib/TCP.c     ****  *
 250:Lib/TCP.c     ****  *  \return Boolean true if the connection was updated or created, false otherwise (no more space i
 251:Lib/TCP.c     ****  */
 252:Lib/TCP.c     **** bool TCP_SetConnectionState(const uint16_t Port,
 253:Lib/TCP.c     ****                             const IP_Address_t RemoteAddress,
 254:Lib/TCP.c     ****                             const uint16_t RemotePort,
 255:Lib/TCP.c     ****                             const uint8_t State)
 256:Lib/TCP.c     **** {
 257:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 258:Lib/TCP.c     **** 
 259:Lib/TCP.c     **** 	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
 260:Lib/TCP.c     **** 	{
 261:Lib/TCP.c     **** 		/* Find port entry in the table */
 262:Lib/TCP.c     **** 		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
 263:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 264:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 265:Lib/TCP.c     **** 		{
 266:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].State = State;
 267:Lib/TCP.c     **** 			return true;
 268:Lib/TCP.c     **** 		}
 269:Lib/TCP.c     **** 	}
 270:Lib/TCP.c     **** 
 271:Lib/TCP.c     **** 	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
 272:Lib/TCP.c     **** 	{
 273:Lib/TCP.c     **** 		/* Find empty entry in the table */
 274:Lib/TCP.c     **** 		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
 275:Lib/TCP.c     **** 		{
 276:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].Port          = Port;
 277:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
 278:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
 279:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].State         = State;
 280:Lib/TCP.c     **** 			return true;
 281:Lib/TCP.c     **** 		}
 282:Lib/TCP.c     **** 	}
 283:Lib/TCP.c     **** 
 284:Lib/TCP.c     **** 	return false;
 285:Lib/TCP.c     **** }
 286:Lib/TCP.c     **** 
 287:Lib/TCP.c     **** /** Retrieves the current state of a given TCP connection to a host.
 288:Lib/TCP.c     ****  *
 289:Lib/TCP.c     ****  *  \param[in] Port           TCP port on the device in the connection, specified in big endian
 290:Lib/TCP.c     ****  *  \param[in] RemoteAddress  Remote protocol IP address of the connected host
 291:Lib/TCP.c     ****  *  \param[in] RemotePort     Remote TCP port of the connected host, specified in big endian
 292:Lib/TCP.c     ****  *
 293:Lib/TCP.c     ****  *  \return A value from the \ref TCP_ConnectionStates_t enum
 294:Lib/TCP.c     ****  */
 295:Lib/TCP.c     **** uint8_t TCP_GetConnectionState(const uint16_t Port,
 296:Lib/TCP.c     ****                                const IP_Address_t RemoteAddress,
 297:Lib/TCP.c     ****                                const uint16_t RemotePort)
 298:Lib/TCP.c     **** {
 299:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 300:Lib/TCP.c     **** 
 301:Lib/TCP.c     **** 	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
 302:Lib/TCP.c     **** 	{
 303:Lib/TCP.c     **** 		/* Find port entry in the table */
 304:Lib/TCP.c     **** 		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
 305:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 306:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 307:Lib/TCP.c     **** 
 308:Lib/TCP.c     **** 		{
 309:Lib/TCP.c     **** 			return ConnectionStateTable[CSTableEntry].State;
 310:Lib/TCP.c     **** 		}
 311:Lib/TCP.c     **** 	}
 312:Lib/TCP.c     **** 
 313:Lib/TCP.c     **** 	return TCP_Connection_Closed;
 314:Lib/TCP.c     **** }
 315:Lib/TCP.c     **** 
 316:Lib/TCP.c     **** /** Retrieves the connection info structure of a given connection to a host.
 317:Lib/TCP.c     ****  *
 318:Lib/TCP.c     ****  *  \param[in] Port           TCP port on the device in the connection, specified in big endian
 319:Lib/TCP.c     ****  *  \param[in] RemoteAddress  Remote protocol IP address of the connected host
 320:Lib/TCP.c     ****  *  \param[in] RemotePort     Remote TCP port of the connected host, specified in big endian
 321:Lib/TCP.c     ****  *
 322:Lib/TCP.c     ****  *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 323:Lib/TCP.c     ****  */
 324:Lib/TCP.c     **** TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
 325:Lib/TCP.c     ****                                             const IP_Address_t RemoteAddress,
 326:Lib/TCP.c     ****                                             const uint16_t RemotePort)
 327:Lib/TCP.c     **** {
 328:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 329:Lib/TCP.c     **** 
 330:Lib/TCP.c     **** 	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
 331:Lib/TCP.c     **** 	{
 332:Lib/TCP.c     **** 		/* Find port entry in the table */
 333:Lib/TCP.c     **** 		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
 334:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 335:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 336:Lib/TCP.c     **** 		{
 337:Lib/TCP.c     **** 			return &ConnectionStateTable[CSTableEntry].Info;
 338:Lib/TCP.c     **** 		}
 339:Lib/TCP.c     **** 	}
 340:Lib/TCP.c     **** 
 341:Lib/TCP.c     **** 	return NULL;
 342:Lib/TCP.c     **** }
 343:Lib/TCP.c     **** 
 344:Lib/TCP.c     **** /** Processes a TCP packet inside an Ethernet frame, and writes the appropriate response
 345:Lib/TCP.c     ****  *  to the output Ethernet frame if one is created by a application handler.
 346:Lib/TCP.c     ****  *
 347:Lib/TCP.c     ****  *  \param[in] IPHeaderInStart     Pointer to the start of the incoming packet's IP header
 348:Lib/TCP.c     ****  *  \param[in] TCPHeaderInStart    Pointer to the start of the incoming packet's TCP header
 349:Lib/TCP.c     ****  *  \param[out] TCPHeaderOutStart  Pointer to the start of the outgoing packet's TCP header
 350:Lib/TCP.c     ****  *
 351:Lib/TCP.c     ****  *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE if no
 352:Lib/TCP.c     ****  *           response was generated, NO_PROCESS if the packet processing was deferred until the
 353:Lib/TCP.c     ****  *           next Ethernet packet handler iteration
 354:Lib/TCP.c     ****  */
 355:Lib/TCP.c     **** int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
 356:Lib/TCP.c     ****                              void* TCPHeaderInStart,
 357:Lib/TCP.c     ****                              void* TCPHeaderOutStart)
 358:Lib/TCP.c     **** {
 359:Lib/TCP.c     **** 	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
 360:Lib/TCP.c     **** 	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
 361:Lib/TCP.c     **** 	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
 362:Lib/TCP.c     **** 
 363:Lib/TCP.c     **** 	TCP_ConnectionInfo_t* ConnectionInfo;
 364:Lib/TCP.c     **** 
 365:Lib/TCP.c     **** 	DecodeTCPHeader(TCPHeaderInStart);
 366:Lib/TCP.c     **** 
 367:Lib/TCP.c     **** 	bool PacketResponse = false;
 368:Lib/TCP.c     **** 
 369:Lib/TCP.c     **** 	/* Check if the destination port is open and allows incoming connections */
 370:Lib/TCP.c     **** 	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
 371:Lib/TCP.c     **** 	{
 372:Lib/TCP.c     **** 		/* Detect SYN from host to start a connection */
 373:Lib/TCP.c     **** 		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
 374:Lib/TCP.c     **** 		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->So
 375:Lib/TCP.c     **** 
 376:Lib/TCP.c     **** 		/* Detect RST from host to abort existing connection */
 377:Lib/TCP.c     **** 		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
 378:Lib/TCP.c     **** 		{
 379:Lib/TCP.c     **** 			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 380:Lib/TCP.c     **** 			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
 381:Lib/TCP.c     **** 			{
 382:Lib/TCP.c     **** 				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
 383:Lib/TCP.c     **** 				PacketResponse = true;
 384:Lib/TCP.c     **** 			}
 385:Lib/TCP.c     **** 		}
 386:Lib/TCP.c     **** 		else
 387:Lib/TCP.c     **** 		{
 388:Lib/TCP.c     **** 			/* Process the incoming TCP packet based on the current connection state for the sender and port
 389:Lib/TCP.c     **** 			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeade
 390:Lib/TCP.c     **** 			{
 391:Lib/TCP.c     **** 				case TCP_Connection_Listen:
 392:Lib/TCP.c     **** 					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
 393:Lib/TCP.c     **** 					{
 394:Lib/TCP.c     **** 						/* SYN connection starts a connection with a peer */
 395:Lib/TCP.c     **** 						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 396:Lib/TCP.c     **** 						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
 397:Lib/TCP.c     **** 						{
 398:Lib/TCP.c     **** 							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
 399:Lib/TCP.c     **** 
 400:Lib/TCP.c     **** 							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddre
 401:Lib/TCP.c     **** 
 402:Lib/TCP.c     **** 							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
 403:Lib/TCP.c     **** 							ConnectionInfo->SequenceNumberOut = 0;
 404:Lib/TCP.c     **** 							ConnectionInfo->Buffer.InUse      = false;
 405:Lib/TCP.c     **** 						}
 406:Lib/TCP.c     **** 						else
 407:Lib/TCP.c     **** 						{
 408:Lib/TCP.c     **** 							TCPHeaderOUT->Flags = TCP_FLAG_RST;
 409:Lib/TCP.c     **** 						}
 410:Lib/TCP.c     **** 
 411:Lib/TCP.c     **** 						PacketResponse      = true;
 412:Lib/TCP.c     **** 					}
 413:Lib/TCP.c     **** 
 414:Lib/TCP.c     **** 					break;
 415:Lib/TCP.c     **** 				case TCP_Connection_SYNReceived:
 416:Lib/TCP.c     **** 					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
 417:Lib/TCP.c     **** 					{
 418:Lib/TCP.c     **** 						/* ACK during the connection process completes the connection to a peer */
 419:Lib/TCP.c     **** 
 420:Lib/TCP.c     **** 						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 421:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_Established);
 422:Lib/TCP.c     **** 
 423:Lib/TCP.c     **** 						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddres
 424:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 425:Lib/TCP.c     **** 
 426:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberOut++;
 427:Lib/TCP.c     **** 					}
 428:Lib/TCP.c     **** 
 429:Lib/TCP.c     **** 					break;
 430:Lib/TCP.c     **** 				case TCP_Connection_Established:
 431:Lib/TCP.c     **** 					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
 432:Lib/TCP.c     **** 					{
 433:Lib/TCP.c     **** 						/* FIN ACK when connected to a peer starts the finalization process */
 434:Lib/TCP.c     **** 
 435:Lib/TCP.c     **** 						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
 436:Lib/TCP.c     **** 						PacketResponse      = true;
 437:Lib/TCP.c     **** 
 438:Lib/TCP.c     **** 						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 439:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);
 440:Lib/TCP.c     **** 
 441:Lib/TCP.c     **** 						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddres
 442:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 443:Lib/TCP.c     **** 
 444:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberIn++;
 445:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberOut++;
 446:Lib/TCP.c     **** 					}
 447:Lib/TCP.c     **** 					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FL
 448:Lib/TCP.c     **** 					{
 449:Lib/TCP.c     **** 						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddres
 450:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 451:Lib/TCP.c     **** 
 452:Lib/TCP.c     **** 						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
 453:Lib/TCP.c     **** 						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
 454:Lib/TCP.c     **** 						{
 455:Lib/TCP.c     **** 							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
 456:Lib/TCP.c     **** 							ConnectionInfo->Buffer.InUse     = true;
 457:Lib/TCP.c     **** 							ConnectionInfo->Buffer.Length    = 0;
 458:Lib/TCP.c     **** 						}
 459:Lib/TCP.c     **** 
 460:Lib/TCP.c     **** 						/* Check if the buffer has been claimed by us to read in data from the peer */
 461:Lib/TCP.c     **** 						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
 462:Lib/TCP.c     **** 							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
 463:Lib/TCP.c     **** 						{
 464:Lib/TCP.c     **** 							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
 465:Lib/TCP.c     **** 							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
 466:Lib/TCP.c     **** 							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
 467:Lib/TCP.c     **** 
 468:Lib/TCP.c     **** 							/* Copy the packet data into the buffer */
 469:Lib/TCP.c     **** 							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
 470:Lib/TCP.c     **** 								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
 471:Lib/TCP.c     **** 								   DataLength);
 472:Lib/TCP.c     **** 
 473:Lib/TCP.c     **** 							ConnectionInfo->SequenceNumberIn += DataLength;
 474:Lib/TCP.c     **** 							ConnectionInfo->Buffer.Length    += DataLength;
 475:Lib/TCP.c     **** 
 476:Lib/TCP.c     **** 							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
 477:Lib/TCP.c     **** 							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_P
 478:Lib/TCP.c     **** 							{
 479:Lib/TCP.c     **** 								ConnectionInfo->Buffer.InUse = false;
 480:Lib/TCP.c     **** 								ConnectionInfo->Buffer.Ready = true;
 481:Lib/TCP.c     **** 
 482:Lib/TCP.c     **** 								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
 483:Lib/TCP.c     **** 								PacketResponse      = true;
 484:Lib/TCP.c     **** 							}
 485:Lib/TCP.c     **** 						}
 486:Lib/TCP.c     **** 						else
 487:Lib/TCP.c     **** 						{
 488:Lib/TCP.c     **** 							/* Buffer is currently in use by the application, defer processing of the incoming packet */
 489:Lib/TCP.c     **** 							return NO_PROCESS;
 490:Lib/TCP.c     **** 						}
 491:Lib/TCP.c     **** 					}
 492:Lib/TCP.c     **** 
 493:Lib/TCP.c     **** 					break;
 494:Lib/TCP.c     **** 				case TCP_Connection_Closing:
 495:Lib/TCP.c     **** 						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddres
 496:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 497:Lib/TCP.c     **** 
 498:Lib/TCP.c     **** 						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
 499:Lib/TCP.c     **** 						PacketResponse      = true;
 500:Lib/TCP.c     **** 
 501:Lib/TCP.c     **** 						ConnectionInfo->Buffer.InUse = false;
 502:Lib/TCP.c     **** 
 503:Lib/TCP.c     **** 						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 504:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);
 505:Lib/TCP.c     **** 
 506:Lib/TCP.c     **** 					break;
 507:Lib/TCP.c     **** 				case TCP_Connection_FINWait1:
 508:Lib/TCP.c     **** 					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
 509:Lib/TCP.c     **** 					{
 510:Lib/TCP.c     **** 						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddres
 511:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 512:Lib/TCP.c     **** 
 513:Lib/TCP.c     **** 						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
 514:Lib/TCP.c     **** 						PacketResponse      = true;
 515:Lib/TCP.c     **** 
 516:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberIn++;
 517:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberOut++;
 518:Lib/TCP.c     **** 
 519:Lib/TCP.c     **** 						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 520:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
 521:Lib/TCP.c     **** 					}
 522:Lib/TCP.c     **** 					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
 523:Lib/TCP.c     **** 					{
 524:Lib/TCP.c     **** 						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 525:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
 526:Lib/TCP.c     **** 					}
 527:Lib/TCP.c     **** 
 528:Lib/TCP.c     **** 					break;
 529:Lib/TCP.c     **** 				case TCP_Connection_FINWait2:
 530:Lib/TCP.c     **** 					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
 531:Lib/TCP.c     **** 					{
 532:Lib/TCP.c     **** 						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddres
 533:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 534:Lib/TCP.c     **** 
 535:Lib/TCP.c     **** 						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
 536:Lib/TCP.c     **** 						PacketResponse      = true;
 537:Lib/TCP.c     **** 
 538:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberIn++;
 539:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberOut++;
 540:Lib/TCP.c     **** 
 541:Lib/TCP.c     **** 						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 542:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
 543:Lib/TCP.c     **** 					}
 544:Lib/TCP.c     **** 
 545:Lib/TCP.c     **** 					break;
 546:Lib/TCP.c     **** 				case TCP_Connection_CloseWait:
 547:Lib/TCP.c     **** 					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
 548:Lib/TCP.c     **** 					{
 549:Lib/TCP.c     **** 						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 550:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
 551:Lib/TCP.c     **** 					}
 552:Lib/TCP.c     **** 
 553:Lib/TCP.c     **** 					break;
 554:Lib/TCP.c     **** 			}
 555:Lib/TCP.c     **** 		}
 556:Lib/TCP.c     **** 	}
 557:Lib/TCP.c     **** 	else
 558:Lib/TCP.c     **** 	{
 559:Lib/TCP.c     **** 		/* Port is not open, indicate via a RST/ACK response to the sender */
 560:Lib/TCP.c     **** 		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
 561:Lib/TCP.c     **** 		PacketResponse      = true;
 562:Lib/TCP.c     **** 	}
 563:Lib/TCP.c     **** 
 564:Lib/TCP.c     **** 	/* Check if we need to respond to the sent packet */
 565:Lib/TCP.c     **** 	if (PacketResponse)
 566:Lib/TCP.c     **** 	{
 567:Lib/TCP.c     **** 		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
 568:Lib/TCP.c     **** 		                                       TCPHeaderIN->SourcePort);
 569:Lib/TCP.c     **** 
 570:Lib/TCP.c     **** 		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
 571:Lib/TCP.c     **** 		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
 572:Lib/TCP.c     **** 		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
 573:Lib/TCP.c     **** 		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
 574:Lib/TCP.c     **** 		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
 575:Lib/TCP.c     **** 
 576:Lib/TCP.c     **** 		if (!(ConnectionInfo->Buffer.InUse))
 577:Lib/TCP.c     **** 		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
 578:Lib/TCP.c     **** 		else
 579:Lib/TCP.c     **** 		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Lengt
 580:Lib/TCP.c     **** 
 581:Lib/TCP.c     **** 		TCPHeaderOUT->UrgentPointer        = 0;
 582:Lib/TCP.c     **** 		TCPHeaderOUT->Checksum             = 0;
 583:Lib/TCP.c     **** 		TCPHeaderOUT->Reserved             = 0;
 584:Lib/TCP.c     **** 
 585:Lib/TCP.c     **** 		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
 586:Lib/TCP.c     **** 		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_
 587:Lib/TCP.c     **** 
 588:Lib/TCP.c     **** 		return sizeof(TCP_Header_t);
 589:Lib/TCP.c     **** 	}
 590:Lib/TCP.c     **** 
 591:Lib/TCP.c     **** 	return NO_RESPONSE;
 592:Lib/TCP.c     **** }
 593:Lib/TCP.c     **** 
 594:Lib/TCP.c     **** /** Calculates the appropriate TCP checksum, consisting of the addition of the one's compliment of 
 595:Lib/TCP.c     ****  *  complimented.
 596:Lib/TCP.c     ****  *
 597:Lib/TCP.c     ****  *  \param[in] TCPHeaderOutStart   Pointer to the start of the packet's outgoing TCP header
 598:Lib/TCP.c     ****  *  \param[in] SourceAddress       Source protocol IP address of the outgoing IP header
 599:Lib/TCP.c     ****  *  \param[in] DestinationAddress  Destination protocol IP address of the outgoing IP header
 600:Lib/TCP.c     ****  *  \param[in] TCPOutSize          Size in bytes of the TCP data header and payload
 601:Lib/TCP.c     ****  *
 602:Lib/TCP.c     ****  *  \return A 16-bit TCP checksum value
 603:Lib/TCP.c     ****  */
 604:Lib/TCP.c     **** static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
 605:Lib/TCP.c     ****                                const IP_Address_t SourceAddress,
 606:Lib/TCP.c     ****                                const IP_Address_t DestinationAddress,
 607:Lib/TCP.c     ****                                const uint16_t TCPOutSize)
 608:Lib/TCP.c     **** {
  59               		.loc 2 608 0
  60               		.cfi_startproc
  61               	.LVL4:
  62 0000 8F92      		push r8
  63               	.LCFI0:
  64               		.cfi_def_cfa_offset 3
  65               		.cfi_offset 8, -2
  66 0002 9F92      		push r9
  67               	.LCFI1:
  68               		.cfi_def_cfa_offset 4
  69               		.cfi_offset 9, -3
  70 0004 AF92      		push r10
  71               	.LCFI2:
  72               		.cfi_def_cfa_offset 5
  73               		.cfi_offset 10, -4
  74 0006 BF92      		push r11
  75               	.LCFI3:
  76               		.cfi_def_cfa_offset 6
  77               		.cfi_offset 11, -5
  78 0008 EF92      		push r14
  79               	.LCFI4:
  80               		.cfi_def_cfa_offset 7
  81               		.cfi_offset 14, -6
  82 000a FF92      		push r15
  83               	.LCFI5:
  84               		.cfi_def_cfa_offset 8
  85               		.cfi_offset 15, -7
  86 000c 0F93      		push r16
  87               	.LCFI6:
  88               		.cfi_def_cfa_offset 9
  89               		.cfi_offset 16, -8
  90 000e 1F93      		push r17
  91               	.LCFI7:
  92               		.cfi_def_cfa_offset 10
  93               		.cfi_offset 17, -9
  94 0010 CF93      		push r28
  95               	.LCFI8:
  96               		.cfi_def_cfa_offset 11
  97               		.cfi_offset 28, -10
  98 0012 DF93      		push r29
  99               	.LCFI9:
 100               		.cfi_def_cfa_offset 12
 101               		.cfi_offset 29, -11
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 10 */
 105               	.L__stack_usage = 10
 106 0014 EC01      		movw r28,r24
 107               	.LVL5:
 108 0016 CB01      		movw r24,r22
 109               	.LVL6:
 110 0018 A0E0      		ldi r26,0
 111 001a B0E0      		ldi r27,0
 112 001c 840F      		add r24,r20
 113 001e 951F      		adc r25,r21
 114 0020 A11D      		adc r26,__zero_reg__
 115 0022 B11D      		adc r27,__zero_reg__
 116 0024 9A5F      		subi r25,-6
 117 0026 AF4F      		sbci r26,-1
 118 0028 BF4F      		sbci r27,-1
 119 002a 800F      		add r24,r16
 120 002c 911F      		adc r25,r17
 121 002e A11D      		adc r26,__zero_reg__
 122 0030 B11D      		adc r27,__zero_reg__
 123               	.LVL7:
 609:Lib/TCP.c     **** 	uint32_t Checksum = 0;
 610:Lib/TCP.c     **** 
 611:Lib/TCP.c     **** 	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-
 612:Lib/TCP.c     **** 	   complimented */
 613:Lib/TCP.c     **** 
 614:Lib/TCP.c     **** 	Checksum += ((uint16_t*)&SourceAddress)[0];
 615:Lib/TCP.c     **** 	Checksum += ((uint16_t*)&SourceAddress)[1];
 616:Lib/TCP.c     **** 	Checksum += ((uint16_t*)&DestinationAddress)[0];
 617:Lib/TCP.c     **** 	Checksum += ((uint16_t*)&DestinationAddress)[1];
 618:Lib/TCP.c     **** 	Checksum += SwapEndian_16(PROTOCOL_TCP);
 124               		.loc 2 618 0
 125 0032 4C01      		movw r8,r24
 126 0034 5D01      		movw r10,r26
 127 0036 820E      		add r8,r18
 128 0038 931E      		adc r9,r19
 129 003a A11C      		adc r10,__zero_reg__
 130 003c B11C      		adc r11,__zero_reg__
 131               	.LVL8:
 619:Lib/TCP.c     **** 	Checksum += SwapEndian_16(TCPOutSize);
 132               		.loc 2 619 0
 133 003e C701      		movw r24,r14
 134 0040 0E94 0000 		call SwapEndian_16
 135               	.LVL9:
 136 0044 A501      		movw r20,r10
 137 0046 9401      		movw r18,r8
 138 0048 280F      		add r18,r24
 139 004a 391F      		adc r19,r25
 140 004c 411D      		adc r20,__zero_reg__
 141 004e 511D      		adc r21,__zero_reg__
 142 0050 DA01      		movw r26,r20
 143 0052 C901      		movw r24,r18
 144               	.LVL10:
 145               	.LBB20:
 620:Lib/TCP.c     **** 
 621:Lib/TCP.c     **** 	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
 146               		.loc 2 621 0
 147 0054 A701      		movw r20,r14
 148 0056 5695      		lsr r21
 149 0058 4795      		ror r20
 150 005a FE01      		movw r30,r28
 151 005c 20E0      		ldi r18,0
 152 005e 30E0      		ldi r19,0
 153               	.LVL11:
 154               	.L4:
 155               		.loc 2 621 0 is_stmt 0 discriminator 1
 156 0060 2417      		cp r18,r20
 157 0062 3507      		cpc r19,r21
 158 0064 01F0      		breq .L13
 622:Lib/TCP.c     **** 	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
 159               		.loc 2 622 0 is_stmt 1 discriminator 3
 160 0066 6191      		ld r22,Z+
 161 0068 7191      		ld r23,Z+
 162 006a 860F      		add r24,r22
 163 006c 971F      		adc r25,r23
 164 006e A11D      		adc r26,__zero_reg__
 165 0070 B11D      		adc r27,__zero_reg__
 166               	.LVL12:
 621:Lib/TCP.c     **** 	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
 167               		.loc 2 621 0 discriminator 3
 168 0072 2F5F      		subi r18,-1
 169 0074 3F4F      		sbci r19,-1
 170               	.LVL13:
 171 0076 00C0      		rjmp .L4
 172               	.L13:
 173               	.LBE20:
 623:Lib/TCP.c     **** 
 624:Lib/TCP.c     **** 	if (TCPOutSize & 0x01)
 174               		.loc 2 624 0
 175 0078 E0FE      		sbrs r14,0
 176 007a 00C0      		rjmp .L7
 625:Lib/TCP.c     **** 	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
 177               		.loc 2 625 0
 178 007c 220F      		lsl r18
 179 007e 331F      		rol r19
 180               	.LVL14:
 181 0080 C20F      		add r28,r18
 182 0082 D31F      		adc r29,r19
 183               	.LVL15:
 184 0084 2881      		ld r18,Y
 185 0086 820F      		add r24,r18
 186 0088 911D      		adc r25,__zero_reg__
 187 008a A11D      		adc r26,__zero_reg__
 188 008c B11D      		adc r27,__zero_reg__
 189               	.LVL16:
 190               	.L7:
 626:Lib/TCP.c     **** 
 627:Lib/TCP.c     **** 	while (Checksum & 0xFFFF0000)
 191               		.loc 2 627 0
 192 008e AC01      		movw r20,r24
 193 0090 BD01      		movw r22,r26
 194 0092 4427      		clr r20
 195 0094 5527      		clr r21
 196 0096 452B      		or r20,r21
 197 0098 462B      		or r20,r22
 198 009a 472B      		or r20,r23
 199 009c 01F0      		breq .L14
 628:Lib/TCP.c     **** 	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
 200               		.loc 2 628 0
 201 009e AC01      		movw r20,r24
 202 00a0 BD01      		movw r22,r26
 203 00a2 6627      		clr r22
 204 00a4 7727      		clr r23
 205 00a6 CD01      		movw r24,r26
 206 00a8 AA27      		clr r26
 207 00aa BB27      		clr r27
 208               	.LVL17:
 209 00ac 840F      		add r24,r20
 210 00ae 951F      		adc r25,r21
 211 00b0 A61F      		adc r26,r22
 212 00b2 B71F      		adc r27,r23
 213               	.LVL18:
 214 00b4 00C0      		rjmp .L7
 215               	.L14:
 629:Lib/TCP.c     **** 
 630:Lib/TCP.c     **** 	return ~Checksum;
 216               		.loc 2 630 0
 217 00b6 8095      		com r24
 218 00b8 9095      		com r25
 219               	.LVL19:
 220               	/* epilogue start */
 631:Lib/TCP.c     **** }
 221               		.loc 2 631 0
 222 00ba DF91      		pop r29
 223 00bc CF91      		pop r28
 224 00be 1F91      		pop r17
 225 00c0 0F91      		pop r16
 226               	.LVL20:
 227 00c2 FF90      		pop r15
 228 00c4 EF90      		pop r14
 229               	.LVL21:
 230 00c6 BF90      		pop r11
 231 00c8 AF90      		pop r10
 232 00ca 9F90      		pop r9
 233 00cc 8F90      		pop r8
 234 00ce 0895      		ret
 235               		.cfi_endproc
 236               	.LFE112:
 238               		.section	.rodata
 239               	.LC0:
 240 0000 02        		.byte	2
 241 0001 00        		.byte	0
 242 0002 02        		.byte	2
 243 0003 00        		.byte	0
 244 0004 02        		.byte	2
 245 0005 00        		.byte	0
 246               		.section	.text.TCP_TCPTask,"ax",@progbits
 247               	.global	TCP_TCPTask
 249               	TCP_TCPTask:
 250               	.LFB104:
  60:Lib/TCP.c     **** 	/* Run each application in sequence, to process incoming and generate outgoing packets */
 251               		.loc 2 60 0
 252               		.cfi_startproc
 253               	.LVL22:
 254 0000 4F92      		push r4
 255               	.LCFI10:
 256               		.cfi_def_cfa_offset 3
 257               		.cfi_offset 4, -2
 258 0002 5F92      		push r5
 259               	.LCFI11:
 260               		.cfi_def_cfa_offset 4
 261               		.cfi_offset 5, -3
 262 0004 6F92      		push r6
 263               	.LCFI12:
 264               		.cfi_def_cfa_offset 5
 265               		.cfi_offset 6, -4
 266 0006 7F92      		push r7
 267               	.LCFI13:
 268               		.cfi_def_cfa_offset 6
 269               		.cfi_offset 7, -5
 270 0008 8F92      		push r8
 271               	.LCFI14:
 272               		.cfi_def_cfa_offset 7
 273               		.cfi_offset 8, -6
 274 000a 9F92      		push r9
 275               	.LCFI15:
 276               		.cfi_def_cfa_offset 8
 277               		.cfi_offset 9, -7
 278 000c AF92      		push r10
 279               	.LCFI16:
 280               		.cfi_def_cfa_offset 9
 281               		.cfi_offset 10, -8
 282 000e BF92      		push r11
 283               	.LCFI17:
 284               		.cfi_def_cfa_offset 10
 285               		.cfi_offset 11, -9
 286 0010 CF92      		push r12
 287               	.LCFI18:
 288               		.cfi_def_cfa_offset 11
 289               		.cfi_offset 12, -10
 290 0012 DF92      		push r13
 291               	.LCFI19:
 292               		.cfi_def_cfa_offset 12
 293               		.cfi_offset 13, -11
 294 0014 EF92      		push r14
 295               	.LCFI20:
 296               		.cfi_def_cfa_offset 13
 297               		.cfi_offset 14, -12
 298 0016 FF92      		push r15
 299               	.LCFI21:
 300               		.cfi_def_cfa_offset 14
 301               		.cfi_offset 15, -13
 302 0018 0F93      		push r16
 303               	.LCFI22:
 304               		.cfi_def_cfa_offset 15
 305               		.cfi_offset 16, -14
 306 001a 1F93      		push r17
 307               	.LCFI23:
 308               		.cfi_def_cfa_offset 16
 309               		.cfi_offset 17, -15
 310 001c CF93      		push r28
 311               	.LCFI24:
 312               		.cfi_def_cfa_offset 17
 313               		.cfi_offset 28, -16
 314 001e DF93      		push r29
 315               	.LCFI25:
 316               		.cfi_def_cfa_offset 18
 317               		.cfi_offset 29, -17
 318               	/* prologue: function */
 319               	/* frame size = 0 */
 320               	/* stack size = 16 */
 321               	.L__stack_usage = 16
 322 0020 EB01      		movw r28,r22
 323               	.LVL23:
 324 0022 00E0      		ldi r16,lo8(ConnectionStateTable)
 325 0024 10E0      		ldi r17,hi8(ConnectionStateTable)
 326 0026 80E0      		ldi r24,lo8(ConnectionStateTable+1602)
 327 0028 E82E      		mov r14,r24
 328 002a 80E0      		ldi r24,hi8(ConnectionStateTable+1602)
 329 002c F82E      		mov r15,r24
 330               	.LVL24:
 331               	.L16:
 332               	.LBB21:
 333               	.LBB22:
  68:Lib/TCP.c     **** 			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
 334               		.loc 2 68 0
 335 002e 2091 0000 		lds r18,PortStateTable
 336 0032 3091 0000 		lds r19,PortStateTable+1
 337 0036 F801      		movw r30,r16
 338 0038 8081      		ld r24,Z
 339 003a 9181      		ldd r25,Z+1
 340 003c 2817      		cp r18,r24
 341 003e 3907      		cpc r19,r25
 342 0040 01F4      		brne .L17
  68:Lib/TCP.c     **** 			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
 343               		.loc 2 68 0 is_stmt 0 discriminator 1
 344 0042 8091 0000 		lds r24,PortStateTable+2
 345 0046 8130      		cpi r24,lo8(1)
 346 0048 01F4      		brne .L17
  71:Lib/TCP.c     **** 				                                               &ConnectionStateTable[CSTableEntry].Info.Buffer)
 347               		.loc 2 71 0 is_stmt 1
 348 004a E091 0000 		lds r30,PortStateTable+3
 349 004e F091 0000 		lds r31,PortStateTable+3+1
 350 0052 B801      		movw r22,r16
 351 0054 605F      		subi r22,-16
 352 0056 7F4F      		sbci r23,-1
 353 0058 C801      		movw r24,r16
 354 005a 0995      		icall
 355               	.LVL25:
 356               	.L17:
 357 005c 0A5E      		subi r16,-22
 358 005e 1D4F      		sbci r17,-3
 359               	.LBE22:
  62:Lib/TCP.c     **** 	{
 360               		.loc 2 62 0 discriminator 2
 361 0060 E016      		cp r14,r16
 362 0062 F106      		cpc r15,r17
 363 0064 01F4      		brne .L16
 364               	.LBE21:
  78:Lib/TCP.c     **** 	  return;
 365               		.loc 2 78 0
 366 0066 4E01      		movw r8,r28
 367 0068 F4E2      		ldi r31,36
 368 006a 8F1A      		sub r8,r31
 369 006c FAEF      		ldi r31,-6
 370 006e 9F0A      		sbc r9,r31
 371 0070 F401      		movw r30,r8
 372 0072 8081      		ld r24,Z
 373 0074 9181      		ldd r25,Z+1
 374 0076 892B      		or r24,r25
 375 0078 01F0      		breq .+2
 376 007a 00C0      		rjmp .L15
 377 007c E0E0      		ldi r30,lo8(ConnectionStateTable+530)
 378 007e F0E0      		ldi r31,hi8(ConnectionStateTable+530)
 379 0080 80E0      		ldi r24,0
 380 0082 90E0      		ldi r25,0
 381               	.L22:
 382               	.LVL26:
 383               	.LBB23:
  85:Lib/TCP.c     **** 		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
 384               		.loc 2 85 0
 385 0084 2081      		ld r18,Z
 386 0086 2223      		tst r18
 387 0088 01F4      		brne .+2
 388 008a 00C0      		rjmp .L21
  85:Lib/TCP.c     **** 		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
 389               		.loc 2 85 0 is_stmt 0 discriminator 1
 390 008c 2181      		ldd r18,Z+1
 391 008e 2223      		tst r18
 392 0090 01F4      		brne .+2
 393 0092 00C0      		rjmp .L21
 394               	.LVL27:
 395               	.LBB24:
  96:Lib/TCP.c     **** 
 396               		.loc 2 96 0 is_stmt 1
 397 0094 26E1      		ldi r18,lo8(22)
 398 0096 32E0      		ldi r19,lo8(2)
 399 0098 829F      		mul r24,r18
 400 009a 8001      		movw r16,r0
 401 009c 839F      		mul r24,r19
 402 009e 100D      		add r17,r0
 403 00a0 929F      		mul r25,r18
 404 00a2 100D      		add r17,r0
 405 00a4 1124      		clr r1
 406 00a6 C801      		movw r24,r16
 407               	.LVL28:
 408 00a8 8050      		subi r24,lo8(-(ConnectionStateTable))
 409 00aa 9040      		sbci r25,hi8(-(ConnectionStateTable))
 410 00ac 6C01      		movw r12,r24
 411 00ae FC01      		movw r30,r24
 412 00b0 A088      		ldd r10,Z+16
 413 00b2 B188      		ldd r11,Z+17
 414               	.LVL29:
  99:Lib/TCP.c     **** 			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
 415               		.loc 2 99 0
 416 00b4 8081      		ld r24,Z
 417 00b6 9181      		ldd r25,Z+1
 418 00b8 9BA3      		std Y+35,r25
 419 00ba 8AA3      		std Y+34,r24
 100:Lib/TCP.c     **** 			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.Seque
 420               		.loc 2 100 0
 421 00bc 8281      		ldd r24,Z+2
 422 00be 9381      		ldd r25,Z+3
 423 00c0 9DA3      		std Y+37,r25
 424 00c2 8CA3      		std Y+36,r24
 101:Lib/TCP.c     **** 			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.Seque
 425               		.loc 2 101 0
 426 00c4 6485      		ldd r22,Z+12
 427 00c6 7585      		ldd r23,Z+13
 428 00c8 8685      		ldd r24,Z+14
 429 00ca 9785      		ldd r25,Z+15
 430 00cc 0E94 0000 		call SwapEndian_32
 431               	.LVL30:
 432 00d0 6EA3      		std Y+38,r22
 433 00d2 7FA3      		std Y+39,r23
 434 00d4 88A7      		std Y+40,r24
 435 00d6 99A7      		std Y+41,r25
 102:Lib/TCP.c     **** 			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
 436               		.loc 2 102 0
 437 00d8 F601      		movw r30,r12
 438 00da 6085      		ldd r22,Z+8
 439 00dc 7185      		ldd r23,Z+9
 440 00de 8285      		ldd r24,Z+10
 441 00e0 9385      		ldd r25,Z+11
 442 00e2 0E94 0000 		call SwapEndian_32
 443               	.LVL31:
 444 00e6 6AA7      		std Y+42,r22
 445 00e8 7BA7      		std Y+43,r23
 446 00ea 8CA7      		std Y+44,r24
 447 00ec 9DA7      		std Y+45,r25
 104:Lib/TCP.c     **** 
 448               		.loc 2 104 0
 449 00ee 82E0      		ldi r24,lo8(2)
 450 00f0 90E0      		ldi r25,0
 451 00f2 99AB      		std Y+49,r25
 452 00f4 88AB      		std Y+48,r24
 106:Lib/TCP.c     **** 			TCPHeaderOUT->UrgentPointer        = 0;
 453               		.loc 2 106 0
 454 00f6 80E1      		ldi r24,lo8(16)
 455 00f8 8FA7      		std Y+47,r24
 107:Lib/TCP.c     **** 			TCPHeaderOUT->Checksum             = 0;
 456               		.loc 2 107 0
 457 00fa 1DAA      		std Y+53,__zero_reg__
 458 00fc 1CAA      		std Y+52,__zero_reg__
 108:Lib/TCP.c     **** 			TCPHeaderOUT->Reserved             = 0;
 459               		.loc 2 108 0
 460 00fe 1BAA      		std Y+51,__zero_reg__
 461 0100 1AAA      		std Y+50,__zero_reg__
 109:Lib/TCP.c     **** 
 462               		.loc 2 109 0
 463 0102 80E5      		ldi r24,lo8(80)
 464 0104 8EA7      		std Y+46,r24
 111:Lib/TCP.c     **** 
 465               		.loc 2 111 0
 466 0106 B801      		movw r22,r16
 467 0108 6050      		subi r22,lo8(-(ConnectionStateTable+18))
 468 010a 7040      		sbci r23,hi8(-(ConnectionStateTable+18))
 469 010c A501      		movw r20,r10
 470 010e CE01      		movw r24,r28
 471 0110 C696      		adiw r24,54
 472               	.LVL32:
 473 0112 0E94 0000 		call memcpy
 474               	.LVL33:
 113:Lib/TCP.c     **** 
 475               		.loc 2 113 0
 476 0116 F601      		movw r30,r12
 477 0118 8485      		ldd r24,Z+12
 478 011a 9585      		ldd r25,Z+13
 479 011c A685      		ldd r26,Z+14
 480 011e B785      		ldd r27,Z+15
 481 0120 8A0D      		add r24,r10
 482 0122 9B1D      		adc r25,r11
 483 0124 A11D      		adc r26,__zero_reg__
 484 0126 B11D      		adc r27,__zero_reg__
 485 0128 8487      		std Z+12,r24
 486 012a 9587      		std Z+13,r25
 487 012c A687      		std Z+14,r26
 488 012e B787      		std Z+15,r27
 115:Lib/TCP.c     **** 			                                                    ConnectionStateTable[CSTableEntry].RemoteAdd
 489               		.loc 2 115 0
 490 0130 7501      		movw r14,r10
 491 0132 F4E1      		ldi r31,20
 492 0134 EF0E      		add r14,r31
 493 0136 F11C      		adc r15,__zero_reg__
 494 0138 F601      		movw r30,r12
 495 013a 0481      		ldd r16,Z+4
 496 013c 1581      		ldd r17,Z+5
 497 013e 2681      		ldd r18,Z+6
 498 0140 3781      		ldd r19,Z+7
 499 0142 4090 0000 		lds r4,ServerIPAddress
 500 0146 5090 0000 		lds r5,ServerIPAddress+1
 501 014a 6090 0000 		lds r6,ServerIPAddress+2
 502 014e 7090 0000 		lds r7,ServerIPAddress+3
 503 0152 B301      		movw r22,r6
 504 0154 A201      		movw r20,r4
 505 0156 CE01      		movw r24,r28
 506 0158 8296      		adiw r24,34
 507               	.LVL34:
 508 015a 0E94 0000 		call TCP_Checksum16
 509               	.LVL35:
 510 015e 9BAB      		std Y+51,r25
 511 0160 8AAB      		std Y+50,r24
 512               	.LVL36:
 122:Lib/TCP.c     **** 			IPHeaderOUT->TypeOfService      = 0;
 513               		.loc 2 122 0
 514 0162 C501      		movw r24,r10
 515 0164 8896      		adiw r24,40
 516 0166 0E94 0000 		call SwapEndian_16
 517               	.LVL37:
 518 016a 998B      		std Y+17,r25
 519 016c 888B      		std Y+16,r24
 123:Lib/TCP.c     **** 			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
 520               		.loc 2 123 0
 521 016e 1F86      		std Y+15,__zero_reg__
 125:Lib/TCP.c     **** 			IPHeaderOUT->Flags              = 0;
 522               		.loc 2 125 0
 523 0170 85E4      		ldi r24,lo8(69)
 524 0172 8E87      		std Y+14,r24
 127:Lib/TCP.c     **** 			IPHeaderOUT->Identification     = 0;
 525               		.loc 2 127 0
 526 0174 1C8A      		std Y+20,__zero_reg__
 527 0176 1D8A      		std Y+21,__zero_reg__
 128:Lib/TCP.c     **** 			IPHeaderOUT->HeaderChecksum     = 0;
 528               		.loc 2 128 0
 529 0178 1B8A      		std Y+19,__zero_reg__
 530 017a 1A8A      		std Y+18,__zero_reg__
 129:Lib/TCP.c     **** 			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
 531               		.loc 2 129 0
 532 017c 198E      		std Y+25,__zero_reg__
 533 017e 188E      		std Y+24,__zero_reg__
 130:Lib/TCP.c     **** 			IPHeaderOUT->TTL                = DEFAULT_TTL;
 534               		.loc 2 130 0
 535 0180 16E0      		ldi r17,lo8(6)
 536 0182 1F8B      		std Y+23,r17
 131:Lib/TCP.c     **** 			IPHeaderOUT->SourceAddress      = ServerIPAddress;
 537               		.loc 2 131 0
 538 0184 80E8      		ldi r24,lo8(-128)
 539 0186 8E8B      		std Y+22,r24
 132:Lib/TCP.c     **** 			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
 540               		.loc 2 132 0
 541 0188 4A8E      		std Y+26,r4
 542 018a 5B8E      		std Y+27,r5
 543 018c 6C8E      		std Y+28,r6
 544 018e 7D8E      		std Y+29,r7
 133:Lib/TCP.c     **** 
 545               		.loc 2 133 0
 546 0190 F601      		movw r30,r12
 547 0192 8481      		ldd r24,Z+4
 548 0194 9581      		ldd r25,Z+5
 549 0196 A681      		ldd r26,Z+6
 550 0198 B781      		ldd r27,Z+7
 551 019a 8E8F      		std Y+30,r24
 552 019c 9F8F      		std Y+31,r25
 553 019e A8A3      		std Y+32,r26
 554 01a0 B9A3      		std Y+33,r27
 135:Lib/TCP.c     **** 
 555               		.loc 2 135 0
 556 01a2 64E1      		ldi r22,lo8(20)
 557 01a4 70E0      		ldi r23,0
 558 01a6 CE01      		movw r24,r28
 559 01a8 0E96      		adiw r24,14
 560               	.LVL38:
 561 01aa 0E94 0000 		call Ethernet_Checksum16
 562               	.LVL39:
 563 01ae 998F      		std Y+25,r25
 564 01b0 888F      		std Y+24,r24
 565               	.LVL40:
 140:Lib/TCP.c     **** 			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
 566               		.loc 2 140 0
 567 01b2 E0E0      		ldi r30,lo8(ServerMACAddress)
 568 01b4 F0E0      		ldi r31,hi8(ServerMACAddress)
 569 01b6 DE01      		movw r26,r28
 570 01b8 1696      		adiw r26,6
 571 01ba 812F      		mov r24,r17
 572               		0:
 573 01bc 0190      		ld r0,Z+
 574 01be 0D92      		st X+,r0
 575 01c0 8A95      		dec r24
 576 01c2 01F4      		brne 0b
 141:Lib/TCP.c     **** 			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
 577               		.loc 2 141 0
 578 01c4 E0E0      		ldi r30,lo8(.LC0)
 579 01c6 F0E0      		ldi r31,hi8(.LC0)
 580 01c8 DE01      		movw r26,r28
 581               		0:
 582 01ca 0190      		ld r0,Z+
 583 01cc 0D92      		st X+,r0
 584 01ce 1A95      		dec r17
 585 01d0 01F4      		brne 0b
 142:Lib/TCP.c     **** 
 586               		.loc 2 142 0
 587 01d2 88E0      		ldi r24,lo8(8)
 588 01d4 90E0      		ldi r25,0
 589 01d6 9D87      		std Y+13,r25
 590 01d8 8C87      		std Y+12,r24
 591               	.LVL41:
 147:Lib/TCP.c     **** 
 592               		.loc 2 147 0
 593 01da F6E3      		ldi r31,54
 594 01dc AF0E      		add r10,r31
 595 01de B11C      		adc r11,__zero_reg__
 596               	.LVL42:
 597 01e0 F401      		movw r30,r8
 598 01e2 B182      		std Z+1,r11
 599 01e4 A082      		st Z,r10
 149:Lib/TCP.c     **** 
 600               		.loc 2 149 0
 601 01e6 F601      		movw r30,r12
 602 01e8 ED5E      		subi r30,-19
 603 01ea FD4F      		sbci r31,-3
 604 01ec 1082      		st Z,__zero_reg__
 151:Lib/TCP.c     **** 		}
 605               		.loc 2 151 0
 606 01ee 00C0      		rjmp .L15
 607               	.LVL43:
 608               	.L21:
 609 01f0 0196      		adiw r24,1
 610               	.LVL44:
 611 01f2 EA5E      		subi r30,-22
 612 01f4 FD4F      		sbci r31,-3
 613               	.LBE24:
  82:Lib/TCP.c     **** 	{
 614               		.loc 2 82 0 discriminator 2
 615 01f6 8330      		cpi r24,3
 616 01f8 9105      		cpc r25,__zero_reg__
 617 01fa 01F0      		breq .+2
 618 01fc 00C0      		rjmp .L22
 619               	.LVL45:
 620               	.L15:
 621               	/* epilogue start */
 622               	.LBE23:
 154:Lib/TCP.c     **** 
 623               		.loc 2 154 0
 624 01fe DF91      		pop r29
 625 0200 CF91      		pop r28
 626               	.LVL46:
 627 0202 1F91      		pop r17
 628 0204 0F91      		pop r16
 629 0206 FF90      		pop r15
 630 0208 EF90      		pop r14
 631 020a DF90      		pop r13
 632 020c CF90      		pop r12
 633 020e BF90      		pop r11
 634 0210 AF90      		pop r10
 635 0212 9F90      		pop r9
 636 0214 8F90      		pop r8
 637               	.LVL47:
 638 0216 7F90      		pop r7
 639 0218 6F90      		pop r6
 640 021a 5F90      		pop r5
 641 021c 4F90      		pop r4
 642 021e 0895      		ret
 643               		.cfi_endproc
 644               	.LFE104:
 646               		.section	.text.TCP_Init,"ax",@progbits
 647               	.global	TCP_Init
 649               	TCP_Init:
 650               	.LFB105:
 160:Lib/TCP.c     **** 	/* Initialize the port state table with all CLOSED entries */
 651               		.loc 2 160 0
 652               		.cfi_startproc
 653               	/* prologue: function */
 654               	/* frame size = 0 */
 655               	/* stack size = 0 */
 656               	.L__stack_usage = 0
 657               	.LVL48:
 658               	.LBB25:
 163:Lib/TCP.c     **** 
 659               		.loc 2 163 0
 660 0000 1092 0000 		sts PortStateTable+2,__zero_reg__
 661               	.LVL49:
 662               	.LBE25:
 663               	.LBB26:
 167:Lib/TCP.c     **** }
 664               		.loc 2 167 0
 665 0004 8AE0      		ldi r24,lo8(10)
 666 0006 8093 0000 		sts ConnectionStateTable+533,r24
 667               	.LVL50:
 668 000a 8093 0000 		sts ConnectionStateTable+1067,r24
 669               	.LVL51:
 670 000e 8093 0000 		sts ConnectionStateTable+1601,r24
 671               	.LVL52:
 672 0012 0895      		ret
 673               	.LBE26:
 674               		.cfi_endproc
 675               	.LFE105:
 677               		.section	.text.TCP_SetPortState,"ax",@progbits
 678               	.global	TCP_SetPortState
 680               	TCP_SetPortState:
 681               	.LFB106:
 181:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 682               		.loc 2 181 0
 683               		.cfi_startproc
 684               	.LVL53:
 685               	/* prologue: function */
 686               	/* frame size = 0 */
 687               	/* stack size = 0 */
 688               	.L__stack_usage = 0
 689               	.LBB27:
 188:Lib/TCP.c     **** 		{
 690               		.loc 2 188 0
 691 0000 2091 0000 		lds r18,PortStateTable
 692 0004 3091 0000 		lds r19,PortStateTable+1
 693 0008 2817      		cp r18,r24
 694 000a 3907      		cpc r19,r25
 695 000c 01F0      		breq .L36
 696               	.LVL54:
 697               	.LBE27:
 197:Lib/TCP.c     **** 	{
 698               		.loc 2 197 0
 699 000e 6130      		cpi r22,lo8(1)
 700 0010 01F4      		brne .L34
 701               	.LVL55:
 702               	.LBB28:
 202:Lib/TCP.c     **** 			{
 703               		.loc 2 202 0
 704 0012 2091 0000 		lds r18,PortStateTable+2
 705 0016 2111      		cpse r18,__zero_reg__
 706 0018 00C0      		rjmp .L35
 204:Lib/TCP.c     **** 				PortStateTable[PTableEntry].State = State;
 707               		.loc 2 204 0
 708 001a 9093 0000 		sts PortStateTable+1,r25
 709 001e 8093 0000 		sts PortStateTable,r24
 710               	.LVL56:
 711               	.L36:
 205:Lib/TCP.c     **** 				PortStateTable[PTableEntry].ApplicationHandler = Handler;
 712               		.loc 2 205 0
 713 0022 6093 0000 		sts PortStateTable+2,r22
 206:Lib/TCP.c     **** 				return true;
 714               		.loc 2 206 0
 715 0026 5093 0000 		sts PortStateTable+3+1,r21
 716 002a 4093 0000 		sts PortStateTable+3,r20
 717               	.L34:
 718               	.LBE28:
 217:Lib/TCP.c     **** 	}
 719               		.loc 2 217 0
 720 002e 81E0      		ldi r24,lo8(1)
 721               	.LVL57:
 722 0030 0895      		ret
 723               	.LVL58:
 724               	.L35:
 212:Lib/TCP.c     **** 	}
 725               		.loc 2 212 0
 726 0032 80E0      		ldi r24,0
 727               	.LVL59:
 219:Lib/TCP.c     **** 
 728               		.loc 2 219 0
 729 0034 0895      		ret
 730               		.cfi_endproc
 731               	.LFE106:
 733               		.section	.text.TCP_GetPortState,"ax",@progbits
 734               	.global	TCP_GetPortState
 736               	TCP_GetPortState:
 737               	.LFB107:
 228:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 738               		.loc 2 228 0
 739               		.cfi_startproc
 740               	.LVL60:
 741               	/* prologue: function */
 742               	/* frame size = 0 */
 743               	/* stack size = 0 */
 744               	.L__stack_usage = 0
 745               	.LBB29:
 234:Lib/TCP.c     **** 		  return PortStateTable[PTableEntry].State;
 746               		.loc 2 234 0
 747 0000 2091 0000 		lds r18,PortStateTable
 748 0004 3091 0000 		lds r19,PortStateTable+1
 749 0008 2817      		cp r18,r24
 750 000a 3907      		cpc r19,r25
 751 000c 01F4      		brne .L39
 235:Lib/TCP.c     **** 	}
 752               		.loc 2 235 0
 753 000e 8091 0000 		lds r24,PortStateTable+2
 754               	.LVL61:
 755 0012 0895      		ret
 756               	.LVL62:
 757               	.L39:
 758               	.LBE29:
 239:Lib/TCP.c     **** }
 759               		.loc 2 239 0
 760 0014 80E0      		ldi r24,0
 761               	.LVL63:
 240:Lib/TCP.c     **** 
 762               		.loc 2 240 0
 763 0016 0895      		ret
 764               		.cfi_endproc
 765               	.LFE107:
 767               		.section	.text.TCP_SetConnectionState,"ax",@progbits
 768               	.global	TCP_SetConnectionState
 770               	TCP_SetConnectionState:
 771               	.LFB108:
 256:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 772               		.loc 2 256 0
 773               		.cfi_startproc
 774               	.LVL64:
 775 0000 9F92      		push r9
 776               	.LCFI26:
 777               		.cfi_def_cfa_offset 3
 778               		.cfi_offset 9, -2
 779 0002 AF92      		push r10
 780               	.LCFI27:
 781               		.cfi_def_cfa_offset 4
 782               		.cfi_offset 10, -3
 783 0004 BF92      		push r11
 784               	.LCFI28:
 785               		.cfi_def_cfa_offset 5
 786               		.cfi_offset 11, -4
 787 0006 CF92      		push r12
 788               	.LCFI29:
 789               		.cfi_def_cfa_offset 6
 790               		.cfi_offset 12, -5
 791 0008 DF92      		push r13
 792               	.LCFI30:
 793               		.cfi_def_cfa_offset 7
 794               		.cfi_offset 13, -6
 795 000a EF92      		push r14
 796               	.LCFI31:
 797               		.cfi_def_cfa_offset 8
 798               		.cfi_offset 14, -7
 799 000c FF92      		push r15
 800               	.LCFI32:
 801               		.cfi_def_cfa_offset 9
 802               		.cfi_offset 15, -8
 803 000e 0F93      		push r16
 804               	.LCFI33:
 805               		.cfi_def_cfa_offset 10
 806               		.cfi_offset 16, -9
 807 0010 1F93      		push r17
 808               	.LCFI34:
 809               		.cfi_def_cfa_offset 11
 810               		.cfi_offset 17, -10
 811 0012 CF93      		push r28
 812               	.LCFI35:
 813               		.cfi_def_cfa_offset 12
 814               		.cfi_offset 28, -11
 815 0014 DF93      		push r29
 816               	.LCFI36:
 817               		.cfi_def_cfa_offset 13
 818               		.cfi_offset 29, -12
 819 0016 00D0      		rcall .
 820 0018 00D0      		rcall .
 821               	.LCFI37:
 822               		.cfi_def_cfa_offset 17
 823 001a CDB7      		in r28,__SP_L__
 824 001c DEB7      		in r29,__SP_H__
 825               	.LCFI38:
 826               		.cfi_def_cfa_register 28
 827               	/* prologue: function */
 828               	/* frame size = 4 */
 829               	/* stack size = 15 */
 830               	.L__stack_usage = 15
 831 001e 6C01      		movw r12,r24
 832 0020 4983      		std Y+1,r20
 833 0022 5A83      		std Y+2,r21
 834 0024 6B83      		std Y+3,r22
 835 0026 7C83      		std Y+4,r23
 836 0028 7901      		movw r14,r18
 837 002a 902E      		mov r9,r16
 838               	.LVL65:
 839 002c 00E0      		ldi r16,lo8(ConnectionStateTable)
 840 002e 10E0      		ldi r17,hi8(ConnectionStateTable)
 841               	.LVL66:
 256:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 842               		.loc 2 256 0
 843 0030 A12C      		mov r10,__zero_reg__
 844 0032 B12C      		mov r11,__zero_reg__
 845               	.LVL67:
 846               	.L43:
 847               	.LBB30:
 262:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 848               		.loc 2 262 0
 849 0034 F801      		movw r30,r16
 850 0036 8081      		ld r24,Z
 851 0038 9181      		ldd r25,Z+1
 852 003a 8C15      		cp r24,r12
 853 003c 9D05      		cpc r25,r13
 854 003e 01F4      		brne .L41
 263:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 855               		.loc 2 263 0 discriminator 1
 856 0040 44E0      		ldi r20,lo8(4)
 857 0042 50E0      		ldi r21,0
 858 0044 BE01      		movw r22,r28
 859 0046 6F5F      		subi r22,-1
 860 0048 7F4F      		sbci r23,-1
 861 004a C801      		movw r24,r16
 862 004c 0496      		adiw r24,4
 863 004e 0E94 0000 		call memcmp
 864               	.LVL68:
 262:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 865               		.loc 2 262 0 discriminator 1
 866 0052 892B      		or r24,r25
 867 0054 01F4      		brne .L41
 263:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 868               		.loc 2 263 0
 869 0056 F801      		movw r30,r16
 870 0058 8281      		ldd r24,Z+2
 871 005a 9381      		ldd r25,Z+3
 872 005c 8E15      		cp r24,r14
 873 005e 9F05      		cpc r25,r15
 874 0060 01F4      		brne .L41
 266:Lib/TCP.c     **** 			return true;
 875               		.loc 2 266 0
 876 0062 86E1      		ldi r24,lo8(22)
 877 0064 92E0      		ldi r25,lo8(2)
 878 0066 A89E      		mul r10,r24
 879 0068 F001      		movw r30,r0
 880 006a A99E      		mul r10,r25
 881 006c F00D      		add r31,r0
 882 006e B89E      		mul r11,r24
 883 0070 F00D      		add r31,r0
 884 0072 1124      		clr r1
 885 0074 E050      		subi r30,lo8(-(ConnectionStateTable+533))
 886 0076 F040      		sbci r31,hi8(-(ConnectionStateTable+533))
 887 0078 00C0      		rjmp .L49
 888               	.L41:
 889               	.LVL69:
 890 007a FFEF      		ldi r31,-1
 891 007c AF1A      		sub r10,r31
 892 007e BF0A      		sbc r11,r31
 893               	.LVL70:
 894 0080 0A5E      		subi r16,-22
 895 0082 1D4F      		sbci r17,-3
 259:Lib/TCP.c     **** 	{
 896               		.loc 2 259 0 discriminator 2
 897 0084 83E0      		ldi r24,3
 898 0086 A816      		cp r10,r24
 899 0088 B104      		cpc r11,__zero_reg__
 900 008a 01F4      		brne .L43
 901               	.LVL71:
 902               	.LBE30:
 903               	.LBB31:
 274:Lib/TCP.c     **** 		{
 904               		.loc 2 274 0
 905 008c 8091 0000 		lds r24,ConnectionStateTable+533
 906 0090 8A30      		cpi r24,lo8(10)
 907 0092 01F0      		breq .L45
 908               	.LVL72:
 909 0094 8091 0000 		lds r24,ConnectionStateTable+1067
 910 0098 8A30      		cpi r24,lo8(10)
 911 009a 01F0      		breq .L46
 912               	.LVL73:
 913 009c 8091 0000 		lds r24,ConnectionStateTable+1601
 914 00a0 8A30      		cpi r24,lo8(10)
 915 00a2 01F4      		brne .L47
 916 00a4 82E0      		ldi r24,lo8(2)
 917 00a6 90E0      		ldi r25,0
 918 00a8 00C0      		rjmp .L44
 919               	.LVL74:
 920               	.L45:
 921 00aa 80E0      		ldi r24,0
 922 00ac 90E0      		ldi r25,0
 923 00ae 00C0      		rjmp .L44
 924               	.LVL75:
 925               	.L46:
 926 00b0 81E0      		ldi r24,lo8(1)
 927 00b2 90E0      		ldi r25,0
 928               	.LVL76:
 929               	.L44:
 276:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
 930               		.loc 2 276 0
 931 00b4 26E1      		ldi r18,lo8(22)
 932 00b6 32E0      		ldi r19,lo8(2)
 933 00b8 829F      		mul r24,r18
 934 00ba F001      		movw r30,r0
 935 00bc 839F      		mul r24,r19
 936 00be F00D      		add r31,r0
 937 00c0 929F      		mul r25,r18
 938 00c2 F00D      		add r31,r0
 939 00c4 1124      		clr r1
 940 00c6 E050      		subi r30,lo8(-(ConnectionStateTable))
 941 00c8 F040      		sbci r31,hi8(-(ConnectionStateTable))
 942 00ca D182      		std Z+1,r13
 943 00cc C082      		st Z,r12
 277:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
 944               		.loc 2 277 0
 945 00ce 8981      		ldd r24,Y+1
 946 00d0 9A81      		ldd r25,Y+2
 947 00d2 AB81      		ldd r26,Y+3
 948 00d4 BC81      		ldd r27,Y+4
 949 00d6 8483      		std Z+4,r24
 950 00d8 9583      		std Z+5,r25
 951 00da A683      		std Z+6,r26
 952 00dc B783      		std Z+7,r27
 278:Lib/TCP.c     **** 			ConnectionStateTable[CSTableEntry].State         = State;
 953               		.loc 2 278 0
 954 00de F382      		std Z+3,r15
 955 00e0 E282      		std Z+2,r14
 279:Lib/TCP.c     **** 			return true;
 956               		.loc 2 279 0
 957 00e2 EB5E      		subi r30,-21
 958 00e4 FD4F      		sbci r31,-3
 959               	.LVL77:
 960               	.L49:
 961 00e6 9082      		st Z,r9
 280:Lib/TCP.c     **** 		}
 962               		.loc 2 280 0
 963 00e8 81E0      		ldi r24,lo8(1)
 964 00ea 00C0      		rjmp .L42
 965               	.LVL78:
 966               	.L47:
 967               	.LBE31:
 284:Lib/TCP.c     **** }
 968               		.loc 2 284 0
 969 00ec 80E0      		ldi r24,0
 970               	.LVL79:
 971               	.L42:
 972               	/* epilogue start */
 285:Lib/TCP.c     **** 
 973               		.loc 2 285 0
 974 00ee 0F90      		pop __tmp_reg__
 975 00f0 0F90      		pop __tmp_reg__
 976 00f2 0F90      		pop __tmp_reg__
 977 00f4 0F90      		pop __tmp_reg__
 978 00f6 DF91      		pop r29
 979 00f8 CF91      		pop r28
 980 00fa 1F91      		pop r17
 981 00fc 0F91      		pop r16
 982 00fe FF90      		pop r15
 983 0100 EF90      		pop r14
 984               	.LVL80:
 985 0102 DF90      		pop r13
 986 0104 CF90      		pop r12
 987               	.LVL81:
 988 0106 BF90      		pop r11
 989 0108 AF90      		pop r10
 990 010a 9F90      		pop r9
 991               	.LVL82:
 992 010c 0895      		ret
 993               		.cfi_endproc
 994               	.LFE108:
 996               		.section	.text.TCP_GetConnectionState,"ax",@progbits
 997               	.global	TCP_GetConnectionState
 999               	TCP_GetConnectionState:
 1000               	.LFB109:
 298:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 1001               		.loc 2 298 0
 1002               		.cfi_startproc
 1003               	.LVL83:
 1004 0000 AF92      		push r10
 1005               	.LCFI39:
 1006               		.cfi_def_cfa_offset 3
 1007               		.cfi_offset 10, -2
 1008 0002 BF92      		push r11
 1009               	.LCFI40:
 1010               		.cfi_def_cfa_offset 4
 1011               		.cfi_offset 11, -3
 1012 0004 CF92      		push r12
 1013               	.LCFI41:
 1014               		.cfi_def_cfa_offset 5
 1015               		.cfi_offset 12, -4
 1016 0006 DF92      		push r13
 1017               	.LCFI42:
 1018               		.cfi_def_cfa_offset 6
 1019               		.cfi_offset 13, -5
 1020 0008 EF92      		push r14
 1021               	.LCFI43:
 1022               		.cfi_def_cfa_offset 7
 1023               		.cfi_offset 14, -6
 1024 000a FF92      		push r15
 1025               	.LCFI44:
 1026               		.cfi_def_cfa_offset 8
 1027               		.cfi_offset 15, -7
 1028 000c 0F93      		push r16
 1029               	.LCFI45:
 1030               		.cfi_def_cfa_offset 9
 1031               		.cfi_offset 16, -8
 1032 000e 1F93      		push r17
 1033               	.LCFI46:
 1034               		.cfi_def_cfa_offset 10
 1035               		.cfi_offset 17, -9
 1036 0010 CF93      		push r28
 1037               	.LCFI47:
 1038               		.cfi_def_cfa_offset 11
 1039               		.cfi_offset 28, -10
 1040 0012 DF93      		push r29
 1041               	.LCFI48:
 1042               		.cfi_def_cfa_offset 12
 1043               		.cfi_offset 29, -11
 1044 0014 00D0      		rcall .
 1045 0016 00D0      		rcall .
 1046               	.LCFI49:
 1047               		.cfi_def_cfa_offset 16
 1048 0018 CDB7      		in r28,__SP_L__
 1049 001a DEB7      		in r29,__SP_H__
 1050               	.LCFI50:
 1051               		.cfi_def_cfa_register 28
 1052               	/* prologue: function */
 1053               	/* frame size = 4 */
 1054               	/* stack size = 14 */
 1055               	.L__stack_usage = 14
 1056 001c 6C01      		movw r12,r24
 1057 001e 4983      		std Y+1,r20
 1058 0020 5A83      		std Y+2,r21
 1059 0022 6B83      		std Y+3,r22
 1060 0024 7C83      		std Y+4,r23
 1061 0026 5901      		movw r10,r18
 1062               	.LVL84:
 1063 0028 00E0      		ldi r16,lo8(ConnectionStateTable)
 1064 002a 10E0      		ldi r17,hi8(ConnectionStateTable)
 298:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 1065               		.loc 2 298 0
 1066 002c E12C      		mov r14,__zero_reg__
 1067 002e F12C      		mov r15,__zero_reg__
 1068               	.LVL85:
 1069               	.L53:
 1070               	.LBB32:
 304:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 1071               		.loc 2 304 0
 1072 0030 F801      		movw r30,r16
 1073 0032 8081      		ld r24,Z
 1074 0034 9181      		ldd r25,Z+1
 1075 0036 8C15      		cp r24,r12
 1076 0038 9D05      		cpc r25,r13
 1077 003a 01F4      		brne .L51
 305:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 1078               		.loc 2 305 0 discriminator 1
 1079 003c 44E0      		ldi r20,lo8(4)
 1080 003e 50E0      		ldi r21,0
 1081 0040 BE01      		movw r22,r28
 1082 0042 6F5F      		subi r22,-1
 1083 0044 7F4F      		sbci r23,-1
 1084 0046 C801      		movw r24,r16
 1085 0048 0496      		adiw r24,4
 1086 004a 0E94 0000 		call memcmp
 1087               	.LVL86:
 304:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 1088               		.loc 2 304 0 discriminator 1
 1089 004e 892B      		or r24,r25
 1090 0050 01F4      		brne .L51
 305:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 1091               		.loc 2 305 0
 1092 0052 F801      		movw r30,r16
 1093 0054 8281      		ldd r24,Z+2
 1094 0056 9381      		ldd r25,Z+3
 1095 0058 8A15      		cp r24,r10
 1096 005a 9B05      		cpc r25,r11
 1097 005c 01F4      		brne .L51
 309:Lib/TCP.c     **** 		}
 1098               		.loc 2 309 0
 1099 005e 86E1      		ldi r24,lo8(22)
 1100 0060 92E0      		ldi r25,lo8(2)
 1101 0062 E89E      		mul r14,r24
 1102 0064 F001      		movw r30,r0
 1103 0066 E99E      		mul r14,r25
 1104 0068 F00D      		add r31,r0
 1105 006a F89E      		mul r15,r24
 1106 006c F00D      		add r31,r0
 1107 006e 1124      		clr r1
 1108 0070 E050      		subi r30,lo8(-(ConnectionStateTable+533))
 1109 0072 F040      		sbci r31,hi8(-(ConnectionStateTable+533))
 1110 0074 8081      		ld r24,Z
 1111 0076 00C0      		rjmp .L52
 1112               	.L51:
 1113               	.LVL87:
 1114 0078 FFEF      		ldi r31,-1
 1115 007a EF1A      		sub r14,r31
 1116 007c FF0A      		sbc r15,r31
 1117               	.LVL88:
 1118 007e 0A5E      		subi r16,-22
 1119 0080 1D4F      		sbci r17,-3
 301:Lib/TCP.c     **** 	{
 1120               		.loc 2 301 0 discriminator 2
 1121 0082 83E0      		ldi r24,3
 1122 0084 E816      		cp r14,r24
 1123 0086 F104      		cpc r15,__zero_reg__
 1124 0088 01F4      		brne .L53
 1125               	.LBE32:
 313:Lib/TCP.c     **** }
 1126               		.loc 2 313 0
 1127 008a 8AE0      		ldi r24,lo8(10)
 1128               	.LVL89:
 1129               	.L52:
 1130               	/* epilogue start */
 314:Lib/TCP.c     **** 
 1131               		.loc 2 314 0
 1132 008c 0F90      		pop __tmp_reg__
 1133 008e 0F90      		pop __tmp_reg__
 1134 0090 0F90      		pop __tmp_reg__
 1135 0092 0F90      		pop __tmp_reg__
 1136 0094 DF91      		pop r29
 1137 0096 CF91      		pop r28
 1138 0098 1F91      		pop r17
 1139 009a 0F91      		pop r16
 1140 009c FF90      		pop r15
 1141 009e EF90      		pop r14
 1142 00a0 DF90      		pop r13
 1143 00a2 CF90      		pop r12
 1144               	.LVL90:
 1145 00a4 BF90      		pop r11
 1146 00a6 AF90      		pop r10
 1147               	.LVL91:
 1148 00a8 0895      		ret
 1149               		.cfi_endproc
 1150               	.LFE109:
 1152               		.section	.text.TCP_GetConnectionInfo,"ax",@progbits
 1153               	.global	TCP_GetConnectionInfo
 1155               	TCP_GetConnectionInfo:
 1156               	.LFB110:
 327:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 1157               		.loc 2 327 0
 1158               		.cfi_startproc
 1159               	.LVL92:
 1160 0000 AF92      		push r10
 1161               	.LCFI51:
 1162               		.cfi_def_cfa_offset 3
 1163               		.cfi_offset 10, -2
 1164 0002 BF92      		push r11
 1165               	.LCFI52:
 1166               		.cfi_def_cfa_offset 4
 1167               		.cfi_offset 11, -3
 1168 0004 CF92      		push r12
 1169               	.LCFI53:
 1170               		.cfi_def_cfa_offset 5
 1171               		.cfi_offset 12, -4
 1172 0006 DF92      		push r13
 1173               	.LCFI54:
 1174               		.cfi_def_cfa_offset 6
 1175               		.cfi_offset 13, -5
 1176 0008 EF92      		push r14
 1177               	.LCFI55:
 1178               		.cfi_def_cfa_offset 7
 1179               		.cfi_offset 14, -6
 1180 000a FF92      		push r15
 1181               	.LCFI56:
 1182               		.cfi_def_cfa_offset 8
 1183               		.cfi_offset 15, -7
 1184 000c 0F93      		push r16
 1185               	.LCFI57:
 1186               		.cfi_def_cfa_offset 9
 1187               		.cfi_offset 16, -8
 1188 000e 1F93      		push r17
 1189               	.LCFI58:
 1190               		.cfi_def_cfa_offset 10
 1191               		.cfi_offset 17, -9
 1192 0010 CF93      		push r28
 1193               	.LCFI59:
 1194               		.cfi_def_cfa_offset 11
 1195               		.cfi_offset 28, -10
 1196 0012 DF93      		push r29
 1197               	.LCFI60:
 1198               		.cfi_def_cfa_offset 12
 1199               		.cfi_offset 29, -11
 1200 0014 00D0      		rcall .
 1201 0016 00D0      		rcall .
 1202               	.LCFI61:
 1203               		.cfi_def_cfa_offset 16
 1204 0018 CDB7      		in r28,__SP_L__
 1205 001a DEB7      		in r29,__SP_H__
 1206               	.LCFI62:
 1207               		.cfi_def_cfa_register 28
 1208               	/* prologue: function */
 1209               	/* frame size = 4 */
 1210               	/* stack size = 14 */
 1211               	.L__stack_usage = 14
 1212 001c 6C01      		movw r12,r24
 1213 001e 4983      		std Y+1,r20
 1214 0020 5A83      		std Y+2,r21
 1215 0022 6B83      		std Y+3,r22
 1216 0024 7C83      		std Y+4,r23
 1217 0026 5901      		movw r10,r18
 1218               	.LVL93:
 1219 0028 00E0      		ldi r16,lo8(ConnectionStateTable)
 1220 002a 10E0      		ldi r17,hi8(ConnectionStateTable)
 327:Lib/TCP.c     **** 	/* Note, Port number should be specified in BIG endian to simplify network code */
 1221               		.loc 2 327 0
 1222 002c E12C      		mov r14,__zero_reg__
 1223 002e F12C      		mov r15,__zero_reg__
 1224               	.LVL94:
 1225               	.L58:
 1226               	.LBB33:
 333:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 1227               		.loc 2 333 0
 1228 0030 F801      		movw r30,r16
 1229 0032 8081      		ld r24,Z
 1230 0034 9181      		ldd r25,Z+1
 1231 0036 8C15      		cp r24,r12
 1232 0038 9D05      		cpc r25,r13
 1233 003a 01F4      		brne .L56
 334:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 1234               		.loc 2 334 0 discriminator 1
 1235 003c 44E0      		ldi r20,lo8(4)
 1236 003e 50E0      		ldi r21,0
 1237 0040 BE01      		movw r22,r28
 1238 0042 6F5F      		subi r22,-1
 1239 0044 7F4F      		sbci r23,-1
 1240 0046 C801      		movw r24,r16
 1241 0048 0496      		adiw r24,4
 1242 004a 0E94 0000 		call memcmp
 1243               	.LVL95:
 333:Lib/TCP.c     **** 		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
 1244               		.loc 2 333 0 discriminator 1
 1245 004e 892B      		or r24,r25
 1246 0050 01F4      		brne .L56
 334:Lib/TCP.c     **** 			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
 1247               		.loc 2 334 0
 1248 0052 F801      		movw r30,r16
 1249 0054 8281      		ldd r24,Z+2
 1250 0056 9381      		ldd r25,Z+3
 1251 0058 8A15      		cp r24,r10
 1252 005a 9B05      		cpc r25,r11
 1253 005c 01F4      		brne .L56
 337:Lib/TCP.c     **** 		}
 1254               		.loc 2 337 0
 1255 005e 26E1      		ldi r18,lo8(22)
 1256 0060 32E0      		ldi r19,lo8(2)
 1257 0062 E29E      		mul r14,r18
 1258 0064 C001      		movw r24,r0
 1259 0066 E39E      		mul r14,r19
 1260 0068 900D      		add r25,r0
 1261 006a F29E      		mul r15,r18
 1262 006c 900D      		add r25,r0
 1263 006e 1124      		clr r1
 1264 0070 8050      		subi r24,lo8(-(ConnectionStateTable+8))
 1265 0072 9040      		sbci r25,hi8(-(ConnectionStateTable+8))
 1266 0074 00C0      		rjmp .L57
 1267               	.L56:
 1268               	.LVL96:
 1269 0076 FFEF      		ldi r31,-1
 1270 0078 EF1A      		sub r14,r31
 1271 007a FF0A      		sbc r15,r31
 1272               	.LVL97:
 1273 007c 0A5E      		subi r16,-22
 1274 007e 1D4F      		sbci r17,-3
 330:Lib/TCP.c     **** 	{
 1275               		.loc 2 330 0 discriminator 2
 1276 0080 83E0      		ldi r24,3
 1277 0082 E816      		cp r14,r24
 1278 0084 F104      		cpc r15,__zero_reg__
 1279 0086 01F4      		brne .L58
 1280               	.LBE33:
 341:Lib/TCP.c     **** }
 1281               		.loc 2 341 0
 1282 0088 80E0      		ldi r24,0
 1283 008a 90E0      		ldi r25,0
 1284               	.LVL98:
 1285               	.L57:
 1286               	/* epilogue start */
 342:Lib/TCP.c     **** 
 1287               		.loc 2 342 0
 1288 008c 0F90      		pop __tmp_reg__
 1289 008e 0F90      		pop __tmp_reg__
 1290 0090 0F90      		pop __tmp_reg__
 1291 0092 0F90      		pop __tmp_reg__
 1292 0094 DF91      		pop r29
 1293 0096 CF91      		pop r28
 1294 0098 1F91      		pop r17
 1295 009a 0F91      		pop r16
 1296 009c FF90      		pop r15
 1297 009e EF90      		pop r14
 1298 00a0 DF90      		pop r13
 1299 00a2 CF90      		pop r12
 1300               	.LVL99:
 1301 00a4 BF90      		pop r11
 1302 00a6 AF90      		pop r10
 1303               	.LVL100:
 1304 00a8 0895      		ret
 1305               		.cfi_endproc
 1306               	.LFE110:
 1308               		.section	.text.TCP_ProcessTCPPacket,"ax",@progbits
 1309               	.global	TCP_ProcessTCPPacket
 1311               	TCP_ProcessTCPPacket:
 1312               	.LFB111:
 358:Lib/TCP.c     **** 	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
 1313               		.loc 2 358 0
 1314               		.cfi_startproc
 1315               	.LVL101:
 1316 0000 4F92      		push r4
 1317               	.LCFI63:
 1318               		.cfi_def_cfa_offset 3
 1319               		.cfi_offset 4, -2
 1320 0002 5F92      		push r5
 1321               	.LCFI64:
 1322               		.cfi_def_cfa_offset 4
 1323               		.cfi_offset 5, -3
 1324 0004 6F92      		push r6
 1325               	.LCFI65:
 1326               		.cfi_def_cfa_offset 5
 1327               		.cfi_offset 6, -4
 1328 0006 7F92      		push r7
 1329               	.LCFI66:
 1330               		.cfi_def_cfa_offset 6
 1331               		.cfi_offset 7, -5
 1332 0008 8F92      		push r8
 1333               	.LCFI67:
 1334               		.cfi_def_cfa_offset 7
 1335               		.cfi_offset 8, -6
 1336 000a 9F92      		push r9
 1337               	.LCFI68:
 1338               		.cfi_def_cfa_offset 8
 1339               		.cfi_offset 9, -7
 1340 000c AF92      		push r10
 1341               	.LCFI69:
 1342               		.cfi_def_cfa_offset 9
 1343               		.cfi_offset 10, -8
 1344 000e BF92      		push r11
 1345               	.LCFI70:
 1346               		.cfi_def_cfa_offset 10
 1347               		.cfi_offset 11, -9
 1348 0010 CF92      		push r12
 1349               	.LCFI71:
 1350               		.cfi_def_cfa_offset 11
 1351               		.cfi_offset 12, -10
 1352 0012 DF92      		push r13
 1353               	.LCFI72:
 1354               		.cfi_def_cfa_offset 12
 1355               		.cfi_offset 13, -11
 1356 0014 EF92      		push r14
 1357               	.LCFI73:
 1358               		.cfi_def_cfa_offset 13
 1359               		.cfi_offset 14, -12
 1360 0016 FF92      		push r15
 1361               	.LCFI74:
 1362               		.cfi_def_cfa_offset 14
 1363               		.cfi_offset 15, -13
 1364 0018 0F93      		push r16
 1365               	.LCFI75:
 1366               		.cfi_def_cfa_offset 15
 1367               		.cfi_offset 16, -14
 1368 001a 1F93      		push r17
 1369               	.LCFI76:
 1370               		.cfi_def_cfa_offset 16
 1371               		.cfi_offset 17, -15
 1372 001c CF93      		push r28
 1373               	.LCFI77:
 1374               		.cfi_def_cfa_offset 17
 1375               		.cfi_offset 28, -16
 1376 001e DF93      		push r29
 1377               	.LCFI78:
 1378               		.cfi_def_cfa_offset 18
 1379               		.cfi_offset 29, -17
 1380               	/* prologue: function */
 1381               	/* frame size = 0 */
 1382               	/* stack size = 16 */
 1383               	.L__stack_usage = 16
 1384 0020 7C01      		movw r14,r24
 1385 0022 EB01      		movw r28,r22
 1386 0024 6A01      		movw r12,r20
 1387               	.LVL102:
 365:Lib/TCP.c     **** 
 1388               		.loc 2 365 0
 1389 0026 CB01      		movw r24,r22
 1390               	.LVL103:
 1391 0028 0E94 0000 		call DecodeTCPHeader
 1392               	.LVL104:
 370:Lib/TCP.c     **** 	{
 1393               		.loc 2 370 0
 1394 002c AA80      		ldd r10,Y+2
 1395 002e BB80      		ldd r11,Y+3
 1396 0030 C501      		movw r24,r10
 1397 0032 0E94 0000 		call TCP_GetPortState
 1398               	.LVL105:
 1399 0036 8130      		cpi r24,lo8(1)
 1400 0038 01F4      		brne .L61
 373:Lib/TCP.c     **** 		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->So
 1401               		.loc 2 373 0
 1402 003a 8D85      		ldd r24,Y+13
 1403 003c 81FF      		sbrs r24,1
 1404 003e 00C0      		rjmp .L62
 374:Lib/TCP.c     **** 
 1405               		.loc 2 374 0
 1406 0040 2881      		ld r18,Y
 1407 0042 3981      		ldd r19,Y+1
 1408 0044 D701      		movw r26,r14
 1409 0046 1C96      		adiw r26,12
 1410 0048 4D91      		ld r20,X+
 1411 004a 5D91      		ld r21,X+
 1412 004c 6D91      		ld r22,X+
 1413 004e 7C91      		ld r23,X
 1414 0050 1F97      		sbiw r26,12+3
 1415 0052 00E0      		ldi r16,0
 1416 0054 C501      		movw r24,r10
 1417 0056 0E94 0000 		call TCP_SetConnectionState
 1418               	.LVL106:
 1419               	.L62:
 377:Lib/TCP.c     **** 		{
 1420               		.loc 2 377 0
 1421 005a 1D85      		ldd r17,Y+13
 1422 005c AA80      		ldd r10,Y+2
 1423 005e BB80      		ldd r11,Y+3
 1424 0060 8880      		ld r8,Y
 1425 0062 9980      		ldd r9,Y+1
 1426 0064 F701      		movw r30,r14
 1427 0066 4484      		ldd r4,Z+12
 1428 0068 5584      		ldd r5,Z+13
 1429 006a 6684      		ldd r6,Z+14
 1430 006c 7784      		ldd r7,Z+15
 1431 006e 12FF      		sbrs r17,2
 1432 0070 00C0      		rjmp .L63
 379:Lib/TCP.c     **** 			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
 1433               		.loc 2 379 0
 1434 0072 0AE0      		ldi r16,lo8(10)
 1435 0074 9401      		movw r18,r8
 1436 0076 B301      		movw r22,r6
 1437 0078 A201      		movw r20,r4
 1438 007a C501      		movw r24,r10
 1439 007c 0E94 0000 		call TCP_SetConnectionState
 1440               	.LVL107:
 1441 0080 8823      		tst r24
 1442 0082 01F4      		brne .+2
 1443 0084 00C0      		rjmp .L66
 1444               	.L61:
 382:Lib/TCP.c     **** 				PacketResponse = true;
 1445               		.loc 2 382 0
 1446 0086 84E1      		ldi r24,lo8(20)
 1447 0088 D601      		movw r26,r12
 1448 008a 1D96      		adiw r26,13
 1449 008c 8C93      		st X,r24
 1450               	.LVL108:
 1451 008e 00C0      		rjmp .L65
 1452               	.LVL109:
 1453               	.L63:
 389:Lib/TCP.c     **** 			{
 1454               		.loc 2 389 0
 1455 0090 9401      		movw r18,r8
 1456 0092 B301      		movw r22,r6
 1457 0094 A201      		movw r20,r4
 1458 0096 C501      		movw r24,r10
 1459 0098 0E94 0000 		call TCP_GetConnectionState
 1460               	.LVL110:
 1461 009c 90E0      		ldi r25,0
 1462 009e 8830      		cpi r24,8
 1463 00a0 9105      		cpc r25,__zero_reg__
 1464 00a2 00F0      		brlo .+2
 1465 00a4 00C0      		rjmp .L66
 1466 00a6 FC01      		movw r30,r24
 1467 00a8 E050      		subi r30,lo8(-(gs(.L68)))
 1468 00aa F040      		sbci r31,hi8(-(gs(.L68)))
 1469 00ac 0C94 0000 		jmp __tablejump2__
 1470               		.section	.progmem.gcc_sw_table.TCP_ProcessTCPPacket,"a",@progbits
 1471               		.p2align	1
 1472               	.L68:
 1473 0000 0000      		.word gs(.L67)
 1474 0002 0000      		.word gs(.L66)
 1475 0004 0000      		.word gs(.L69)
 1476 0006 0000      		.word gs(.L70)
 1477 0008 0000      		.word gs(.L71)
 1478 000a 0000      		.word gs(.L72)
 1479 000c 0000      		.word gs(.L73)
 1480 000e 0000      		.word gs(.L74)
 1481               		.section	.text.TCP_ProcessTCPPacket
 1482               	.L67:
 392:Lib/TCP.c     **** 					{
 1483               		.loc 2 392 0
 1484 00b0 1230      		cpi r17,lo8(2)
 1485 00b2 01F0      		breq .+2
 1486 00b4 00C0      		rjmp .L66
 395:Lib/TCP.c     **** 						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
 1487               		.loc 2 395 0
 1488 00b6 02E0      		ldi r16,lo8(2)
 1489 00b8 9401      		movw r18,r8
 1490 00ba B301      		movw r22,r6
 1491 00bc A201      		movw r20,r4
 1492 00be C501      		movw r24,r10
 1493 00c0 0E94 0000 		call TCP_SetConnectionState
 1494               	.LVL111:
 1495 00c4 8823      		tst r24
 1496 00c6 01F0      		breq .L75
 398:Lib/TCP.c     **** 
 1497               		.loc 2 398 0
 1498 00c8 82E1      		ldi r24,lo8(18)
 1499 00ca F601      		movw r30,r12
 1500 00cc 8587      		std Z+13,r24
 400:Lib/TCP.c     **** 
 1501               		.loc 2 400 0
 1502 00ce 2881      		ld r18,Y
 1503 00d0 3981      		ldd r19,Y+1
 1504 00d2 D701      		movw r26,r14
 1505 00d4 1C96      		adiw r26,12
 1506 00d6 4D91      		ld r20,X+
 1507 00d8 5D91      		ld r21,X+
 1508 00da 6D91      		ld r22,X+
 1509 00dc 7C91      		ld r23,X
 1510 00de 1F97      		sbiw r26,12+3
 1511 00e0 8A81      		ldd r24,Y+2
 1512 00e2 9B81      		ldd r25,Y+3
 1513 00e4 0E94 0000 		call TCP_GetConnectionInfo
 1514               	.LVL112:
 1515 00e8 8C01      		movw r16,r24
 1516               	.LVL113:
 402:Lib/TCP.c     **** 							ConnectionInfo->SequenceNumberOut = 0;
 1517               		.loc 2 402 0
 1518 00ea 6C81      		ldd r22,Y+4
 1519 00ec 7D81      		ldd r23,Y+5
 1520 00ee 8E81      		ldd r24,Y+6
 1521 00f0 9F81      		ldd r25,Y+7
 1522 00f2 0E94 0000 		call SwapEndian_32
 1523               	.LVL114:
 1524 00f6 DC01      		movw r26,r24
 1525 00f8 CB01      		movw r24,r22
 1526 00fa 0196      		adiw r24,1
 1527 00fc A11D      		adc r26,__zero_reg__
 1528 00fe B11D      		adc r27,__zero_reg__
 1529 0100 F801      		movw r30,r16
 1530 0102 8083      		st Z,r24
 1531 0104 9183      		std Z+1,r25
 1532 0106 A283      		std Z+2,r26
 1533 0108 B383      		std Z+3,r27
 403:Lib/TCP.c     **** 							ConnectionInfo->Buffer.InUse      = false;
 1534               		.loc 2 403 0
 1535 010a 1482      		std Z+4,__zero_reg__
 1536 010c 1582      		std Z+5,__zero_reg__
 1537 010e 1682      		std Z+6,__zero_reg__
 1538 0110 1782      		std Z+7,__zero_reg__
 404:Lib/TCP.c     **** 						}
 1539               		.loc 2 404 0
 1540 0112 E45F      		subi r30,-12
 1541 0114 FD4F      		sbci r31,-3
 1542 0116 1082      		st Z,__zero_reg__
 1543 0118 00C0      		rjmp .L65
 1544               	.LVL115:
 1545               	.L75:
 408:Lib/TCP.c     **** 						}
 1546               		.loc 2 408 0
 1547 011a 84E0      		ldi r24,lo8(4)
 1548 011c 00C0      		rjmp .L103
 1549               	.L69:
 416:Lib/TCP.c     **** 					{
 1550               		.loc 2 416 0
 1551 011e 1031      		cpi r17,lo8(16)
 1552 0120 01F0      		breq .+2
 1553 0122 00C0      		rjmp .L66
 420:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_Established);
 1554               		.loc 2 420 0
 1555 0124 03E0      		ldi r16,lo8(3)
 1556 0126 9401      		movw r18,r8
 1557 0128 B301      		movw r22,r6
 1558 012a A201      		movw r20,r4
 1559 012c C501      		movw r24,r10
 1560 012e 0E94 0000 		call TCP_SetConnectionState
 1561               	.LVL116:
 423:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 1562               		.loc 2 423 0
 1563 0132 2881      		ld r18,Y
 1564 0134 3981      		ldd r19,Y+1
 1565 0136 D701      		movw r26,r14
 1566 0138 1C96      		adiw r26,12
 1567 013a 4D91      		ld r20,X+
 1568 013c 5D91      		ld r21,X+
 1569 013e 6D91      		ld r22,X+
 1570 0140 7C91      		ld r23,X
 1571 0142 1F97      		sbiw r26,12+3
 1572 0144 8A81      		ldd r24,Y+2
 1573 0146 9B81      		ldd r25,Y+3
 1574 0148 0E94 0000 		call TCP_GetConnectionInfo
 1575               	.LVL117:
 426:Lib/TCP.c     **** 					}
 1576               		.loc 2 426 0
 1577 014c FC01      		movw r30,r24
 1578 014e 4481      		ldd r20,Z+4
 1579 0150 5581      		ldd r21,Z+5
 1580 0152 6681      		ldd r22,Z+6
 1581 0154 7781      		ldd r23,Z+7
 1582 0156 4F5F      		subi r20,-1
 1583 0158 5F4F      		sbci r21,-1
 1584 015a 6F4F      		sbci r22,-1
 1585 015c 7F4F      		sbci r23,-1
 1586 015e 4483      		std Z+4,r20
 1587 0160 5583      		std Z+5,r21
 1588 0162 6683      		std Z+6,r22
 1589 0164 7783      		std Z+7,r23
 1590 0166 00C0      		rjmp .L66
 1591               	.LVL118:
 1592               	.L70:
 431:Lib/TCP.c     **** 					{
 1593               		.loc 2 431 0
 1594 0168 1131      		cpi r17,lo8(17)
 1595 016a 01F4      		brne .L76
 435:Lib/TCP.c     **** 						PacketResponse      = true;
 1596               		.loc 2 435 0
 1597 016c F601      		movw r30,r12
 1598 016e 1587      		std Z+13,r17
 1599               	.LVL119:
 438:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);
 1600               		.loc 2 438 0
 1601 0170 2881      		ld r18,Y
 1602 0172 3981      		ldd r19,Y+1
 1603 0174 D701      		movw r26,r14
 1604 0176 1C96      		adiw r26,12
 1605 0178 4D91      		ld r20,X+
 1606 017a 5D91      		ld r21,X+
 1607 017c 6D91      		ld r22,X+
 1608 017e 7C91      		ld r23,X
 1609 0180 1F97      		sbiw r26,12+3
 1610 0182 06E0      		ldi r16,lo8(6)
 1611 0184 8A81      		ldd r24,Y+2
 1612 0186 9B81      		ldd r25,Y+3
 1613 0188 0E94 0000 		call TCP_SetConnectionState
 1614               	.LVL120:
 441:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 1615               		.loc 2 441 0
 1616 018c 2881      		ld r18,Y
 1617 018e 3981      		ldd r19,Y+1
 1618 0190 F701      		movw r30,r14
 1619 0192 4485      		ldd r20,Z+12
 1620 0194 5585      		ldd r21,Z+13
 1621 0196 6685      		ldd r22,Z+14
 1622 0198 7785      		ldd r23,Z+15
 1623 019a 8A81      		ldd r24,Y+2
 1624 019c 9B81      		ldd r25,Y+3
 1625 019e 0E94 0000 		call TCP_GetConnectionInfo
 1626               	.LVL121:
 1627 01a2 FC01      		movw r30,r24
 1628               	.LVL122:
 444:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberOut++;
 1629               		.loc 2 444 0
 1630 01a4 8081      		ld r24,Z
 1631 01a6 9181      		ldd r25,Z+1
 1632 01a8 A281      		ldd r26,Z+2
 1633 01aa B381      		ldd r27,Z+3
 1634               	.LVL123:
 1635 01ac 0196      		adiw r24,1
 1636 01ae A11D      		adc r26,__zero_reg__
 1637 01b0 B11D      		adc r27,__zero_reg__
 1638 01b2 8083      		st Z,r24
 1639 01b4 9183      		std Z+1,r25
 1640 01b6 A283      		std Z+2,r26
 1641 01b8 B383      		std Z+3,r27
 445:Lib/TCP.c     **** 					}
 1642               		.loc 2 445 0
 1643 01ba 8481      		ldd r24,Z+4
 1644 01bc 9581      		ldd r25,Z+5
 1645 01be A681      		ldd r26,Z+6
 1646 01c0 B781      		ldd r27,Z+7
 1647 01c2 0196      		adiw r24,1
 1648 01c4 A11D      		adc r26,__zero_reg__
 1649 01c6 B11D      		adc r27,__zero_reg__
 1650 01c8 8483      		std Z+4,r24
 1651 01ca 9583      		std Z+5,r25
 1652 01cc A683      		std Z+6,r26
 1653 01ce B783      		std Z+7,r27
 1654 01d0 00C0      		rjmp .L65
 1655               	.LVL124:
 1656               	.L76:
 447:Lib/TCP.c     **** 					{
 1657               		.loc 2 447 0
 1658 01d2 177F      		andi r17,lo8(-9)
 1659 01d4 1031      		cpi r17,lo8(16)
 1660 01d6 01F0      		breq .+2
 1661 01d8 00C0      		rjmp .L66
 449:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 1662               		.loc 2 449 0
 1663 01da 9401      		movw r18,r8
 1664 01dc B301      		movw r22,r6
 1665 01de A201      		movw r20,r4
 1666 01e0 C501      		movw r24,r10
 1667 01e2 0E94 0000 		call TCP_GetConnectionInfo
 1668               	.LVL125:
 1669 01e6 8C01      		movw r16,r24
 1670               	.LVL126:
 453:Lib/TCP.c     **** 						{
 1671               		.loc 2 453 0
 1672 01e8 4C01      		movw r8,r24
 1673 01ea F4EF      		ldi r31,-12
 1674 01ec 8F1A      		sub r8,r31
 1675 01ee FDEF      		ldi r31,-3
 1676 01f0 9F0A      		sbc r9,r31
 1677 01f2 D401      		movw r26,r8
 1678 01f4 8C91      		ld r24,X
 1679 01f6 F801      		movw r30,r16
 1680 01f8 E65F      		subi r30,-10
 1681 01fa FD4F      		sbci r31,-3
 1682 01fc 8111      		cpse r24,__zero_reg__
 1683 01fe 00C0      		rjmp .L77
 453:Lib/TCP.c     **** 						{
 1684               		.loc 2 453 0 is_stmt 0 discriminator 1
 1685 0200 1197      		sbiw r26,1
 1686 0202 8C91      		ld r24,X
 1687 0204 8111      		cpse r24,__zero_reg__
 1688 0206 00C0      		rjmp .L77
 455:Lib/TCP.c     **** 							ConnectionInfo->Buffer.InUse     = true;
 1689               		.loc 2 455 0 is_stmt 1
 1690 0208 1082      		st Z,__zero_reg__
 456:Lib/TCP.c     **** 							ConnectionInfo->Buffer.Length    = 0;
 1691               		.loc 2 456 0
 1692 020a 81E0      		ldi r24,lo8(1)
 1693 020c D401      		movw r26,r8
 1694 020e 8C93      		st X,r24
 457:Lib/TCP.c     **** 						}
 1695               		.loc 2 457 0
 1696 0210 D801      		movw r26,r16
 1697 0212 1996      		adiw r26,8+1
 1698 0214 1C92      		st X,__zero_reg__
 1699 0216 1E92      		st -X,__zero_reg__
 1700 0218 1897      		sbiw r26,8
 1701               	.L77:
 461:Lib/TCP.c     **** 							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
 1702               		.loc 2 461 0
 1703 021a 8081      		ld r24,Z
 1704 021c 8111      		cpse r24,__zero_reg__
 1705 021e 00C0      		rjmp .L85
 462:Lib/TCP.c     **** 						{
 1706               		.loc 2 462 0 discriminator 1
 1707 0220 F801      		movw r30,r16
 1708 0222 6084      		ldd r6,Z+8
 1709 0224 7184      		ldd r7,Z+9
 461:Lib/TCP.c     **** 							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
 1710               		.loc 2 461 0 discriminator 1
 1711 0226 6114      		cp r6,__zero_reg__
 1712 0228 F2E0      		ldi r31,2
 1713 022a 7F06      		cpc r7,r31
 1714 022c 01F4      		brne .+2
 1715 022e 00C0      		rjmp .L85
 1716               	.LBB34:
 464:Lib/TCP.c     **** 							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
 1717               		.loc 2 464 0
 1718 0230 D701      		movw r26,r14
 1719 0232 8C91      		ld r24,X
 1720 0234 8F70      		andi r24,lo8(15)
 1721 0236 B4E0      		ldi r27,lo8(4)
 1722 0238 8B9F      		mul r24,r27
 1723 023a 5001      		movw r10,r0
 1724 023c 1124      		clr __zero_reg__
 1725               	.LVL127:
 465:Lib/TCP.c     **** 							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
 1726               		.loc 2 465 0
 1727 023e 4C84      		ldd r4,Y+12
 1728 0240 4294      		swap r4
 1729 0242 9FE0      		ldi r25,lo8(15)
 1730 0244 4922      		and r4,r25
 1731 0246 E4E0      		ldi r30,lo8(4)
 1732 0248 4E9E      		mul r4,r30
 1733 024a 2001      		movw r4,r0
 1734 024c 1124      		clr __zero_reg__
 1735               	.LVL128:
 466:Lib/TCP.c     **** 
 1736               		.loc 2 466 0
 1737 024e D701      		movw r26,r14
 1738 0250 1296      		adiw r26,2
 1739 0252 8D91      		ld r24,X+
 1740 0254 9C91      		ld r25,X
 1741 0256 1397      		sbiw r26,2+1
 1742 0258 0E94 0000 		call SwapEndian_16
 1743               	.LVL129:
 1744 025c 8A19      		sub r24,r10
 1745 025e 9B09      		sbc r25,r11
 1746 0260 5C01      		movw r10,r24
 1747               	.LVL130:
 1748 0262 A418      		sub r10,r4
 1749 0264 B508      		sbc r11,r5
 1750               	.LVL131:
 469:Lib/TCP.c     **** 								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
 1751               		.loc 2 469 0
 1752 0266 C301      		movw r24,r6
 1753 0268 0A96      		adiw r24,10
 1754 026a BE01      		movw r22,r28
 1755 026c 640D      		add r22,r4
 1756 026e 751D      		adc r23,r5
 1757 0270 A501      		movw r20,r10
 1758 0272 800F      		add r24,r16
 1759 0274 911F      		adc r25,r17
 1760 0276 0E94 0000 		call memcpy
 1761               	.LVL132:
 473:Lib/TCP.c     **** 							ConnectionInfo->Buffer.Length    += DataLength;
 1762               		.loc 2 473 0
 1763 027a F801      		movw r30,r16
 1764 027c 8081      		ld r24,Z
 1765 027e 9181      		ldd r25,Z+1
 1766 0280 A281      		ldd r26,Z+2
 1767 0282 B381      		ldd r27,Z+3
 1768 0284 8A0D      		add r24,r10
 1769 0286 9B1D      		adc r25,r11
 1770 0288 A11D      		adc r26,__zero_reg__
 1771 028a B11D      		adc r27,__zero_reg__
 1772 028c 8083      		st Z,r24
 1773 028e 9183      		std Z+1,r25
 1774 0290 A283      		std Z+2,r26
 1775 0292 B383      		std Z+3,r27
 474:Lib/TCP.c     **** 
 1776               		.loc 2 474 0
 1777 0294 8085      		ldd r24,Z+8
 1778 0296 9185      		ldd r25,Z+9
 1779 0298 A80E      		add r10,r24
 1780 029a B91E      		adc r11,r25
 1781               	.LVL133:
 1782 029c B186      		std Z+9,r11
 1783 029e A086      		std Z+8,r10
 477:Lib/TCP.c     **** 							{
 1784               		.loc 2 477 0
 1785 02a0 A114      		cp r10,__zero_reg__
 1786 02a2 F2E0      		ldi r31,2
 1787 02a4 BF06      		cpc r11,r31
 1788 02a6 01F0      		breq .L79
 477:Lib/TCP.c     **** 							{
 1789               		.loc 2 477 0 is_stmt 0 discriminator 1
 1790 02a8 8D85      		ldd r24,Y+13
 1791 02aa 83FF      		sbrs r24,3
 1792 02ac 00C0      		rjmp .L66
 1793               	.L79:
 479:Lib/TCP.c     **** 								ConnectionInfo->Buffer.Ready = true;
 1794               		.loc 2 479 0 is_stmt 1
 1795 02ae D401      		movw r26,r8
 1796 02b0 1C92      		st X,__zero_reg__
 480:Lib/TCP.c     **** 
 1797               		.loc 2 480 0
 1798 02b2 F801      		movw r30,r16
 1799 02b4 E55F      		subi r30,-11
 1800 02b6 FD4F      		sbci r31,-3
 1801 02b8 81E0      		ldi r24,lo8(1)
 1802 02ba 8083      		st Z,r24
 482:Lib/TCP.c     **** 								PacketResponse      = true;
 1803               		.loc 2 482 0
 1804 02bc 80E1      		ldi r24,lo8(16)
 1805               	.LVL134:
 1806               	.L103:
 1807 02be F601      		movw r30,r12
 1808 02c0 8587      		std Z+13,r24
 1809               	.LVL135:
 1810 02c2 00C0      		rjmp .L65
 1811               	.LVL136:
 1812               	.L74:
 1813               	.LBE34:
 495:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 1814               		.loc 2 495 0
 1815 02c4 9401      		movw r18,r8
 1816 02c6 B301      		movw r22,r6
 1817 02c8 A201      		movw r20,r4
 1818 02ca C501      		movw r24,r10
 1819 02cc 0E94 0000 		call TCP_GetConnectionInfo
 1820               	.LVL137:
 498:Lib/TCP.c     **** 						PacketResponse      = true;
 1821               		.loc 2 498 0
 1822 02d0 21E1      		ldi r18,lo8(17)
 1823 02d2 D601      		movw r26,r12
 1824 02d4 1D96      		adiw r26,13
 1825 02d6 2C93      		st X,r18
 1826               	.LVL138:
 501:Lib/TCP.c     **** 
 1827               		.loc 2 501 0
 1828 02d8 845F      		subi r24,-12
 1829 02da 9D4F      		sbci r25,-3
 1830               	.LVL139:
 1831 02dc FC01      		movw r30,r24
 1832 02de 1082      		st Z,__zero_reg__
 503:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);
 1833               		.loc 2 503 0
 1834 02e0 2881      		ld r18,Y
 1835 02e2 3981      		ldd r19,Y+1
 1836 02e4 D701      		movw r26,r14
 1837 02e6 1C96      		adiw r26,12
 1838 02e8 4D91      		ld r20,X+
 1839 02ea 5D91      		ld r21,X+
 1840 02ec 6D91      		ld r22,X+
 1841 02ee 7C91      		ld r23,X
 1842 02f0 1F97      		sbiw r26,12+3
 1843 02f2 04E0      		ldi r16,lo8(4)
 1844 02f4 00C0      		rjmp .L104
 1845               	.LVL140:
 1846               	.L71:
 508:Lib/TCP.c     **** 					{
 1847               		.loc 2 508 0
 1848 02f6 1131      		cpi r17,lo8(17)
 1849 02f8 01F0      		breq .L102
 522:Lib/TCP.c     **** 					{
 1850               		.loc 2 522 0
 1851 02fa 1031      		cpi r17,lo8(16)
 1852 02fc 01F0      		breq .+2
 1853 02fe 00C0      		rjmp .L66
 524:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
 1854               		.loc 2 524 0
 1855 0300 05E0      		ldi r16,lo8(5)
 1856 0302 00C0      		rjmp .L101
 1857               	.L72:
 530:Lib/TCP.c     **** 					{
 1858               		.loc 2 530 0
 1859 0304 1131      		cpi r17,lo8(17)
 1860 0306 01F4      		brne .L66
 1861               	.L102:
 532:Lib/TCP.c     **** 															   TCPHeaderIN->SourcePort);
 1862               		.loc 2 532 0
 1863 0308 9401      		movw r18,r8
 1864 030a B301      		movw r22,r6
 1865 030c A201      		movw r20,r4
 1866 030e C501      		movw r24,r10
 1867 0310 0E94 0000 		call TCP_GetConnectionInfo
 1868               	.LVL141:
 1869 0314 FC01      		movw r30,r24
 1870               	.LVL142:
 535:Lib/TCP.c     **** 						PacketResponse      = true;
 1871               		.loc 2 535 0
 1872 0316 80E1      		ldi r24,lo8(16)
 1873               	.LVL143:
 1874 0318 D601      		movw r26,r12
 1875 031a 1D96      		adiw r26,13
 1876 031c 8C93      		st X,r24
 1877               	.LVL144:
 538:Lib/TCP.c     **** 						ConnectionInfo->SequenceNumberOut++;
 1878               		.loc 2 538 0
 1879 031e 8081      		ld r24,Z
 1880 0320 9181      		ldd r25,Z+1
 1881 0322 A281      		ldd r26,Z+2
 1882 0324 B381      		ldd r27,Z+3
 1883 0326 0196      		adiw r24,1
 1884 0328 A11D      		adc r26,__zero_reg__
 1885 032a B11D      		adc r27,__zero_reg__
 1886 032c 8083      		st Z,r24
 1887 032e 9183      		std Z+1,r25
 1888 0330 A283      		std Z+2,r26
 1889 0332 B383      		std Z+3,r27
 539:Lib/TCP.c     **** 
 1890               		.loc 2 539 0
 1891 0334 8481      		ldd r24,Z+4
 1892 0336 9581      		ldd r25,Z+5
 1893 0338 A681      		ldd r26,Z+6
 1894 033a B781      		ldd r27,Z+7
 1895 033c 0196      		adiw r24,1
 1896 033e A11D      		adc r26,__zero_reg__
 1897 0340 B11D      		adc r27,__zero_reg__
 1898 0342 8483      		std Z+4,r24
 1899 0344 9583      		std Z+5,r25
 1900 0346 A683      		std Z+6,r26
 1901 0348 B783      		std Z+7,r27
 541:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
 1902               		.loc 2 541 0
 1903 034a 2881      		ld r18,Y
 1904 034c 3981      		ldd r19,Y+1
 1905 034e F701      		movw r30,r14
 1906               	.LVL145:
 1907 0350 4485      		ldd r20,Z+12
 1908 0352 5585      		ldd r21,Z+13
 1909 0354 6685      		ldd r22,Z+14
 1910 0356 7785      		ldd r23,Z+15
 1911 0358 0AE0      		ldi r16,lo8(10)
 1912               	.L104:
 1913 035a 8A81      		ldd r24,Y+2
 1914 035c 9B81      		ldd r25,Y+3
 1915 035e 0E94 0000 		call TCP_SetConnectionState
 1916               	.LVL146:
 1917 0362 00C0      		rjmp .L65
 1918               	.LVL147:
 1919               	.L73:
 547:Lib/TCP.c     **** 					{
 1920               		.loc 2 547 0
 1921 0364 1031      		cpi r17,lo8(16)
 1922 0366 01F4      		brne .L66
 549:Lib/TCP.c     **** 											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
 1923               		.loc 2 549 0
 1924 0368 0AE0      		ldi r16,lo8(10)
 1925               	.L101:
 1926 036a 9401      		movw r18,r8
 1927 036c B301      		movw r22,r6
 1928 036e A201      		movw r20,r4
 1929 0370 C501      		movw r24,r10
 1930 0372 0E94 0000 		call TCP_SetConnectionState
 1931               	.LVL148:
 1932 0376 00C0      		rjmp .L66
 1933               	.LVL149:
 1934               	.L85:
 489:Lib/TCP.c     **** 						}
 1935               		.loc 2 489 0
 1936 0378 8FEF      		ldi r24,lo8(-1)
 1937 037a 9FEF      		ldi r25,lo8(-1)
 1938 037c 00C0      		rjmp .L98
 1939               	.LVL150:
 1940               	.L66:
 591:Lib/TCP.c     **** }
 1941               		.loc 2 591 0
 1942 037e 80E0      		ldi r24,0
 1943 0380 90E0      		ldi r25,0
 1944 0382 00C0      		rjmp .L98
 1945               	.LVL151:
 1946               	.L65:
 567:Lib/TCP.c     **** 		                                       TCPHeaderIN->SourcePort);
 1947               		.loc 2 567 0
 1948 0384 AA80      		ldd r10,Y+2
 1949 0386 BB80      		ldd r11,Y+3
 1950 0388 2881      		ld r18,Y
 1951 038a 3981      		ldd r19,Y+1
 1952 038c D701      		movw r26,r14
 1953 038e 1C96      		adiw r26,12
 1954 0390 4D91      		ld r20,X+
 1955 0392 5D91      		ld r21,X+
 1956 0394 6D91      		ld r22,X+
 1957 0396 7C91      		ld r23,X
 1958 0398 1F97      		sbiw r26,12+3
 1959 039a C501      		movw r24,r10
 1960 039c 0E94 0000 		call TCP_GetConnectionInfo
 1961               	.LVL152:
 1962 03a0 8C01      		movw r16,r24
 1963               	.LVL153:
 570:Lib/TCP.c     **** 		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
 1964               		.loc 2 570 0
 1965 03a2 F601      		movw r30,r12
 1966 03a4 B182      		std Z+1,r11
 1967 03a6 A082      		st Z,r10
 571:Lib/TCP.c     **** 		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
 1968               		.loc 2 571 0
 1969 03a8 8881      		ld r24,Y
 1970 03aa 9981      		ldd r25,Y+1
 1971 03ac 9383      		std Z+3,r25
 1972 03ae 8283      		std Z+2,r24
 572:Lib/TCP.c     **** 		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
 1973               		.loc 2 572 0
 1974 03b0 D801      		movw r26,r16
 1975 03b2 1496      		adiw r26,4
 1976 03b4 6D91      		ld r22,X+
 1977 03b6 7D91      		ld r23,X+
 1978 03b8 8D91      		ld r24,X+
 1979 03ba 9C91      		ld r25,X
 1980 03bc 1797      		sbiw r26,4+3
 1981 03be 0E94 0000 		call SwapEndian_32
 1982               	.LVL154:
 1983 03c2 F601      		movw r30,r12
 1984 03c4 6483      		std Z+4,r22
 1985 03c6 7583      		std Z+5,r23
 1986 03c8 8683      		std Z+6,r24
 1987 03ca 9783      		std Z+7,r25
 573:Lib/TCP.c     **** 		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
 1988               		.loc 2 573 0
 1989 03cc D801      		movw r26,r16
 1990 03ce 6D91      		ld r22,X+
 1991 03d0 7D91      		ld r23,X+
 1992 03d2 8D91      		ld r24,X+
 1993 03d4 9C91      		ld r25,X
 1994 03d6 0E94 0000 		call SwapEndian_32
 1995               	.LVL155:
 1996 03da F601      		movw r30,r12
 1997 03dc 6087      		std Z+8,r22
 1998 03de 7187      		std Z+9,r23
 1999 03e0 8287      		std Z+10,r24
 2000 03e2 9387      		std Z+11,r25
 574:Lib/TCP.c     **** 
 2001               		.loc 2 574 0
 2002 03e4 8485      		ldd r24,Z+12
 2003 03e6 8F70      		andi r24,lo8(15)
 2004 03e8 8065      		ori r24,lo8(80)
 2005 03ea 8487      		std Z+12,r24
 576:Lib/TCP.c     **** 		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
 2006               		.loc 2 576 0
 2007 03ec F801      		movw r30,r16
 2008 03ee E45F      		subi r30,-12
 2009 03f0 FD4F      		sbci r31,-3
 2010 03f2 8081      		ld r24,Z
 2011 03f4 8111      		cpse r24,__zero_reg__
 2012 03f6 00C0      		rjmp .L82
 577:Lib/TCP.c     **** 		else
 2013               		.loc 2 577 0
 2014 03f8 82E0      		ldi r24,lo8(2)
 2015 03fa 90E0      		ldi r25,0
 2016 03fc 00C0      		rjmp .L100
 2017               	.L82:
 579:Lib/TCP.c     **** 
 2018               		.loc 2 579 0
 2019 03fe F801      		movw r30,r16
 2020 0400 2085      		ldd r18,Z+8
 2021 0402 3185      		ldd r19,Z+9
 2022 0404 80E0      		ldi r24,0
 2023 0406 92E0      		ldi r25,lo8(2)
 2024 0408 821B      		sub r24,r18
 2025 040a 930B      		sbc r25,r19
 2026 040c 0E94 0000 		call SwapEndian_16
 2027               	.LVL156:
 2028               	.L100:
 2029 0410 D601      		movw r26,r12
 2030 0412 1F96      		adiw r26,14+1
 2031 0414 9C93      		st X,r25
 2032 0416 8E93      		st -X,r24
 2033 0418 1E97      		sbiw r26,14
 581:Lib/TCP.c     **** 		TCPHeaderOUT->Checksum             = 0;
 2034               		.loc 2 581 0
 2035 041a F601      		movw r30,r12
 2036 041c 138A      		std Z+19,__zero_reg__
 2037 041e 128A      		std Z+18,__zero_reg__
 582:Lib/TCP.c     **** 		TCPHeaderOUT->Reserved             = 0;
 2038               		.loc 2 582 0
 2039 0420 118A      		std Z+17,__zero_reg__
 2040 0422 108A      		std Z+16,__zero_reg__
 583:Lib/TCP.c     **** 
 2041               		.loc 2 583 0
 2042 0424 8485      		ldd r24,Z+12
 2043 0426 807F      		andi r24,lo8(-16)
 2044 0428 8487      		std Z+12,r24
 585:Lib/TCP.c     **** 		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_
 2045               		.loc 2 585 0
 2046 042a D701      		movw r26,r14
 2047 042c 1C96      		adiw r26,12
 2048 042e 0D91      		ld r16,X+
 2049 0430 1D91      		ld r17,X+
 2050 0432 2D91      		ld r18,X+
 2051 0434 3C91      		ld r19,X
 2052 0436 1F97      		sbiw r26,12+3
 2053               	.LVL157:
 2054 0438 5096      		adiw r26,16
 2055 043a 4D91      		ld r20,X+
 2056 043c 5D91      		ld r21,X+
 2057 043e 6D91      		ld r22,X+
 2058 0440 7C91      		ld r23,X
 2059 0442 5397      		sbiw r26,16+3
 2060 0444 84E1      		ldi r24,lo8(20)
 2061 0446 E82E      		mov r14,r24
 2062 0448 F12C      		mov r15,__zero_reg__
 2063               	.LVL158:
 2064 044a C601      		movw r24,r12
 2065 044c 0E94 0000 		call TCP_Checksum16
 2066               	.LVL159:
 2067 0450 F601      		movw r30,r12
 2068 0452 918B      		std Z+17,r25
 2069 0454 808B      		std Z+16,r24
 588:Lib/TCP.c     **** 	}
 2070               		.loc 2 588 0
 2071 0456 84E1      		ldi r24,lo8(20)
 2072 0458 90E0      		ldi r25,0
 2073               	.LVL160:
 2074               	.L98:
 2075               	/* epilogue start */
 592:Lib/TCP.c     **** 
 2076               		.loc 2 592 0
 2077 045a DF91      		pop r29
 2078 045c CF91      		pop r28
 2079               	.LVL161:
 2080 045e 1F91      		pop r17
 2081 0460 0F91      		pop r16
 2082 0462 FF90      		pop r15
 2083 0464 EF90      		pop r14
 2084 0466 DF90      		pop r13
 2085 0468 CF90      		pop r12
 2086               	.LVL162:
 2087 046a BF90      		pop r11
 2088 046c AF90      		pop r10
 2089 046e 9F90      		pop r9
 2090 0470 8F90      		pop r8
 2091 0472 7F90      		pop r7
 2092 0474 6F90      		pop r6
 2093 0476 5F90      		pop r5
 2094 0478 4F90      		pop r4
 2095 047a 0895      		ret
 2096               		.cfi_endproc
 2097               	.LFE111:
 2099               		.comm	ConnectionStateTable,1602,1
 2100               		.comm	PortStateTable,5,1
 2101               		.text
 2102               	.Letext0:
 2103               		.file 3 "/usr/lib/avr/include/stdint.h"
 2104               		.file 4 "/usr/lib/avr/include/stdio.h"
 2105               		.file 5 "../../../../LUFA/Drivers/USB/Class/Device/../Common/RNDIS.h"
 2106               		.file 6 "../../../../LUFA/Drivers/USB/Class/Device/RNDIS.h"
 2107               		.file 7 "Lib/EthernetProtocols.h"
 2108               		.file 8 "Lib/IP.h"
 2109               		.file 9 "Lib/Ethernet.h"
 2110               		.file 10 "Lib/TCP.h"
 2111               		.file 11 "../../../../LUFA/Drivers/USB/Class/Device/../../Core/USBTask.h"
 2112               		.file 12 "../../../../LUFA/Drivers/Peripheral/AVR8/Serial_AVR8.h"
 2113               		.file 13 "/usr/lib/avr/include/string.h"
 2114               		.file 14 "Lib/ProtocolDecoders.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 TCP.c
     /tmp/ccgNx74r.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccgNx74r.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccgNx74r.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccgNx74r.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccgNx74r.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccgNx74r.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccgNx74r.s:13     .text.SwapEndian_32:0000000000000000 SwapEndian_32
     /tmp/ccgNx74r.s:36     .text.SwapEndian_16:0000000000000000 SwapEndian_16
     /tmp/ccgNx74r.s:56     .text.TCP_Checksum16:0000000000000000 TCP_Checksum16
     /tmp/ccgNx74r.s:249    .text.TCP_TCPTask:0000000000000000 TCP_TCPTask
                            *COM*:0000000000000642 ConnectionStateTable
                            *COM*:0000000000000005 PortStateTable
     /tmp/ccgNx74r.s:649    .text.TCP_Init:0000000000000000 TCP_Init
     /tmp/ccgNx74r.s:680    .text.TCP_SetPortState:0000000000000000 TCP_SetPortState
     /tmp/ccgNx74r.s:736    .text.TCP_GetPortState:0000000000000000 TCP_GetPortState
     /tmp/ccgNx74r.s:770    .text.TCP_SetConnectionState:0000000000000000 TCP_SetConnectionState
     /tmp/ccgNx74r.s:999    .text.TCP_GetConnectionState:0000000000000000 TCP_GetConnectionState
     /tmp/ccgNx74r.s:1155   .text.TCP_GetConnectionInfo:0000000000000000 TCP_GetConnectionInfo
     /tmp/ccgNx74r.s:1311   .text.TCP_ProcessTCPPacket:0000000000000000 TCP_ProcessTCPPacket

UNDEFINED SYMBOLS
memcpy
ServerIPAddress
Ethernet_Checksum16
ServerMACAddress
memcmp
DecodeTCPHeader
__tablejump2__
__do_copy_data
__do_clear_bss
