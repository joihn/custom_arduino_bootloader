   1               		.file	"V2Protocol.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.__vector_12,"ax",@progbits
  12               	.global	__vector_12
  14               	__vector_12:
  15               	.LFB117:
  16               		.file 1 "../AVRISP-MKII/Lib/V2Protocol.c"
   1:../AVRISP-MKII/Lib/V2Protocol.c **** /*
   2:../AVRISP-MKII/Lib/V2Protocol.c ****              LUFA Library
   3:../AVRISP-MKII/Lib/V2Protocol.c ****      Copyright (C) Dean Camera, 2011.
   4:../AVRISP-MKII/Lib/V2Protocol.c **** 
   5:../AVRISP-MKII/Lib/V2Protocol.c ****   dean [at] fourwalledcubicle [dot] com
   6:../AVRISP-MKII/Lib/V2Protocol.c ****            www.lufa-lib.org
   7:../AVRISP-MKII/Lib/V2Protocol.c **** */
   8:../AVRISP-MKII/Lib/V2Protocol.c **** 
   9:../AVRISP-MKII/Lib/V2Protocol.c **** /*
  10:../AVRISP-MKII/Lib/V2Protocol.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../AVRISP-MKII/Lib/V2Protocol.c **** 
  12:../AVRISP-MKII/Lib/V2Protocol.c ****   Permission to use, copy, modify, distribute, and sell this
  13:../AVRISP-MKII/Lib/V2Protocol.c ****   software and its documentation for any purpose is hereby granted
  14:../AVRISP-MKII/Lib/V2Protocol.c ****   without fee, provided that the above copyright notice appear in
  15:../AVRISP-MKII/Lib/V2Protocol.c ****   all copies and that both that the copyright notice and this
  16:../AVRISP-MKII/Lib/V2Protocol.c ****   permission notice and warranty disclaimer appear in supporting
  17:../AVRISP-MKII/Lib/V2Protocol.c ****   documentation, and that the name of the author not be used in
  18:../AVRISP-MKII/Lib/V2Protocol.c ****   advertising or publicity pertaining to distribution of the
  19:../AVRISP-MKII/Lib/V2Protocol.c ****   software without specific, written prior permission.
  20:../AVRISP-MKII/Lib/V2Protocol.c **** 
  21:../AVRISP-MKII/Lib/V2Protocol.c ****   The author disclaim all warranties with regard to this
  22:../AVRISP-MKII/Lib/V2Protocol.c ****   software, including all implied warranties of merchantability
  23:../AVRISP-MKII/Lib/V2Protocol.c ****   and fitness.  In no event shall the author be liable for any
  24:../AVRISP-MKII/Lib/V2Protocol.c ****   special, indirect or consequential damages or any damages
  25:../AVRISP-MKII/Lib/V2Protocol.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:../AVRISP-MKII/Lib/V2Protocol.c ****   in an action of contract, negligence or other tortious action,
  27:../AVRISP-MKII/Lib/V2Protocol.c ****   arising out of or in connection with the use or performance of
  28:../AVRISP-MKII/Lib/V2Protocol.c ****   this software.
  29:../AVRISP-MKII/Lib/V2Protocol.c **** */
  30:../AVRISP-MKII/Lib/V2Protocol.c **** 
  31:../AVRISP-MKII/Lib/V2Protocol.c **** /** \file
  32:../AVRISP-MKII/Lib/V2Protocol.c ****  *
  33:../AVRISP-MKII/Lib/V2Protocol.c ****  *  V2Protocol handler, to process V2 Protocol commands used in Atmel programmer devices.
  34:../AVRISP-MKII/Lib/V2Protocol.c ****  */
  35:../AVRISP-MKII/Lib/V2Protocol.c **** 
  36:../AVRISP-MKII/Lib/V2Protocol.c **** #define  INCLUDE_FROM_V2PROTOCOL_C
  37:../AVRISP-MKII/Lib/V2Protocol.c **** #include "V2Protocol.h"
  38:../AVRISP-MKII/Lib/V2Protocol.c **** 
  39:../AVRISP-MKII/Lib/V2Protocol.c **** /** Current memory address for FLASH/EEPROM memory read/write commands */
  40:../AVRISP-MKII/Lib/V2Protocol.c **** uint32_t CurrentAddress;
  41:../AVRISP-MKII/Lib/V2Protocol.c **** 
  42:../AVRISP-MKII/Lib/V2Protocol.c **** /** Flag to indicate that the next read/write operation must update the device's current extended F
  43:../AVRISP-MKII/Lib/V2Protocol.c **** bool MustLoadExtendedAddress;
  44:../AVRISP-MKII/Lib/V2Protocol.c **** 
  45:../AVRISP-MKII/Lib/V2Protocol.c **** 
  46:../AVRISP-MKII/Lib/V2Protocol.c **** /** ISR to manage timeouts whilst processing a V2Protocol command */
  47:../AVRISP-MKII/Lib/V2Protocol.c **** ISR(WDT_vect, ISR_BLOCK)
  48:../AVRISP-MKII/Lib/V2Protocol.c **** {
  17               		.loc 1 48 0
  18               		.cfi_startproc
  19 0000 1F92      		push r1
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 1, -2
  23 0002 0F92      		push r0
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 0, -3
  27 0004 0FB6      		in r0,__SREG__
  28 0006 0F92      		push r0
  29 0008 1124      		clr __zero_reg__
  30 000a 8F93      		push r24
  31               	.LCFI2:
  32               		.cfi_def_cfa_offset 5
  33               		.cfi_offset 24, -4
  34               	/* prologue: Signal */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  49:../AVRISP-MKII/Lib/V2Protocol.c **** 	TimeoutExpired = true;
  38               		.loc 1 49 0
  39 000c 81E0      		ldi r24,lo8(1)
  40 000e 8ABD      		out 0x2a,r24
  41               	.LBB94:
  42               	.LBB95:
  43               		.file 2 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 474:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 475:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 476:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 477:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 478:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 479:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 480:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 481:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 482:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 483:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 484:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 485:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 486:/usr/lib/avr/include/avr/wdt.h **** 		);
 487:/usr/lib/avr/include/avr/wdt.h **** 	}
 488:/usr/lib/avr/include/avr/wdt.h **** }
 489:/usr/lib/avr/include/avr/wdt.h **** 
 490:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 491:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 492:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 493:/usr/lib/avr/include/avr/wdt.h **** {
 494:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 495:/usr/lib/avr/include/avr/wdt.h **** 	{
 496:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 497:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 498:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 499:/usr/lib/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 500:/usr/lib/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 501:/usr/lib/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 502:/usr/lib/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 503:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 504:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 505:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 506:/usr/lib/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 507:/usr/lib/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 508:/usr/lib/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 509:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 510:/usr/lib/avr/include/avr/wdt.h **** 		);
 511:/usr/lib/avr/include/avr/wdt.h **** 	}
 512:/usr/lib/avr/include/avr/wdt.h **** 	else
 513:/usr/lib/avr/include/avr/wdt.h **** 	{
 514:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 515:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
  44               		.loc 2 515 0
  45               	/* #APP */
  46               	 ;  515 "/usr/lib/avr/include/avr/wdt.h" 1
  47 0010 0FB6      		in __tmp_reg__,__SREG__
  48 0012 F894      		cli
  49 0014 A895      		wdr
  50 0016 8091 6000 		lds r24,96
  51 001a 8861      		ori r24,24
  52 001c 8093 6000 		sts 96,r24
  53 0020 1092 6000 		sts 96,__zero_reg__
  54 0024 0FBE      		out __SREG__,__tmp_reg__
  55               		
  56               	 ;  0 "" 2
  57               	/* epilogue start */
  58               	/* #NOAPP */
  59               	.LBE95:
  60               	.LBE94:
  50:../AVRISP-MKII/Lib/V2Protocol.c **** 	wdt_disable();
  51:../AVRISP-MKII/Lib/V2Protocol.c **** }
  61               		.loc 1 51 0
  62 0026 8F91      		pop r24
  63 0028 0F90      		pop r0
  64 002a 0FBE      		out __SREG__,r0
  65 002c 0F90      		pop r0
  66 002e 1F90      		pop r1
  67 0030 1895      		reti
  68               		.cfi_endproc
  69               	.LFE117:
  71               		.section	.text.V2Protocol_Init,"ax",@progbits
  72               	.global	V2Protocol_Init
  74               	V2Protocol_Init:
  75               	.LFB118:
  52:../AVRISP-MKII/Lib/V2Protocol.c **** 
  53:../AVRISP-MKII/Lib/V2Protocol.c **** /** Initializes the hardware and software associated with the V2 protocol command handling. */
  54:../AVRISP-MKII/Lib/V2Protocol.c **** void V2Protocol_Init(void)
  55:../AVRISP-MKII/Lib/V2Protocol.c **** {
  76               		.loc 1 55 0
  77               		.cfi_startproc
  78               	/* prologue: function */
  79               	/* frame size = 0 */
  80               	/* stack size = 0 */
  81               	.L__stack_usage = 0
  82               	.LVL0:
  83               	.LBB102:
  84               	.LBB103:
  85               		.file 3 "../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h"
   1:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** /*
   2:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****              LUFA Library
   3:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
   5:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****            www.lufa-lib.org
   7:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** */
   8:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
   9:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** /*
  10:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  12:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  21:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****   this software.
  29:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** */
  30:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  31:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** /** \file
  32:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  \brief ADC Peripheral Driver (AVR8)
  33:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  34:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  On-chip Analogue-to-Digital converter (ADC) driver for supported U4, U6 and U7 model AVRs that 
  35:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  peripheral internally.
  36:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  37:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  38:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *        dispatch header located in LUFA/Drivers/Peripheral/ADC.h.
  39:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  */
  40:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  41:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** /** \ingroup Group_ADC
  42:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  \defgroup Group_ADC_AVR8 ADC Peripheral Driver (AVR8)
  43:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  44:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  \section Sec_ModDescription Module Description
  45:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  On-chip Analogue-to-Digital converter (ADC) driver for supported U4, U6 and U7 model AVRs that 
  46:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  peripheral internally.
  47:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  48:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  49:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *        dispatch header located in LUFA/Drivers/Peripheral/ADC.h.
  50:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  51:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  \section Sec_ExampleUsage Example Usage
  52:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  The following snippet is an example of how this module may be used within a typical
  53:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  application.
  54:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  55:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  \code
  56:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      // Initialize the ADC driver before first use
  57:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      ADC_Init(ADC_FREE_RUNNING | ADC_PRESCALE_32);
  58:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  59:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      // Must setup the ADC channel to read beforehand
  60:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      ADC_SetupChannel(1);
  61:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  62:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      // Perform a single conversion of the ADC channel 1
  63:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      ADC_GetChannelReading(ADC_REFERENCE_AVCC | ADC_RIGHT_ADJUSTED | ADC_CHANNEL1);
  64:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      printf("Conversion Result: %d\r\n", ADC_GetResult());
  65:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  66:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      // Start reading ADC channel 1 in free running (continuous conversion) mode
  67:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      ADC_StartReading(ADC_REFERENCE_AVCC | ADC_RIGHT_ADJUSTED | ADC_CHANNEL1);
  68:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      for (;;)
  69:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      {
  70:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *           while (!(ADC_IsReadingComplete())) {};
  71:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *           printf("Conversion Result: %d\r\n", ADC_GetResult());
  72:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *      }
  73:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  \endcode
  74:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *
  75:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  *  @{
  76:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h ****  */
  77:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  78:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** #ifndef __ADC_AVR8_H__
  79:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** #define __ADC_AVR8_H__
  80:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  81:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 	/* Includes: */
  82:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		#include "../../../Common/Common.h"
  83:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  84:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  85:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		#if defined(__cplusplus)
  86:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			extern "C" {
  87:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		#endif
  88:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  89:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 	/* Preprocessor Checks: */
  90:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		#if !defined(__INCLUDE_FROM_ADC_H)
  91:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/Peripheral/ADC.h instead.
  92:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		#endif
  93:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
  94:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		#if !(defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB646__) || \
  95:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		      defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB647__) || \
  96:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			  defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || \
  97:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			  defined(__AVR_ATmega32U6__))
  98:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#error The ADC peripheral driver is not currently available for your selected microcontroller mo
  99:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		#endif
 100:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 101:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 	/* Private Interface - For use in library only: */
 102:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 	#if !defined(__DOXYGEN__)
 103:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		/* Macros: */
 104:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define _ADC_GET_MUX_MASK2(y)           ADC_CHANNEL ## y
 105:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define _ADC_GET_MUX_MASK(y)            _ADC_GET_MUX_MASK2(y)
 106:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 	#endif
 107:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 	
 108:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 109:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		/* Macros: */
 110:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** \name ADC Reference Configuration Masks */
 111:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@{
 112:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Reference mask, for using the voltage present at the AVR's AREF pin for the ADC reference. *
 113:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_REFERENCE_AREF              0
 114:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 115:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Reference mask, for using the voltage present at the AVR's AVCC pin for the ADC reference. *
 116:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_REFERENCE_AVCC              (1 << REFS0)
 117:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 118:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Reference mask, for using the internally generated 2.56V reference voltage as the ADC refere
 119:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_REFERENCE_INT2560MV         ((1 << REFS1) | (1 << REFS0))
 120:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@}
 121:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			
 122:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** \name ADC Result Adjustment Configuration Masks */
 123:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@{
 124:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Left-adjusts the 10-bit ADC result, so that the upper 8 bits of the value returned by the
 125:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \ref ADC_GetResult() macro contain the 8 most significant bits of the result.
 126:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 127:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_LEFT_ADJUSTED               (1 << ADLAR)
 128:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 129:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Right-adjusts the 10-bit ADC result, so that the lower 8 bits of the value returned by the
 130:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \ref ADC_GetResult() macro contain the 8 least significant bits of the result.
 131:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 132:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_RIGHT_ADJUSTED              (0 << ADLAR)
 133:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@}
 134:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 135:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** \name ADC Mode Configuration Masks */
 136:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@{
 137:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC mode to free running, so that conversions take place continuously as fast as th
 138:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  is capable of at the given input clock speed.
 139:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 140:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_FREE_RUNNING                (1 << ADATE)
 141:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 142:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC mode to single conversion, so that only a single conversion will take place bef
 143:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  the ADC returns to idle.
 144:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 145:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_SINGLE_CONVERSION           (0 << ADATE)
 146:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@}
 147:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			
 148:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** \name ADC Prescaler Configuration Masks */
 149:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@{
 150:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC input clock to prescale by a factor of 2 the AVR's system clock. */
 151:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_PRESCALE_2                  (1 << ADPS0)
 152:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 153:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC input clock to prescale by a factor of 4 the AVR's system clock. */
 154:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_PRESCALE_4                  (1 << ADPS1)
 155:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 156:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC input clock to prescale by a factor of 8 the AVR's system clock. */
 157:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_PRESCALE_8                  ((1 << ADPS0) | (1 << ADPS1))
 158:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 159:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC input clock to prescale by a factor of 16 the AVR's system clock. */
 160:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_PRESCALE_16                 (1 << ADPS2)
 161:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 162:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC input clock to prescale by a factor of 32 the AVR's system clock. */
 163:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_PRESCALE_32                 ((1 << ADPS2) | (1 << ADPS0))
 164:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 165:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC input clock to prescale by a factor of 64 the AVR's system clock. */
 166:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_PRESCALE_64                 ((1 << ADPS2) | (1 << ADPS1))
 167:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 168:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Sets the ADC input clock to prescale by a factor of 128 the AVR's system clock. */
 169:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_PRESCALE_128                ((1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0))
 170:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@}
 171:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 172:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** \name ADC MUX Masks */
 173:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@{
 174:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** MUX mask define for the ADC0 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_Ge
 175:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_CHANNEL0                    (0x00 << MUX0)
 176:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 177:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** MUX mask define for the ADC1 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_Ge
 178:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_CHANNEL1                    (0x01 << MUX0)
 179:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 180:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#if !(defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || defined(__DOXYGEN__))
 181:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the ADC2 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_G
 182:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 183:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 184:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 185:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_CHANNEL2                (0x02 << MUX0)
 186:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 187:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the ADC3 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_G
 188:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 189:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 190:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 191:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_CHANNEL3                (0x03 << MUX0)
 192:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#endif
 193:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 194:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** MUX mask define for the ADC4 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_Ge
 195:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_CHANNEL4                    (0x04 << MUX0)
 196:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 197:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** MUX mask define for the ADC5 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_Ge
 198:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_CHANNEL5                    (0x05 << MUX0)
 199:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 200:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** MUX mask define for the ADC6 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_Ge
 201:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_CHANNEL6                    (0x06 << MUX0)
 202:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 203:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** MUX mask define for the ADC7 channel of the ADC. See \ref ADC_StartReading and \ref ADC_GetC
 204:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_CHANNEL7                    (0x07 << MUX0)
 205:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 206:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** MUX mask define for the internal 1.1V bandgap channel of the ADC. See \ref ADC_StartReading(
 207:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_1100MV_BANDGAP              (0x1E << MUX0)
 208:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 209:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#if (defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || defined(__DOXYGEN__))
 210:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the ADC8 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_G
 211:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 212:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 213:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 214:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_CHANNEL8                ((1 << 8) | (0x00 << MUX0))
 215:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 216:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the ADC9 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_G
 217:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 218:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 219:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 220:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_CHANNEL9                ((1 << 8) | (0x01 << MUX0))
 221:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 222:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the ADC10 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_
 223:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 224:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 225:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 226:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_CHANNEL10               ((1 << 8) | (0x02 << MUX0))
 227:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 228:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the ADC11 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_
 229:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 230:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 231:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 232:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_CHANNEL11               ((1 << 8) | (0x03 << MUX0))
 233:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 234:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the ADC12 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_
 235:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 236:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 237:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 238:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_CHANNEL12               ((1 << 8) | (0x04 << MUX0))
 239:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 240:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the ADC13 channel of the ADC. See \ref ADC_StartReading() and \ref ADC_
 241:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 242:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 243:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 244:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_CHANNEL13               ((1 << 8) | (0x05 << MUX0))
 245:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 246:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				/** MUX mask define for the internal temperature sensor channel of the ADC. See \ref ADC_StartR
 247:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \ref ADC_GetChannelReading().
 248:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *
 249:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 *  \note Not available on all AVR models.
 250:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				 */
 251:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#define ADC_INT_TEMP_SENS           ((1 << 8) | (0x07 << MUX0))
 252:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#endif
 253:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 254:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Retrieves the ADC MUX mask for the given ADC channel number.
 255:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 256:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \note This macro will only work correctly on channel numbers that are compile-time
 257:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *        constants defined by the preprocessor.
 258:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 259:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \param[in] Channel  Index of the ADC channel whose MUX mask is to be retrieved.
 260:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 261:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			#define ADC_GET_CHANNEL_MASK(Channel)   _ADC_GET_MUX_MASK(Channel)
 262:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			//@}
 263:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 264:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 		/* Inline Functions: */
 265:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Configures the given ADC channel, ready for ADC conversions. This function sets the
 266:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  associated port pin as an input and disables the digital portion of the I/O to reduce
 267:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  power consumption.
 268:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 269:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \note This must only be called for ADC channels with are connected to a physical port
 270:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *        pin of the AVR, denoted by its special alternative function ADCx.
 271:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *        \n\n
 272:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 273:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \note The channel number must be specified as an integer, and <b>not</b> a \c ADC_CHANNEL* m
 274:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 275:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \param[in] ChannelIndex  ADC channel number to set up for conversions.
 276:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 277:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline void ADC_SetupChannel(const uint8_t ChannelIndex)
 278:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			{
 279:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#if (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB646__) || \
 280:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					 defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB647__) || \
 281:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					 defined(__AVR_ATmega32U6__))
 282:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				DDRF  &= ~(1 << ChannelIndex);
 283:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				DIDR0 |=  (1 << ChannelIndex);
 284:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#elif (defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__))
 285:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				if (ChannelIndex < 8)
 286:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				{
 287:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DDRF  &= ~(1 << ChannelIndex);
 288:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DIDR0 |=  (1 << ChannelIndex);
 289:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				}
 290:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				else if (ChannelIndex == 8)
 291:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				{
 292:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DDRD  &= ~(1 << 4);
 293:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DIDR2 |=  (1 << 0);
 294:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				}
 295:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				else if (ChannelIndex < 11)
 296:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				{
 297:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DDRD  &= ~(1 << (ChannelIndex - 3));
 298:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DIDR2 |=  (1 << (ChannelIndex - 8));
 299:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				}
 300:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				else
 301:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				{
 302:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DDRB  &= ~(1 << (ChannelIndex - 7));
 303:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DIDR2 |=  (1 << (ChannelIndex - 8));
 304:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				}
 305:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#endif
 306:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			}
 307:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 308:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** De-configures the given ADC channel, re-enabling digital I/O mode instead of analog. This
 309:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  function sets the associated port pin as an input and re-enabled the digital portion of
 310:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  the I/O.
 311:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 312:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \note This must only be called for ADC channels with are connected to a physical port
 313:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *        pin of the AVR, denoted by its special alternative function ADCx.
 314:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *        \n\n
 315:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 316:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \note The channel number must be specified as an integer, and <b>not</b> a \c ADC_CHANNEL* m
 317:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 318:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \param[in] ChannelIndex  ADC channel number to set up for conversions.
 319:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 320:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline void ADC_DisableChannel(const uint8_t ChannelIndex)
 321:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			{
 322:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#if (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB646__) || \
 323:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					 defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB647__) || \
 324:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					 defined(__AVR_ATmega32U6__))
 325:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				DDRF  &= ~(1 << ChannelIndex);
 326:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				DIDR0 &= ~(1 << ChannelIndex);
 327:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#elif (defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__))
 328:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				if (ChannelIndex < 8)
 329:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				{
 330:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DDRF  &= ~(1 << ChannelIndex);
 331:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DIDR0 &= ~(1 << ChannelIndex);
 332:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				}
 333:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				else if (ChannelIndex == 8)
 334:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				{
 335:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DDRD  &= ~(1 << 4);
 336:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DIDR2 &= ~(1 << 0);
 337:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				}
 338:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				else if (ChannelIndex < 11)
 339:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				{
 340:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DDRD  &= ~(1 << (ChannelIndex - 3));
 341:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DIDR2 &= ~(1 << (ChannelIndex - 8));
 342:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				}
 343:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				else
 344:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				{
 345:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DDRB  &= ~(1 << (ChannelIndex - 7));
 346:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 					DIDR2 &= ~(1 << (ChannelIndex - 8));
 347:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				}
 348:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#endif
 349:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			}
 350:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 351:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Starts the reading of the given channel, but does not wait until the conversion has complete
 352:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  Once executed, the conversion status can be determined via the \ref ADC_IsReadingComplete() 
 353:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  the result read via the \ref ADC_GetResult() macro.
 354:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 355:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  If the ADC has been initialized in free running mode, calling this function once will begin 
 356:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  conversions. If the ADC is in single conversion mode (or the channel to convert from is to b
 357:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  this function must be called each time a conversion is to take place.
 358:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 359:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \param[in] MUXMask  ADC channel mask, reference mask and adjustment mask.
 360:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 361:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline void ADC_StartReading(const uint16_t MUXMask)
 362:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			{
 363:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				ADMUX = MUXMask;
 364:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 365:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#if (defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || defined(__DOXYGEN__))
 366:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				if (MUXMask & (1 << 8))
 367:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				  ADCSRB |=  (1 << MUX5);
 368:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				else
 369:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				  ADCSRB &= ~(1 << MUX5);
 370:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#endif
 371:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 372:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				ADCSRA |= (1 << ADSC);
 373:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			}
 374:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 375:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Indicates if the current ADC conversion is completed, or still in progress.
 376:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 377:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \return Boolean false if the reading is still taking place, or true if the conversion is
 378:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *          complete and ready to be read out with \ref ADC_GetResult().
 379:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 380:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline bool ADC_IsReadingComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 381:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline bool ADC_IsReadingComplete(void)
 382:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			{
 383:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				return ((ADCSRA & (1 << ADIF)) ? true : false);
 384:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			}
 385:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 386:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Retrieves the conversion value of the last completed ADC conversion and clears the reading
 387:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  completion flag.
 388:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 389:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \return The result of the last ADC conversion as an unsigned value.
 390:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 391:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline uint16_t ADC_GetResult(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 392:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline uint16_t ADC_GetResult(void)
 393:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			{
 394:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				ADCSRA |= (1 << ADIF);
 395:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				return ADC;
 396:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			}
 397:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 398:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Performs a complete single reading from channel, including a polling spin-loop to wait for t
 399:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  conversion to complete, and the returning of the converted value.
 400:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 401:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \note For free running mode, the automated conversions should be initialized with a single c
 402:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *        to \ref ADC_StartReading() to select the channel and begin the automated conversions, 
 403:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *        the results read directly from the \ref ADC_GetResult() instead to reduce overhead.
 404:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 405:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \param[in] MUXMask  Mask comprising of an ADC channel mask, reference mask and adjustment ma
 406:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 407:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \return Converted ADC result for the given ADC channel.
 408:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 409:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask) ATTR_WARN_UNUSED_RESULT;
 410:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask)
 411:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			{
 412:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				ADC_StartReading(MUXMask);
 413:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 414:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				while (!(ADC_IsReadingComplete()));
 415:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 416:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				return ADC_GetResult();
 417:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			}
 418:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 419:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			/** Initializes the ADC, ready for conversions. This must be called before any other ADC operati
 420:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  The "mode" parameter should be a mask comprised of a conversion mode (free running or single
 421:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  prescaler masks.
 422:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *
 423:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 *  \param[in] Mode  Mask of ADC prescale and mode settings.
 424:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			 */
 425:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline void ADC_Init(uint8_t Mode) ATTR_ALWAYS_INLINE;
 426:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			static inline void ADC_Init(uint8_t Mode)
 427:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			{
 428:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				ADCSRA = ((1 << ADEN) | Mode);
  86               		.loc 3 428 0
  87 0000 EAE7      		ldi r30,lo8(122)
  88 0002 F0E0      		ldi r31,0
  89 0004 87EA      		ldi r24,lo8(-89)
  90 0006 8083      		st Z,r24
  91               	.LVL1:
  92               	.LBE103:
  93               	.LBE102:
  94               	.LBB104:
  95               	.LBB105:
 282:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				DIDR0 |=  (1 << ChannelIndex);
  96               		.loc 3 282 0
  97 0008 8298      		cbi 0x10,2
 283:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 				#elif (defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__))
  98               		.loc 3 283 0
  99 000a AEE7      		ldi r26,lo8(126)
 100 000c B0E0      		ldi r27,0
 101 000e 8C91      		ld r24,X
 102 0010 8460      		ori r24,lo8(4)
 103 0012 8C93      		st X,r24
 104               	.LVL2:
 105               	.LBE105:
 106               	.LBE104:
 107               	.LBB106:
 108               	.LBB107:
 363:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 
 109               		.loc 3 363 0
 110 0014 82E4      		ldi r24,lo8(66)
 111 0016 8093 7C00 		sts 124,r24
 372:../../LUFA/Drivers/Peripheral/AVR8/ADC_AVR8.h **** 			}
 112               		.loc 3 372 0
 113 001a 8081      		ld r24,Z
 114 001c 8064      		ori r24,lo8(64)
 115 001e 8083      		st Z,r24
 116               	.LVL3:
 117               	.LBE107:
 118               	.LBE106:
  56:../AVRISP-MKII/Lib/V2Protocol.c **** 	#if defined(ADC)
  57:../AVRISP-MKII/Lib/V2Protocol.c **** 	/* Initialize the ADC converter for VTARGET level detection on supported AVR models */
  58:../AVRISP-MKII/Lib/V2Protocol.c **** 	ADC_Init(ADC_FREE_RUNNING | ADC_PRESCALE_128);
  59:../AVRISP-MKII/Lib/V2Protocol.c **** 	ADC_SetupChannel(VTARGET_ADC_CHANNEL);
  60:../AVRISP-MKII/Lib/V2Protocol.c **** 	ADC_StartReading(VTARGET_REF_MASK | ADC_RIGHT_ADJUSTED | VTARGET_ADC_CHANNEL_MASK);
  61:../AVRISP-MKII/Lib/V2Protocol.c **** 	#endif
  62:../AVRISP-MKII/Lib/V2Protocol.c **** 
  63:../AVRISP-MKII/Lib/V2Protocol.c **** 	V2Params_LoadNonVolatileParamValues();
 119               		.loc 1 63 0
 120 0020 0C94 0000 		jmp V2Params_LoadNonVolatileParamValues
 121               	.LVL4:
 122               		.cfi_endproc
 123               	.LFE118:
 125               		.section	.rodata.str1.1,"aMS",@progbits,1
 126               	.LC0:
 127 0000 4156 5249 		.string	"AVRISP_MK2"
 127      5350 5F4D 
 127      4B32 00
 128               		.section	.text.V2Protocol_ProcessCommand,"ax",@progbits
 129               	.global	V2Protocol_ProcessCommand
 131               	V2Protocol_ProcessCommand:
 132               	.LFB119:
  64:../AVRISP-MKII/Lib/V2Protocol.c **** 	
  65:../AVRISP-MKII/Lib/V2Protocol.c **** 	#if defined(ENABLE_ISP_PROTOCOL)
  66:../AVRISP-MKII/Lib/V2Protocol.c **** 	ISPTarget_ConfigureRescueClock();
  67:../AVRISP-MKII/Lib/V2Protocol.c **** 	#endif
  68:../AVRISP-MKII/Lib/V2Protocol.c **** }
  69:../AVRISP-MKII/Lib/V2Protocol.c **** 
  70:../AVRISP-MKII/Lib/V2Protocol.c **** /** Master V2 Protocol packet handler, for received V2 Protocol packets from a connected host.
  71:../AVRISP-MKII/Lib/V2Protocol.c ****  *  This routine decodes the issued command and passes off the handling of the command to the
  72:../AVRISP-MKII/Lib/V2Protocol.c ****  *  appropriate function.
  73:../AVRISP-MKII/Lib/V2Protocol.c ****  */
  74:../AVRISP-MKII/Lib/V2Protocol.c **** void V2Protocol_ProcessCommand(void)
  75:../AVRISP-MKII/Lib/V2Protocol.c **** {
 133               		.loc 1 75 0
 134               		.cfi_startproc
 135 0000 1F93      		push r17
 136               	.LCFI3:
 137               		.cfi_def_cfa_offset 3
 138               		.cfi_offset 17, -2
 139 0002 CF93      		push r28
 140               	.LCFI4:
 141               		.cfi_def_cfa_offset 4
 142               		.cfi_offset 28, -3
 143 0004 DF93      		push r29
 144               	.LCFI5:
 145               		.cfi_def_cfa_offset 5
 146               		.cfi_offset 29, -4
 147               	/* prologue: function */
 148               	/* frame size = 0 */
 149               	/* stack size = 3 */
 150               	.L__stack_usage = 3
 151               	.LBB204:
 152               	.LBB205:
 153               		.file 4 "../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h"
   1:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /*
   2:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****              LUFA Library
   3:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
   5:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****            www.lufa-lib.org
   7:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** */
   8:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
   9:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /*
  10:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  12:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  21:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   this software.
  29:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** */
  30:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  31:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \file
  32:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief USB Endpoint definitions for the AVR8 microcontrollers.
  33:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \copydetails Group_EndpointManagement_AVR8
  34:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  35:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  38:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  39:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \ingroup Group_EndpointRW
  40:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \defgroup Group_EndpointRW_AVR8 Endpoint Data Reading and Writing (AVR8)
  41:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief Endpoint data read/write definitions for the Atmel AVR8 architecture.
  42:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  43:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to e
  44:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  45:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  46:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \ingroup Group_EndpointPrimitiveRW
  47:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \defgroup Group_EndpointPrimitiveRW_AVR8 Read/Write of Primitive Data Types (AVR8)
  48:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief Endpoint primitive read/write definitions for the Atmel AVR8 architecture.
  49:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  50:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  51:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  from and to endpoints.
  52:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  53:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  54:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \ingroup Group_EndpointPacketManagement
  55:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \defgroup Group_EndpointPacketManagement_AVR8 Endpoint Packet Management (AVR8)
  56:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief Endpoint packet management definitions for the Atmel AVR8 architecture.
  57:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  58:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  Functions, macros, variables, enums and types related to packet management of endpoints.
  59:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  60:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  61:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \ingroup Group_EndpointManagement
  62:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \defgroup Group_EndpointManagement_AVR8 Endpoint Management (AVR8)
  63:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief Endpoint management definitions for the Atmel AVR8 architecture.
  64:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  65:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  Functions, macros and enums related to endpoint management when in USB Device mode. This
  66:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  module contains the endpoint management macros, as well as endpoint interrupt and data
  67:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  send/receive functions for various data types.
  68:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  69:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  @{
  70:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  71:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  72:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** #ifndef __ENDPOINT_AVR8_H__
  73:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** #define __ENDPOINT_AVR8_H__
  74:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  75:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Includes: */
  76:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#include "../../../../Common/Common.h"
  77:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#include "../USBTask.h"
  78:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#include "../USBInterrupt.h"
  79:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  80:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  81:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#if defined(__cplusplus)
  82:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			extern "C" {
  83:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#endif
  84:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  85:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Preprocessor Checks: */
  86:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  87:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  88:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#endif
  89:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  90:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Private Interface - For use in library only: */
  91:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	#if !defined(__DOXYGEN__)
  92:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Macros: */
  93:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_MAXSIZE(EPIndex)         _ENDPOINT_GET_MAXSIZE2(ENDPOINT_DETAILS_EP ## EPI
  94:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_MAXSIZE2(EPDetails)      _ENDPOINT_GET_MAXSIZE3(EPDetails)
  95:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_MAXSIZE3(MaxSize, Banks) (MaxSize)
  96:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  97:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_BANKS(EPIndex)           _ENDPOINT_GET_BANKS2(ENDPOINT_DETAILS_EP ## EPInd
  98:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_BANKS2(EPDetails)        _ENDPOINT_GET_BANKS3(EPDetails)
  99:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_BANKS3(MaxSize, Banks)   (Banks)
 100:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 101:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
 102:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_MAXEP             7
 103:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 104:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP0               64,  1
 105:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP1               256, 2
 106:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP2               64,  2
 107:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP3               64,  2
 108:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP4               64,  2
 109:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP5               64,  2
 110:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP6               64,  2
 111:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#else
 112:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_MAXEP             5
 113:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 114:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP0               64,  1
 115:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP1               64,  1
 116:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP2               64,  1
 117:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP3               64,  2
 118:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP4               64,  2
 119:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#endif
 120:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 121:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Inline Functions: */
 122:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT A
 123:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                                                       ATTR_ALWAYS_INLINE;
 124:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
 125:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 126:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				uint8_t  MaskVal    = 0;
 127:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				uint16_t CheckBytes = 8;
 128:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 129:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				while (CheckBytes < Bytes)
 130:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 131:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					MaskVal++;
 132:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					CheckBytes <<= 1;
 133:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				}
 134:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 135:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return (MaskVal << EPSIZE0);
 136:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 137:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 138:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Function Prototypes: */
 139:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			void Endpoint_ClearEndpoints(void);
 140:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
 141:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                    const uint8_t UECFG0XData,
 142:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                    const uint8_t UECFG1XData);
 143:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 144:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	#endif
 145:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 146:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 147:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Macros: */			
 148:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** \name Endpoint Bank Mode Masks */
 149:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			//@{
 150:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Endpoint_ConfigureEndpoint() macro. This indic
 151:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  that the endpoint should have one single bank, which requires less USB FIFO memory but resul
 152:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  in slower transfers as only one USB device (the AVR or the host) can access the endpoint's
 153:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  bank at the one time.
 154:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 155:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define ENDPOINT_BANK_SINGLE                    (0 << EPBK0)
 156:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 157:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Endpoint_ConfigureEndpoint() macro. This indic
 158:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  that the endpoint should have two banks, which requires more USB FIFO memory but results
 159:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  in faster transfers as one USB device (the AVR or the host) can access one bank while the ot
 160:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  accesses the second bank.
 161:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 162:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define ENDPOINT_BANK_DOUBLE                    (1 << EPBK0)
 163:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			//@}
 164:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 165:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#if (!defined(FIXED_CONTROL_ENDPOINT_SIZE) || defined(__DOXYGEN__))
 166:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				/** Default size of the default control endpoint's bank, until altered by the control endpoint 
 167:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 *  value in the device descriptor. Not available if the \c FIXED_CONTROL_ENDPOINT_SIZE token i
 168:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 */
 169:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_CONTROLEP_DEFAULT_SIZE     8
 170:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#endif
 171:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 172:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Retrieves the maximum bank size in bytes of a given endpoint.
 173:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 174:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note This macro will only work correctly on endpoint indexes that are compile-time constant
 175:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        defined by the preprocessor.
 176:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 177:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EPIndex  Endpoint number, a value between 0 and (\ref ENDPOINT_TOTAL_ENDPOINTS - 
 178:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 179:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define ENDPOINT_MAX_SIZE(EPIndex)              _ENDPOINT_GET_MAXSIZE(EPIndex)
 180:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 181:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Retrieves the total number of banks supported by the given endpoint.
 182:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 183:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note This macro will only work correctly on endpoint indexes that are compile-time constant
 184:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        defined by the preprocessor.
 185:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 186:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EPIndex  Endpoint number, a value between 0 and (\ref ENDPOINT_TOTAL_ENDPOINTS - 
 187:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 188:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define ENDPOINT_BANKS_SUPPORTED(EPIndex)       _ENDPOINT_GET_BANKS(EPIndex)
 189:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 190:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#if !defined(CONTROL_ONLY_DEVICE) || defined(__DOXYGEN__)
 191:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				/** Total number of endpoints (including the default control endpoint at address 0) which may
 192:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 *  be used in the device. Different USB AVR models support different amounts of endpoints,
 193:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 *  this value reflects the maximum number of endpoints for the currently selected AVR model.
 194:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 */
 195:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_TOTAL_ENDPOINTS            ENDPOINT_DETAILS_MAXEP
 196:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#else
 197:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_TOTAL_ENDPOINTS            1
 198:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#endif
 199:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 200:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Enums: */
 201:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Enum for the possible error return codes of the \ref Endpoint_WaitUntilReady() function.
 202:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 203:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointRW_AVR8
 204:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 205:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			enum Endpoint_WaitUntilReady_ErrorCodes_t
 206:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 207:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_NoError                 = 0, /**< Endpoint is ready for next packet, no erro
 208:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_EndpointStalled         = 1, /**< The endpoint was stalled during the stream
 209:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   transfer by the host or device.
 210:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 */
 211:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host whil
 212:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   waiting for the endpoint to become ready.
 213:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 */
 214:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_BusSuspended            = 3, /**< The USB bus has been suspended by the host
 215:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   no USB endpoint traffic can occur until th
 216:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   has resumed.
 217:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 */
 218:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_Timeout                 = 4, /**< The host failed to accept or send the next
 219:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   within the software timeout period set by 
 220:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   \ref USB_STREAM_TIMEOUT_MS macro.
 221:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 */
 222:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			};
 223:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 224:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Inline Functions: */
 225:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Configures the specified endpoint number with the given endpoint type, direction, bank size
 226:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  and banking mode. Once configured, the endpoint may be read from or written to, depending
 227:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  on its direction.
 228:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 229:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Number     Endpoint number to configure. This must be more than 0 and less than
 230:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        \ref ENDPOINT_TOTAL_ENDPOINTS.
 231:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 232:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Type       Type of endpoint to configure, a \c EP_TYPE_* mask. Not all endpoint t
 233:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        are available on Low Speed USB devices - refer to the USB 2.0 specific
 234:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 235:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Direction  Endpoint data direction, either \ref ENDPOINT_DIR_OUT or \ref ENDPOINT
 236:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        All endpoints (except Control type) are unidirectional - data may only
 237:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        from or written to the endpoint bank based on its direction, not both.
 238:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 239:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Size       Size of the endpoint's bank, where packets are stored before they are 
 240:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        to the USB host, or after they have been received from the USB host (d
 241:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        the endpoint's data direction). The bank size must indicate the maximu
 242:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        that the endpoint can handle.
 243:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 244:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Banks      Number of banks to use for the endpoint being configured, an \c ENDPOI
 245:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        More banks uses more USB DPRAM, but offers better performance. Isochro
 246:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        endpoints <b>must</b> have at least two banks.
 247:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 248:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note When the \c ORDERED_EP_CONFIG compile time option is used, Endpoints <b>must</b> be co
 249:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        ascending order, or bank corruption will occur.
 250:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        \n\n
 251:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 252:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note Different endpoints may have different maximum packet sizes based on the endpoint's in
 253:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        the chosen microcontroller model's datasheet to determine the maximum bank size for ea
 254:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        \n\n
 255:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 256:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note The default control endpoint should not be manually configured by the user application
 257:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        it is automatically configured by the library internally.
 258:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        \n\n
 259:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 260:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note This routine will automatically select the specified endpoint upon success. Upon failu
 261:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        which failed to reconfigure correctly will be selected.
 262:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 263:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the configuration succeeded, \c false otherwise.
 264:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 265:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Number,
 266:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Type,
 267:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Direction,
 268:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint16_t Size,
 269:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Banks) ATTR_ALWAYS_INLINE;
 270:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Number,
 271:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Type,
 272:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Direction,
 273:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint16_t Size,
 274:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Banks)
 275:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 276:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 
 277:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 278:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 279:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 280:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Indicates the number of bytes currently stored in the current endpoint's selected bank.
 281:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 282:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note The return width of this function may differ, depending on the maximum endpoint bank s
 283:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        of the selected AVR model.
 284:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 285:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointRW_AVR8
 286:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 287:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
 288:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 289:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE
 290:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint16_t Endpoint_BytesInEndpoint(void)
 291:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 292:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
 293:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return UEBCX;
 294:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#elif defined(USB_SERIES_4_AVR)
 295:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return (((uint16_t)UEBCHX << 8) | UEBCLX);
 296:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#elif defined(USB_SERIES_2_AVR)
 297:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return UEBCLX;
 298:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 299:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 300:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 301:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Get the endpoint address of the currently selected endpoint. This is typically used to save
 302:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  the currently selected endpoint number so that it can be restored after another endpoint has
 303:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  been manipulated.
 304:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 305:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Index of the currently selected endpoint.
 306:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 307:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLI
 308:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
 309:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 310:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 311:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return (UENUM & ENDPOINT_EPNUM_MASK);
 312:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 313:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return ENDPOINT_CONTROLEP;
 314:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 315:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 316:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 317:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Selects the given endpoint number. If the address from the device descriptors is used, the
 318:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  value should be masked with the \ref ENDPOINT_EPNUM_MASK constant to extract only the endpoi
 319:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  number (and discarding the endpoint direction bit).
 320:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 321:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  Any endpoint operations which do not require the endpoint number to be indicated will operat
 322:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  the currently selected endpoint.
 323:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 324:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EndpointNumber Endpoint number to select.
 325:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 326:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
 327:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
 328:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 329:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 330:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UENUM = EndpointNumber;
 331:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 332:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 333:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 334:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Resets the endpoint bank FIFO. This clears all the endpoint banks and resets the USB control
 335:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  data In and Out pointers to the bank's contents.
 336:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 337:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
 338:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 339:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
 340:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
 341:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 342:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UERST = (1 << EndpointNumber);
 343:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UERST = 0;
 344:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 345:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 346:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Enables the currently selected endpoint so that data can be sent and received through it to
 347:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  and from a host.
 348:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 349:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
 350:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 351:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
 352:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_EnableEndpoint(void)
 353:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 354:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX |= (1 << EPEN);
 355:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 356:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 357:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Disables the currently selected endpoint so that data cannot be sent and received through it
 358:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  to and from a host.
 359:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 360:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
 361:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_DisableEndpoint(void)
 362:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 363:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX &= ~(1 << EPEN);
 364:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 365:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 366:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the currently selected endpoint is enabled, but not necessarily configured.
 367:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 368:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
 369:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 370:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 371:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsEnabled(void)
 372:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 373:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UECONX & (1 << EPEN)) ? true : false);
 374:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 375:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 376:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Retrieves the number of busy banks in the currently selected endpoint, which have been queue
 377:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  transmission via the \ref Endpoint_ClearIN() command, or are awaiting acknowledgement via th
 378:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ref Endpoint_ClearOUT() command.
 379:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 380:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 381:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 382:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Total number of busy banks in the selected endpoint.
 383:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 384:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetBusyBanks(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
 385:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetBusyBanks(void)
 386:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 387:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return (UESTA0X & (0x03 << NBUSYBK0));
 388:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 389:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 390:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Aborts all pending IN transactions on the currently selected endpoint, once the bank
 391:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  has been queued for transmission to the host via \ref Endpoint_ClearIN(). This function
 392:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  will terminate all queued transactions, resetting the endpoint banks ready for a new
 393:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  packet.
 394:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 395:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 396:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 397:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_AbortPendingIN(void)
 398:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 399:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				while (Endpoint_GetBusyBanks() != 0)
 400:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 401:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX |= (1 << RXOUTI);
 402:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					while (UEINTX & (1 << RXOUTI));
 403:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				}
 404:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 405:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 406:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the currently selected endpoint may be read from (if data is waiting in the en
 407:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  bank and the endpoint is an OUT direction, or if the bank is not yet full if the endpoint is
 408:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  direction). This function will return false if an error has occurred in the endpoint, if the
 409:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  is an OUT direction and no packet (or an empty packet) has been received, or if the endpoint
 410:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  direction and the endpoint bank is full.
 411:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 412:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 413:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 414:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the currently selected endpoint may be read from or written to, d
 415:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *          on its direction.
 416:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 417:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 418:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsReadWriteAllowed(void)
 419:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 420:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UEINTX & (1 << RWAL)) ? true : false);
 421:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 422:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 423:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the currently selected endpoint is configured.
 424:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 425:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false oth
 426:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 427:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 428:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsConfigured(void)
 429:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 430:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UESTA0X & (1 << CFGOK)) ? true : false);
 431:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 432:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 433:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Returns a mask indicating which INTERRUPT type endpoints have interrupted - i.e. their
 434:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  interrupt duration has elapsed. Which endpoints have interrupted can be determined by
 435:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  masking the return value against <tt>(1 << <i>{Endpoint Number}</i>)</tt>.
 436:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 437:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Mask whose bits indicate which endpoints have interrupted.
 438:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 439:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetEndpointInterrupts(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_I
 440:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetEndpointInterrupts(void)
 441:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 442:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return UEINT;
 443:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 444:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 445:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the specified endpoint number has interrupted (valid only for INTERRUPT type
 446:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  endpoints).
 447:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 448:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EndpointNumber  Index of the endpoint whose interrupt flag should be tested.
 449:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 450:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the specified endpoint has interrupted, \c false otherwise.
 451:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 452:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_HasEndpointInterrupted(const uint8_t EndpointNumber) ATTR_WARN_UNUSE
 453:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_HasEndpointInterrupted(const uint8_t EndpointNumber)
 454:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 455:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((Endpoint_GetEndpointInterrupts() & (1 << EndpointNumber)) ? true : false);
 456:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 457:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 458:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the selected IN endpoint is ready for a new packet to be sent to the host.
 459:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 460:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 461:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 462:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwis
 463:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 464:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 465:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsINReady(void)
 466:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 467:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UEINTX & (1 << TXINI)) ? true : false);
 468:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 469:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 470:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the selected OUT endpoint has received new packet from the host.
 471:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 472:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 473:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 474:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwis
 475:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 476:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 477:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsOUTReceived(void)
 478:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 479:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 480:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 481:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 482:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the current CONTROL type endpoint has received a SETUP packet.
 483:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 484:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 485:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 486:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false other
 487:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 488:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 489:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsSETUPReceived(void)
 490:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 491:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 492:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 493:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 494:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Clears a received SETUP packet on the currently selected CONTROL type endpoint, freeing up t
 495:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  endpoint for the next packet.
 496:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 497:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 498:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 499:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note This is not applicable for non CONTROL type endpoints.
 500:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 501:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
 502:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearSETUP(void)
 503:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 504:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UEINTX &= ~(1 << RXSTPI);
 505:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 506:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 507:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Sends an IN packet to the host on the currently selected endpoint, freeing up the endpoint f
 508:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  next packet and switching to the alternative endpoint bank if double banked.
 509:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 510:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 511:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 512:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
 513:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearIN(void)
 514:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 515:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 516:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 517:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 518:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX &= ~(1 << TXINI);
 519:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 520:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 521:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 522:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Acknowledges an OUT packet to the host on the currently selected endpoint, freeing up the en
 523:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  for the next packet and switching to the alternative endpoint bank if double banked.
 524:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 525:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 526:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 527:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
 528:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearOUT(void)
 529:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 530:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 531:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 532:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 533:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX &= ~(1 << RXOUTI);
 534:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 535:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 536:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 537:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Stalls the current endpoint, indicating to the host that a logical problem occurred with the
 538:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  indicated endpoint and that the current transfer sequence should be aborted. This provides a
 539:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  way for devices to indicate invalid commands to the host so that the current transfer can be
 540:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  aborted and the host can begin its own recovery sequence.
 541:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 542:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  The currently selected endpoint remains stalled until either the \ref Endpoint_ClearStall() 
 543:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  is called, or the host issues a CLEAR FEATURE request to the device for the currently select
 544:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  endpoint.
 545:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 546:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 547:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 548:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
 549:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_StallTransaction(void)
 550:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 551:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX |= (1 << STALLRQ);
 552:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 553:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 554:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Clears the STALL condition on the currently selected endpoint.
 555:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 556:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 557:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 558:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
 559:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearStall(void)
 560:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 561:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX |= (1 << STALLRQC);
 562:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 563:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 564:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the currently selected endpoint is stalled, false otherwise.
 565:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 566:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 567:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 568:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
 569:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 570:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 571:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsStalled(void)
 572:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 573:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UECONX & (1 << STALLRQ)) ? true : false);
 574:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 575:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 576:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Resets the data toggle of the currently selected endpoint. */
 577:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
 578:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ResetDataToggle(void)
 579:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 580:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX |= (1 << RSTDT);
 581:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 582:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 583:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines the currently selected endpoint's direction.
 584:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 585:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
 586:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 587:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_IN
 588:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetEndpointDirection(void)
 589:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 590:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
 591:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 592:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 593:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Sets the direction of the currently selected endpoint.
 594:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 595:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] DirectionMask  New endpoint direction, as a \c ENDPOINT_DIR_* mask.
 596:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 597:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_SetEndpointDirection(const uint8_t DirectionMask) ATTR_ALWAYS_INLINE
 598:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_SetEndpointDirection(const uint8_t DirectionMask)
 599:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 600:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECFG0X = ((UECFG0X & ~(1 << EPDIR)) | (DirectionMask ? (1 << EPDIR) : 0));
 601:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 602:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 603:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints.
 604:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 605:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPrimitiveRW_AVR8
 606:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 607:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
 608:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 609:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 610:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_Read_8(void)
 611:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 612:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return UEDATX;
 154               		.loc 4 612 0
 155 0006 C091 F100 		lds r28,241
 156               	.LBE205:
 157               	.LBE204:
  76:../AVRISP-MKII/Lib/V2Protocol.c **** 	uint8_t V2Command = Endpoint_Read_8();
  77:../AVRISP-MKII/Lib/V2Protocol.c **** 
  78:../AVRISP-MKII/Lib/V2Protocol.c **** 	/* Start the watchdog with timeout interrupt enabled to manage the timeout */
  79:../AVRISP-MKII/Lib/V2Protocol.c **** 	TimeoutExpired = false;
 158               		.loc 1 79 0
 159 000a 1ABC      		out 0x2a,__zero_reg__
 160               	.LVL5:
 161               	.LBB206:
 162               	.LBB207:
 473:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 163               		.loc 2 473 0
 164 000c 9EE0      		ldi r25,lo8(14)
 165 000e 88E1      		ldi r24,lo8(24)
 166               	/* #APP */
 167               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 168 0010 0FB6      		in __tmp_reg__,__SREG__
 169 0012 F894      		cli
 170 0014 A895      		wdr
 171 0016 8093 6000 		sts 96, r24
 172 001a 0FBE      		out __SREG__,__tmp_reg__
 173 001c 9093 6000 		sts 96, r25
 174               	 	
 175               	 ;  0 "" 2
 176               	.LVL6:
 177               	/* #NOAPP */
 178               	.LBE207:
 179               	.LBE206:
  80:../AVRISP-MKII/Lib/V2Protocol.c **** 	wdt_enable(WDTO_1S);
  81:../AVRISP-MKII/Lib/V2Protocol.c **** 	WDTCSR |= (1 << WDIE);
 180               		.loc 1 81 0
 181 0020 8091 6000 		lds r24,96
 182 0024 8064      		ori r24,lo8(64)
 183 0026 8093 6000 		sts 96,r24
  82:../AVRISP-MKII/Lib/V2Protocol.c **** 
  83:../AVRISP-MKII/Lib/V2Protocol.c **** 	switch (V2Command)
 184               		.loc 1 83 0
 185 002a C630      		cpi r28,lo8(6)
 186 002c 01F4      		brne .+2
 187 002e 00C0      		rjmp .L5
 188 0030 00F4      		brsh .L6
 189 0032 C130      		cpi r28,lo8(1)
 190 0034 01F0      		breq .L7
 191 0036 00F4      		brsh .+2
 192 0038 00C0      		rjmp .L23
 193 003a C430      		cpi r28,lo8(4)
 194 003c 00F0      		brlo .L26
 195 003e 00C0      		rjmp .L23
 196               	.L6:
 197 0040 C035      		cpi r28,lo8(80)
 198 0042 01F4      		brne .+2
 199 0044 00C0      		rjmp .L9
 200 0046 C135      		cpi r28,lo8(81)
 201 0048 01F4      		brne .+2
 202 004a 00C0      		rjmp .L10
 203 004c CA30      		cpi r28,lo8(10)
 204 004e 01F0      		breq .+2
 205 0050 00C0      		rjmp .L23
 206               	.LBB208:
 207               	.LBB209:
 208               	.LBB210:
 531:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 209               		.loc 4 531 0
 210 0052 8091 E800 		lds r24,232
 211 0056 8B77      		andi r24,lo8(123)
 212 0058 8093 E800 		sts 232,r24
 213               	.LVL7:
 214               	.LBE210:
 215               	.LBE209:
 216               	.LBB211:
 217               	.LBB212:
 330:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 218               		.loc 4 330 0
 219 005c 82E0      		ldi r24,lo8(2)
 220 005e 8093 E900 		sts 233,r24
 221               	.LVL8:
 222               	.LBE212:
 223               	.LBE211:
 224               	.LBB213:
 225               	.LBB214:
 600:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 226               		.loc 4 600 0
 227 0062 8091 EC00 		lds r24,236
 228 0066 8160      		ori r24,lo8(1)
 229 0068 8093 EC00 		sts 236,r24
 230               	.LVL9:
 231               	.LBE214:
 232               	.LBE213:
 233               	.LBB215:
 234               	.LBB216:
 613:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 614:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 615:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Writes one byte to the currently selected endpoint's bank, for IN direction endpoints.
 616:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 617:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPrimitiveRW_AVR8
 618:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 619:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
 620:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 621:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
 622:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_Write_8(const uint8_t Data)
 623:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 624:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UEDATX = Data;
 235               		.loc 4 624 0
 236 006c C093 F100 		sts 241,r28
 237 0070 00C0      		rjmp .L30
 238               	.LVL10:
 239               	.L7:
 240               	.LBE216:
 241               	.LBE215:
 242               	.LBE208:
 243               	.LBB219:
 244               	.LBB220:
 245               	.LBB221:
 246               	.LBB222:
 531:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 247               		.loc 4 531 0
 248 0072 8091 E800 		lds r24,232
 249 0076 8B77      		andi r24,lo8(123)
 250 0078 8093 E800 		sts 232,r24
 251               	.LVL11:
 252               	.LBE222:
 253               	.LBE221:
 254               	.LBB223:
 255               	.LBB224:
 330:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 256               		.loc 4 330 0
 257 007c 82E0      		ldi r24,lo8(2)
 258 007e 8093 E900 		sts 233,r24
 259               	.LVL12:
 260               	.LBE224:
 261               	.LBE223:
 262               	.LBB225:
 263               	.LBB226:
 600:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 264               		.loc 4 600 0
 265 0082 8091 EC00 		lds r24,236
 266 0086 8160      		ori r24,lo8(1)
 267 0088 8093 EC00 		sts 236,r24
 268               	.LVL13:
 269               	.LBE226:
 270               	.LBE225:
 271               	.LBB227:
 272               	.LBB228:
 273               		.loc 4 624 0
 274 008c C093 F100 		sts 241,r28
 275               	.LVL14:
 276               	.LBE228:
 277               	.LBE227:
 278               	.LBB229:
 279               	.LBB230:
 280 0090 1092 F100 		sts 241,__zero_reg__
 281               	.LVL15:
 282               	.LBE230:
 283               	.LBE229:
 284               	.LBB231:
 285               	.LBB232:
 286 0094 8AE0      		ldi r24,lo8(10)
 287 0096 8093 F100 		sts 241,r24
 288               	.LVL16:
 289               	.LBE232:
 290               	.LBE231:
  84:../AVRISP-MKII/Lib/V2Protocol.c **** 	{
  85:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_SIGN_ON:
  86:../AVRISP-MKII/Lib/V2Protocol.c **** 			V2Protocol_SignOn();
  87:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
  88:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_SET_PARAMETER:
  89:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_GET_PARAMETER:
  90:../AVRISP-MKII/Lib/V2Protocol.c **** 			V2Protocol_GetSetParam(V2Command);
  91:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
  92:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_LOAD_ADDRESS:
  93:../AVRISP-MKII/Lib/V2Protocol.c **** 			V2Protocol_LoadAddress();
  94:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
  95:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_RESET_PROTECTION:
  96:../AVRISP-MKII/Lib/V2Protocol.c **** 			V2Protocol_ResetProtection();
  97:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
  98:../AVRISP-MKII/Lib/V2Protocol.c **** #if defined(ENABLE_ISP_PROTOCOL)
  99:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_ENTER_PROGMODE_ISP:
 100:../AVRISP-MKII/Lib/V2Protocol.c **** 			ISPProtocol_EnterISPMode();
 101:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 102:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_LEAVE_PROGMODE_ISP:
 103:../AVRISP-MKII/Lib/V2Protocol.c **** 			ISPProtocol_LeaveISPMode();
 104:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 105:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_PROGRAM_FLASH_ISP:
 106:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_PROGRAM_EEPROM_ISP:
 107:../AVRISP-MKII/Lib/V2Protocol.c **** 			ISPProtocol_ProgramMemory(V2Command);
 108:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 109:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_READ_FLASH_ISP:
 110:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_READ_EEPROM_ISP:
 111:../AVRISP-MKII/Lib/V2Protocol.c **** 			ISPProtocol_ReadMemory(V2Command);
 112:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 113:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_CHIP_ERASE_ISP:
 114:../AVRISP-MKII/Lib/V2Protocol.c **** 			ISPProtocol_ChipErase();
 115:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 116:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_READ_FUSE_ISP:
 117:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_READ_LOCK_ISP:
 118:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_READ_SIGNATURE_ISP:
 119:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_READ_OSCCAL_ISP:
 120:../AVRISP-MKII/Lib/V2Protocol.c **** 			ISPProtocol_ReadFuseLockSigOSCCAL(V2Command);
 121:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 122:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_PROGRAM_FUSE_ISP:
 123:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_PROGRAM_LOCK_ISP:
 124:../AVRISP-MKII/Lib/V2Protocol.c **** 			ISPProtocol_WriteFuseLock(V2Command);
 125:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 126:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_SPI_MULTI:
 127:../AVRISP-MKII/Lib/V2Protocol.c **** 			ISPProtocol_SPIMulti();
 128:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 129:../AVRISP-MKII/Lib/V2Protocol.c **** #endif
 130:../AVRISP-MKII/Lib/V2Protocol.c **** #if defined(ENABLE_XPROG_PROTOCOL)
 131:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_XPROG_SETMODE:
 132:../AVRISP-MKII/Lib/V2Protocol.c **** 			XPROGProtocol_SetMode();
 133:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 134:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_XPROG:
 135:../AVRISP-MKII/Lib/V2Protocol.c **** 			XPROGProtocol_Command();
 136:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 137:../AVRISP-MKII/Lib/V2Protocol.c **** #endif
 138:../AVRISP-MKII/Lib/V2Protocol.c **** 		default:
 139:../AVRISP-MKII/Lib/V2Protocol.c **** 			V2Protocol_UnknownCommand(V2Command);
 140:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 141:../AVRISP-MKII/Lib/V2Protocol.c **** 	}
 142:../AVRISP-MKII/Lib/V2Protocol.c **** 
 143:../AVRISP-MKII/Lib/V2Protocol.c **** 	/* Disable the timeout management watchdog timer */
 144:../AVRISP-MKII/Lib/V2Protocol.c **** 	wdt_disable();
 145:../AVRISP-MKII/Lib/V2Protocol.c **** 
 146:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_WaitUntilReady();
 147:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SelectEndpoint(AVRISP_DATA_OUT_EPNUM);
 148:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SetEndpointDirection(ENDPOINT_DIR_OUT);
 149:../AVRISP-MKII/Lib/V2Protocol.c **** }
 150:../AVRISP-MKII/Lib/V2Protocol.c **** 
 151:../AVRISP-MKII/Lib/V2Protocol.c **** /** Handler for unknown V2 protocol commands. This discards all sent data and returns a
 152:../AVRISP-MKII/Lib/V2Protocol.c ****  *  STATUS_CMD_UNKNOWN status back to the host.
 153:../AVRISP-MKII/Lib/V2Protocol.c ****  *
 154:../AVRISP-MKII/Lib/V2Protocol.c ****  *  \param[in] V2Command  Issued V2 Protocol command byte from the host
 155:../AVRISP-MKII/Lib/V2Protocol.c ****  */
 156:../AVRISP-MKII/Lib/V2Protocol.c **** static void V2Protocol_UnknownCommand(const uint8_t V2Command)
 157:../AVRISP-MKII/Lib/V2Protocol.c **** {
 158:../AVRISP-MKII/Lib/V2Protocol.c **** 	/* Discard all incoming data */
 159:../AVRISP-MKII/Lib/V2Protocol.c **** 	while (Endpoint_BytesInEndpoint() == AVRISP_DATA_EPSIZE)
 160:../AVRISP-MKII/Lib/V2Protocol.c **** 	{
 161:../AVRISP-MKII/Lib/V2Protocol.c **** 		Endpoint_ClearOUT();
 162:../AVRISP-MKII/Lib/V2Protocol.c **** 		Endpoint_WaitUntilReady();
 163:../AVRISP-MKII/Lib/V2Protocol.c **** 	}
 164:../AVRISP-MKII/Lib/V2Protocol.c **** 
 165:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearOUT();
 166:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SelectEndpoint(AVRISP_DATA_IN_EPNUM);
 167:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SetEndpointDirection(ENDPOINT_DIR_IN);
 168:../AVRISP-MKII/Lib/V2Protocol.c **** 
 169:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_8(V2Command);
 170:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_8(STATUS_CMD_UNKNOWN);
 171:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearIN();
 172:../AVRISP-MKII/Lib/V2Protocol.c **** }
 173:../AVRISP-MKII/Lib/V2Protocol.c **** 
 174:../AVRISP-MKII/Lib/V2Protocol.c **** /** Handler for the CMD_SIGN_ON command, returning the programmer ID string to the host. */
 175:../AVRISP-MKII/Lib/V2Protocol.c **** static void V2Protocol_SignOn(void)
 176:../AVRISP-MKII/Lib/V2Protocol.c **** {
 177:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearOUT();
 178:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SelectEndpoint(AVRISP_DATA_IN_EPNUM);
 179:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SetEndpointDirection(ENDPOINT_DIR_IN);
 180:../AVRISP-MKII/Lib/V2Protocol.c **** 
 181:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_8(CMD_SIGN_ON);
 182:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_8(STATUS_CMD_OK);
 183:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_8(sizeof(PROGRAMMER_ID) - 1);
 184:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_Stream_LE(PROGRAMMER_ID, (sizeof(PROGRAMMER_ID) - 1), NULL);
 291               		.loc 1 184 0
 292 009a 40E0      		ldi r20,0
 293 009c 50E0      		ldi r21,0
 294 009e 6AE0      		ldi r22,lo8(10)
 295 00a0 70E0      		ldi r23,0
 296 00a2 80E0      		ldi r24,lo8(.LC0)
 297 00a4 90E0      		ldi r25,hi8(.LC0)
 298 00a6 0E94 0000 		call Endpoint_Write_Stream_LE
 299               	.LVL17:
 300 00aa 00C0      		rjmp .L28
 301               	.L26:
 302               	.LVL18:
 303               	.LBE220:
 304               	.LBE219:
 305               	.LBB233:
 306               	.LBB234:
 307               	.LBB235:
 308               	.LBB236:
 612:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 309               		.loc 4 612 0
 310 00ac D091 F100 		lds r29,241
 311               	.LBE236:
 312               	.LBE235:
 185:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearIN();
 186:../AVRISP-MKII/Lib/V2Protocol.c **** }
 187:../AVRISP-MKII/Lib/V2Protocol.c **** 
 188:../AVRISP-MKII/Lib/V2Protocol.c **** /** Handler for the CMD_RESET_PROTECTION command, implemented as a dummy ACK function as
 189:../AVRISP-MKII/Lib/V2Protocol.c ****  *  no target short-circuit protection is currently implemented.
 190:../AVRISP-MKII/Lib/V2Protocol.c ****  */
 191:../AVRISP-MKII/Lib/V2Protocol.c **** static void V2Protocol_ResetProtection(void)
 192:../AVRISP-MKII/Lib/V2Protocol.c **** {
 193:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearOUT();
 194:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SelectEndpoint(AVRISP_DATA_IN_EPNUM);
 195:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SetEndpointDirection(ENDPOINT_DIR_IN);
 196:../AVRISP-MKII/Lib/V2Protocol.c **** 
 197:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_8(CMD_RESET_PROTECTION);
 198:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_8(STATUS_CMD_OK);
 199:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearIN();
 200:../AVRISP-MKII/Lib/V2Protocol.c **** }
 201:../AVRISP-MKII/Lib/V2Protocol.c **** 
 202:../AVRISP-MKII/Lib/V2Protocol.c **** 
 203:../AVRISP-MKII/Lib/V2Protocol.c **** /** Handler for the CMD_SET_PARAMETER and CMD_GET_PARAMETER commands from the host, setting or
 204:../AVRISP-MKII/Lib/V2Protocol.c ****  *  getting a device parameter's value from the parameter table.
 205:../AVRISP-MKII/Lib/V2Protocol.c ****  *
 206:../AVRISP-MKII/Lib/V2Protocol.c ****  *  \param[in] V2Command  Issued V2 Protocol command byte from the host
 207:../AVRISP-MKII/Lib/V2Protocol.c ****  */
 208:../AVRISP-MKII/Lib/V2Protocol.c **** static void V2Protocol_GetSetParam(const uint8_t V2Command)
 209:../AVRISP-MKII/Lib/V2Protocol.c **** {
 210:../AVRISP-MKII/Lib/V2Protocol.c **** 	uint8_t ParamID = Endpoint_Read_8();
 211:../AVRISP-MKII/Lib/V2Protocol.c **** 	uint8_t ParamValue;
 212:../AVRISP-MKII/Lib/V2Protocol.c **** 
 213:../AVRISP-MKII/Lib/V2Protocol.c **** 	if (V2Command == CMD_SET_PARAMETER)
 313               		.loc 1 213 0
 314 00b0 C230      		cpi r28,lo8(2)
 315 00b2 01F4      		brne .L13
 316               	.LBB237:
 317               	.LBB238:
 612:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 318               		.loc 4 612 0
 319 00b4 1091 F100 		lds r17,241
 320               	.L13:
 321               	.LVL19:
 322               	.LBE238:
 323               	.LBE237:
 324               	.LBB239:
 325               	.LBB240:
 531:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 326               		.loc 4 531 0
 327 00b8 8091 E800 		lds r24,232
 328 00bc 8B77      		andi r24,lo8(123)
 329 00be 8093 E800 		sts 232,r24
 330               	.LVL20:
 331               	.LBE240:
 332               	.LBE239:
 333               	.LBB241:
 334               	.LBB242:
 330:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 335               		.loc 4 330 0
 336 00c2 82E0      		ldi r24,lo8(2)
 337 00c4 8093 E900 		sts 233,r24
 338               	.LVL21:
 339               	.LBE242:
 340               	.LBE241:
 341               	.LBB243:
 342               	.LBB244:
 600:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 343               		.loc 4 600 0
 344 00c8 8091 EC00 		lds r24,236
 345 00cc 8160      		ori r24,lo8(1)
 346 00ce 8093 EC00 		sts 236,r24
 347               	.LVL22:
 348               	.LBE244:
 349               	.LBE243:
 350               	.LBB245:
 351               	.LBB246:
 352               		.loc 4 624 0
 353 00d2 C093 F100 		sts 241,r28
 354               	.LVL23:
 355               	.LBE246:
 356               	.LBE245:
 214:../AVRISP-MKII/Lib/V2Protocol.c **** 	  ParamValue = Endpoint_Read_8();
 215:../AVRISP-MKII/Lib/V2Protocol.c **** 
 216:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearOUT();
 217:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SelectEndpoint(AVRISP_DATA_IN_EPNUM);
 218:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SetEndpointDirection(ENDPOINT_DIR_IN);
 219:../AVRISP-MKII/Lib/V2Protocol.c **** 
 220:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Write_8(V2Command);
 221:../AVRISP-MKII/Lib/V2Protocol.c **** 
 222:../AVRISP-MKII/Lib/V2Protocol.c **** 	uint8_t ParamPrivs = V2Params_GetParameterPrivileges(ParamID);
 357               		.loc 1 222 0
 358 00d6 8D2F      		mov r24,r29
 359 00d8 0E94 0000 		call V2Params_GetParameterPrivileges
 360               	.LVL24:
 223:../AVRISP-MKII/Lib/V2Protocol.c **** 
 224:../AVRISP-MKII/Lib/V2Protocol.c **** 	if ((V2Command == CMD_SET_PARAMETER) && (ParamPrivs & PARAM_PRIV_WRITE))
 361               		.loc 1 224 0
 362 00dc C230      		cpi r28,lo8(2)
 363 00de 01F4      		brne .L14
 364 00e0 81FF      		sbrs r24,1
 365 00e2 00C0      		rjmp .L15
 366               	.LVL25:
 367               	.LBB247:
 368               	.LBB248:
 369               		.loc 4 624 0
 370 00e4 1092 F100 		sts 241,__zero_reg__
 371               	.LVL26:
 372               	.LBE248:
 373               	.LBE247:
 225:../AVRISP-MKII/Lib/V2Protocol.c **** 	{
 226:../AVRISP-MKII/Lib/V2Protocol.c **** 		Endpoint_Write_8(STATUS_CMD_OK);
 227:../AVRISP-MKII/Lib/V2Protocol.c **** 		V2Params_SetParameterValue(ParamID, ParamValue);
 374               		.loc 1 227 0
 375 00e8 612F      		mov r22,r17
 376 00ea 8D2F      		mov r24,r29
 377               	.LVL27:
 378 00ec 0E94 0000 		call V2Params_SetParameterValue
 379               	.LVL28:
 380 00f0 00C0      		rjmp .L28
 381               	.LVL29:
 382               	.L14:
 228:../AVRISP-MKII/Lib/V2Protocol.c **** 	}
 229:../AVRISP-MKII/Lib/V2Protocol.c **** 	else if ((V2Command == CMD_GET_PARAMETER) && (ParamPrivs & PARAM_PRIV_READ))
 383               		.loc 1 229 0
 384 00f2 80FF      		sbrs r24,0
 385 00f4 00C0      		rjmp .L15
 386               	.LVL30:
 387               	.LBB249:
 388               	.LBB250:
 389               		.loc 4 624 0
 390 00f6 1092 F100 		sts 241,__zero_reg__
 391               	.LVL31:
 392               	.LBE250:
 393               	.LBE249:
 230:../AVRISP-MKII/Lib/V2Protocol.c **** 	{
 231:../AVRISP-MKII/Lib/V2Protocol.c **** 		Endpoint_Write_8(STATUS_CMD_OK);
 232:../AVRISP-MKII/Lib/V2Protocol.c **** 		Endpoint_Write_8(V2Params_GetParameterValue(ParamID));
 394               		.loc 1 232 0
 395 00fa 8D2F      		mov r24,r29
 396               	.LVL32:
 397 00fc 0E94 0000 		call V2Params_GetParameterValue
 398               	.LVL33:
 399 0100 00C0      		rjmp .L29
 400               	.LVL34:
 401               	.L15:
 402               	.LBB251:
 403               	.LBB252:
 404               		.loc 4 624 0
 405 0102 80EC      		ldi r24,lo8(-64)
 406               	.LVL35:
 407 0104 00C0      		rjmp .L29
 408               	.LVL36:
 409               	.L5:
 410               	.LBE252:
 411               	.LBE251:
 412               	.LBE234:
 413               	.LBE233:
 414               	.LBB253:
 415               	.LBB254:
 233:../AVRISP-MKII/Lib/V2Protocol.c **** 	}
 234:../AVRISP-MKII/Lib/V2Protocol.c **** 	else
 235:../AVRISP-MKII/Lib/V2Protocol.c **** 	{
 236:../AVRISP-MKII/Lib/V2Protocol.c **** 		Endpoint_Write_8(STATUS_CMD_FAILED);
 237:../AVRISP-MKII/Lib/V2Protocol.c **** 	}
 238:../AVRISP-MKII/Lib/V2Protocol.c **** 
 239:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearIN();
 240:../AVRISP-MKII/Lib/V2Protocol.c **** }
 241:../AVRISP-MKII/Lib/V2Protocol.c **** 
 242:../AVRISP-MKII/Lib/V2Protocol.c **** /** Handler for the CMD_LOAD_ADDRESS command, loading the given device address into a
 243:../AVRISP-MKII/Lib/V2Protocol.c ****  *  global storage variable for later use, and issuing LOAD EXTENDED ADDRESS commands
 244:../AVRISP-MKII/Lib/V2Protocol.c ****  *  to the attached device as required.
 245:../AVRISP-MKII/Lib/V2Protocol.c ****  */
 246:../AVRISP-MKII/Lib/V2Protocol.c **** static void V2Protocol_LoadAddress(void)
 247:../AVRISP-MKII/Lib/V2Protocol.c **** {
 248:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_Read_Stream_BE(&CurrentAddress, sizeof(CurrentAddress), NULL);
 416               		.loc 1 248 0
 417 0106 40E0      		ldi r20,0
 418 0108 50E0      		ldi r21,0
 419 010a 64E0      		ldi r22,lo8(4)
 420 010c 70E0      		ldi r23,0
 421 010e 80E0      		ldi r24,lo8(CurrentAddress)
 422 0110 90E0      		ldi r25,hi8(CurrentAddress)
 423 0112 0E94 0000 		call Endpoint_Read_Stream_BE
 424               	.LVL37:
 425               	.LBB255:
 426               	.LBB256:
 531:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 427               		.loc 4 531 0
 428 0116 8091 E800 		lds r24,232
 429 011a 8B77      		andi r24,lo8(123)
 430 011c 8093 E800 		sts 232,r24
 431               	.LVL38:
 432               	.LBE256:
 433               	.LBE255:
 434               	.LBB257:
 435               	.LBB258:
 330:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 436               		.loc 4 330 0
 437 0120 82E0      		ldi r24,lo8(2)
 438 0122 8093 E900 		sts 233,r24
 439               	.LVL39:
 440               	.LBE258:
 441               	.LBE257:
 442               	.LBB259:
 443               	.LBB260:
 600:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 444               		.loc 4 600 0
 445 0126 8091 EC00 		lds r24,236
 446 012a 8160      		ori r24,lo8(1)
 447 012c 8093 EC00 		sts 236,r24
 448               	.LVL40:
 449               	.LBE260:
 450               	.LBE259:
 249:../AVRISP-MKII/Lib/V2Protocol.c **** 
 250:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_ClearOUT();
 251:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SelectEndpoint(AVRISP_DATA_IN_EPNUM);
 252:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SetEndpointDirection(ENDPOINT_DIR_IN);
 253:../AVRISP-MKII/Lib/V2Protocol.c **** 
 254:../AVRISP-MKII/Lib/V2Protocol.c **** 	if (CurrentAddress & (1UL << 31))
 451               		.loc 1 254 0
 452 0130 8091 0000 		lds r24,CurrentAddress
 453 0134 9091 0000 		lds r25,CurrentAddress+1
 454 0138 A091 0000 		lds r26,CurrentAddress+2
 455 013c B091 0000 		lds r27,CurrentAddress+3
 456 0140 B7FF      		sbrs r27,7
 457 0142 00C0      		rjmp .L17
 255:../AVRISP-MKII/Lib/V2Protocol.c **** 	  MustLoadExtendedAddress = true;
 458               		.loc 1 255 0
 459 0144 81E0      		ldi r24,lo8(1)
 460 0146 8093 0000 		sts MustLoadExtendedAddress,r24
 461               	.L17:
 462               	.LVL41:
 463               	.LBB261:
 464               	.LBB262:
 465               		.loc 4 624 0
 466 014a 86E0      		ldi r24,lo8(6)
 467 014c 8093 F100 		sts 241,r24
 468               	.LVL42:
 469               	.L30:
 470               	.LBE262:
 471               	.LBE261:
 472               	.LBE254:
 473               	.LBE253:
 474               	.LBB263:
 475               	.LBB217:
 476               	.LBB218:
 477 0150 1092 F100 		sts 241,__zero_reg__
 478               	.LVL43:
 479 0154 00C0      		rjmp .L28
 480               	.L10:
 481               	.LBE218:
 482               	.LBE217:
 483               	.LBE263:
 132:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 484               		.loc 1 132 0
 485 0156 0E94 0000 		call XPROGProtocol_SetMode
 486               	.LVL44:
 133:../AVRISP-MKII/Lib/V2Protocol.c **** 		case CMD_XPROG:
 487               		.loc 1 133 0
 488 015a 00C0      		rjmp .L12
 489               	.L9:
 135:../AVRISP-MKII/Lib/V2Protocol.c **** 			break;
 490               		.loc 1 135 0
 491 015c 0E94 0000 		call XPROGProtocol_Command
 492               	.LVL45:
 136:../AVRISP-MKII/Lib/V2Protocol.c **** #endif
 493               		.loc 1 136 0
 494 0160 00C0      		rjmp .L12
 495               	.L23:
 496               	.LBB264:
 497               	.LBB265:
 498               	.LBB266:
 499               	.LBB267:
 293:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#elif defined(USB_SERIES_4_AVR)
 500               		.loc 4 293 0
 501 0162 8091 F200 		lds r24,242
 502 0166 9091 F300 		lds r25,242+1
 503               	.LBE267:
 504               	.LBE266:
 159:../AVRISP-MKII/Lib/V2Protocol.c **** 	{
 505               		.loc 1 159 0
 506 016a 8034      		cpi r24,64
 507 016c 9105      		cpc r25,__zero_reg__
 508 016e 01F4      		brne .L32
 509               	.LBB268:
 510               	.LBB269:
 531:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 511               		.loc 4 531 0
 512 0170 8091 E800 		lds r24,232
 513 0174 8B77      		andi r24,lo8(123)
 514 0176 8093 E800 		sts 232,r24
 515               	.LBE269:
 516               	.LBE268:
 162:../AVRISP-MKII/Lib/V2Protocol.c **** 	}
 517               		.loc 1 162 0
 518 017a 0E94 0000 		call Endpoint_WaitUntilReady
 519               	.LVL46:
 520 017e 00C0      		rjmp .L23
 521               	.L32:
 522               	.LBB270:
 523               	.LBB271:
 531:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 524               		.loc 4 531 0
 525 0180 8091 E800 		lds r24,232
 526 0184 8B77      		andi r24,lo8(123)
 527 0186 8093 E800 		sts 232,r24
 528               	.LVL47:
 529               	.LBE271:
 530               	.LBE270:
 531               	.LBB272:
 532               	.LBB273:
 330:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 533               		.loc 4 330 0
 534 018a 82E0      		ldi r24,lo8(2)
 535 018c 8093 E900 		sts 233,r24
 536               	.LVL48:
 537               	.LBE273:
 538               	.LBE272:
 539               	.LBB274:
 540               	.LBB275:
 600:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 541               		.loc 4 600 0
 542 0190 8091 EC00 		lds r24,236
 543 0194 8160      		ori r24,lo8(1)
 544 0196 8093 EC00 		sts 236,r24
 545               	.LVL49:
 546               	.LBE275:
 547               	.LBE274:
 548               	.LBB276:
 549               	.LBB277:
 550               		.loc 4 624 0
 551 019a C093 F100 		sts 241,r28
 552               	.LVL50:
 553               	.LBE277:
 554               	.LBE276:
 555               	.LBB278:
 556               	.LBB279:
 557 019e 89EC      		ldi r24,lo8(-55)
 558               	.LVL51:
 559               	.L29:
 560 01a0 8093 F100 		sts 241,r24
 561               	.L28:
 562               	.LBE279:
 563               	.LBE278:
 564               	.LBB280:
 565               	.LBB281:
 516:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 566               		.loc 4 516 0
 567 01a4 8091 E800 		lds r24,232
 568 01a8 8E77      		andi r24,lo8(126)
 569 01aa 8093 E800 		sts 232,r24
 570               	.L12:
 571               	.LBE281:
 572               	.LBE280:
 573               	.LBE265:
 574               	.LBE264:
 575               	.LBB282:
 576               	.LBB283:
 577               		.loc 2 515 0
 578               	/* #APP */
 579               	 ;  515 "/usr/lib/avr/include/avr/wdt.h" 1
 580 01ae 0FB6      		in __tmp_reg__,__SREG__
 581 01b0 F894      		cli
 582 01b2 A895      		wdr
 583 01b4 8091 6000 		lds r24,96
 584 01b8 8861      		ori r24,24
 585 01ba 8093 6000 		sts 96,r24
 586 01be 1092 6000 		sts 96,__zero_reg__
 587 01c2 0FBE      		out __SREG__,__tmp_reg__
 588               		
 589               	 ;  0 "" 2
 590               	/* #NOAPP */
 591               	.LBE283:
 592               	.LBE282:
 146:../AVRISP-MKII/Lib/V2Protocol.c **** 	Endpoint_SelectEndpoint(AVRISP_DATA_OUT_EPNUM);
 593               		.loc 1 146 0
 594 01c4 0E94 0000 		call Endpoint_WaitUntilReady
 595               	.LVL52:
 596               	.LBB284:
 597               	.LBB285:
 330:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 598               		.loc 4 330 0
 599 01c8 82E0      		ldi r24,lo8(2)
 600 01ca 8093 E900 		sts 233,r24
 601               	.LVL53:
 602               	.LBE285:
 603               	.LBE284:
 604               	.LBB286:
 605               	.LBB287:
 600:../../LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 606               		.loc 4 600 0
 607 01ce 8091 EC00 		lds r24,236
 608 01d2 8E7F      		andi r24,lo8(-2)
 609 01d4 8093 EC00 		sts 236,r24
 610               	.LVL54:
 611               	/* epilogue start */
 612               	.LBE287:
 613               	.LBE286:
 149:../AVRISP-MKII/Lib/V2Protocol.c **** 
 614               		.loc 1 149 0
 615 01d8 DF91      		pop r29
 616 01da CF91      		pop r28
 617 01dc 1F91      		pop r17
 618 01de 0895      		ret
 619               		.cfi_endproc
 620               	.LFE119:
 622               		.comm	MustLoadExtendedAddress,1,1
 623               		.comm	CurrentAddress,4,1
 624               		.text
 625               	.Letext0:
 626               		.file 5 "/usr/lib/avr/include/stdint.h"
 627               		.file 6 "../AVRISP-MKII/Lib/ISP/ISPTarget.h"
 628               		.file 7 "../AVRISP-MKII/Lib/V2ProtocolParams.h"
 629               		.file 8 "../../LUFA/Drivers/USB/Core/AVR8/../AVR8/EndpointStream_AVR8.h"
 630               		.file 9 "../AVRISP-MKII/Lib/XPROG/XPROGProtocol.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 V2Protocol.c
     /tmp/ccYtTE8R.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccYtTE8R.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccYtTE8R.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccYtTE8R.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccYtTE8R.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccYtTE8R.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccYtTE8R.s:14     .text.__vector_12:0000000000000000 __vector_12
     /tmp/ccYtTE8R.s:74     .text.V2Protocol_Init:0000000000000000 V2Protocol_Init
     /tmp/ccYtTE8R.s:131    .text.V2Protocol_ProcessCommand:0000000000000000 V2Protocol_ProcessCommand
                            *COM*:0000000000000004 CurrentAddress
                            *COM*:0000000000000001 MustLoadExtendedAddress

UNDEFINED SYMBOLS
V2Params_LoadNonVolatileParamValues
Endpoint_Write_Stream_LE
V2Params_GetParameterPrivileges
V2Params_SetParameterValue
V2Params_GetParameterValue
Endpoint_Read_Stream_BE
XPROGProtocol_SetMode
XPROGProtocol_Command
Endpoint_WaitUntilReady
__do_copy_data
__do_clear_bss
