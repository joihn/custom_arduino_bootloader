   1               		.file	"TWI_AVR8.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.TWI_StartTransmission,"ax",@progbits
  12               	.global	TWI_StartTransmission
  14               	TWI_StartTransmission:
  15               	.LFB20:
  16               		.file 1 "../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c"
   1:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** /*
   2:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****              LUFA Library
   3:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
   5:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****            www.lufa-lib.org
   7:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** */
   8:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
   9:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** /*
  10:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  12:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   documentation, and that the name of the author not be used in
  18:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  21:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****   this software.
  29:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** */
  30:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  31:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** #define  __INCLUDE_FROM_TWI_C
  32:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** #include "../TWI.h"
  33:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  34:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** uint8_t TWI_StartTransmission(const uint8_t SlaveAddress,
  35:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                               const uint8_t TimeoutMS)
  36:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** {
  17               		.loc 1 36 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  24               	.LBB11:
  37:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	for (;;)
  38:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	{
  39:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		bool     BusCaptured = false;
  40:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		uint16_t TimeoutRemaining;
  41:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  42:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		TWCR = ((1 << TWINT) | (1 << TWSTA) | (1 << TWEN));
  25               		.loc 1 42 0
  26 0000 94EA      		ldi r25,lo8(-92)
  27 0002 9093 BC00 		sts 188,r25
  28               	.LVL1:
  29 0006 24E6      		ldi r18,lo8(100)
  30 0008 629F      		mul r22,r18
  31 000a B001      		movw r22,r0
  32 000c 1124      		clr __zero_reg__
  33               	.LVL2:
  34 000e 6150      		subi r22,1
  35 0010 7109      		sbc r23,__zero_reg__
  43:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  44:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		TimeoutRemaining = (TimeoutMS * 100);
  45:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		while (TimeoutRemaining-- && !(BusCaptured))
  36               		.loc 1 45 0
  37 0012 9B01      		movw r18,r22
  39:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		uint16_t TimeoutRemaining;
  38               		.loc 1 39 0
  39 0014 40E0      		ldi r20,0
  46:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
  47:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			if (TWCR & (1 << TWINT))
  48:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			{
  49:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				switch (TWSR & TW_STATUS_MASK)
  50:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				{
  51:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 					case TW_START:
  52:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 					case TW_REP_START:
  53:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						BusCaptured = true;
  54:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						break;
  55:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 					case TW_MT_ARB_LOST:
  56:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						TWCR = ((1 << TWINT) | (1 << TWSTA) | (1 << TWEN));
  40               		.loc 1 56 0
  41 0016 54EA      		ldi r21,lo8(-92)
  42               	.LVL3:
  43               	.L2:
  45:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
  44               		.loc 1 45 0
  45 0018 2F3F      		cpi r18,-1
  46 001a 9FEF      		ldi r25,-1
  47 001c 3907      		cpc r19,r25
  48 001e 01F0      		breq .L8
  45:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
  49               		.loc 1 45 0 is_stmt 0 discriminator 1
  50 0020 4111      		cpse r20,__zero_reg__
  51 0022 00C0      		rjmp .L35
  47:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			{
  52               		.loc 1 47 0 is_stmt 1
  53 0024 9091 BC00 		lds r25,188
  54 0028 97FF      		sbrs r25,7
  55 002a 00C0      		rjmp .L3
  49:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				{
  56               		.loc 1 49 0
  57 002c 9091 B900 		lds r25,185
  58 0030 987F      		andi r25,lo8(-8)
  59 0032 9031      		cpi r25,lo8(16)
  60 0034 01F0      		breq .L15
  61 0036 9833      		cpi r25,lo8(56)
  62 0038 01F0      		breq .L5
  63 003a 9830      		cpi r25,lo8(8)
  64 003c 01F0      		breq .L15
  57:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						continue;
  58:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 					default:
  59:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						TWCR = (1 << TWEN);
  65               		.loc 1 59 0
  66 003e 84E0      		ldi r24,lo8(4)
  67               	.LVL4:
  68 0040 8093 BC00 		sts 188,r24
  60:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						return TWI_ERROR_BusFault;
  69               		.loc 1 60 0
  70 0044 81E0      		ldi r24,lo8(1)
  71 0046 0895      		ret
  72               	.LVL5:
  73               	.L5:
  56:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						continue;
  74               		.loc 1 56 0
  75 0048 5093 BC00 		sts 188,r21
  57:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						continue;
  76               		.loc 1 57 0
  77 004c 00C0      		rjmp .L6
  78               	.L15:
  53:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 						break;
  79               		.loc 1 53 0
  80 004e 41E0      		ldi r20,lo8(1)
  81               	.LVL6:
  82               	.L3:
  83               	.LBB12:
  84               	.LBB13:
  85               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  86               		.loc 2 276 0
  87 0050 9AE1      		ldi r25,lo8(26)
  88 0052 9A95      	1:	dec r25
  89 0054 01F4      		brne 1b
  90 0056 00C0      		rjmp .
  91               	.LVL7:
  92               	.L6:
  93 0058 2150      		subi r18,1
  94 005a 3109      		sbc r19,__zero_reg__
  95               	.LVL8:
  96 005c 00C0      		rjmp .L2
  97               	.LVL9:
  98               	.L35:
  99               	.LBE13:
 100               	.LBE12:
  61:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				}
  62:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			}
  63:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  64:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			_delay_us(10);
  65:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		}
  66:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  67:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		if (!(TimeoutRemaining))
 101               		.loc 1 67 0
 102 005e 232B      		or r18,r19
 103 0060 01F4      		brne .L8
  68:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
  69:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			TWCR = (1 << TWEN);
 104               		.loc 1 69 0
 105 0062 84E0      		ldi r24,lo8(4)
 106               	.LVL10:
 107 0064 8093 BC00 		sts 188,r24
  70:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			return TWI_ERROR_BusCaptureTimeout;
 108               		.loc 1 70 0
 109 0068 82E0      		ldi r24,lo8(2)
 110 006a 0895      		ret
 111               	.LVL11:
 112               	.L8:
  71:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		}
  72:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  73:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		TWDR = SlaveAddress;
 113               		.loc 1 73 0
 114 006c 8093 BB00 		sts 187,r24
  74:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		TWCR = ((1 << TWINT) | (1 << TWEN));
 115               		.loc 1 74 0
 116 0070 84E8      		ldi r24,lo8(-124)
 117               	.LVL12:
 118 0072 8093 BC00 		sts 188,r24
 119               	.LVL13:
 120               	.L10:
  75:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  76:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		TimeoutRemaining = (TimeoutMS * 100);
  77:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		while (TimeoutRemaining--)
 121               		.loc 1 77 0
 122 0076 6F3F      		cpi r22,-1
 123 0078 8FEF      		ldi r24,-1
 124 007a 7807      		cpc r23,r24
 125 007c 01F0      		breq .L13
  78:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
  79:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			if (TWCR & (1 << TWINT))
 126               		.loc 1 79 0
 127 007e 2091 BC00 		lds r18,188
 128 0082 CB01      		movw r24,r22
 129 0084 0197      		sbiw r24,1
 130 0086 27FD      		sbrc r18,7
 131 0088 00C0      		rjmp .L11
 132               	.LVL14:
 133               	.LBB14:
 134               	.LBB15:
 135               		.loc 2 276 0
 136 008a 2AE1      		ldi r18,lo8(26)
 137 008c 2A95      	1:	dec r18
 138 008e 01F4      		brne 1b
 139 0090 00C0      		rjmp .
 140 0092 BC01      		movw r22,r24
 141               	.LVL15:
 142 0094 00C0      		rjmp .L10
 143               	.LVL16:
 144               	.L11:
 145               	.LBE15:
 146               	.LBE14:
  80:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			  break;
  81:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  82:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			_delay_us(10);
  83:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		}
  84:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  85:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		if (!(TimeoutRemaining))
 147               		.loc 1 85 0
 148 0096 672B      		or r22,r23
 149 0098 01F0      		breq .L16
 150               	.L13:
  86:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		  return TWI_ERROR_SlaveResponseTimeout;
  87:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
  88:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		switch (TWSR & TW_STATUS_MASK)
 151               		.loc 1 88 0
 152 009a 8091 B900 		lds r24,185
 153 009e 887F      		andi r24,lo8(-8)
 154 00a0 8831      		cpi r24,lo8(24)
 155 00a2 01F0      		breq .L17
 156 00a4 8034      		cpi r24,lo8(64)
 157 00a6 01F0      		breq .L17
  89:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
  90:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			case TW_MT_SLA_ACK:
  91:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			case TW_MR_SLA_ACK:
  92:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				return TWI_ERROR_NoError;
  93:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			default:
  94:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				TWCR = ((1 << TWINT) | (1 << TWSTO) | (1 << TWEN));
 158               		.loc 1 94 0
 159 00a8 84E9      		ldi r24,lo8(-108)
 160 00aa 8093 BC00 		sts 188,r24
  95:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				return TWI_ERROR_SlaveNotReady;
 161               		.loc 1 95 0
 162 00ae 84E0      		ldi r24,lo8(4)
 163 00b0 0895      		ret
 164               	.L16:
  86:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		  return TWI_ERROR_SlaveResponseTimeout;
 165               		.loc 1 86 0
 166 00b2 83E0      		ldi r24,lo8(3)
 167 00b4 0895      		ret
 168               	.L17:
  92:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			default:
 169               		.loc 1 92 0
 170 00b6 80E0      		ldi r24,0
 171               	.LBE11:
  96:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		}
  97:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	}
  98:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** }
 172               		.loc 1 98 0
 173 00b8 0895      		ret
 174               		.cfi_endproc
 175               	.LFE20:
 177               		.section	.text.TWI_SendByte,"ax",@progbits
 178               	.global	TWI_SendByte
 180               	TWI_SendByte:
 181               	.LFB21:
  99:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 100:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** bool TWI_SendByte(const uint8_t Byte)
 101:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** {
 182               		.loc 1 101 0
 183               		.cfi_startproc
 184               	.LVL17:
 185               	/* prologue: function */
 186               	/* frame size = 0 */
 187               	/* stack size = 0 */
 188               	.L__stack_usage = 0
 102:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	TWDR = Byte;
 189               		.loc 1 102 0
 190 0000 8093 BB00 		sts 187,r24
 103:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	TWCR = ((1 << TWINT) | (1 << TWEN));
 191               		.loc 1 103 0
 192 0004 84E8      		ldi r24,lo8(-124)
 193               	.LVL18:
 194 0006 8093 BC00 		sts 188,r24
 195               	.LVL19:
 196               	.L37:
 104:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	while (!(TWCR & (1 << TWINT)));
 197               		.loc 1 104 0 discriminator 1
 198 000a 8091 BC00 		lds r24,188
 199 000e 87FF      		sbrs r24,7
 200 0010 00C0      		rjmp .L37
 105:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 106:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	return ((TWSR & TW_STATUS_MASK) == TW_MT_DATA_ACK);
 201               		.loc 1 106 0
 202 0012 9091 B900 		lds r25,185
 203 0016 987F      		andi r25,lo8(-8)
 204 0018 81E0      		ldi r24,lo8(1)
 205 001a 9832      		cpi r25,lo8(40)
 206 001c 01F0      		breq .L38
 207 001e 80E0      		ldi r24,0
 208               	.L38:
 107:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** }
 209               		.loc 1 107 0
 210 0020 0895      		ret
 211               		.cfi_endproc
 212               	.LFE21:
 214               		.section	.text.TWI_ReceiveByte,"ax",@progbits
 215               	.global	TWI_ReceiveByte
 217               	TWI_ReceiveByte:
 218               	.LFB22:
 108:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 109:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** bool TWI_ReceiveByte(uint8_t* const Byte,
 110:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 					 const bool LastByte)
 111:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** {
 219               		.loc 1 111 0
 220               		.cfi_startproc
 221               	.LVL20:
 222               	/* prologue: function */
 223               	/* frame size = 0 */
 224               	/* stack size = 0 */
 225               	.L__stack_usage = 0
 226 0000 FC01      		movw r30,r24
 112:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	uint8_t TWCRMask;
 113:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 114:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	if (LastByte)
 227               		.loc 1 114 0
 228 0002 6111      		cpse r22,__zero_reg__
 229 0004 00C0      		rjmp .L50
 115:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	  TWCRMask = ((1 << TWINT) | (1 << TWEN));
 116:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	else
 117:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	  TWCRMask = ((1 << TWINT) | (1 << TWEN) | (1 << TWEA));
 230               		.loc 1 117 0
 231 0006 94EC      		ldi r25,lo8(-60)
 232 0008 00C0      		rjmp .L44
 233               	.L50:
 115:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	  TWCRMask = ((1 << TWINT) | (1 << TWEN));
 234               		.loc 1 115 0
 235 000a 94E8      		ldi r25,lo8(-124)
 236               	.L44:
 237               	.LVL21:
 118:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 119:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	TWCR = TWCRMask;
 238               		.loc 1 119 0
 239 000c 9093 BC00 		sts 188,r25
 240               	.LVL22:
 241               	.L45:
 120:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	while (!(TWCR & (1 << TWINT)));
 242               		.loc 1 120 0 discriminator 1
 243 0010 8091 BC00 		lds r24,188
 244 0014 87FF      		sbrs r24,7
 245 0016 00C0      		rjmp .L45
 121:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	*Byte = TWDR;
 246               		.loc 1 121 0
 247 0018 8091 BB00 		lds r24,187
 248 001c 8083      		st Z,r24
 122:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	
 123:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	uint8_t Status = (TWSR & TW_STATUS_MASK);
 249               		.loc 1 123 0
 250 001e 9091 B900 		lds r25,185
 251               	.LVL23:
 252 0022 987F      		andi r25,lo8(-8)
 253               	.LVL24:
 124:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	
 125:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	return ((LastByte) ? (Status == TW_MR_DATA_NACK) : (Status == TW_MR_DATA_ACK));
 254               		.loc 1 125 0
 255 0024 81E0      		ldi r24,lo8(1)
 256 0026 6623      		tst r22
 257 0028 01F0      		breq .L46
 258               		.loc 1 125 0 is_stmt 0 discriminator 1
 259 002a 9835      		cpi r25,lo8(88)
 260 002c 01F4      		brne .L58
 261 002e 00C0      		rjmp .L48
 262               	.L46:
 263               		.loc 1 125 0 discriminator 2
 264 0030 9035      		cpi r25,lo8(80)
 265 0032 01F0      		breq .L48
 266               	.L58:
 267 0034 80E0      		ldi r24,0
 268               	.L48:
 126:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** }
 269               		.loc 1 126 0 is_stmt 1 discriminator 4
 270 0036 0895      		ret
 271               		.cfi_endproc
 272               	.LFE22:
 274               		.section	.text.TWI_ReadPacket,"ax",@progbits
 275               	.global	TWI_ReadPacket
 277               	TWI_ReadPacket:
 278               	.LFB23:
 127:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 128:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** uint8_t TWI_ReadPacket(const uint8_t SlaveAddress,
 129:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                        const uint8_t TimeoutMS,
 130:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                        const uint8_t* InternalAddress,
 131:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                        uint8_t InternalAddressLen,
 132:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                        uint8_t* Buffer,
 133:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                        uint8_t Length)
 134:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** {
 279               		.loc 1 134 0
 280               		.cfi_startproc
 281               	.LVL25:
 282 0000 9F92      		push r9
 283               	.LCFI0:
 284               		.cfi_def_cfa_offset 3
 285               		.cfi_offset 9, -2
 286 0002 AF92      		push r10
 287               	.LCFI1:
 288               		.cfi_def_cfa_offset 4
 289               		.cfi_offset 10, -3
 290 0004 BF92      		push r11
 291               	.LCFI2:
 292               		.cfi_def_cfa_offset 5
 293               		.cfi_offset 11, -4
 294 0006 CF92      		push r12
 295               	.LCFI3:
 296               		.cfi_def_cfa_offset 6
 297               		.cfi_offset 12, -5
 298 0008 DF92      		push r13
 299               	.LCFI4:
 300               		.cfi_def_cfa_offset 7
 301               		.cfi_offset 13, -6
 302 000a EF92      		push r14
 303               	.LCFI5:
 304               		.cfi_def_cfa_offset 8
 305               		.cfi_offset 14, -7
 306 000c FF92      		push r15
 307               	.LCFI6:
 308               		.cfi_def_cfa_offset 9
 309               		.cfi_offset 15, -8
 310 000e 0F93      		push r16
 311               	.LCFI7:
 312               		.cfi_def_cfa_offset 10
 313               		.cfi_offset 16, -9
 314 0010 1F93      		push r17
 315               	.LCFI8:
 316               		.cfi_def_cfa_offset 11
 317               		.cfi_offset 17, -10
 318 0012 CF93      		push r28
 319               	.LCFI9:
 320               		.cfi_def_cfa_offset 12
 321               		.cfi_offset 28, -11
 322 0014 DF93      		push r29
 323               	.LCFI10:
 324               		.cfi_def_cfa_offset 13
 325               		.cfi_offset 29, -12
 326               	/* prologue: function */
 327               	/* frame size = 0 */
 328               	/* stack size = 11 */
 329               	.L__stack_usage = 11
 330 0016 F82E      		mov r15,r24
 331 0018 B62E      		mov r11,r22
 332 001a 942E      		mov r9,r20
 333 001c A52E      		mov r10,r21
 334 001e C22F      		mov r28,r18
 135:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	uint8_t ErrorCode;
 136:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	
 137:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_WRIT
 335               		.loc 1 137 0
 336 0020 8E7F      		andi r24,lo8(-2)
 337               	.LVL26:
 338 0022 0E94 0000 		call TWI_StartTransmission
 339               	.LVL27:
 340 0026 D82F      		mov r29,r24
 341               	.LVL28:
 342 0028 8111      		cpse r24,__zero_reg__
 343 002a 00C0      		rjmp .L60
 344 002c C92C      		mov r12,r9
 345 002e DA2C      		mov r13,r10
 346               	.LVL29:
 347               	.L61:
 138:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	                                       TimeoutMS)) == TWI_ERROR_NoError)
 139:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	{
 140:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		while (InternalAddressLen--)
 348               		.loc 1 140 0
 349 0030 CC23      		tst r28
 350 0032 01F0      		breq .L64
 351               	.LVL30:
 141:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
 142:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			if (!(TWI_SendByte(*(InternalAddress++))))
 352               		.loc 1 142 0
 353 0034 F601      		movw r30,r12
 354 0036 8191      		ld r24,Z+
 355               	.LVL31:
 356 0038 6F01      		movw r12,r30
 357 003a 0E94 0000 		call TWI_SendByte
 358               	.LVL32:
 359 003e C150      		subi r28,lo8(-(-1))
 360               	.LVL33:
 361 0040 8111      		cpse r24,__zero_reg__
 362 0042 00C0      		rjmp .L61
 363               	.LVL34:
 364               	.L64:
 143:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			{				
 144:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				ErrorCode = TWI_ERROR_SlaveNAK;
 145:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				break;
 146:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			}
 147:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		}
 148:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		
 149:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_REA
 365               		.loc 1 149 0
 366 0044 6B2D      		mov r22,r11
 367 0046 8F2D      		mov r24,r15
 368 0048 8160      		ori r24,lo8(1)
 369 004a 0E94 0000 		call TWI_StartTransmission
 370               	.LVL35:
 371 004e D82F      		mov r29,r24
 372               	.LVL36:
 373 0050 8111      		cpse r24,__zero_reg__
 374 0052 00C0      		rjmp .L60
 375 0054 CFEF      		ldi r28,lo8(-1)
 376 0056 CE0D      		add r28,r14
 377               	.LVL37:
 378               	.L65:
 150:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 											   TimeoutMS)) == TWI_ERROR_NoError)
 151:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
 152:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			while (Length--)
 379               		.loc 1 152 0
 380 0058 CF3F      		cpi r28,lo8(-1)
 381 005a 01F0      		breq .L67
 153:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			{
 154:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				if (!(TWI_ReceiveByte(Buffer++, (Length == 0))))
 382               		.loc 1 154 0
 383 005c 7801      		movw r14,r16
 384 005e FFEF      		ldi r31,-1
 385 0060 EF1A      		sub r14,r31
 386 0062 FF0A      		sbc r15,r31
 387               	.LVL38:
 388 0064 61E0      		ldi r22,lo8(1)
 389 0066 C111      		cpse r28,__zero_reg__
 390 0068 60E0      		ldi r22,0
 391               	.L66:
 392 006a C801      		movw r24,r16
 393 006c 0E94 0000 		call TWI_ReceiveByte
 394               	.LVL39:
 395 0070 C150      		subi r28,lo8(-(-1))
 396               	.LVL40:
 397 0072 8823      		tst r24
 398 0074 01F0      		breq .L69
 399 0076 8701      		movw r16,r14
 400 0078 00C0      		rjmp .L65
 401               	.L69:
 155:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				{
 156:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 					ErrorCode = TWI_ERROR_SlaveNAK;
 402               		.loc 1 156 0
 403 007a D5E0      		ldi r29,lo8(5)
 404               	.LVL41:
 405               	.L67:
 406               	.LBB16:
 407               	.LBB17:
 408               		.file 3 "../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h"
   1:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** /*
   2:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****              LUFA Library
   3:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
   5:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****            www.lufa-lib.org
   7:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** */
   8:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
   9:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** /*
  10:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
  12:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
  21:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****   this software.
  29:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** */
  30:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
  31:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** /** \file
  32:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \brief TWI Peripheral Driver (AVR8)
  33:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  34:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  On-chip TWI driver for the 8-bit AVR microcontrollers.
  35:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  36:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  37:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *        dispatch header located in LUFA/Drivers/Peripheral/TWI.h.
  38:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  */
  39:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
  40:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** /** \ingroup Group_TWI
  41:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \defgroup Group_TWI_AVR8 TWI Peripheral Driver (AVR8)
  42:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  43:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \section Sec_ModDescription Module Description
  44:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  Master mode TWI driver for the 8-bit AVR microcontrollers which contain a hardware TWI module.
  45:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  46:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  47:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *        dispatch header located in LUFA/Drivers/Peripheral/TWI.h.
  48:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  49:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \section Sec_ExampleUsage Example Usage
  50:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  The following snippet is an example of how this module may be used within a typical
  51:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  application.
  52:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  53:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  <b>Low Level API Example:</b>
  54:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \code
  55:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      // Initialize the TWI driver before first use at 200KHz
  56:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      TWI_Init(TWI_BIT_PRESCALE_1, TWI_BITLENGTH_FROM_FREQ(1, 200000));
  57:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  58:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      // Start a write session to device at device address 0xA0, internal address 0xDC with a 10m
  59:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      if (TWI_StartTransmission(0xA0 | TWI_ADDRESS_WRITE, 10) == TWI_ERROR_NoError)
  60:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      {
  61:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          TWI_SendByte(0xDC);
  62:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  63:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          TWI_SendByte(0x01);
  64:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          TWI_SendByte(0x02);
  65:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          TWI_SendByte(0x03);
  66:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  67:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          // Must stop transmission afterwards to release the bus
  68:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          TWI_StopTransmission();
  69:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      }
  70:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  71:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      // Start a read session to device at address 0xA0, internal address 0xDC with a 10ms timeou
  72:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      if (TWI_StartTransmission(0xA0 | TWI_ADDRESS_WRITE, 10) == TWI_ERROR_NoError)
  73:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      {
  74:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          TWI_SendByte(0xDC);
  75:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          TWI_StopTransmission();
  76:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  77:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          if (TWI_StartTransmission(0xA0 | TWI_ADDRESS_READ, 10) == TWI_ERROR_NoError)
  78:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          {
  79:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *              uint8_t Byte1, Byte2, Byte3;
  80:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  81:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *              // Read three bytes, acknowledge after the third byte is received
  82:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *              TWI_ReceiveByte(&Byte1, false);
  83:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *              TWI_ReceiveByte(&Byte2, false);
  84:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *              TWI_ReceiveByte(&Byte3, true);
  85:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  86:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *              // Must stop transmission afterwards to release the bus
  87:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *              TWI_StopTransmission();
  88:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *          }
  89:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      }
  90:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \endcode
  91:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  * 
  92:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  <b>High Level API Example:</b>
  93:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \code
  94:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      // Initialize the TWI driver before first use at 200KHz
  95:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      TWI_Init(TWI_BIT_PRESCALE_1, TWI_BITLENGTH_FROM_FREQ(1, 200000));
  96:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
  97:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      // Start a write session to device at device address 0xA0, internal address 0xDC with a 10m
  98:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      uint8_t InternalWriteAddress = 0xDC;
  99:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      uint8_t WritePacket[3] = {0x01, 0x02, 0x03};
 100:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
 101:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      TWI_WritePacket(0xA0, 10, &InternalWriteAddress, sizeof(InternalWriteAddress),
 102:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *                      &WritePacket, sizeof(WritePacket);
 103:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
 104:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      // Start a read session to device at address 0xA0, internal address 0xDC with a 10ms timeou
 105:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      uint8_t InternalReadAddress = 0xDC;
 106:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      uint8_t ReadPacket[3];
 107:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
 108:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *      TWI_ReadPacket(0xA0, 10, &InternalReadAddress, sizeof(InternalReadAddress),
 109:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *                     &ReadPacket, sizeof(ReadPacket);
 110:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  \endcode
 111:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *
 112:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  *  @{
 113:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h ****  */
 114:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 115:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** #ifndef __TWI_AVR8_H__
 116:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** #define __TWI_AVR8_H__
 117:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 118:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 	/* Includes: */
 119:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#include "../../../Common/Common.h"
 120:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 121:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#include <stdio.h>
 122:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#include <util/twi.h>
 123:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 124:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
 125:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#if defined(__cplusplus)
 126:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			extern "C" {
 127:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#endif
 128:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 129:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 	/* Preprocessor Checks: */
 130:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#if !defined(__INCLUDE_FROM_TWI_H) && !defined(__INCLUDE_FROM_TWI_C)
 131:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/Peripheral/TWI.h instead.
 132:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#endif
 133:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 134:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#if !(defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB646__) || \
 135:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		      defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB647__) || \
 136:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			  defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || \
 137:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			  defined(__AVR_ATmega32U6__))
 138:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#error The TWI peripheral driver is not currently available for your selected microcontroller mo
 139:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		#endif
 140:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 141:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 142:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		/* Macros: */
 143:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** TWI slave device address mask for a read session. Mask with a slave device base address to o
 144:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  the correct TWI bus address for the slave device when reading data from it.
 145:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 */
 146:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#define TWI_ADDRESS_READ         0x01
 147:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 148:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** TWI slave device address mask for a write session. Mask with a slave device base address to 
 149:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  the correct TWI bus address for the slave device when writing data to it.
 150:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 */
 151:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#define TWI_ADDRESS_WRITE        0x00
 152:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 153:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Mask to retrieve the base address for a TWI device, which can then be ORed with \ref TWI_ADD
 154:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  or \ref TWI_ADDRESS_WRITE to obtain the device's read and write address respectively.
 155:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 */
 156:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#define TWI_DEVICE_ADDRESS_MASK  0xFE
 157:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			
 158:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Bit length prescaler for \ref TWI_Init(). This mask multiplies the TWI bit length prescaler 
 159:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#define TWI_BIT_PRESCALE_1       ((0 << TWPS1) | (0 << TWPS0))
 160:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			
 161:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Bit length prescaler for \ref TWI_Init(). This mask multiplies the TWI bit length prescaler 
 162:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#define TWI_BIT_PRESCALE_4       ((0 << TWPS1) | (1 << TWPS0))
 163:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 164:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Bit length prescaler for \ref TWI_Init(). This mask multiplies the TWI bit length prescaler 
 165:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#define TWI_BIT_PRESCALE_16      ((1 << TWPS1) | (0 << TWPS0))
 166:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 167:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Bit length prescaler for \ref TWI_Init(). This mask multiplies the TWI bit length prescaler 
 168:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#define TWI_BIT_PRESCALE_64      ((1 << TWPS1) | (1 << TWPS0))
 169:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			
 170:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Calculates the length of each bit on the TWI bus for a given target frequency. This may be u
 171:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  the \ref TWI_Init() function to convert a bus frequency to a number of clocks for the \c Bit
 172:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  parameter.
 173:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *
 174:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  \param[in] Prescale   Prescaler set on the TWI bus.
 175:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  \param[in] Frequency  Desired TWI bus frequency in Hz.
 176:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *
 177:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  \return Bit length in clocks for the given TWI bus frequency at the given prescaler value.
 178:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 */
 179:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			#define TWI_BITLENGTH_FROM_FREQ(Prescale, Frequency) ((((F_CPU / (Prescale)) / (Frequency)) - 16
 180:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 181:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		/* Enums: */
 182:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Enum for the possible return codes of the TWI transfer start routine and other dependant TWI
 183:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			enum TWI_ErrorCodes_t
 184:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			{
 185:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWI_ERROR_NoError              = 0, /**< Indicates that the command completed successfully. */
 186:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWI_ERROR_BusFault             = 1, /**< A TWI bus fault occurred while attempting to capture t
 187:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWI_ERROR_BusCaptureTimeout    = 2, /**< A timeout occurred whilst waiting for the bus to be re
 188:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWI_ERROR_SlaveResponseTimeout = 3, /**< No ACK received at the nominated slave address within 
 189:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWI_ERROR_SlaveNotReady        = 4, /**< Slave NAKed the TWI bus START condition. */
 190:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWI_ERROR_SlaveNAK             = 5, /**< Slave NAKed whilst attempting to send data to the devi
 191:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			};
 192:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 	
 193:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 		/* Inline Functions: */
 194:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Initializes the TWI hardware into master mode, ready for data transmission and reception. Th
 195:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  before any other TWI operations.
 196:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *
 197:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  The generated SCL frequency will be according to the formula <pre>F_CPU / (16 + 2 * BitLengt
 198:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *
 199:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  \note The value of the \c BitLength parameter should not be set below 10 or invalid bus cond
 200:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *        occur, as indicated in the AVR8 microcontroller datasheet.
 201:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *
 202:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  \param[in] Prescale   Prescaler to use when determining the bus frequency, a \c TWI_BIT_PRES
 203:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  \param[in] BitLength  Length of the bits sent on the bus.
 204:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 */
 205:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			static inline void TWI_Init(const uint8_t Prescale, const uint8_t BitLength) ATTR_ALWAYS_INLINE;
 206:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			static inline void TWI_Init(const uint8_t Prescale, const uint8_t BitLength)
 207:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			{
 208:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWCR |= (1 << TWEN);
 209:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWSR  = Prescale;
 210:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWBR  = BitLength;
 211:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			}
 212:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 213:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Turns off the TWI driver hardware. If this is called, any further TWI operations will requir
 214:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 *  \ref TWI_Init() before the TWI can be used again.
 215:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			 */
 216:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			static inline void TWI_Disable(void) ATTR_ALWAYS_INLINE;
 217:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			static inline void TWI_Disable(void)
 218:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			{
 219:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWCR &= ~(1 << TWEN);
 220:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			}
 221:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 
 222:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			/** Sends a TWI STOP onto the TWI bus, terminating communication with the currently addressed de
 223:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			static inline void TWI_StopTransmission(void) ATTR_ALWAYS_INLINE;
 224:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			static inline void TWI_StopTransmission(void)
 225:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 			{
 226:../../LUFA/Drivers/Peripheral/AVR8/../AVR8/TWI_AVR8.h **** 				TWCR = ((1 << TWINT) | (1 << TWSTO) | (1 << TWEN));
 409               		.loc 3 226 0
 410 007c 84E9      		ldi r24,lo8(-108)
 411 007e 8093 BC00 		sts 188,r24
 412               	.LVL42:
 413               	.L60:
 414               	.LBE17:
 415               	.LBE16:
 157:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 					break;
 158:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				}
 159:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			}
 160:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			
 161:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			TWI_StopTransmission();
 162:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		}
 163:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	}
 164:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	
 165:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	return ErrorCode;
 166:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** }
 416               		.loc 1 166 0
 417 0082 8D2F      		mov r24,r29
 418               	/* epilogue start */
 419 0084 DF91      		pop r29
 420               	.LVL43:
 421 0086 CF91      		pop r28
 422 0088 1F91      		pop r17
 423 008a 0F91      		pop r16
 424 008c FF90      		pop r15
 425               	.LVL44:
 426 008e EF90      		pop r14
 427 0090 DF90      		pop r13
 428 0092 CF90      		pop r12
 429 0094 BF90      		pop r11
 430               	.LVL45:
 431 0096 AF90      		pop r10
 432 0098 9F90      		pop r9
 433 009a 0895      		ret
 434               		.cfi_endproc
 435               	.LFE23:
 437               		.section	.text.TWI_WritePacket,"ax",@progbits
 438               	.global	TWI_WritePacket
 440               	TWI_WritePacket:
 441               	.LFB24:
 167:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 168:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** uint8_t TWI_WritePacket(const uint8_t SlaveAddress,
 169:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                         const uint8_t TimeoutMS,
 170:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                         const uint8_t* InternalAddress,
 171:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                         uint8_t InternalAddressLen,
 172:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                         const uint8_t* Buffer,
 173:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c ****                         uint8_t Length)
 174:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** {
 442               		.loc 1 174 0
 443               		.cfi_startproc
 444               	.LVL46:
 445 0000 BF92      		push r11
 446               	.LCFI11:
 447               		.cfi_def_cfa_offset 3
 448               		.cfi_offset 11, -2
 449 0002 CF92      		push r12
 450               	.LCFI12:
 451               		.cfi_def_cfa_offset 4
 452               		.cfi_offset 12, -3
 453 0004 DF92      		push r13
 454               	.LCFI13:
 455               		.cfi_def_cfa_offset 5
 456               		.cfi_offset 13, -4
 457 0006 EF92      		push r14
 458               	.LCFI14:
 459               		.cfi_def_cfa_offset 6
 460               		.cfi_offset 14, -5
 461 0008 FF92      		push r15
 462               	.LCFI15:
 463               		.cfi_def_cfa_offset 7
 464               		.cfi_offset 15, -6
 465 000a 0F93      		push r16
 466               	.LCFI16:
 467               		.cfi_def_cfa_offset 8
 468               		.cfi_offset 16, -7
 469 000c 1F93      		push r17
 470               	.LCFI17:
 471               		.cfi_def_cfa_offset 9
 472               		.cfi_offset 17, -8
 473 000e CF93      		push r28
 474               	.LCFI18:
 475               		.cfi_def_cfa_offset 10
 476               		.cfi_offset 28, -9
 477 0010 DF93      		push r29
 478               	.LCFI19:
 479               		.cfi_def_cfa_offset 11
 480               		.cfi_offset 29, -10
 481               	/* prologue: function */
 482               	/* frame size = 0 */
 483               	/* stack size = 9 */
 484               	.L__stack_usage = 9
 485 0012 B42E      		mov r11,r20
 486 0014 F52E      		mov r15,r21
 487 0016 C22F      		mov r28,r18
 175:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	uint8_t ErrorCode;
 176:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 177:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	if ((ErrorCode = TWI_StartTransmission((SlaveAddress & TWI_DEVICE_ADDRESS_MASK) | TWI_ADDRESS_WRIT
 488               		.loc 1 177 0
 489 0018 8E7F      		andi r24,lo8(-2)
 490               	.LVL47:
 491 001a 0E94 0000 		call TWI_StartTransmission
 492               	.LVL48:
 493 001e D82F      		mov r29,r24
 494               	.LVL49:
 495 0020 8111      		cpse r24,__zero_reg__
 496 0022 00C0      		rjmp .L75
 497 0024 CB2C      		mov r12,r11
 498 0026 DF2C      		mov r13,r15
 499               	.LVL50:
 500               	.L76:
 178:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	                                       TimeoutMS)) == TWI_ERROR_NoError)
 179:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	{
 180:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		while (InternalAddressLen--)
 501               		.loc 1 180 0
 502 0028 CC23      		tst r28
 503 002a 01F0      		breq .L77
 504               	.LVL51:
 181:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
 182:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			if (!(TWI_SendByte(*(InternalAddress++))))
 505               		.loc 1 182 0
 506 002c F601      		movw r30,r12
 507 002e 8191      		ld r24,Z+
 508               	.LVL52:
 509 0030 6F01      		movw r12,r30
 510 0032 0E94 0000 		call TWI_SendByte
 511               	.LVL53:
 512 0036 C150      		subi r28,lo8(-(-1))
 513               	.LVL54:
 514 0038 8111      		cpse r24,__zero_reg__
 515 003a 00C0      		rjmp .L76
 183:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			{				
 184:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				ErrorCode = TWI_ERROR_SlaveNAK;
 516               		.loc 1 184 0
 517 003c D5E0      		ldi r29,lo8(5)
 518               	.LVL55:
 519               	.L77:
 520 003e 6801      		movw r12,r16
 521               	.LVL56:
 522               	.L79:
 185:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				break;
 186:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			}
 187:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		}
 188:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 
 189:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		while (Length--)
 523               		.loc 1 189 0
 524 0040 EE20      		tst r14
 525 0042 01F0      		breq .L80
 526               	.LVL57:
 190:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		{
 191:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			if (!(TWI_SendByte(*(Buffer++))))
 527               		.loc 1 191 0
 528 0044 F601      		movw r30,r12
 529 0046 8191      		ld r24,Z+
 530               	.LVL58:
 531 0048 6F01      		movw r12,r30
 532 004a 0E94 0000 		call TWI_SendByte
 533               	.LVL59:
 534 004e EA94      		dec r14
 535               	.LVL60:
 536 0050 8111      		cpse r24,__zero_reg__
 537 0052 00C0      		rjmp .L79
 192:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			{
 193:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				ErrorCode = TWI_ERROR_SlaveNAK;
 538               		.loc 1 193 0
 539 0054 D5E0      		ldi r29,lo8(5)
 540               	.LVL61:
 541               	.L80:
 542               	.LBB18:
 543               	.LBB19:
 544               		.loc 3 226 0
 545 0056 84E9      		ldi r24,lo8(-108)
 546 0058 8093 BC00 		sts 188,r24
 547               	.LVL62:
 548               	.L75:
 549               	.LBE19:
 550               	.LBE18:
 194:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 				break;
 195:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 			}
 196:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		}
 197:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		
 198:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 		TWI_StopTransmission();
 199:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	}
 200:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	
 201:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** 	return ErrorCode;
 202:../../LUFA/Drivers/Peripheral/AVR8/TWI_AVR8.c **** }
 551               		.loc 1 202 0
 552 005c 8D2F      		mov r24,r29
 553               	/* epilogue start */
 554 005e DF91      		pop r29
 555               	.LVL63:
 556 0060 CF91      		pop r28
 557 0062 1F91      		pop r17
 558 0064 0F91      		pop r16
 559 0066 FF90      		pop r15
 560 0068 EF90      		pop r14
 561 006a DF90      		pop r13
 562 006c CF90      		pop r12
 563 006e BF90      		pop r11
 564 0070 0895      		ret
 565               		.cfi_endproc
 566               	.LFE24:
 568               		.text
 569               	.Letext0:
 570               		.file 4 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 TWI_AVR8.c
     /tmp/ccgoNwzr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccgoNwzr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccgoNwzr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccgoNwzr.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccgoNwzr.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccgoNwzr.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccgoNwzr.s:14     .text.TWI_StartTransmission:0000000000000000 TWI_StartTransmission
     /tmp/ccgoNwzr.s:180    .text.TWI_SendByte:0000000000000000 TWI_SendByte
     /tmp/ccgoNwzr.s:217    .text.TWI_ReceiveByte:0000000000000000 TWI_ReceiveByte
     /tmp/ccgoNwzr.s:277    .text.TWI_ReadPacket:0000000000000000 TWI_ReadPacket
     /tmp/ccgoNwzr.s:440    .text.TWI_WritePacket:0000000000000000 TWI_WritePacket

NO UNDEFINED SYMBOLS
