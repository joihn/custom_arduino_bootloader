
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f8  00800100  00002968  000029fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002968  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001225  008001f8  008001f8  00002af4  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00002af4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002b08  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000448  00000000  00000000  00002b48  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009d14  00000000  00000000  00002f90  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000031a0  00000000  00000000  0000cca4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004b31  00000000  00000000  0000fe44  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000df0  00000000  00000000  00014978  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003536  00000000  00000000  00015768  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000056f1  00000000  00000000  00018c9e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000558  00000000  00000000  0001e38f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	22 c2       	rjmp	.+1092   	; 0x446 <__ctors_end>
       2:	00 00       	nop
       4:	3e c2       	rjmp	.+1148   	; 0x482 <__bad_interrupt>
       6:	00 00       	nop
       8:	3c c2       	rjmp	.+1144   	; 0x482 <__bad_interrupt>
       a:	00 00       	nop
       c:	3a c2       	rjmp	.+1140   	; 0x482 <__bad_interrupt>
       e:	00 00       	nop
      10:	38 c2       	rjmp	.+1136   	; 0x482 <__bad_interrupt>
      12:	00 00       	nop
      14:	36 c2       	rjmp	.+1132   	; 0x482 <__bad_interrupt>
      16:	00 00       	nop
      18:	34 c2       	rjmp	.+1128   	; 0x482 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	32 c2       	rjmp	.+1124   	; 0x482 <__bad_interrupt>
      1e:	00 00       	nop
      20:	30 c2       	rjmp	.+1120   	; 0x482 <__bad_interrupt>
      22:	00 00       	nop
      24:	2e c2       	rjmp	.+1116   	; 0x482 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 a7 0c 	jmp	0x194e	; 0x194e <__vector_10>
      2c:	2a c2       	rjmp	.+1108   	; 0x482 <__bad_interrupt>
      2e:	00 00       	nop
      30:	28 c2       	rjmp	.+1104   	; 0x482 <__bad_interrupt>
      32:	00 00       	nop
      34:	26 c2       	rjmp	.+1100   	; 0x482 <__bad_interrupt>
      36:	00 00       	nop
      38:	24 c2       	rjmp	.+1096   	; 0x482 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	22 c2       	rjmp	.+1092   	; 0x482 <__bad_interrupt>
      3e:	00 00       	nop
      40:	20 c2       	rjmp	.+1088   	; 0x482 <__bad_interrupt>
      42:	00 00       	nop
      44:	1e c2       	rjmp	.+1084   	; 0x482 <__bad_interrupt>
      46:	00 00       	nop
      48:	1c c2       	rjmp	.+1080   	; 0x482 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1a c2       	rjmp	.+1076   	; 0x482 <__bad_interrupt>
      4e:	00 00       	nop
      50:	18 c2       	rjmp	.+1072   	; 0x482 <__bad_interrupt>
      52:	00 00       	nop
      54:	16 c2       	rjmp	.+1068   	; 0x482 <__bad_interrupt>
      56:	00 00       	nop
      58:	14 c2       	rjmp	.+1064   	; 0x482 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	12 c2       	rjmp	.+1060   	; 0x482 <__bad_interrupt>
      5e:	00 00       	nop
      60:	10 c2       	rjmp	.+1056   	; 0x482 <__bad_interrupt>
      62:	00 00       	nop
      64:	0e c2       	rjmp	.+1052   	; 0x482 <__bad_interrupt>
      66:	00 00       	nop
      68:	0c c2       	rjmp	.+1048   	; 0x482 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	0a c2       	rjmp	.+1044   	; 0x482 <__bad_interrupt>
      6e:	00 00       	nop
      70:	08 c2       	rjmp	.+1040   	; 0x482 <__bad_interrupt>
      72:	00 00       	nop
      74:	06 c2       	rjmp	.+1036   	; 0x482 <__bad_interrupt>
      76:	00 00       	nop
      78:	04 c2       	rjmp	.+1032   	; 0x482 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	02 c2       	rjmp	.+1028   	; 0x482 <__bad_interrupt>
      7e:	00 00       	nop
      80:	00 c2       	rjmp	.+1024   	; 0x482 <__bad_interrupt>
      82:	00 00       	nop
      84:	fe c1       	rjmp	.+1020   	; 0x482 <__bad_interrupt>
      86:	00 00       	nop
      88:	fc c1       	rjmp	.+1016   	; 0x482 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fa c1       	rjmp	.+1012   	; 0x482 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f8 c1       	rjmp	.+1008   	; 0x482 <__bad_interrupt>
      92:	00 00       	nop
      94:	f6 c1       	rjmp	.+1004   	; 0x482 <__bad_interrupt>
      96:	00 00       	nop
      98:	24 07       	cpc	r18, r20
      9a:	7e 08       	sbc	r7, r14
      9c:	58 07       	cpc	r21, r24
      9e:	7b 07       	cpc	r23, r27
      a0:	3d 08       	sbc	r3, r13
      a2:	44 08       	sbc	r4, r4
      a4:	72 08       	sbc	r7, r2
      a6:	25 08       	sbc	r2, r5
      a8:	1d 0f       	add	r17, r29
      aa:	3f 0f       	add	r19, r31
      ac:	2e 10       	cpse	r2, r14
      ae:	3f 0f       	add	r19, r31
      b0:	2e 10       	cpse	r2, r14
      b2:	84 0f       	add	r24, r20
      b4:	a7 0f       	add	r26, r23
      b6:	2e 10       	cpse	r2, r14
      b8:	fa 0f       	add	r31, r26
      ba:	0c 10       	cpse	r0, r12

000000bc <ProductString>:
      bc:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
      cc:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
      dc:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

000000e6 <ManufacturerString>:
      e6:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      f6:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000100 <LanguageString>:
     100:	04 03 09 04                                         ....

00000104 <ConfigurationDescriptor>:
     104:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     114:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
     124:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     134:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

00000142 <DeviceDescriptor>:
     142:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
     152:	00 01                                               ..

00000154 <HTTPPage>:
     154:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     164:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     174:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     184:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     194:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     1a4:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     1b4:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     1c4:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     1d4:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     1e4:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     1f4:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     204:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     214:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     224:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     234:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     244:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     254:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     264:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     274:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     284:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     294:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     2a4:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     2b4:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     2c4:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     2d4:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     2e4:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     2f4:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     304:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     314:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     324:	3c 2f 69 3e 31 31 31 30 30 39 09 09 3c 2f 70 3e     </i>111009..</p>
     334:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

00000344 <HTTP404Header>:
     344:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     354:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     364:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     374:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     384:	0a 00                                               ..

00000386 <HTTP200Header>:
     386:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     396:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     3a6:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     3b6:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     3c6:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     3d6:	0a 0d 0a 00                                         ....

000003da <AdapterSupportedOIDList>:
     3da:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3ea:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3fa:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     40a:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     41a:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     42a:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     43a:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000446 <__ctors_end>:
     446:	11 24       	eor	r1, r1
     448:	1f be       	out	0x3f, r1	; 63
     44a:	cf ef       	ldi	r28, 0xFF	; 255
     44c:	d0 e2       	ldi	r29, 0x20	; 32
     44e:	de bf       	out	0x3e, r29	; 62
     450:	cd bf       	out	0x3d, r28	; 61

00000452 <__do_copy_data>:
     452:	11 e0       	ldi	r17, 0x01	; 1
     454:	a0 e0       	ldi	r26, 0x00	; 0
     456:	b1 e0       	ldi	r27, 0x01	; 1
     458:	e8 e6       	ldi	r30, 0x68	; 104
     45a:	f9 e2       	ldi	r31, 0x29	; 41
     45c:	00 e0       	ldi	r16, 0x00	; 0
     45e:	0b bf       	out	0x3b, r16	; 59
     460:	02 c0       	rjmp	.+4      	; 0x466 <__do_copy_data+0x14>
     462:	07 90       	elpm	r0, Z+
     464:	0d 92       	st	X+, r0
     466:	a8 3f       	cpi	r26, 0xF8	; 248
     468:	b1 07       	cpc	r27, r17
     46a:	d9 f7       	brne	.-10     	; 0x462 <__do_copy_data+0x10>

0000046c <__do_clear_bss>:
     46c:	24 e1       	ldi	r18, 0x14	; 20
     46e:	a8 ef       	ldi	r26, 0xF8	; 248
     470:	b1 e0       	ldi	r27, 0x01	; 1
     472:	01 c0       	rjmp	.+2      	; 0x476 <.do_clear_bss_start>

00000474 <.do_clear_bss_loop>:
     474:	1d 92       	st	X+, r1

00000476 <.do_clear_bss_start>:
     476:	ad 31       	cpi	r26, 0x1D	; 29
     478:	b2 07       	cpc	r27, r18
     47a:	e1 f7       	brne	.-8      	; 0x474 <.do_clear_bss_loop>
     47c:	52 d0       	rcall	.+164    	; 0x522 <main>
     47e:	0c 94 b2 14 	jmp	0x2964	; 0x2964 <_exit>

00000482 <__bad_interrupt>:
     482:	be cd       	rjmp	.-1156   	; 0x0 <__vectors>

00000484 <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     484:	9b b1       	in	r25, 0x0b	; 11
     486:	9f 70       	andi	r25, 0x0F	; 15
     488:	89 2b       	or	r24, r25
     48a:	8b b9       	out	0x0b, r24	; 11
     48c:	08 95       	ret

0000048e <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     48e:	84 b7       	in	r24, 0x34	; 52
     490:	87 7f       	andi	r24, 0xF7	; 247
     492:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     494:	0f b6       	in	r0, 0x3f	; 63
     496:	f8 94       	cli
     498:	a8 95       	wdr
     49a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     49e:	88 61       	ori	r24, 0x18	; 24
     4a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     4a4:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     4a8:	0f be       	out	0x3f, r0	; 63
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     4aa:	90 e0       	ldi	r25, 0x00	; 0
     4ac:	80 e8       	ldi	r24, 0x80	; 128
     4ae:	0f b6       	in	r0, 0x3f	; 63
     4b0:	f8 94       	cli
     4b2:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
     4b6:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
     4ba:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4bc:	8a b1       	in	r24, 0x0a	; 10
     4be:	80 6f       	ori	r24, 0xF0	; 240
     4c0:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4c2:	8b b1       	in	r24, 0x0b	; 11
     4c4:	8f 70       	andi	r24, 0x0F	; 15
     4c6:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4c8:	83 e3       	ldi	r24, 0x33	; 51
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
     4d0:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4d4:	86 e0       	ldi	r24, 0x06	; 6
     4d6:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4da:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4de:	88 e1       	ldi	r24, 0x18	; 24
     4e0:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

				DDRD  |= (1 << 3);
     4e4:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4e6:	5a 9a       	sbi	0x0b, 2	; 11
	clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4e8:	0e 94 91 0c 	call	0x1922	; 0x1922 <USB_Init>
			static inline void Serial_CreateStream(FILE* Stream)
			{
				if (!(Stream))
				{
					Stream = &USARTSerialStream;
					stdin  = Stream;
     4ec:	a7 e1       	ldi	r26, 0x17	; 23
     4ee:	b4 e1       	ldi	r27, 0x14	; 20
     4f0:	e9 e0       	ldi	r30, 0x09	; 9
     4f2:	f4 e1       	ldi	r31, 0x14	; 20
     4f4:	11 96       	adiw	r26, 0x01	; 1
     4f6:	fc 93       	st	X, r31
     4f8:	ee 93       	st	-X, r30
					stdout = Stream;
     4fa:	13 96       	adiw	r26, 0x03	; 3
     4fc:	fc 93       	st	X, r31
     4fe:	ee 93       	st	-X, r30
     500:	12 97       	sbiw	r26, 0x02	; 2
				}
			
				*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
     502:	8e e0       	ldi	r24, 0x0E	; 14
     504:	df 01       	movw	r26, r30
     506:	1d 92       	st	X+, r1
     508:	8a 95       	dec	r24
     50a:	e9 f7       	brne	.-6      	; 0x506 <SetupHardware+0x78>
     50c:	83 e0       	ldi	r24, 0x03	; 3
     50e:	83 83       	std	Z+3, r24	; 0x03
     510:	81 e3       	ldi	r24, 0x31	; 49
     512:	94 e1       	ldi	r25, 0x14	; 20
     514:	91 87       	std	Z+9, r25	; 0x09
     516:	80 87       	std	Z+8, r24	; 0x08
     518:	8a e3       	ldi	r24, 0x3A	; 58
     51a:	94 e1       	ldi	r25, 0x14	; 20
     51c:	93 87       	std	Z+11, r25	; 0x0b
     51e:	82 87       	std	Z+10, r24	; 0x0a
     520:	08 95       	ret

00000522 <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     522:	b5 df       	rcall	.-150    	; 0x48e <SetupHardware>

	TCP_Init();
     524:	dc d2       	rcall	.+1464   	; 0xade <TCP_Init>
     526:	0e 94 c0 0b 	call	0x1780	; 0x1780 <Webserver_Init>
	Webserver_Init();

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     52a:	80 e1       	ldi	r24, 0x10	; 16
     52c:	ab df       	rcall	.-170    	; 0x484 <LEDs_SetAllLEDs>
     52e:	78 94       	sei
	sei();
     530:	80 e0       	ldi	r24, 0x00	; 0

	for (;;)
	{
		if (RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface))
     532:	91 e0       	ldi	r25, 0x01	; 1
     534:	0e 94 57 13 	call	0x26ae	; 0x26ae <RNDIS_Device_IsPacketReceived>
     538:	88 23       	and	r24, r24
     53a:	11 f1       	breq	.+68     	; 0x580 <main+0x5e>
		{
			LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     53c:	80 e2       	ldi	r24, 0x20	; 32
     53e:	a2 df       	rcall	.-188    	; 0x484 <LEDs_SetAllLEDs>
     540:	42 eb       	ldi	r20, 0xB2	; 178
			
			RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface, &FrameIN.FrameData, &FrameIN.FrameLength);
     542:	5d e0       	ldi	r21, 0x0D	; 13
     544:	66 ed       	ldi	r22, 0xD6	; 214
     546:	77 e0       	ldi	r23, 0x07	; 7
     548:	80 e0       	ldi	r24, 0x00	; 0
     54a:	91 e0       	ldi	r25, 0x01	; 1
     54c:	0e 94 6d 13 	call	0x26da	; 0x26da <RNDIS_Device_ReadPacket>
     550:	68 ef       	ldi	r22, 0xF8	; 248
			Ethernet_ProcessPacket(&FrameIN, &FrameOUT);
     552:	71 e0       	ldi	r23, 0x01	; 1
     554:	86 ed       	ldi	r24, 0xD6	; 214
     556:	97 e0       	ldi	r25, 0x07	; 7
     558:	61 d0       	rcall	.+194    	; 0x61c <Ethernet_ProcessPacket>
     55a:	40 91 d4 07 	lds	r20, 0x07D4	; 0x8007d4 <__data_end+0x5dc>
			
			if (FrameOUT.FrameLength)
     55e:	50 91 d5 07 	lds	r21, 0x07D5	; 0x8007d5 <__data_end+0x5dd>
     562:	41 15       	cp	r20, r1
     564:	51 05       	cpc	r21, r1
     566:	51 f0       	breq	.+20     	; 0x57c <main+0x5a>
     568:	68 ef       	ldi	r22, 0xF8	; 248
			{
				RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface, &FrameOUT.FrameData, FrameOUT.FrameLength);				
     56a:	71 e0       	ldi	r23, 0x01	; 1
     56c:	80 e0       	ldi	r24, 0x00	; 0
     56e:	91 e0       	ldi	r25, 0x01	; 1
     570:	0e 94 c8 13 	call	0x2790	; 0x2790 <RNDIS_Device_SendPacket>
     574:	10 92 d5 07 	sts	0x07D5, r1	; 0x8007d5 <__data_end+0x5dd>
				FrameOUT.FrameLength = 0;
     578:	10 92 d4 07 	sts	0x07D4, r1	; 0x8007d4 <__data_end+0x5dc>
			}
			
			LEDs_SetAllLEDs(LEDMASK_USB_READY);
     57c:	80 e6       	ldi	r24, 0x60	; 96
     57e:	82 df       	rcall	.-252    	; 0x484 <LEDs_SetAllLEDs>
		}

		TCP_TCPTask(&Ethernet_RNDIS_Interface, &FrameOUT);
     580:	68 ef       	ldi	r22, 0xF8	; 248
     582:	71 e0       	ldi	r23, 0x01	; 1
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	91 e0       	ldi	r25, 0x01	; 1
     588:	9f d1       	rcall	.+830    	; 0x8c8 <TCP_TCPTask>
     58a:	80 e0       	ldi	r24, 0x00	; 0

		RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
     58c:	91 e0       	ldi	r25, 0x01	; 1
     58e:	0e 94 16 13 	call	0x262c	; 0x262c <RNDIS_Device_USBTask>
     592:	0e 94 48 10 	call	0x2090	; 0x2090 <USB_USBTask>
		USB_USBTask();
     596:	cc cf       	rjmp	.-104    	; 0x530 <main+0xe>

00000598 <EVENT_USB_Device_Connect>:
	}
     598:	80 ea       	ldi	r24, 0xA0	; 160
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     59a:	74 cf       	rjmp	.-280    	; 0x484 <LEDs_SetAllLEDs>

0000059c <EVENT_USB_Device_Disconnect>:
}

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     59c:	80 e1       	ldi	r24, 0x10	; 16
     59e:	72 cf       	rjmp	.-284    	; 0x484 <LEDs_SetAllLEDs>

000005a0 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);
     5a0:	80 e0       	ldi	r24, 0x00	; 0
     5a2:	91 e0       	ldi	r25, 0x01	; 1
     5a4:	0e 94 cb 12 	call	0x2596	; 0x2596 <RNDIS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     5a8:	81 11       	cpse	r24, r1
     5aa:	02 c0       	rjmp	.+4      	; 0x5b0 <EVENT_USB_Device_ConfigurationChanged+0x10>
     5ac:	80 e9       	ldi	r24, 0x90	; 144
     5ae:	01 c0       	rjmp	.+2      	; 0x5b2 <EVENT_USB_Device_ConfigurationChanged+0x12>
     5b0:	80 e6       	ldi	r24, 0x60	; 96
     5b2:	68 cf       	rjmp	.-304    	; 0x484 <LEDs_SetAllLEDs>

000005b4 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	91 e0       	ldi	r25, 0x01	; 1
     5b8:	0c 94 5a 10 	jmp	0x20b4	; 0x20b4 <RNDIS_Device_ProcessControlRequest>

000005bc <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     5bc:	29 2f       	mov	r18, r25
     5be:	33 27       	eor	r19, r19
     5c0:	22 30       	cpi	r18, 0x02	; 2
     5c2:	31 05       	cpc	r19, r1
     5c4:	59 f0       	breq	.+22     	; 0x5dc <CALLBACK_USB_GetDescriptor+0x20>
     5c6:	23 30       	cpi	r18, 0x03	; 3
     5c8:	31 05       	cpc	r19, r1
     5ca:	69 f0       	breq	.+26     	; 0x5e6 <CALLBACK_USB_GetDescriptor+0x2a>
     5cc:	21 30       	cpi	r18, 0x01	; 1
     5ce:	31 05       	cpc	r19, r1
     5d0:	e9 f4       	brne	.+58     	; 0x60c <CALLBACK_USB_GetDescriptor+0x50>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     5d2:	82 e1       	ldi	r24, 0x12	; 18
     5d4:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     5d6:	22 e4       	ldi	r18, 0x42	; 66
     5d8:	31 e0       	ldi	r19, 0x01	; 1
     5da:	1c c0       	rjmp	.+56     	; 0x614 <CALLBACK_USB_GetDescriptor+0x58>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     5dc:	8e e3       	ldi	r24, 0x3E	; 62
     5de:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     5e0:	24 e0       	ldi	r18, 0x04	; 4
     5e2:	31 e0       	ldi	r19, 0x01	; 1
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     5e4:	17 c0       	rjmp	.+46     	; 0x614 <CALLBACK_USB_GetDescriptor+0x58>
		case DTYPE_String:
			switch (DescriptorNumber)
     5e6:	99 27       	eor	r25, r25
     5e8:	81 30       	cpi	r24, 0x01	; 1
     5ea:	91 05       	cpc	r25, r1
     5ec:	49 f0       	breq	.+18     	; 0x600 <CALLBACK_USB_GetDescriptor+0x44>
     5ee:	28 f0       	brcs	.+10     	; 0x5fa <CALLBACK_USB_GetDescriptor+0x3e>
     5f0:	02 97       	sbiw	r24, 0x02	; 2
     5f2:	61 f4       	brne	.+24     	; 0x60c <CALLBACK_USB_GetDescriptor+0x50>
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     5f4:	ec eb       	ldi	r30, 0xBC	; 188
     5f6:	f0 e0       	ldi	r31, 0x00	; 0
     5f8:	05 c0       	rjmp	.+10     	; 0x604 <CALLBACK_USB_GetDescriptor+0x48>
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     5fa:	e0 e0       	ldi	r30, 0x00	; 0
     5fc:	f1 e0       	ldi	r31, 0x01	; 1
     5fe:	02 c0       	rjmp	.+4      	; 0x604 <CALLBACK_USB_GetDescriptor+0x48>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     600:	e6 ee       	ldi	r30, 0xE6	; 230
     602:	f0 e0       	ldi	r31, 0x00	; 0
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     604:	84 91       	lpm	r24, Z
     606:	90 e0       	ldi	r25, 0x00	; 0
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case 0x02:
					Address = &ProductString;
     608:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     60a:	04 c0       	rjmp	.+8      	; 0x614 <CALLBACK_USB_GetDescriptor+0x58>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     60c:	80 e0       	ldi	r24, 0x00	; 0
     60e:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     610:	20 e0       	ldi	r18, 0x00	; 0
     612:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     614:	fa 01       	movw	r30, r20
     616:	31 83       	std	Z+1, r19	; 0x01
     618:	20 83       	st	Z, r18
	return Size;
}
     61a:	08 95       	ret

0000061c <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     61c:	ef 92       	push	r14
     61e:	ff 92       	push	r15
     620:	0f 93       	push	r16
     622:	1f 93       	push	r17
     624:	cf 93       	push	r28
     626:	df 93       	push	r29
     628:	ec 01       	movw	r28, r24
     62a:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN->FrameData);
     62c:	91 d0       	rcall	.+290    	; 0x750 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     62e:	46 e0       	ldi	r20, 0x06	; 6
     630:	50 e0       	ldi	r21, 0x00	; 0
     632:	6d ea       	ldi	r22, 0xAD	; 173
     634:	71 e0       	ldi	r23, 0x01	; 1
     636:	ce 01       	movw	r24, r28
     638:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
     63c:	9e 01       	movw	r18, r28
     63e:	24 52       	subi	r18, 0x24	; 36
     640:	3a 4f       	sbci	r19, 0xFA	; 250
     642:	79 01       	movw	r14, r18
     644:	89 2b       	or	r24, r25
     646:	51 f0       	breq	.+20     	; 0x65c <Ethernet_ProcessPacket+0x40>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     648:	46 e0       	ldi	r20, 0x06	; 6
     64a:	50 e0       	ldi	r21, 0x00	; 0
     64c:	63 ea       	ldi	r22, 0xA3	; 163
     64e:	71 e0       	ldi	r23, 0x01	; 1
     650:	ce 01       	movw	r24, r28
     652:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     656:	89 2b       	or	r24, r25
     658:	09 f0       	breq	.+2      	; 0x65c <Ethernet_ProcessPacket+0x40>
     65a:	3f c0       	rjmp	.+126    	; 0x6da <Ethernet_ProcessPacket+0xbe>

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
     65c:	f7 01       	movw	r30, r14
     65e:	81 81       	ldd	r24, Z+1	; 0x01
     660:	90 81       	ld	r25, Z
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     662:	81 30       	cpi	r24, 0x01	; 1
     664:	96 40       	sbci	r25, 0x06	; 6
     666:	c8 f1       	brcs	.+114    	; 0x6da <Ethernet_ProcessPacket+0xbe>
     668:	8d 85       	ldd	r24, Y+13	; 0x0d
     66a:	9c 85       	ldd	r25, Y+12	; 0x0c
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     66c:	81 15       	cp	r24, r1
     66e:	28 e0       	ldi	r18, 0x08	; 8
     670:	92 07       	cpc	r25, r18
     672:	51 f0       	breq	.+20     	; 0x688 <Ethernet_ProcessPacket+0x6c>
     674:	86 30       	cpi	r24, 0x06	; 6
     676:	98 40       	sbci	r25, 0x08	; 8
     678:	81 f5       	brne	.+96     	; 0x6da <Ethernet_ProcessPacket+0xbe>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
     67a:	b8 01       	movw	r22, r16
     67c:	62 5f       	subi	r22, 0xF2	; 242
     67e:	7f 4f       	sbci	r23, 0xFF	; 255
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     680:	ce 01       	movw	r24, r28
     682:	0e 96       	adiw	r24, 0x0e	; 14
     684:	ac d6       	rcall	.+3416   	; 0x13de <ARP_ProcessARPPacket>
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     686:	08 c0       	rjmp	.+16     	; 0x698 <Ethernet_ProcessPacket+0x7c>
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     688:	a8 01       	movw	r20, r16
     68a:	42 5f       	subi	r20, 0xF2	; 242
     68c:	5f 4f       	sbci	r21, 0xFF	; 255
     68e:	be 01       	movw	r22, r28
     690:	62 5f       	subi	r22, 0xF2	; 242
     692:	7f 4f       	sbci	r23, 0xFF	; 255
     694:	ce 01       	movw	r24, r28
     696:	0a d7       	rcall	.+3604   	; 0x14ac <IP_ProcessIPPacket>
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     698:	18 16       	cp	r1, r24
     69a:	19 06       	cpc	r1, r25
     69c:	e4 f4       	brge	.+56     	; 0x6d6 <Ethernet_ProcessPacket+0xba>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     69e:	26 e0       	ldi	r18, 0x06	; 6
     6a0:	ed ea       	ldi	r30, 0xAD	; 173
     6a2:	f1 e0       	ldi	r31, 0x01	; 1
     6a4:	d8 01       	movw	r26, r16
     6a6:	16 96       	adiw	r26, 0x06	; 6
     6a8:	01 90       	ld	r0, Z+
     6aa:	0d 92       	st	X+, r0
     6ac:	2a 95       	dec	r18
     6ae:	e1 f7       	brne	.-8      	; 0x6a8 <Ethernet_ProcessPacket+0x8c>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     6b0:	26 e0       	ldi	r18, 0x06	; 6
     6b2:	fe 01       	movw	r30, r28
     6b4:	36 96       	adiw	r30, 0x06	; 6
     6b6:	d8 01       	movw	r26, r16
     6b8:	01 90       	ld	r0, Z+
     6ba:	0d 92       	st	X+, r0
     6bc:	2a 95       	dec	r18
     6be:	e1 f7       	brne	.-8      	; 0x6b8 <Ethernet_ProcessPacket+0x9c>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     6c0:	2c 85       	ldd	r18, Y+12	; 0x0c
     6c2:	3d 85       	ldd	r19, Y+13	; 0x0d
     6c4:	f8 01       	movw	r30, r16
     6c6:	35 87       	std	Z+13, r19	; 0x0d
     6c8:	24 87       	std	Z+12, r18	; 0x0c

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     6ca:	e4 52       	subi	r30, 0x24	; 36
     6cc:	fa 4f       	sbci	r31, 0xFA	; 250
     6ce:	0e 96       	adiw	r24, 0x0e	; 14
     6d0:	91 83       	std	Z+1, r25	; 0x01
     6d2:	80 83       	st	Z, r24
     6d4:	02 c0       	rjmp	.+4      	; 0x6da <Ethernet_ProcessPacket+0xbe>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     6d6:	01 96       	adiw	r24, 0x01	; 1
     6d8:	19 f0       	breq	.+6      	; 0x6e0 <Ethernet_ProcessPacket+0xc4>
	{
		/* Clear the frame buffer */
		FrameIN->FrameLength = 0;
     6da:	f7 01       	movw	r30, r14
     6dc:	11 82       	std	Z+1, r1	; 0x01
     6de:	10 82       	st	Z, r1
	}
}
     6e0:	df 91       	pop	r29
     6e2:	cf 91       	pop	r28
     6e4:	1f 91       	pop	r17
     6e6:	0f 91       	pop	r16
     6e8:	ff 90       	pop	r15
     6ea:	ef 90       	pop	r14
     6ec:	08 95       	ret

000006ee <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     6ee:	cf 93       	push	r28
     6f0:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     6f2:	9b 01       	movw	r18, r22
     6f4:	36 95       	lsr	r19
     6f6:	27 95       	ror	r18
     6f8:	e0 e0       	ldi	r30, 0x00	; 0
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	ba 01       	movw	r22, r20

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     702:	e2 17       	cp	r30, r18
     704:	f3 07       	cpc	r31, r19
     706:	51 f0       	breq	.+20     	; 0x71c <Ethernet_Checksum16+0x2e>
	  Checksum += Words[CurrWord];
     708:	ec 01       	movw	r28, r24
     70a:	a9 91       	ld	r26, Y+
     70c:	b9 91       	ld	r27, Y+
     70e:	ce 01       	movw	r24, r28
     710:	4a 0f       	add	r20, r26
     712:	5b 1f       	adc	r21, r27
     714:	61 1d       	adc	r22, r1
     716:	71 1d       	adc	r23, r1
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     718:	31 96       	adiw	r30, 0x01	; 1
     71a:	f3 cf       	rjmp	.-26     	; 0x702 <Ethernet_Checksum16+0x14>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     71c:	db 01       	movw	r26, r22
     71e:	ca 01       	movw	r24, r20
     720:	88 27       	eor	r24, r24
     722:	99 27       	eor	r25, r25
     724:	89 2b       	or	r24, r25
     726:	8a 2b       	or	r24, r26
     728:	8b 2b       	or	r24, r27
     72a:	61 f0       	breq	.+24     	; 0x744 <Ethernet_Checksum16+0x56>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     72c:	db 01       	movw	r26, r22
     72e:	ca 01       	movw	r24, r20
     730:	aa 27       	eor	r26, r26
     732:	bb 27       	eor	r27, r27
     734:	ab 01       	movw	r20, r22
     736:	66 27       	eor	r22, r22
     738:	77 27       	eor	r23, r23
     73a:	48 0f       	add	r20, r24
     73c:	59 1f       	adc	r21, r25
     73e:	6a 1f       	adc	r22, r26
     740:	7b 1f       	adc	r23, r27
     742:	ec cf       	rjmp	.-40     	; 0x71c <Ethernet_Checksum16+0x2e>

	return ~Checksum;
     744:	ca 01       	movw	r24, r20
     746:	80 95       	com	r24
     748:	90 95       	com	r25
}
     74a:	df 91       	pop	r29
     74c:	cf 91       	pop	r28
     74e:	08 95       	ret

00000750 <DecodeEthernetFrameHeader>:
     750:	08 95       	ret

00000752 <DecodeARPHeader>:
     752:	08 95       	ret

00000754 <DecodeIPHeader>:
     754:	08 95       	ret

00000756 <DecodeICMPHeader>:
     756:	08 95       	ret

00000758 <DecodeTCPHeader>:
     758:	08 95       	ret

0000075a <DecodeUDPHeader>:
     75a:	08 95       	ret

0000075c <DecodeDHCPHeader>:
/** Decodes an DHCP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of a DHCP packet header
 */
void DecodeDHCPHeader(void* InDataStart)
{
     75c:	08 95       	ret

0000075e <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     75e:	ef 92       	push	r14
     760:	ff 92       	push	r15
     762:	0f 93       	push	r16
     764:	1f 93       	push	r17
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	ec 01       	movw	r28, r24
     76c:	7b 01       	movw	r14, r22
     76e:	8a 01       	movw	r16, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     770:	cb 01       	movw	r24, r22
     772:	f1 df       	rcall	.-30     	; 0x756 <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     774:	f7 01       	movw	r30, r14
     776:	80 81       	ld	r24, Z
     778:	88 30       	cpi	r24, 0x08	; 8
     77a:	61 f5       	brne	.+88     	; 0x7d4 <ICMP_ProcessICMPPacket+0x76>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     77c:	f8 01       	movw	r30, r16
     77e:	10 82       	st	Z, r1
		ICMPHeaderOUT->Code     = 0;
     780:	11 82       	std	Z+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     782:	13 82       	std	Z+3, r1	; 0x03
     784:	12 82       	std	Z+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     786:	f7 01       	movw	r30, r14
     788:	84 81       	ldd	r24, Z+4	; 0x04
     78a:	95 81       	ldd	r25, Z+5	; 0x05
     78c:	f8 01       	movw	r30, r16
     78e:	95 83       	std	Z+5, r25	; 0x05
     790:	84 83       	std	Z+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     792:	f7 01       	movw	r30, r14
     794:	86 81       	ldd	r24, Z+6	; 0x06
     796:	97 81       	ldd	r25, Z+7	; 0x07
     798:	f8 01       	movw	r30, r16
     79a:	97 83       	std	Z+7, r25	; 0x07
     79c:	86 83       	std	Z+6, r24	; 0x06

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     79e:	fe 01       	movw	r30, r28
     7a0:	e4 52       	subi	r30, 0x24	; 36
     7a2:	fa 4f       	sbci	r31, 0xFA	; 250
     7a4:	80 81       	ld	r24, Z
     7a6:	91 81       	ldd	r25, Z+1	; 0x01
     7a8:	c8 0f       	add	r28, r24
     7aa:	d9 1f       	adc	r29, r25
     7ac:	ce 19       	sub	r28, r14
     7ae:	df 09       	sbc	r29, r15

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     7b0:	ae 01       	movw	r20, r28
     7b2:	48 50       	subi	r20, 0x08	; 8
     7b4:	51 09       	sbc	r21, r1
     7b6:	b7 01       	movw	r22, r14
     7b8:	68 5f       	subi	r22, 0xF8	; 248
     7ba:	7f 4f       	sbci	r23, 0xFF	; 255
     7bc:	c8 01       	movw	r24, r16
     7be:	08 96       	adiw	r24, 0x08	; 8
     7c0:	0e 94 93 14 	call	0x2926	; 0x2926 <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     7c4:	be 01       	movw	r22, r28
     7c6:	c8 01       	movw	r24, r16
     7c8:	92 df       	rcall	.-220    	; 0x6ee <Ethernet_Checksum16>
     7ca:	f8 01       	movw	r30, r16
     7cc:	93 83       	std	Z+3, r25	; 0x03
     7ce:	82 83       	std	Z+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     7d0:	ce 01       	movw	r24, r28
     7d2:	02 c0       	rjmp	.+4      	; 0x7d8 <ICMP_ProcessICMPPacket+0x7a>
	}

	return NO_RESPONSE;
     7d4:	80 e0       	ldi	r24, 0x00	; 0
     7d6:	90 e0       	ldi	r25, 0x00	; 0
}
     7d8:	df 91       	pop	r29
     7da:	cf 91       	pop	r28
     7dc:	1f 91       	pop	r17
     7de:	0f 91       	pop	r16
     7e0:	ff 90       	pop	r15
     7e2:	ef 90       	pop	r14
     7e4:	08 95       	ret

000007e6 <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     7e6:	9b 01       	movw	r18, r22
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     7e8:	69 2f       	mov	r22, r25
     7ea:	78 2f       	mov	r23, r24
     7ec:	83 2f       	mov	r24, r19
     7ee:	92 2f       	mov	r25, r18
     7f0:	08 95       	ret

000007f2 <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     7f2:	28 2f       	mov	r18, r24
     7f4:	89 2f       	mov	r24, r25
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     7f6:	92 2f       	mov	r25, r18
     7f8:	08 95       	ret

000007fa <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               const uint16_t TCPOutSize)
{
     7fa:	8f 92       	push	r8
     7fc:	9f 92       	push	r9
     7fe:	af 92       	push	r10
     800:	bf 92       	push	r11
     802:	ef 92       	push	r14
     804:	ff 92       	push	r15
     806:	0f 93       	push	r16
     808:	1f 93       	push	r17
     80a:	cf 93       	push	r28
     80c:	df 93       	push	r29
     80e:	ec 01       	movw	r28, r24
     810:	cb 01       	movw	r24, r22
     812:	a0 e0       	ldi	r26, 0x00	; 0
     814:	b0 e0       	ldi	r27, 0x00	; 0
     816:	84 0f       	add	r24, r20
     818:	95 1f       	adc	r25, r21
     81a:	a1 1d       	adc	r26, r1
     81c:	b1 1d       	adc	r27, r1
     81e:	9a 5f       	subi	r25, 0xFA	; 250
     820:	af 4f       	sbci	r26, 0xFF	; 255
     822:	bf 4f       	sbci	r27, 0xFF	; 255
     824:	80 0f       	add	r24, r16
     826:	91 1f       	adc	r25, r17
     828:	a1 1d       	adc	r26, r1
     82a:	b1 1d       	adc	r27, r1

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     82c:	4c 01       	movw	r8, r24
     82e:	5d 01       	movw	r10, r26
     830:	82 0e       	add	r8, r18
     832:	93 1e       	adc	r9, r19
     834:	a1 1c       	adc	r10, r1
     836:	b1 1c       	adc	r11, r1
	Checksum += SwapEndian_16(TCPOutSize);
     838:	c7 01       	movw	r24, r14
     83a:	db df       	rcall	.-74     	; 0x7f2 <SwapEndian_16>
     83c:	a5 01       	movw	r20, r10
     83e:	94 01       	movw	r18, r8
     840:	28 0f       	add	r18, r24
     842:	39 1f       	adc	r19, r25
     844:	41 1d       	adc	r20, r1
     846:	51 1d       	adc	r21, r1
     848:	da 01       	movw	r26, r20
     84a:	c9 01       	movw	r24, r18

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     84c:	a7 01       	movw	r20, r14
     84e:	56 95       	lsr	r21
     850:	47 95       	ror	r20
     852:	fe 01       	movw	r30, r28
     854:	20 e0       	ldi	r18, 0x00	; 0
     856:	30 e0       	ldi	r19, 0x00	; 0
     858:	24 17       	cp	r18, r20
     85a:	35 07       	cpc	r19, r21
     85c:	49 f0       	breq	.+18     	; 0x870 <TCP_Checksum16+0x76>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     85e:	61 91       	ld	r22, Z+
     860:	71 91       	ld	r23, Z+
     862:	86 0f       	add	r24, r22
     864:	97 1f       	adc	r25, r23
     866:	a1 1d       	adc	r26, r1
     868:	b1 1d       	adc	r27, r1
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     86a:	2f 5f       	subi	r18, 0xFF	; 255
     86c:	3f 4f       	sbci	r19, 0xFF	; 255
     86e:	f4 cf       	rjmp	.-24     	; 0x858 <TCP_Checksum16+0x5e>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     870:	e0 fe       	sbrs	r14, 0
     872:	09 c0       	rjmp	.+18     	; 0x886 <TCP_Checksum16+0x8c>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     874:	22 0f       	add	r18, r18
     876:	33 1f       	adc	r19, r19
     878:	c2 0f       	add	r28, r18
     87a:	d3 1f       	adc	r29, r19
     87c:	28 81       	ld	r18, Y
     87e:	82 0f       	add	r24, r18
     880:	91 1d       	adc	r25, r1
     882:	a1 1d       	adc	r26, r1
     884:	b1 1d       	adc	r27, r1

	while (Checksum & 0xFFFF0000)
     886:	ac 01       	movw	r20, r24
     888:	bd 01       	movw	r22, r26
     88a:	44 27       	eor	r20, r20
     88c:	55 27       	eor	r21, r21
     88e:	45 2b       	or	r20, r21
     890:	46 2b       	or	r20, r22
     892:	47 2b       	or	r20, r23
     894:	61 f0       	breq	.+24     	; 0x8ae <TCP_Checksum16+0xb4>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     896:	ac 01       	movw	r20, r24
     898:	bd 01       	movw	r22, r26
     89a:	66 27       	eor	r22, r22
     89c:	77 27       	eor	r23, r23
     89e:	cd 01       	movw	r24, r26
     8a0:	aa 27       	eor	r26, r26
     8a2:	bb 27       	eor	r27, r27
     8a4:	84 0f       	add	r24, r20
     8a6:	95 1f       	adc	r25, r21
     8a8:	a6 1f       	adc	r26, r22
     8aa:	b7 1f       	adc	r27, r23
     8ac:	ec cf       	rjmp	.-40     	; 0x886 <TCP_Checksum16+0x8c>

	return ~Checksum;
     8ae:	80 95       	com	r24
     8b0:	90 95       	com	r25
}
     8b2:	df 91       	pop	r29
     8b4:	cf 91       	pop	r28
     8b6:	1f 91       	pop	r17
     8b8:	0f 91       	pop	r16
     8ba:	ff 90       	pop	r15
     8bc:	ef 90       	pop	r14
     8be:	bf 90       	pop	r11
     8c0:	af 90       	pop	r10
     8c2:	9f 90       	pop	r9
     8c4:	8f 90       	pop	r8
     8c6:	08 95       	ret

000008c8 <TCP_TCPTask>:
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
     8c8:	4f 92       	push	r4
     8ca:	5f 92       	push	r5
     8cc:	6f 92       	push	r6
     8ce:	7f 92       	push	r7
     8d0:	8f 92       	push	r8
     8d2:	9f 92       	push	r9
     8d4:	af 92       	push	r10
     8d6:	bf 92       	push	r11
     8d8:	cf 92       	push	r12
     8da:	df 92       	push	r13
     8dc:	ef 92       	push	r14
     8de:	ff 92       	push	r15
     8e0:	0f 93       	push	r16
     8e2:	1f 93       	push	r17
     8e4:	cf 93       	push	r28
     8e6:	df 93       	push	r29
     8e8:	eb 01       	movw	r28, r22
     8ea:	05 eb       	ldi	r16, 0xB5	; 181
     8ec:	1d e0       	ldi	r17, 0x0D	; 13
     8ee:	87 ef       	ldi	r24, 0xF7	; 247
     8f0:	e8 2e       	mov	r14, r24
     8f2:	83 e1       	ldi	r24, 0x13	; 19
     8f4:	f8 2e       	mov	r15, r24
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     8f6:	20 91 f7 13 	lds	r18, 0x13F7	; 0x8013f7 <PortStateTable>
     8fa:	30 91 f8 13 	lds	r19, 0x13F8	; 0x8013f8 <PortStateTable+0x1>
     8fe:	f8 01       	movw	r30, r16
     900:	80 81       	ld	r24, Z
     902:	91 81       	ldd	r25, Z+1	; 0x01
     904:	28 17       	cp	r18, r24
     906:	39 07       	cpc	r19, r25
     908:	69 f4       	brne	.+26     	; 0x924 <TCP_TCPTask+0x5c>
     90a:	80 91 f9 13 	lds	r24, 0x13F9	; 0x8013f9 <PortStateTable+0x2>
     90e:	81 30       	cpi	r24, 0x01	; 1
     910:	49 f4       	brne	.+18     	; 0x924 <TCP_TCPTask+0x5c>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
     912:	e0 91 fa 13 	lds	r30, 0x13FA	; 0x8013fa <PortStateTable+0x3>
     916:	f0 91 fb 13 	lds	r31, 0x13FB	; 0x8013fb <PortStateTable+0x4>
     91a:	b8 01       	movw	r22, r16
     91c:	60 5f       	subi	r22, 0xF0	; 240
     91e:	7f 4f       	sbci	r23, 0xFF	; 255
     920:	c8 01       	movw	r24, r16
     922:	09 95       	icall
     924:	0a 5e       	subi	r16, 0xEA	; 234
     926:	1d 4f       	sbci	r17, 0xFD	; 253
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     928:	e0 16       	cp	r14, r16
     92a:	f1 06       	cpc	r15, r17
     92c:	21 f7       	brne	.-56     	; 0x8f6 <TCP_TCPTask+0x2e>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
     92e:	4e 01       	movw	r8, r28
     930:	f4 e2       	ldi	r31, 0x24	; 36
     932:	8f 1a       	sub	r8, r31
     934:	fa ef       	ldi	r31, 0xFA	; 250
     936:	9f 0a       	sbc	r9, r31
     938:	f4 01       	movw	r30, r8
     93a:	80 81       	ld	r24, Z
     93c:	91 81       	ldd	r25, Z+1	; 0x01
     93e:	89 2b       	or	r24, r25
     940:	09 f0       	breq	.+2      	; 0x944 <TCP_TCPTask+0x7c>
     942:	bc c0       	rjmp	.+376    	; 0xabc <TCP_TCPTask+0x1f4>
     944:	e7 ec       	ldi	r30, 0xC7	; 199
     946:	ff e0       	ldi	r31, 0x0F	; 15
     948:	80 e0       	ldi	r24, 0x00	; 0
     94a:	90 e0       	ldi	r25, 0x00	; 0

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
     94c:	20 81       	ld	r18, Z
     94e:	22 23       	and	r18, r18
     950:	09 f4       	brne	.+2      	; 0x954 <TCP_TCPTask+0x8c>
     952:	ad c0       	rjmp	.+346    	; 0xaae <TCP_TCPTask+0x1e6>
     954:	21 81       	ldd	r18, Z+1	; 0x01
     956:	22 23       	and	r18, r18
     958:	09 f4       	brne	.+2      	; 0x95c <TCP_TCPTask+0x94>
     95a:	a9 c0       	rjmp	.+338    	; 0xaae <TCP_TCPTask+0x1e6>
			                                                                              sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
     95c:	26 e1       	ldi	r18, 0x16	; 22
     95e:	32 e0       	ldi	r19, 0x02	; 2
     960:	82 9f       	mul	r24, r18
     962:	80 01       	movw	r16, r0
     964:	83 9f       	mul	r24, r19
     966:	10 0d       	add	r17, r0
     968:	92 9f       	mul	r25, r18
     96a:	10 0d       	add	r17, r0
     96c:	11 24       	eor	r1, r1
     96e:	c8 01       	movw	r24, r16
     970:	8b 54       	subi	r24, 0x4B	; 75
     972:	92 4f       	sbci	r25, 0xF2	; 242
     974:	6c 01       	movw	r12, r24
     976:	fc 01       	movw	r30, r24
     978:	a0 88       	ldd	r10, Z+16	; 0x10
     97a:	b1 88       	ldd	r11, Z+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
     97c:	80 81       	ld	r24, Z
     97e:	91 81       	ldd	r25, Z+1	; 0x01
     980:	9b a3       	std	Y+35, r25	; 0x23
     982:	8a a3       	std	Y+34, r24	; 0x22
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
     984:	82 81       	ldd	r24, Z+2	; 0x02
     986:	93 81       	ldd	r25, Z+3	; 0x03
     988:	9d a3       	std	Y+37, r25	; 0x25
     98a:	8c a3       	std	Y+36, r24	; 0x24
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
     98c:	64 85       	ldd	r22, Z+12	; 0x0c
     98e:	75 85       	ldd	r23, Z+13	; 0x0d
     990:	86 85       	ldd	r24, Z+14	; 0x0e
     992:	97 85       	ldd	r25, Z+15	; 0x0f
     994:	28 df       	rcall	.-432    	; 0x7e6 <SwapEndian_32>
     996:	6e a3       	std	Y+38, r22	; 0x26
     998:	7f a3       	std	Y+39, r23	; 0x27
     99a:	88 a7       	std	Y+40, r24	; 0x28
     99c:	99 a7       	std	Y+41, r25	; 0x29
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
     99e:	f6 01       	movw	r30, r12
     9a0:	60 85       	ldd	r22, Z+8	; 0x08
     9a2:	71 85       	ldd	r23, Z+9	; 0x09
     9a4:	82 85       	ldd	r24, Z+10	; 0x0a
     9a6:	93 85       	ldd	r25, Z+11	; 0x0b
     9a8:	1e df       	rcall	.-452    	; 0x7e6 <SwapEndian_32>
     9aa:	6a a7       	std	Y+42, r22	; 0x2a
     9ac:	7b a7       	std	Y+43, r23	; 0x2b
     9ae:	8c a7       	std	Y+44, r24	; 0x2c
     9b0:	9d a7       	std	Y+45, r25	; 0x2d
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
     9b2:	82 e0       	ldi	r24, 0x02	; 2
     9b4:	90 e0       	ldi	r25, 0x00	; 0
     9b6:	99 ab       	std	Y+49, r25	; 0x31
     9b8:	88 ab       	std	Y+48, r24	; 0x30

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
     9ba:	80 e1       	ldi	r24, 0x10	; 16
     9bc:	8f a7       	std	Y+47, r24	; 0x2f
			TCPHeaderOUT->UrgentPointer        = 0;
     9be:	1d aa       	std	Y+53, r1	; 0x35
     9c0:	1c aa       	std	Y+52, r1	; 0x34
			TCPHeaderOUT->Checksum             = 0;
     9c2:	1b aa       	std	Y+51, r1	; 0x33
     9c4:	1a aa       	std	Y+50, r1	; 0x32
			TCPHeaderOUT->Reserved             = 0;
     9c6:	80 e5       	ldi	r24, 0x50	; 80
     9c8:	8e a7       	std	Y+46, r24	; 0x2e

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
     9ca:	b8 01       	movw	r22, r16
     9cc:	69 53       	subi	r22, 0x39	; 57
     9ce:	72 4f       	sbci	r23, 0xF2	; 242
     9d0:	a5 01       	movw	r20, r10
     9d2:	ce 01       	movw	r24, r28
     9d4:	c6 96       	adiw	r24, 0x36	; 54
     9d6:	0e 94 8a 14 	call	0x2914	; 0x2914 <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
     9da:	f6 01       	movw	r30, r12
     9dc:	84 85       	ldd	r24, Z+12	; 0x0c
     9de:	95 85       	ldd	r25, Z+13	; 0x0d
     9e0:	a6 85       	ldd	r26, Z+14	; 0x0e
     9e2:	b7 85       	ldd	r27, Z+15	; 0x0f
     9e4:	8a 0d       	add	r24, r10
     9e6:	9b 1d       	adc	r25, r11
     9e8:	a1 1d       	adc	r26, r1
     9ea:	b1 1d       	adc	r27, r1
     9ec:	84 87       	std	Z+12, r24	; 0x0c
     9ee:	95 87       	std	Z+13, r25	; 0x0d
     9f0:	a6 87       	std	Z+14, r26	; 0x0e
     9f2:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
     9f4:	75 01       	movw	r14, r10
     9f6:	f4 e1       	ldi	r31, 0x14	; 20
     9f8:	ef 0e       	add	r14, r31
     9fa:	f1 1c       	adc	r15, r1
     9fc:	f6 01       	movw	r30, r12
     9fe:	04 81       	ldd	r16, Z+4	; 0x04
     a00:	15 81       	ldd	r17, Z+5	; 0x05
     a02:	26 81       	ldd	r18, Z+6	; 0x06
     a04:	37 81       	ldd	r19, Z+7	; 0x07
     a06:	40 90 a9 01 	lds	r4, 0x01A9	; 0x8001a9 <ServerIPAddress>
     a0a:	50 90 aa 01 	lds	r5, 0x01AA	; 0x8001aa <ServerIPAddress+0x1>
     a0e:	60 90 ab 01 	lds	r6, 0x01AB	; 0x8001ab <ServerIPAddress+0x2>
     a12:	70 90 ac 01 	lds	r7, 0x01AC	; 0x8001ac <ServerIPAddress+0x3>
     a16:	b3 01       	movw	r22, r6
     a18:	a2 01       	movw	r20, r4
     a1a:	ce 01       	movw	r24, r28
     a1c:	82 96       	adiw	r24, 0x22	; 34
     a1e:	ed de       	rcall	.-550    	; 0x7fa <TCP_Checksum16>
     a20:	9b ab       	std	Y+51, r25	; 0x33
     a22:	8a ab       	std	Y+50, r24	; 0x32
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
     a24:	c5 01       	movw	r24, r10
     a26:	88 96       	adiw	r24, 0x28	; 40
     a28:	e4 de       	rcall	.-568    	; 0x7f2 <SwapEndian_16>
     a2a:	99 8b       	std	Y+17, r25	; 0x11
     a2c:	88 8b       	std	Y+16, r24	; 0x10
     a2e:	1f 86       	std	Y+15, r1	; 0x0f
			IPHeaderOUT->TypeOfService      = 0;
     a30:	85 e4       	ldi	r24, 0x45	; 69
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
     a32:	8e 87       	std	Y+14, r24	; 0x0e
     a34:	1c 8a       	std	Y+20, r1	; 0x14
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
     a36:	1d 8a       	std	Y+21, r1	; 0x15
     a38:	1b 8a       	std	Y+19, r1	; 0x13
			IPHeaderOUT->Identification     = 0;
     a3a:	1a 8a       	std	Y+18, r1	; 0x12
     a3c:	19 8e       	std	Y+25, r1	; 0x19
			IPHeaderOUT->HeaderChecksum     = 0;
     a3e:	18 8e       	std	Y+24, r1	; 0x18
     a40:	16 e0       	ldi	r17, 0x06	; 6
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
     a42:	1f 8b       	std	Y+23, r17	; 0x17
     a44:	80 e8       	ldi	r24, 0x80	; 128
			IPHeaderOUT->TTL                = DEFAULT_TTL;
     a46:	8e 8b       	std	Y+22, r24	; 0x16
     a48:	4a 8e       	std	Y+26, r4	; 0x1a
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
     a4a:	5b 8e       	std	Y+27, r5	; 0x1b
     a4c:	6c 8e       	std	Y+28, r6	; 0x1c
     a4e:	7d 8e       	std	Y+29, r7	; 0x1d
     a50:	f6 01       	movw	r30, r12
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
     a52:	84 81       	ldd	r24, Z+4	; 0x04
     a54:	95 81       	ldd	r25, Z+5	; 0x05
     a56:	a6 81       	ldd	r26, Z+6	; 0x06
     a58:	b7 81       	ldd	r27, Z+7	; 0x07
     a5a:	8e 8f       	std	Y+30, r24	; 0x1e
     a5c:	9f 8f       	std	Y+31, r25	; 0x1f
     a5e:	a8 a3       	std	Y+32, r26	; 0x20
     a60:	b9 a3       	std	Y+33, r27	; 0x21
     a62:	64 e1       	ldi	r22, 0x14	; 20

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
     a64:	70 e0       	ldi	r23, 0x00	; 0
     a66:	ce 01       	movw	r24, r28
     a68:	0e 96       	adiw	r24, 0x0e	; 14
     a6a:	41 de       	rcall	.-894    	; 0x6ee <Ethernet_Checksum16>
     a6c:	99 8f       	std	Y+25, r25	; 0x19
     a6e:	88 8f       	std	Y+24, r24	; 0x18
     a70:	ed ea       	ldi	r30, 0xAD	; 173

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     a72:	f1 e0       	ldi	r31, 0x01	; 1
     a74:	de 01       	movw	r26, r28
     a76:	16 96       	adiw	r26, 0x06	; 6
     a78:	81 2f       	mov	r24, r17
     a7a:	01 90       	ld	r0, Z+
     a7c:	0d 92       	st	X+, r0
     a7e:	8a 95       	dec	r24
     a80:	e1 f7       	brne	.-8      	; 0xa7a <TCP_TCPTask+0x1b2>
     a82:	e3 eb       	ldi	r30, 0xB3	; 179
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
     a84:	f1 e0       	ldi	r31, 0x01	; 1
     a86:	de 01       	movw	r26, r28
     a88:	01 90       	ld	r0, Z+
     a8a:	0d 92       	st	X+, r0
     a8c:	1a 95       	dec	r17
     a8e:	e1 f7       	brne	.-8      	; 0xa88 <TCP_TCPTask+0x1c0>
     a90:	88 e0       	ldi	r24, 0x08	; 8
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	9d 87       	std	Y+13, r25	; 0x0d
     a96:	8c 87       	std	Y+12, r24	; 0x0c
     a98:	f6 e3       	ldi	r31, 0x36	; 54

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
     a9a:	af 0e       	add	r10, r31
     a9c:	b1 1c       	adc	r11, r1
     a9e:	f4 01       	movw	r30, r8
     aa0:	b1 82       	std	Z+1, r11	; 0x01
     aa2:	a0 82       	st	Z, r10
     aa4:	f6 01       	movw	r30, r12

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
     aa6:	ed 5e       	subi	r30, 0xED	; 237
     aa8:	fd 4f       	sbci	r31, 0xFD	; 253
     aaa:	10 82       	st	Z, r1
     aac:	07 c0       	rjmp	.+14     	; 0xabc <TCP_TCPTask+0x1f4>

			break;
     aae:	01 96       	adiw	r24, 0x01	; 1
     ab0:	ea 5e       	subi	r30, 0xEA	; 234
     ab2:	fd 4f       	sbci	r31, 0xFD	; 253
     ab4:	83 30       	cpi	r24, 0x03	; 3
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     ab6:	91 05       	cpc	r25, r1
     ab8:	09 f0       	breq	.+2      	; 0xabc <TCP_TCPTask+0x1f4>
     aba:	48 cf       	rjmp	.-368    	; 0x94c <TCP_TCPTask+0x84>
     abc:	df 91       	pop	r29
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
     abe:	cf 91       	pop	r28
     ac0:	1f 91       	pop	r17
     ac2:	0f 91       	pop	r16
     ac4:	ff 90       	pop	r15
     ac6:	ef 90       	pop	r14
     ac8:	df 90       	pop	r13
     aca:	cf 90       	pop	r12
     acc:	bf 90       	pop	r11
     ace:	af 90       	pop	r10
     ad0:	9f 90       	pop	r9
     ad2:	8f 90       	pop	r8
     ad4:	7f 90       	pop	r7
     ad6:	6f 90       	pop	r6
     ad8:	5f 90       	pop	r5
     ada:	4f 90       	pop	r4
     adc:	08 95       	ret

00000ade <TCP_Init>:
     ade:	10 92 f9 13 	sts	0x13F9, r1	; 0x8013f9 <PortStateTable+0x2>
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     ae2:	8a e0       	ldi	r24, 0x0A	; 10
     ae4:	80 93 ca 0f 	sts	0x0FCA, r24	; 0x800fca <ConnectionStateTable+0x215>
     ae8:	80 93 e0 11 	sts	0x11E0, r24	; 0x8011e0 <ConnectionStateTable+0x42b>
     aec:	80 93 f6 13 	sts	0x13F6, r24	; 0x8013f6 <ConnectionStateTable+0x641>
     af0:	08 95       	ret

00000af2 <TCP_SetPortState>:

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     af2:	20 91 f7 13 	lds	r18, 0x13F7	; 0x8013f7 <PortStateTable>
     af6:	30 91 f8 13 	lds	r19, 0x13F8	; 0x8013f8 <PortStateTable+0x1>
     afa:	28 17       	cp	r18, r24
     afc:	39 07       	cpc	r19, r25
     afe:	51 f0       	breq	.+20     	; 0xb14 <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     b00:	61 30       	cpi	r22, 0x01	; 1
     b02:	71 f4       	brne	.+28     	; 0xb20 <TCP_SetPortState+0x2e>
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     b04:	20 91 f9 13 	lds	r18, 0x13F9	; 0x8013f9 <PortStateTable+0x2>
     b08:	21 11       	cpse	r18, r1
     b0a:	0c c0       	rjmp	.+24     	; 0xb24 <TCP_SetPortState+0x32>
			{
				PortStateTable[PTableEntry].Port  = Port;
     b0c:	90 93 f8 13 	sts	0x13F8, r25	; 0x8013f8 <PortStateTable+0x1>
     b10:	80 93 f7 13 	sts	0x13F7, r24	; 0x8013f7 <PortStateTable>
				PortStateTable[PTableEntry].State = State;
     b14:	60 93 f9 13 	sts	0x13F9, r22	; 0x8013f9 <PortStateTable+0x2>
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     b18:	50 93 fb 13 	sts	0x13FB, r21	; 0x8013fb <PortStateTable+0x4>
     b1c:	40 93 fa 13 	sts	0x13FA, r20	; 0x8013fa <PortStateTable+0x3>
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
     b20:	81 e0       	ldi	r24, 0x01	; 1
     b22:	08 95       	ret
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
     b24:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     b26:	08 95       	ret

00000b28 <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     b28:	20 91 f7 13 	lds	r18, 0x13F7	; 0x8013f7 <PortStateTable>
     b2c:	30 91 f8 13 	lds	r19, 0x13F8	; 0x8013f8 <PortStateTable+0x1>
     b30:	28 17       	cp	r18, r24
     b32:	39 07       	cpc	r19, r25
     b34:	19 f4       	brne	.+6      	; 0xb3c <TCP_GetPortState+0x14>
		  return PortStateTable[PTableEntry].State;
     b36:	80 91 f9 13 	lds	r24, 0x13F9	; 0x8013f9 <PortStateTable+0x2>
     b3a:	08 95       	ret
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
     b3c:	80 e0       	ldi	r24, 0x00	; 0
}
     b3e:	08 95       	ret

00000b40 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     b40:	9f 92       	push	r9
     b42:	af 92       	push	r10
     b44:	bf 92       	push	r11
     b46:	cf 92       	push	r12
     b48:	df 92       	push	r13
     b4a:	ef 92       	push	r14
     b4c:	ff 92       	push	r15
     b4e:	0f 93       	push	r16
     b50:	1f 93       	push	r17
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	00 d0       	rcall	.+0      	; 0xb58 <TCP_SetConnectionState+0x18>
     b58:	00 d0       	rcall	.+0      	; 0xb5a <TCP_SetConnectionState+0x1a>
     b5a:	cd b7       	in	r28, 0x3d	; 61
     b5c:	de b7       	in	r29, 0x3e	; 62
     b5e:	6c 01       	movw	r12, r24
     b60:	49 83       	std	Y+1, r20	; 0x01
     b62:	5a 83       	std	Y+2, r21	; 0x02
     b64:	6b 83       	std	Y+3, r22	; 0x03
     b66:	7c 83       	std	Y+4, r23	; 0x04
     b68:	79 01       	movw	r14, r18
     b6a:	90 2e       	mov	r9, r16
     b6c:	05 eb       	ldi	r16, 0xB5	; 181
     b6e:	1d e0       	ldi	r17, 0x0D	; 13
     b70:	a1 2c       	mov	r10, r1
     b72:	b1 2c       	mov	r11, r1
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     b74:	f8 01       	movw	r30, r16
     b76:	80 81       	ld	r24, Z
     b78:	91 81       	ldd	r25, Z+1	; 0x01
     b7a:	8c 15       	cp	r24, r12
     b7c:	9d 05       	cpc	r25, r13
     b7e:	e9 f4       	brne	.+58     	; 0xbba <TCP_SetConnectionState+0x7a>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     b80:	44 e0       	ldi	r20, 0x04	; 4
     b82:	50 e0       	ldi	r21, 0x00	; 0
     b84:	be 01       	movw	r22, r28
     b86:	6f 5f       	subi	r22, 0xFF	; 255
     b88:	7f 4f       	sbci	r23, 0xFF	; 255
     b8a:	c8 01       	movw	r24, r16
     b8c:	04 96       	adiw	r24, 0x04	; 4
     b8e:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     b92:	89 2b       	or	r24, r25
     b94:	91 f4       	brne	.+36     	; 0xbba <TCP_SetConnectionState+0x7a>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     b96:	f8 01       	movw	r30, r16
     b98:	82 81       	ldd	r24, Z+2	; 0x02
     b9a:	93 81       	ldd	r25, Z+3	; 0x03
     b9c:	8e 15       	cp	r24, r14
     b9e:	9f 05       	cpc	r25, r15
     ba0:	61 f4       	brne	.+24     	; 0xbba <TCP_SetConnectionState+0x7a>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     ba2:	86 e1       	ldi	r24, 0x16	; 22
     ba4:	92 e0       	ldi	r25, 0x02	; 2
     ba6:	a8 9e       	mul	r10, r24
     ba8:	f0 01       	movw	r30, r0
     baa:	a9 9e       	mul	r10, r25
     bac:	f0 0d       	add	r31, r0
     bae:	b8 9e       	mul	r11, r24
     bb0:	f0 0d       	add	r31, r0
     bb2:	11 24       	eor	r1, r1
     bb4:	e6 53       	subi	r30, 0x36	; 54
     bb6:	f0 4f       	sbci	r31, 0xF0	; 240
     bb8:	36 c0       	rjmp	.+108    	; 0xc26 <TCP_SetConnectionState+0xe6>
     bba:	ff ef       	ldi	r31, 0xFF	; 255
     bbc:	af 1a       	sub	r10, r31
     bbe:	bf 0a       	sbc	r11, r31
     bc0:	0a 5e       	subi	r16, 0xEA	; 234
     bc2:	1d 4f       	sbci	r17, 0xFD	; 253
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     bc4:	83 e0       	ldi	r24, 0x03	; 3
     bc6:	a8 16       	cp	r10, r24
     bc8:	b1 04       	cpc	r11, r1
     bca:	a1 f6       	brne	.-88     	; 0xb74 <TCP_SetConnectionState+0x34>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     bcc:	80 91 ca 0f 	lds	r24, 0x0FCA	; 0x800fca <ConnectionStateTable+0x215>
     bd0:	8a 30       	cpi	r24, 0x0A	; 10
     bd2:	59 f0       	breq	.+22     	; 0xbea <TCP_SetConnectionState+0xaa>
     bd4:	80 91 e0 11 	lds	r24, 0x11E0	; 0x8011e0 <ConnectionStateTable+0x42b>
     bd8:	8a 30       	cpi	r24, 0x0A	; 10
     bda:	51 f0       	breq	.+20     	; 0xbf0 <TCP_SetConnectionState+0xb0>
     bdc:	80 91 f6 13 	lds	r24, 0x13F6	; 0x8013f6 <ConnectionStateTable+0x641>
     be0:	8a 30       	cpi	r24, 0x0A	; 10
     be2:	21 f5       	brne	.+72     	; 0xc2c <TCP_SetConnectionState+0xec>
     be4:	82 e0       	ldi	r24, 0x02	; 2
     be6:	90 e0       	ldi	r25, 0x00	; 0
     be8:	05 c0       	rjmp	.+10     	; 0xbf4 <TCP_SetConnectionState+0xb4>
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	90 e0       	ldi	r25, 0x00	; 0
     bee:	02 c0       	rjmp	.+4      	; 0xbf4 <TCP_SetConnectionState+0xb4>
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	90 e0       	ldi	r25, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     bf4:	26 e1       	ldi	r18, 0x16	; 22
     bf6:	32 e0       	ldi	r19, 0x02	; 2
     bf8:	82 9f       	mul	r24, r18
     bfa:	f0 01       	movw	r30, r0
     bfc:	83 9f       	mul	r24, r19
     bfe:	f0 0d       	add	r31, r0
     c00:	92 9f       	mul	r25, r18
     c02:	f0 0d       	add	r31, r0
     c04:	11 24       	eor	r1, r1
     c06:	eb 54       	subi	r30, 0x4B	; 75
     c08:	f2 4f       	sbci	r31, 0xF2	; 242
     c0a:	d1 82       	std	Z+1, r13	; 0x01
     c0c:	c0 82       	st	Z, r12
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     c0e:	89 81       	ldd	r24, Y+1	; 0x01
     c10:	9a 81       	ldd	r25, Y+2	; 0x02
     c12:	ab 81       	ldd	r26, Y+3	; 0x03
     c14:	bc 81       	ldd	r27, Y+4	; 0x04
     c16:	84 83       	std	Z+4, r24	; 0x04
     c18:	95 83       	std	Z+5, r25	; 0x05
     c1a:	a6 83       	std	Z+6, r26	; 0x06
     c1c:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     c1e:	f3 82       	std	Z+3, r15	; 0x03
     c20:	e2 82       	std	Z+2, r14	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
     c22:	eb 5e       	subi	r30, 0xEB	; 235
     c24:	fd 4f       	sbci	r31, 0xFD	; 253
     c26:	90 82       	st	Z, r9
			return true;
     c28:	81 e0       	ldi	r24, 0x01	; 1
     c2a:	01 c0       	rjmp	.+2      	; 0xc2e <TCP_SetConnectionState+0xee>
		}
	}

	return false;
     c2c:	80 e0       	ldi	r24, 0x00	; 0
}
     c2e:	0f 90       	pop	r0
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	df 91       	pop	r29
     c38:	cf 91       	pop	r28
     c3a:	1f 91       	pop	r17
     c3c:	0f 91       	pop	r16
     c3e:	ff 90       	pop	r15
     c40:	ef 90       	pop	r14
     c42:	df 90       	pop	r13
     c44:	cf 90       	pop	r12
     c46:	bf 90       	pop	r11
     c48:	af 90       	pop	r10
     c4a:	9f 90       	pop	r9
     c4c:	08 95       	ret

00000c4e <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     c4e:	af 92       	push	r10
     c50:	bf 92       	push	r11
     c52:	cf 92       	push	r12
     c54:	df 92       	push	r13
     c56:	ef 92       	push	r14
     c58:	ff 92       	push	r15
     c5a:	0f 93       	push	r16
     c5c:	1f 93       	push	r17
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
     c62:	00 d0       	rcall	.+0      	; 0xc64 <TCP_GetConnectionState+0x16>
     c64:	00 d0       	rcall	.+0      	; 0xc66 <TCP_GetConnectionState+0x18>
     c66:	cd b7       	in	r28, 0x3d	; 61
     c68:	de b7       	in	r29, 0x3e	; 62
     c6a:	6c 01       	movw	r12, r24
     c6c:	49 83       	std	Y+1, r20	; 0x01
     c6e:	5a 83       	std	Y+2, r21	; 0x02
     c70:	6b 83       	std	Y+3, r22	; 0x03
     c72:	7c 83       	std	Y+4, r23	; 0x04
     c74:	59 01       	movw	r10, r18
     c76:	05 eb       	ldi	r16, 0xB5	; 181
     c78:	1d e0       	ldi	r17, 0x0D	; 13
     c7a:	e1 2c       	mov	r14, r1
     c7c:	f1 2c       	mov	r15, r1
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c7e:	f8 01       	movw	r30, r16
     c80:	80 81       	ld	r24, Z
     c82:	91 81       	ldd	r25, Z+1	; 0x01
     c84:	8c 15       	cp	r24, r12
     c86:	9d 05       	cpc	r25, r13
     c88:	f1 f4       	brne	.+60     	; 0xcc6 <TCP_GetConnectionState+0x78>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     c8a:	44 e0       	ldi	r20, 0x04	; 4
     c8c:	50 e0       	ldi	r21, 0x00	; 0
     c8e:	be 01       	movw	r22, r28
     c90:	6f 5f       	subi	r22, 0xFF	; 255
     c92:	7f 4f       	sbci	r23, 0xFF	; 255
     c94:	c8 01       	movw	r24, r16
     c96:	04 96       	adiw	r24, 0x04	; 4
     c98:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c9c:	89 2b       	or	r24, r25
     c9e:	99 f4       	brne	.+38     	; 0xcc6 <TCP_GetConnectionState+0x78>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     ca0:	f8 01       	movw	r30, r16
     ca2:	82 81       	ldd	r24, Z+2	; 0x02
     ca4:	93 81       	ldd	r25, Z+3	; 0x03
     ca6:	8a 15       	cp	r24, r10
     ca8:	9b 05       	cpc	r25, r11
     caa:	69 f4       	brne	.+26     	; 0xcc6 <TCP_GetConnectionState+0x78>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     cac:	86 e1       	ldi	r24, 0x16	; 22
     cae:	92 e0       	ldi	r25, 0x02	; 2
     cb0:	e8 9e       	mul	r14, r24
     cb2:	f0 01       	movw	r30, r0
     cb4:	e9 9e       	mul	r14, r25
     cb6:	f0 0d       	add	r31, r0
     cb8:	f8 9e       	mul	r15, r24
     cba:	f0 0d       	add	r31, r0
     cbc:	11 24       	eor	r1, r1
     cbe:	e6 53       	subi	r30, 0x36	; 54
     cc0:	f0 4f       	sbci	r31, 0xF0	; 240
     cc2:	80 81       	ld	r24, Z
     cc4:	0a c0       	rjmp	.+20     	; 0xcda <TCP_GetConnectionState+0x8c>
     cc6:	ff ef       	ldi	r31, 0xFF	; 255
     cc8:	ef 1a       	sub	r14, r31
     cca:	ff 0a       	sbc	r15, r31
     ccc:	0a 5e       	subi	r16, 0xEA	; 234
     cce:	1d 4f       	sbci	r17, 0xFD	; 253
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     cd0:	83 e0       	ldi	r24, 0x03	; 3
     cd2:	e8 16       	cp	r14, r24
     cd4:	f1 04       	cpc	r15, r1
     cd6:	99 f6       	brne	.-90     	; 0xc7e <TCP_GetConnectionState+0x30>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
     cd8:	8a e0       	ldi	r24, 0x0A	; 10
}
     cda:	0f 90       	pop	r0
     cdc:	0f 90       	pop	r0
     cde:	0f 90       	pop	r0
     ce0:	0f 90       	pop	r0
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	ef 90       	pop	r14
     cee:	df 90       	pop	r13
     cf0:	cf 90       	pop	r12
     cf2:	bf 90       	pop	r11
     cf4:	af 90       	pop	r10
     cf6:	08 95       	ret

00000cf8 <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     cf8:	af 92       	push	r10
     cfa:	bf 92       	push	r11
     cfc:	cf 92       	push	r12
     cfe:	df 92       	push	r13
     d00:	ef 92       	push	r14
     d02:	ff 92       	push	r15
     d04:	0f 93       	push	r16
     d06:	1f 93       	push	r17
     d08:	cf 93       	push	r28
     d0a:	df 93       	push	r29
     d0c:	00 d0       	rcall	.+0      	; 0xd0e <TCP_GetConnectionInfo+0x16>
     d0e:	00 d0       	rcall	.+0      	; 0xd10 <TCP_GetConnectionInfo+0x18>
     d10:	cd b7       	in	r28, 0x3d	; 61
     d12:	de b7       	in	r29, 0x3e	; 62
     d14:	6c 01       	movw	r12, r24
     d16:	49 83       	std	Y+1, r20	; 0x01
     d18:	5a 83       	std	Y+2, r21	; 0x02
     d1a:	6b 83       	std	Y+3, r22	; 0x03
     d1c:	7c 83       	std	Y+4, r23	; 0x04
     d1e:	59 01       	movw	r10, r18
     d20:	05 eb       	ldi	r16, 0xB5	; 181
     d22:	1d e0       	ldi	r17, 0x0D	; 13
     d24:	e1 2c       	mov	r14, r1
     d26:	f1 2c       	mov	r15, r1
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     d28:	f8 01       	movw	r30, r16
     d2a:	80 81       	ld	r24, Z
     d2c:	91 81       	ldd	r25, Z+1	; 0x01
     d2e:	8c 15       	cp	r24, r12
     d30:	9d 05       	cpc	r25, r13
     d32:	e9 f4       	brne	.+58     	; 0xd6e <TCP_GetConnectionInfo+0x76>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     d34:	44 e0       	ldi	r20, 0x04	; 4
     d36:	50 e0       	ldi	r21, 0x00	; 0
     d38:	be 01       	movw	r22, r28
     d3a:	6f 5f       	subi	r22, 0xFF	; 255
     d3c:	7f 4f       	sbci	r23, 0xFF	; 255
     d3e:	c8 01       	movw	r24, r16
     d40:	04 96       	adiw	r24, 0x04	; 4
     d42:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     d46:	89 2b       	or	r24, r25
     d48:	91 f4       	brne	.+36     	; 0xd6e <TCP_GetConnectionInfo+0x76>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
     d4a:	f8 01       	movw	r30, r16
     d4c:	82 81       	ldd	r24, Z+2	; 0x02
     d4e:	93 81       	ldd	r25, Z+3	; 0x03
     d50:	8a 15       	cp	r24, r10
     d52:	9b 05       	cpc	r25, r11
     d54:	61 f4       	brne	.+24     	; 0xd6e <TCP_GetConnectionInfo+0x76>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     d56:	26 e1       	ldi	r18, 0x16	; 22
     d58:	32 e0       	ldi	r19, 0x02	; 2
     d5a:	e2 9e       	mul	r14, r18
     d5c:	c0 01       	movw	r24, r0
     d5e:	e3 9e       	mul	r14, r19
     d60:	90 0d       	add	r25, r0
     d62:	f2 9e       	mul	r15, r18
     d64:	90 0d       	add	r25, r0
     d66:	11 24       	eor	r1, r1
     d68:	83 54       	subi	r24, 0x43	; 67
     d6a:	92 4f       	sbci	r25, 0xF2	; 242
     d6c:	0b c0       	rjmp	.+22     	; 0xd84 <TCP_GetConnectionInfo+0x8c>
     d6e:	ff ef       	ldi	r31, 0xFF	; 255
     d70:	ef 1a       	sub	r14, r31
     d72:	ff 0a       	sbc	r15, r31
     d74:	0a 5e       	subi	r16, 0xEA	; 234
     d76:	1d 4f       	sbci	r17, 0xFD	; 253
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     d78:	83 e0       	ldi	r24, 0x03	; 3
     d7a:	e8 16       	cp	r14, r24
     d7c:	f1 04       	cpc	r15, r1
     d7e:	a1 f6       	brne	.-88     	; 0xd28 <TCP_GetConnectionInfo+0x30>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	90 e0       	ldi	r25, 0x00	; 0
}
     d84:	0f 90       	pop	r0
     d86:	0f 90       	pop	r0
     d88:	0f 90       	pop	r0
     d8a:	0f 90       	pop	r0
     d8c:	df 91       	pop	r29
     d8e:	cf 91       	pop	r28
     d90:	1f 91       	pop	r17
     d92:	0f 91       	pop	r16
     d94:	ff 90       	pop	r15
     d96:	ef 90       	pop	r14
     d98:	df 90       	pop	r13
     d9a:	cf 90       	pop	r12
     d9c:	bf 90       	pop	r11
     d9e:	af 90       	pop	r10
     da0:	08 95       	ret

00000da2 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     da2:	4f 92       	push	r4
     da4:	5f 92       	push	r5
     da6:	6f 92       	push	r6
     da8:	7f 92       	push	r7
     daa:	8f 92       	push	r8
     dac:	9f 92       	push	r9
     dae:	af 92       	push	r10
     db0:	bf 92       	push	r11
     db2:	cf 92       	push	r12
     db4:	df 92       	push	r13
     db6:	ef 92       	push	r14
     db8:	ff 92       	push	r15
     dba:	0f 93       	push	r16
     dbc:	1f 93       	push	r17
     dbe:	cf 93       	push	r28
     dc0:	df 93       	push	r29
     dc2:	7c 01       	movw	r14, r24
     dc4:	eb 01       	movw	r28, r22
     dc6:	6a 01       	movw	r12, r20
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     dc8:	cb 01       	movw	r24, r22
     dca:	c6 dc       	rcall	.-1652   	; 0x758 <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     dcc:	aa 80       	ldd	r10, Y+2	; 0x02
     dce:	bb 80       	ldd	r11, Y+3	; 0x03
     dd0:	c5 01       	movw	r24, r10
     dd2:	aa de       	rcall	.-684    	; 0xb28 <TCP_GetPortState>
     dd4:	81 30       	cpi	r24, 0x01	; 1
     dd6:	21 f5       	brne	.+72     	; 0xe20 <TCP_ProcessTCPPacket+0x7e>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     dd8:	8d 85       	ldd	r24, Y+13	; 0x0d
     dda:	81 ff       	sbrs	r24, 1
     ddc:	0c c0       	rjmp	.+24     	; 0xdf6 <TCP_ProcessTCPPacket+0x54>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     dde:	28 81       	ld	r18, Y
     de0:	39 81       	ldd	r19, Y+1	; 0x01
     de2:	d7 01       	movw	r26, r14
     de4:	1c 96       	adiw	r26, 0x0c	; 12
     de6:	4d 91       	ld	r20, X+
     de8:	5d 91       	ld	r21, X+
     dea:	6d 91       	ld	r22, X+
     dec:	7c 91       	ld	r23, X
     dee:	1f 97       	sbiw	r26, 0x0f	; 15
     df0:	00 e0       	ldi	r16, 0x00	; 0
     df2:	c5 01       	movw	r24, r10
     df4:	a5 de       	rcall	.-694    	; 0xb40 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     df6:	1d 85       	ldd	r17, Y+13	; 0x0d
     df8:	aa 80       	ldd	r10, Y+2	; 0x02
     dfa:	bb 80       	ldd	r11, Y+3	; 0x03
     dfc:	88 80       	ld	r8, Y
     dfe:	99 80       	ldd	r9, Y+1	; 0x01
     e00:	f7 01       	movw	r30, r14
     e02:	44 84       	ldd	r4, Z+12	; 0x0c
     e04:	55 84       	ldd	r5, Z+13	; 0x0d
     e06:	66 84       	ldd	r6, Z+14	; 0x0e
     e08:	77 84       	ldd	r7, Z+15	; 0x0f
     e0a:	12 ff       	sbrs	r17, 2
     e0c:	0e c0       	rjmp	.+28     	; 0xe2a <TCP_ProcessTCPPacket+0x88>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e0e:	0a e0       	ldi	r16, 0x0A	; 10
     e10:	94 01       	movw	r18, r8
     e12:	b3 01       	movw	r22, r6
     e14:	a2 01       	movw	r20, r4
     e16:	c5 01       	movw	r24, r10
     e18:	93 de       	rcall	.-730    	; 0xb40 <TCP_SetConnectionState>
     e1a:	88 23       	and	r24, r24
     e1c:	09 f4       	brne	.+2      	; 0xe20 <TCP_ProcessTCPPacket+0x7e>
     e1e:	6e c1       	rjmp	.+732    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
     e20:	84 e1       	ldi	r24, 0x14	; 20
     e22:	d6 01       	movw	r26, r12
     e24:	1d 96       	adiw	r26, 0x0d	; 13
     e26:	8c 93       	st	X, r24
     e28:	6c c1       	rjmp	.+728    	; 0x1102 <__EEPROM_REGION_LENGTH__+0x102>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     e2a:	94 01       	movw	r18, r8
     e2c:	b3 01       	movw	r22, r6
     e2e:	a2 01       	movw	r20, r4
     e30:	c5 01       	movw	r24, r10
     e32:	0d df       	rcall	.-486    	; 0xc4e <TCP_GetConnectionState>
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	88 30       	cpi	r24, 0x08	; 8
     e38:	91 05       	cpc	r25, r1
     e3a:	08 f0       	brcs	.+2      	; 0xe3e <TCP_ProcessTCPPacket+0x9c>
     e3c:	5f c1       	rjmp	.+702    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
     e3e:	fc 01       	movw	r30, r24
     e40:	e4 5b       	subi	r30, 0xB4	; 180
     e42:	ff 4f       	sbci	r31, 0xFF	; 255
     e44:	0c 94 4c 14 	jmp	0x2898	; 0x2898 <__tablejump2__>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     e48:	12 30       	cpi	r17, 0x02	; 2
     e4a:	09 f0       	breq	.+2      	; 0xe4e <TCP_ProcessTCPPacket+0xac>
     e4c:	57 c1       	rjmp	.+686    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e4e:	02 e0       	ldi	r16, 0x02	; 2
     e50:	94 01       	movw	r18, r8
     e52:	b3 01       	movw	r22, r6
     e54:	a2 01       	movw	r20, r4
     e56:	c5 01       	movw	r24, r10
     e58:	73 de       	rcall	.-794    	; 0xb40 <TCP_SetConnectionState>
     e5a:	88 23       	and	r24, r24
     e5c:	39 f1       	breq	.+78     	; 0xeac <TCP_ProcessTCPPacket+0x10a>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     e5e:	82 e1       	ldi	r24, 0x12	; 18
     e60:	f6 01       	movw	r30, r12
     e62:	85 87       	std	Z+13, r24	; 0x0d

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     e64:	28 81       	ld	r18, Y
     e66:	39 81       	ldd	r19, Y+1	; 0x01
     e68:	d7 01       	movw	r26, r14
     e6a:	1c 96       	adiw	r26, 0x0c	; 12
     e6c:	4d 91       	ld	r20, X+
     e6e:	5d 91       	ld	r21, X+
     e70:	6d 91       	ld	r22, X+
     e72:	7c 91       	ld	r23, X
     e74:	1f 97       	sbiw	r26, 0x0f	; 15
     e76:	8a 81       	ldd	r24, Y+2	; 0x02
     e78:	9b 81       	ldd	r25, Y+3	; 0x03
     e7a:	3e df       	rcall	.-388    	; 0xcf8 <TCP_GetConnectionInfo>

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     e7c:	8c 01       	movw	r16, r24
     e7e:	6c 81       	ldd	r22, Y+4	; 0x04
     e80:	7d 81       	ldd	r23, Y+5	; 0x05
     e82:	8e 81       	ldd	r24, Y+6	; 0x06
     e84:	9f 81       	ldd	r25, Y+7	; 0x07
     e86:	af dc       	rcall	.-1698   	; 0x7e6 <SwapEndian_32>
     e88:	dc 01       	movw	r26, r24
     e8a:	cb 01       	movw	r24, r22
     e8c:	01 96       	adiw	r24, 0x01	; 1
     e8e:	a1 1d       	adc	r26, r1
     e90:	b1 1d       	adc	r27, r1
     e92:	f8 01       	movw	r30, r16
     e94:	80 83       	st	Z, r24
     e96:	91 83       	std	Z+1, r25	; 0x01
     e98:	a2 83       	std	Z+2, r26	; 0x02
     e9a:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
     e9c:	14 82       	std	Z+4, r1	; 0x04
     e9e:	15 82       	std	Z+5, r1	; 0x05
     ea0:	16 82       	std	Z+6, r1	; 0x06
     ea2:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
     ea4:	e4 5f       	subi	r30, 0xF4	; 244
     ea6:	fd 4f       	sbci	r31, 0xFD	; 253
     ea8:	10 82       	st	Z, r1
     eaa:	2b c1       	rjmp	.+598    	; 0x1102 <__EEPROM_REGION_LENGTH__+0x102>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     eac:	84 e0       	ldi	r24, 0x04	; 4
     eae:	ca c0       	rjmp	.+404    	; 0x1044 <__EEPROM_REGION_LENGTH__+0x44>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     eb0:	10 31       	cpi	r17, 0x10	; 16
     eb2:	09 f0       	breq	.+2      	; 0xeb6 <TCP_ProcessTCPPacket+0x114>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     eb4:	23 c1       	rjmp	.+582    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
     eb6:	03 e0       	ldi	r16, 0x03	; 3
     eb8:	94 01       	movw	r18, r8
     eba:	b3 01       	movw	r22, r6
     ebc:	a2 01       	movw	r20, r4
     ebe:	c5 01       	movw	r24, r10
     ec0:	3f de       	rcall	.-898    	; 0xb40 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     ec2:	28 81       	ld	r18, Y
     ec4:	39 81       	ldd	r19, Y+1	; 0x01
     ec6:	d7 01       	movw	r26, r14
     ec8:	1c 96       	adiw	r26, 0x0c	; 12
     eca:	4d 91       	ld	r20, X+
     ecc:	5d 91       	ld	r21, X+
     ece:	6d 91       	ld	r22, X+
     ed0:	7c 91       	ld	r23, X
     ed2:	1f 97       	sbiw	r26, 0x0f	; 15
     ed4:	8a 81       	ldd	r24, Y+2	; 0x02
     ed6:	9b 81       	ldd	r25, Y+3	; 0x03
     ed8:	0f df       	rcall	.-482    	; 0xcf8 <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     eda:	fc 01       	movw	r30, r24
     edc:	44 81       	ldd	r20, Z+4	; 0x04
     ede:	55 81       	ldd	r21, Z+5	; 0x05
     ee0:	66 81       	ldd	r22, Z+6	; 0x06
     ee2:	77 81       	ldd	r23, Z+7	; 0x07
     ee4:	4f 5f       	subi	r20, 0xFF	; 255
     ee6:	5f 4f       	sbci	r21, 0xFF	; 255
     ee8:	6f 4f       	sbci	r22, 0xFF	; 255
     eea:	7f 4f       	sbci	r23, 0xFF	; 255
     eec:	44 83       	std	Z+4, r20	; 0x04
     eee:	55 83       	std	Z+5, r21	; 0x05
     ef0:	66 83       	std	Z+6, r22	; 0x06
     ef2:	77 83       	std	Z+7, r23	; 0x07
     ef4:	03 c1       	rjmp	.+518    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     ef6:	11 31       	cpi	r17, 0x11	; 17
     ef8:	89 f5       	brne	.+98     	; 0xf5c <TCP_ProcessTCPPacket+0x1ba>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     efa:	f6 01       	movw	r30, r12
     efc:	15 87       	std	Z+13, r17	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     efe:	28 81       	ld	r18, Y
     f00:	39 81       	ldd	r19, Y+1	; 0x01
     f02:	d7 01       	movw	r26, r14
     f04:	1c 96       	adiw	r26, 0x0c	; 12
     f06:	4d 91       	ld	r20, X+
     f08:	5d 91       	ld	r21, X+
     f0a:	6d 91       	ld	r22, X+
     f0c:	7c 91       	ld	r23, X
     f0e:	1f 97       	sbiw	r26, 0x0f	; 15
     f10:	06 e0       	ldi	r16, 0x06	; 6
     f12:	8a 81       	ldd	r24, Y+2	; 0x02
     f14:	9b 81       	ldd	r25, Y+3	; 0x03
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     f16:	14 de       	rcall	.-984    	; 0xb40 <TCP_SetConnectionState>
     f18:	28 81       	ld	r18, Y
     f1a:	39 81       	ldd	r19, Y+1	; 0x01
     f1c:	f7 01       	movw	r30, r14
     f1e:	44 85       	ldd	r20, Z+12	; 0x0c
     f20:	55 85       	ldd	r21, Z+13	; 0x0d
     f22:	66 85       	ldd	r22, Z+14	; 0x0e
     f24:	77 85       	ldd	r23, Z+15	; 0x0f
     f26:	8a 81       	ldd	r24, Y+2	; 0x02
     f28:	9b 81       	ldd	r25, Y+3	; 0x03
     f2a:	e6 de       	rcall	.-564    	; 0xcf8 <TCP_GetConnectionInfo>
     f2c:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     f2e:	80 81       	ld	r24, Z
     f30:	91 81       	ldd	r25, Z+1	; 0x01
     f32:	a2 81       	ldd	r26, Z+2	; 0x02
     f34:	b3 81       	ldd	r27, Z+3	; 0x03
     f36:	01 96       	adiw	r24, 0x01	; 1
     f38:	a1 1d       	adc	r26, r1
     f3a:	b1 1d       	adc	r27, r1
     f3c:	80 83       	st	Z, r24
     f3e:	91 83       	std	Z+1, r25	; 0x01
     f40:	a2 83       	std	Z+2, r26	; 0x02
     f42:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
     f44:	84 81       	ldd	r24, Z+4	; 0x04
     f46:	95 81       	ldd	r25, Z+5	; 0x05
     f48:	a6 81       	ldd	r26, Z+6	; 0x06
     f4a:	b7 81       	ldd	r27, Z+7	; 0x07
     f4c:	01 96       	adiw	r24, 0x01	; 1
     f4e:	a1 1d       	adc	r26, r1
     f50:	b1 1d       	adc	r27, r1
     f52:	84 83       	std	Z+4, r24	; 0x04
     f54:	95 83       	std	Z+5, r25	; 0x05
     f56:	a6 83       	std	Z+6, r26	; 0x06
     f58:	b7 83       	std	Z+7, r27	; 0x07
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     f5a:	d3 c0       	rjmp	.+422    	; 0x1102 <__EEPROM_REGION_LENGTH__+0x102>
     f5c:	17 7f       	andi	r17, 0xF7	; 247
     f5e:	10 31       	cpi	r17, 0x10	; 16
     f60:	09 f0       	breq	.+2      	; 0xf64 <TCP_ProcessTCPPacket+0x1c2>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     f62:	cc c0       	rjmp	.+408    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
     f64:	94 01       	movw	r18, r8
     f66:	b3 01       	movw	r22, r6
     f68:	a2 01       	movw	r20, r4
     f6a:	c5 01       	movw	r24, r10
     f6c:	c5 de       	rcall	.-630    	; 0xcf8 <TCP_GetConnectionInfo>
     f6e:	8c 01       	movw	r16, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     f70:	4c 01       	movw	r8, r24
     f72:	f4 ef       	ldi	r31, 0xF4	; 244
     f74:	8f 1a       	sub	r8, r31
     f76:	fd ef       	ldi	r31, 0xFD	; 253
     f78:	9f 0a       	sbc	r9, r31
     f7a:	d4 01       	movw	r26, r8
     f7c:	8c 91       	ld	r24, X
     f7e:	f8 01       	movw	r30, r16
     f80:	e6 5f       	subi	r30, 0xF6	; 246
     f82:	fd 4f       	sbci	r31, 0xFD	; 253
     f84:	81 11       	cpse	r24, r1
     f86:	0d c0       	rjmp	.+26     	; 0xfa2 <TCP_ProcessTCPPacket+0x200>
     f88:	11 97       	sbiw	r26, 0x01	; 1
     f8a:	8c 91       	ld	r24, X
     f8c:	81 11       	cpse	r24, r1
     f8e:	09 c0       	rjmp	.+18     	; 0xfa2 <TCP_ProcessTCPPacket+0x200>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     f90:	10 82       	st	Z, r1
							ConnectionInfo->Buffer.InUse     = true;
     f92:	81 e0       	ldi	r24, 0x01	; 1
     f94:	d4 01       	movw	r26, r8
     f96:	8c 93       	st	X, r24
							ConnectionInfo->Buffer.Length    = 0;
     f98:	d8 01       	movw	r26, r16
     f9a:	19 96       	adiw	r26, 0x09	; 9
     f9c:	1c 92       	st	X, r1
     f9e:	1e 92       	st	-X, r1
     fa0:	18 97       	sbiw	r26, 0x08	; 8
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     fa2:	80 81       	ld	r24, Z
     fa4:	81 11       	cpse	r24, r1
     fa6:	a7 c0       	rjmp	.+334    	; 0x10f6 <__EEPROM_REGION_LENGTH__+0xf6>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
     fa8:	f8 01       	movw	r30, r16
     faa:	60 84       	ldd	r6, Z+8	; 0x08
     fac:	71 84       	ldd	r7, Z+9	; 0x09
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     fae:	61 14       	cp	r6, r1
     fb0:	f2 e0       	ldi	r31, 0x02	; 2
     fb2:	7f 06       	cpc	r7, r31
     fb4:	09 f4       	brne	.+2      	; 0xfb8 <TCP_ProcessTCPPacket+0x216>
     fb6:	9f c0       	rjmp	.+318    	; 0x10f6 <__EEPROM_REGION_LENGTH__+0xf6>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
     fb8:	d7 01       	movw	r26, r14
     fba:	8c 91       	ld	r24, X
     fbc:	8f 70       	andi	r24, 0x0F	; 15
     fbe:	b4 e0       	ldi	r27, 0x04	; 4
     fc0:	8b 9f       	mul	r24, r27
     fc2:	50 01       	movw	r10, r0
     fc4:	11 24       	eor	r1, r1
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
     fc6:	4c 84       	ldd	r4, Y+12	; 0x0c
     fc8:	42 94       	swap	r4
     fca:	9f e0       	ldi	r25, 0x0F	; 15
     fcc:	49 22       	and	r4, r25
     fce:	e4 e0       	ldi	r30, 0x04	; 4
     fd0:	4e 9e       	mul	r4, r30
     fd2:	20 01       	movw	r4, r0
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
     fd4:	11 24       	eor	r1, r1
     fd6:	d7 01       	movw	r26, r14
     fd8:	12 96       	adiw	r26, 0x02	; 2
     fda:	8d 91       	ld	r24, X+
     fdc:	9c 91       	ld	r25, X
     fde:	13 97       	sbiw	r26, 0x03	; 3
     fe0:	08 dc       	rcall	.-2032   	; 0x7f2 <SwapEndian_16>
     fe2:	8a 19       	sub	r24, r10
     fe4:	9b 09       	sbc	r25, r11
     fe6:	5c 01       	movw	r10, r24
     fe8:	a4 18       	sub	r10, r4
     fea:	b5 08       	sbc	r11, r5

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
     fec:	c3 01       	movw	r24, r6
     fee:	0a 96       	adiw	r24, 0x0a	; 10
     ff0:	be 01       	movw	r22, r28
     ff2:	64 0d       	add	r22, r4
     ff4:	75 1d       	adc	r23, r5
     ff6:	a5 01       	movw	r20, r10
     ff8:	80 0f       	add	r24, r16
     ffa:	91 1f       	adc	r25, r17
     ffc:	0e 94 8a 14 	call	0x2914	; 0x2914 <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1000:	f8 01       	movw	r30, r16
    1002:	80 81       	ld	r24, Z
    1004:	91 81       	ldd	r25, Z+1	; 0x01
    1006:	a2 81       	ldd	r26, Z+2	; 0x02
    1008:	b3 81       	ldd	r27, Z+3	; 0x03
    100a:	8a 0d       	add	r24, r10
    100c:	9b 1d       	adc	r25, r11
    100e:	a1 1d       	adc	r26, r1
    1010:	b1 1d       	adc	r27, r1
    1012:	80 83       	st	Z, r24
    1014:	91 83       	std	Z+1, r25	; 0x01
    1016:	a2 83       	std	Z+2, r26	; 0x02
    1018:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    101a:	80 85       	ldd	r24, Z+8	; 0x08
    101c:	91 85       	ldd	r25, Z+9	; 0x09
    101e:	a8 0e       	add	r10, r24
    1020:	b9 1e       	adc	r11, r25
    1022:	b1 86       	std	Z+9, r11	; 0x09
    1024:	a0 86       	std	Z+8, r10	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    1026:	a1 14       	cp	r10, r1
    1028:	f2 e0       	ldi	r31, 0x02	; 2
    102a:	bf 06       	cpc	r11, r31
    102c:	19 f0       	breq	.+6      	; 0x1034 <__EEPROM_REGION_LENGTH__+0x34>
    102e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1030:	83 ff       	sbrs	r24, 3
    1032:	64 c0       	rjmp	.+200    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
							{
								ConnectionInfo->Buffer.InUse = false;
    1034:	d4 01       	movw	r26, r8
								ConnectionInfo->Buffer.Ready = true;
    1036:	1c 92       	st	X, r1
    1038:	f8 01       	movw	r30, r16
    103a:	e5 5f       	subi	r30, 0xF5	; 245
    103c:	fd 4f       	sbci	r31, 0xFD	; 253
    103e:	81 e0       	ldi	r24, 0x01	; 1

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1040:	80 83       	st	Z, r24
    1042:	80 e1       	ldi	r24, 0x10	; 16
    1044:	f6 01       	movw	r30, r12
    1046:	85 87       	std	Z+13, r24	; 0x0d
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1048:	5c c0       	rjmp	.+184    	; 0x1102 <__EEPROM_REGION_LENGTH__+0x102>
    104a:	94 01       	movw	r18, r8
    104c:	b3 01       	movw	r22, r6
    104e:	a2 01       	movw	r20, r4
    1050:	c5 01       	movw	r24, r10
    1052:	52 de       	rcall	.-860    	; 0xcf8 <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    1054:	21 e1       	ldi	r18, 0x11	; 17
    1056:	d6 01       	movw	r26, r12
    1058:	1d 96       	adiw	r26, 0x0d	; 13
    105a:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    105c:	84 5f       	subi	r24, 0xF4	; 244
    105e:	9d 4f       	sbci	r25, 0xFD	; 253
    1060:	fc 01       	movw	r30, r24
    1062:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1064:	28 81       	ld	r18, Y
    1066:	39 81       	ldd	r19, Y+1	; 0x01
    1068:	d7 01       	movw	r26, r14
    106a:	1c 96       	adiw	r26, 0x0c	; 12
    106c:	4d 91       	ld	r20, X+
    106e:	5d 91       	ld	r21, X+
    1070:	6d 91       	ld	r22, X+
    1072:	7c 91       	ld	r23, X
    1074:	1f 97       	sbiw	r26, 0x0f	; 15
    1076:	04 e0       	ldi	r16, 0x04	; 4
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1078:	31 c0       	rjmp	.+98     	; 0x10dc <__EEPROM_REGION_LENGTH__+0xdc>
    107a:	11 31       	cpi	r17, 0x11	; 17
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    107c:	39 f0       	breq	.+14     	; 0x108c <__EEPROM_REGION_LENGTH__+0x8c>
    107e:	10 31       	cpi	r17, 0x10	; 16
    1080:	09 f0       	breq	.+2      	; 0x1084 <__EEPROM_REGION_LENGTH__+0x84>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1082:	3c c0       	rjmp	.+120    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
    1084:	05 e0       	ldi	r16, 0x05	; 5
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1086:	31 c0       	rjmp	.+98     	; 0x10ea <__EEPROM_REGION_LENGTH__+0xea>
    1088:	11 31       	cpi	r17, 0x11	; 17
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    108a:	c1 f5       	brne	.+112    	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
    108c:	94 01       	movw	r18, r8
    108e:	b3 01       	movw	r22, r6
    1090:	a2 01       	movw	r20, r4
    1092:	c5 01       	movw	r24, r10
    1094:	31 de       	rcall	.-926    	; 0xcf8 <TCP_GetConnectionInfo>
    1096:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1098:	80 e1       	ldi	r24, 0x10	; 16
    109a:	d6 01       	movw	r26, r12
    109c:	1d 96       	adiw	r26, 0x0d	; 13
    109e:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    10a0:	80 81       	ld	r24, Z
    10a2:	91 81       	ldd	r25, Z+1	; 0x01
    10a4:	a2 81       	ldd	r26, Z+2	; 0x02
    10a6:	b3 81       	ldd	r27, Z+3	; 0x03
    10a8:	01 96       	adiw	r24, 0x01	; 1
    10aa:	a1 1d       	adc	r26, r1
    10ac:	b1 1d       	adc	r27, r1
    10ae:	80 83       	st	Z, r24
    10b0:	91 83       	std	Z+1, r25	; 0x01
    10b2:	a2 83       	std	Z+2, r26	; 0x02
    10b4:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    10b6:	84 81       	ldd	r24, Z+4	; 0x04
    10b8:	95 81       	ldd	r25, Z+5	; 0x05
    10ba:	a6 81       	ldd	r26, Z+6	; 0x06
    10bc:	b7 81       	ldd	r27, Z+7	; 0x07
    10be:	01 96       	adiw	r24, 0x01	; 1
    10c0:	a1 1d       	adc	r26, r1
    10c2:	b1 1d       	adc	r27, r1
    10c4:	84 83       	std	Z+4, r24	; 0x04
    10c6:	95 83       	std	Z+5, r25	; 0x05
    10c8:	a6 83       	std	Z+6, r26	; 0x06

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10ca:	b7 83       	std	Z+7, r27	; 0x07
    10cc:	28 81       	ld	r18, Y
    10ce:	39 81       	ldd	r19, Y+1	; 0x01
    10d0:	f7 01       	movw	r30, r14
    10d2:	44 85       	ldd	r20, Z+12	; 0x0c
    10d4:	55 85       	ldd	r21, Z+13	; 0x0d
    10d6:	66 85       	ldd	r22, Z+14	; 0x0e
    10d8:	77 85       	ldd	r23, Z+15	; 0x0f
    10da:	0a e0       	ldi	r16, 0x0A	; 10
    10dc:	8a 81       	ldd	r24, Y+2	; 0x02
    10de:	9b 81       	ldd	r25, Y+3	; 0x03
    10e0:	2f dd       	rcall	.-1442   	; 0xb40 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    10e2:	0f c0       	rjmp	.+30     	; 0x1102 <__EEPROM_REGION_LENGTH__+0x102>
    10e4:	10 31       	cpi	r17, 0x10	; 16
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10e6:	51 f4       	brne	.+20     	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
    10e8:	0a e0       	ldi	r16, 0x0A	; 10
    10ea:	94 01       	movw	r18, r8
    10ec:	b3 01       	movw	r22, r6
    10ee:	a2 01       	movw	r20, r4
    10f0:	c5 01       	movw	r24, r10
    10f2:	26 dd       	rcall	.-1460   	; 0xb40 <TCP_SetConnectionState>
    10f4:	03 c0       	rjmp	.+6      	; 0x10fc <__EEPROM_REGION_LENGTH__+0xfc>
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    10f6:	8f ef       	ldi	r24, 0xFF	; 255
    10f8:	9f ef       	ldi	r25, 0xFF	; 255
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
	}

	return NO_RESPONSE;
    10fa:	69 c0       	rjmp	.+210    	; 0x11ce <__EEPROM_REGION_LENGTH__+0x1ce>
    10fc:	80 e0       	ldi	r24, 0x00	; 0
    10fe:	90 e0       	ldi	r25, 0x00	; 0
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1100:	66 c0       	rjmp	.+204    	; 0x11ce <__EEPROM_REGION_LENGTH__+0x1ce>
    1102:	aa 80       	ldd	r10, Y+2	; 0x02
    1104:	bb 80       	ldd	r11, Y+3	; 0x03
    1106:	28 81       	ld	r18, Y
    1108:	39 81       	ldd	r19, Y+1	; 0x01
    110a:	d7 01       	movw	r26, r14
    110c:	1c 96       	adiw	r26, 0x0c	; 12
    110e:	4d 91       	ld	r20, X+
    1110:	5d 91       	ld	r21, X+
    1112:	6d 91       	ld	r22, X+
    1114:	7c 91       	ld	r23, X
    1116:	1f 97       	sbiw	r26, 0x0f	; 15
    1118:	c5 01       	movw	r24, r10
    111a:	ee dd       	rcall	.-1060   	; 0xcf8 <TCP_GetConnectionInfo>
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    111c:	8c 01       	movw	r16, r24
    111e:	f6 01       	movw	r30, r12
    1120:	b1 82       	std	Z+1, r11	; 0x01
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1122:	a0 82       	st	Z, r10
    1124:	88 81       	ld	r24, Y
    1126:	99 81       	ldd	r25, Y+1	; 0x01
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1128:	93 83       	std	Z+3, r25	; 0x03
    112a:	82 83       	std	Z+2, r24	; 0x02
    112c:	d8 01       	movw	r26, r16
    112e:	14 96       	adiw	r26, 0x04	; 4
    1130:	6d 91       	ld	r22, X+
    1132:	7d 91       	ld	r23, X+
    1134:	8d 91       	ld	r24, X+
    1136:	9c 91       	ld	r25, X
    1138:	17 97       	sbiw	r26, 0x07	; 7
    113a:	55 db       	rcall	.-2390   	; 0x7e6 <SwapEndian_32>
    113c:	f6 01       	movw	r30, r12
    113e:	64 83       	std	Z+4, r22	; 0x04
    1140:	75 83       	std	Z+5, r23	; 0x05
    1142:	86 83       	std	Z+6, r24	; 0x06
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    1144:	97 83       	std	Z+7, r25	; 0x07
    1146:	d8 01       	movw	r26, r16
    1148:	6d 91       	ld	r22, X+
    114a:	7d 91       	ld	r23, X+
    114c:	8d 91       	ld	r24, X+
    114e:	9c 91       	ld	r25, X
    1150:	4a db       	rcall	.-2412   	; 0x7e6 <SwapEndian_32>
    1152:	f6 01       	movw	r30, r12
    1154:	60 87       	std	Z+8, r22	; 0x08
    1156:	71 87       	std	Z+9, r23	; 0x09
    1158:	82 87       	std	Z+10, r24	; 0x0a
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    115a:	93 87       	std	Z+11, r25	; 0x0b
    115c:	84 85       	ldd	r24, Z+12	; 0x0c
    115e:	8f 70       	andi	r24, 0x0F	; 15
    1160:	80 65       	ori	r24, 0x50	; 80

		if (!(ConnectionInfo->Buffer.InUse))
    1162:	84 87       	std	Z+12, r24	; 0x0c
    1164:	f8 01       	movw	r30, r16
    1166:	e4 5f       	subi	r30, 0xF4	; 244
    1168:	fd 4f       	sbci	r31, 0xFD	; 253
    116a:	80 81       	ld	r24, Z
    116c:	81 11       	cpse	r24, r1
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    116e:	03 c0       	rjmp	.+6      	; 0x1176 <__EEPROM_REGION_LENGTH__+0x176>
    1170:	82 e0       	ldi	r24, 0x02	; 2
    1172:	90 e0       	ldi	r25, 0x00	; 0
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    1174:	08 c0       	rjmp	.+16     	; 0x1186 <__EEPROM_REGION_LENGTH__+0x186>
    1176:	f8 01       	movw	r30, r16
    1178:	20 85       	ldd	r18, Z+8	; 0x08
    117a:	31 85       	ldd	r19, Z+9	; 0x09
    117c:	80 e0       	ldi	r24, 0x00	; 0
    117e:	92 e0       	ldi	r25, 0x02	; 2
    1180:	82 1b       	sub	r24, r18
    1182:	93 0b       	sbc	r25, r19
    1184:	36 db       	rcall	.-2452   	; 0x7f2 <SwapEndian_16>
    1186:	d6 01       	movw	r26, r12
    1188:	1f 96       	adiw	r26, 0x0f	; 15
    118a:	9c 93       	st	X, r25
    118c:	8e 93       	st	-X, r24
    118e:	1e 97       	sbiw	r26, 0x0e	; 14

		TCPHeaderOUT->UrgentPointer        = 0;
    1190:	f6 01       	movw	r30, r12
    1192:	13 8a       	std	Z+19, r1	; 0x13
    1194:	12 8a       	std	Z+18, r1	; 0x12
		TCPHeaderOUT->Checksum             = 0;
    1196:	11 8a       	std	Z+17, r1	; 0x11
		TCPHeaderOUT->Reserved             = 0;
    1198:	10 8a       	std	Z+16, r1	; 0x10
    119a:	84 85       	ldd	r24, Z+12	; 0x0c
    119c:	80 7f       	andi	r24, 0xF0	; 240

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    119e:	84 87       	std	Z+12, r24	; 0x0c
    11a0:	d7 01       	movw	r26, r14
    11a2:	1c 96       	adiw	r26, 0x0c	; 12
    11a4:	0d 91       	ld	r16, X+
    11a6:	1d 91       	ld	r17, X+
    11a8:	2d 91       	ld	r18, X+
    11aa:	3c 91       	ld	r19, X
    11ac:	1f 97       	sbiw	r26, 0x0f	; 15
    11ae:	50 96       	adiw	r26, 0x10	; 16
    11b0:	4d 91       	ld	r20, X+
    11b2:	5d 91       	ld	r21, X+
    11b4:	6d 91       	ld	r22, X+
    11b6:	7c 91       	ld	r23, X
    11b8:	53 97       	sbiw	r26, 0x13	; 19
    11ba:	84 e1       	ldi	r24, 0x14	; 20
    11bc:	e8 2e       	mov	r14, r24
    11be:	f1 2c       	mov	r15, r1
    11c0:	c6 01       	movw	r24, r12
    11c2:	1b db       	rcall	.-2506   	; 0x7fa <TCP_Checksum16>
    11c4:	f6 01       	movw	r30, r12
    11c6:	91 8b       	std	Z+17, r25	; 0x11
    11c8:	80 8b       	std	Z+16, r24	; 0x10
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    11ca:	84 e1       	ldi	r24, 0x14	; 20
    11cc:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
}
    11ce:	df 91       	pop	r29
    11d0:	cf 91       	pop	r28
    11d2:	1f 91       	pop	r17
    11d4:	0f 91       	pop	r16
    11d6:	ff 90       	pop	r15
    11d8:	ef 90       	pop	r14
    11da:	df 90       	pop	r13
    11dc:	cf 90       	pop	r12
    11de:	bf 90       	pop	r11
    11e0:	af 90       	pop	r10
    11e2:	9f 90       	pop	r9
    11e4:	8f 90       	pop	r8
    11e6:	7f 90       	pop	r7
    11e8:	6f 90       	pop	r6
    11ea:	5f 90       	pop	r5
    11ec:	4f 90       	pop	r4
    11ee:	08 95       	ret

000011f0 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    11f0:	ef 92       	push	r14
    11f2:	ff 92       	push	r15
    11f4:	0f 93       	push	r16
    11f6:	1f 93       	push	r17
    11f8:	cf 93       	push	r28
    11fa:	df 93       	push	r29
    11fc:	7c 01       	movw	r14, r24
    11fe:	8b 01       	movw	r16, r22
    1200:	ea 01       	movw	r28, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    1202:	cb 01       	movw	r24, r22
    1204:	aa da       	rcall	.-2732   	; 0x75a <DecodeUDPHeader>

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    1206:	f8 01       	movw	r30, r16
    1208:	83 81       	ldd	r24, Z+3	; 0x03
    120a:	92 81       	ldd	r25, Z+2	; 0x02

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    120c:	83 34       	cpi	r24, 0x43	; 67
    120e:	91 05       	cpc	r25, r1
    1210:	e9 f4       	brne	.+58     	; 0x124c <UDP_ProcessUDPPacket+0x5c>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1212:	ae 01       	movw	r20, r28
    1214:	48 5f       	subi	r20, 0xF8	; 248
    1216:	5f 4f       	sbci	r21, 0xFF	; 255
    1218:	b8 01       	movw	r22, r16
    121a:	68 5f       	subi	r22, 0xF8	; 248
    121c:	7f 4f       	sbci	r23, 0xFF	; 255
    121e:	c7 01       	movw	r24, r14
    1220:	1e d0       	rcall	.+60     	; 0x125e <DHCP_ProcessDHCPPacket>
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1222:	18 16       	cp	r1, r24
    1224:	19 06       	cpc	r1, r25
    1226:	94 f4       	brge	.+36     	; 0x124c <UDP_ProcessUDPPacket+0x5c>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    1228:	f8 01       	movw	r30, r16
    122a:	22 81       	ldd	r18, Z+2	; 0x02
    122c:	33 81       	ldd	r19, Z+3	; 0x03
    122e:	39 83       	std	Y+1, r19	; 0x01
    1230:	28 83       	st	Y, r18
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1232:	20 81       	ld	r18, Z
    1234:	31 81       	ldd	r19, Z+1	; 0x01
    1236:	3b 83       	std	Y+3, r19	; 0x03
    1238:	2a 83       	std	Y+2, r18	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    123a:	1f 82       	std	Y+7, r1	; 0x07
    123c:	1e 82       	std	Y+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    123e:	9c 01       	movw	r18, r24
    1240:	28 5f       	subi	r18, 0xF8	; 248
    1242:	3f 4f       	sbci	r19, 0xFF	; 255
    1244:	3c 83       	std	Y+4, r19	; 0x04
    1246:	2d 83       	std	Y+5, r18	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1248:	c9 01       	movw	r24, r18
    124a:	02 c0       	rjmp	.+4      	; 0x1250 <UDP_ProcessUDPPacket+0x60>
	}

	return NO_RESPONSE;
    124c:	80 e0       	ldi	r24, 0x00	; 0
    124e:	90 e0       	ldi	r25, 0x00	; 0
}
    1250:	df 91       	pop	r29
    1252:	cf 91       	pop	r28
    1254:	1f 91       	pop	r17
    1256:	0f 91       	pop	r16
    1258:	ff 90       	pop	r15
    125a:	ef 90       	pop	r14
    125c:	08 95       	ret

0000125e <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    125e:	8f 92       	push	r8
    1260:	9f 92       	push	r9
    1262:	af 92       	push	r10
    1264:	bf 92       	push	r11
    1266:	cf 92       	push	r12
    1268:	df 92       	push	r13
    126a:	ef 92       	push	r14
    126c:	ff 92       	push	r15
    126e:	0f 93       	push	r16
    1270:	1f 93       	push	r17
    1272:	cf 93       	push	r28
    1274:	df 93       	push	r29
    1276:	6c 01       	movw	r12, r24
    1278:	8b 01       	movw	r16, r22
    127a:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    127c:	7b 01       	movw	r14, r22
    127e:	80 ef       	ldi	r24, 0xF0	; 240
    1280:	e8 0e       	add	r14, r24
    1282:	f1 1c       	adc	r15, r1
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1284:	cb 01       	movw	r24, r22
    1286:	6a da       	rcall	.-2860   	; 0x75c <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    1288:	80 ef       	ldi	r24, 0xF0	; 240
    128a:	fe 01       	movw	r30, r28
    128c:	11 92       	st	Z+, r1
    128e:	8a 95       	dec	r24
    1290:	e9 f7       	brne	.-6      	; 0x128c <DHCP_ProcessDHCPPacket+0x2e>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1292:	f8 01       	movw	r30, r16
    1294:	81 81       	ldd	r24, Z+1	; 0x01
    1296:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    1298:	82 e0       	ldi	r24, 0x02	; 2
    129a:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    129c:	82 81       	ldd	r24, Z+2	; 0x02
    129e:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    12a0:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    12a2:	84 81       	ldd	r24, Z+4	; 0x04
    12a4:	95 81       	ldd	r25, Z+5	; 0x05
    12a6:	a6 81       	ldd	r26, Z+6	; 0x06
    12a8:	b7 81       	ldd	r27, Z+7	; 0x07
    12aa:	8c 83       	std	Y+4, r24	; 0x04
    12ac:	9d 83       	std	Y+5, r25	; 0x05
    12ae:	ae 83       	std	Y+6, r26	; 0x06
    12b0:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    12b2:	19 86       	std	Y+9, r1	; 0x09
    12b4:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    12b6:	82 85       	ldd	r24, Z+10	; 0x0a
    12b8:	93 85       	ldd	r25, Z+11	; 0x0b
    12ba:	9b 87       	std	Y+11, r25	; 0x0b
    12bc:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    12be:	80 90 9b 01 	lds	r8, 0x019B	; 0x80019b <ClientIPAddress>
    12c2:	90 90 9c 01 	lds	r9, 0x019C	; 0x80019c <ClientIPAddress+0x1>
    12c6:	a0 90 9d 01 	lds	r10, 0x019D	; 0x80019d <ClientIPAddress+0x2>
    12ca:	b0 90 9e 01 	lds	r11, 0x019E	; 0x80019e <ClientIPAddress+0x3>
    12ce:	88 8a       	std	Y+16, r8	; 0x10
    12d0:	99 8a       	std	Y+17, r9	; 0x11
    12d2:	aa 8a       	std	Y+18, r10	; 0x12
    12d4:	bb 8a       	std	Y+19, r11	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    12d6:	b8 01       	movw	r22, r16
    12d8:	64 5e       	subi	r22, 0xE4	; 228
    12da:	7f 4f       	sbci	r23, 0xFF	; 255
    12dc:	46 e0       	ldi	r20, 0x06	; 6
    12de:	50 e0       	ldi	r21, 0x00	; 0
    12e0:	ce 01       	movw	r24, r28
    12e2:	4c 96       	adiw	r24, 0x1c	; 28
    12e4:	0e 94 93 14 	call	0x2926	; 0x2926 <memmove>
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    12e8:	fe 01       	movw	r30, r28
    12ea:	e4 51       	subi	r30, 0x14	; 20
    12ec:	ff 4f       	sbci	r31, 0xFF	; 255
    12ee:	83 e6       	ldi	r24, 0x63	; 99
    12f0:	92 e8       	ldi	r25, 0x82	; 130
    12f2:	a3 e5       	ldi	r26, 0x53	; 83
    12f4:	b3 e6       	ldi	r27, 0x63	; 99
    12f6:	80 83       	st	Z, r24
    12f8:	91 83       	std	Z+1, r25	; 0x01
    12fa:	a2 83       	std	Z+2, r26	; 0x02
    12fc:	b3 83       	std	Z+3, r27	; 0x03

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    12fe:	f6 01       	movw	r30, r12
    1300:	84 86       	std	Z+12, r8	; 0x0c
    1302:	95 86       	std	Z+13, r9	; 0x0d
    1304:	a6 86       	std	Z+14, r10	; 0x0e
    1306:	b7 86       	std	Z+15, r11	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1308:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <ServerIPAddress>
    130c:	90 91 aa 01 	lds	r25, 0x01AA	; 0x8001aa <ServerIPAddress+0x1>
    1310:	a0 91 ab 01 	lds	r26, 0x01AB	; 0x8001ab <ServerIPAddress+0x2>
    1314:	b0 91 ac 01 	lds	r27, 0x01AC	; 0x8001ac <ServerIPAddress+0x3>
    1318:	80 8b       	std	Z+16, r24	; 0x10
    131a:	91 8b       	std	Z+17, r25	; 0x11
    131c:	a2 8b       	std	Z+18, r26	; 0x12
    131e:	b3 8b       	std	Z+19, r27	; 0x13

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1320:	f7 01       	movw	r30, r14
    1322:	80 81       	ld	r24, Z
    1324:	8f 3f       	cpi	r24, 0xFF	; 255
    1326:	09 f4       	brne	.+2      	; 0x132a <DHCP_ProcessDHCPPacket+0xcc>
    1328:	4b c0       	rjmp	.+150    	; 0x13c0 <DHCP_ProcessDHCPPacket+0x162>
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    132a:	85 33       	cpi	r24, 0x35	; 53
    132c:	e9 f5       	brne	.+122    	; 0x13a8 <DHCP_ProcessDHCPPacket+0x14a>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    132e:	f7 01       	movw	r30, r14
    1330:	92 81       	ldd	r25, Z+2	; 0x02
    1332:	9d 7f       	andi	r25, 0xFD	; 253
    1334:	91 30       	cpi	r25, 0x01	; 1
    1336:	d1 f5       	brne	.+116    	; 0x13ac <DHCP_ProcessDHCPPacket+0x14e>
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1338:	fe 01       	movw	r30, r28
    133a:	e0 51       	subi	r30, 0x10	; 16
    133c:	ff 4f       	sbci	r31, 0xFF	; 255
    133e:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 1;
    1340:	31 96       	adiw	r30, 0x01	; 1
    1342:	90 83       	st	Z, r25
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    1344:	f7 01       	movw	r30, r14
    1346:	82 81       	ldd	r24, Z+2	; 0x02
    1348:	81 30       	cpi	r24, 0x01	; 1
    134a:	11 f0       	breq	.+4      	; 0x1350 <DHCP_ProcessDHCPPacket+0xf2>
    134c:	85 e0       	ldi	r24, 0x05	; 5
    134e:	01 c0       	rjmp	.+2      	; 0x1352 <DHCP_ProcessDHCPPacket+0xf4>
    1350:	82 e0       	ldi	r24, 0x02	; 2
    1352:	fe 01       	movw	r30, r28
    1354:	ee 50       	subi	r30, 0x0E	; 14
    1356:	ff 4f       	sbci	r31, 0xFF	; 255
    1358:	80 83       	st	Z, r24
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    135a:	31 96       	adiw	r30, 0x01	; 1
    135c:	81 e0       	ldi	r24, 0x01	; 1
    135e:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 4;
    1360:	31 96       	adiw	r30, 0x01	; 1
    1362:	94 e0       	ldi	r25, 0x04	; 4
    1364:	90 83       	st	Z, r25
				*(DHCPOptionsOUTStart++) = 0xFF;
    1366:	31 96       	adiw	r30, 0x01	; 1
    1368:	8f ef       	ldi	r24, 0xFF	; 255
    136a:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0xFF;
    136c:	31 96       	adiw	r30, 0x01	; 1
    136e:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0xFF;
    1370:	31 96       	adiw	r30, 0x01	; 1
    1372:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0x00;
    1374:	31 96       	adiw	r30, 0x01	; 1
    1376:	10 82       	st	Z, r1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1378:	31 96       	adiw	r30, 0x01	; 1
    137a:	26 e3       	ldi	r18, 0x36	; 54
    137c:	20 83       	st	Z, r18
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    137e:	31 96       	adiw	r30, 0x01	; 1
    1380:	90 83       	st	Z, r25
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    1382:	31 96       	adiw	r30, 0x01	; 1
    1384:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <ServerIPAddress>
    1388:	50 91 aa 01 	lds	r21, 0x01AA	; 0x8001aa <ServerIPAddress+0x1>
    138c:	60 91 ab 01 	lds	r22, 0x01AB	; 0x8001ab <ServerIPAddress+0x2>
    1390:	70 91 ac 01 	lds	r23, 0x01AC	; 0x8001ac <ServerIPAddress+0x3>
    1394:	40 83       	st	Z, r20
    1396:	51 83       	std	Z+1, r21	; 0x01
    1398:	62 83       	std	Z+2, r22	; 0x02
    139a:	73 83       	std	Z+3, r23	; 0x03
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    139c:	c1 50       	subi	r28, 0x01	; 1
    139e:	df 4f       	sbci	r29, 0xFF	; 255
    13a0:	88 83       	st	Y, r24

				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
    13a2:	80 e0       	ldi	r24, 0x00	; 0
    13a4:	91 e0       	ldi	r25, 0x01	; 1
    13a6:	0e c0       	rjmp	.+28     	; 0x13c4 <DHCP_ProcessDHCPPacket+0x166>
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    13a8:	88 23       	and	r24, r24
    13aa:	29 f0       	breq	.+10     	; 0x13b6 <DHCP_ProcessDHCPPacket+0x158>
    13ac:	f7 01       	movw	r30, r14
    13ae:	81 81       	ldd	r24, Z+1	; 0x01
    13b0:	90 e0       	ldi	r25, 0x00	; 0
    13b2:	02 96       	adiw	r24, 0x02	; 2
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <DHCP_ProcessDHCPPacket+0x15c>
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	e8 0e       	add	r14, r24
    13bc:	f9 1e       	adc	r15, r25
    13be:	b0 cf       	rjmp	.-160    	; 0x1320 <DHCP_ProcessDHCPPacket+0xc2>
	}

	return NO_RESPONSE;
    13c0:	80 e0       	ldi	r24, 0x00	; 0
    13c2:	90 e0       	ldi	r25, 0x00	; 0
}
    13c4:	df 91       	pop	r29
    13c6:	cf 91       	pop	r28
    13c8:	1f 91       	pop	r17
    13ca:	0f 91       	pop	r16
    13cc:	ff 90       	pop	r15
    13ce:	ef 90       	pop	r14
    13d0:	df 90       	pop	r13
    13d2:	cf 90       	pop	r12
    13d4:	bf 90       	pop	r11
    13d6:	af 90       	pop	r10
    13d8:	9f 90       	pop	r9
    13da:	8f 90       	pop	r8
    13dc:	08 95       	ret

000013de <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    13de:	0f 93       	push	r16
    13e0:	1f 93       	push	r17
    13e2:	cf 93       	push	r28
    13e4:	df 93       	push	r29
    13e6:	ec 01       	movw	r28, r24
    13e8:	8b 01       	movw	r16, r22
	DecodeARPHeader(InDataStart);
    13ea:	b3 d9       	rcall	.-3226   	; 0x752 <DecodeARPHeader>
    13ec:	8b 81       	ldd	r24, Y+3	; 0x03
    13ee:	9a 81       	ldd	r25, Y+2	; 0x02

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    13f0:	81 15       	cp	r24, r1
    13f2:	98 40       	sbci	r25, 0x08	; 8
    13f4:	19 f0       	breq	.+6      	; 0x13fc <ARP_ProcessARPPacket+0x1e>
			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
		}
	}

	return NO_RESPONSE;
    13f6:	80 e0       	ldi	r24, 0x00	; 0
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	53 c0       	rjmp	.+166    	; 0x14a2 <ARP_ProcessARPPacket+0xc4>
    13fc:	8f 81       	ldd	r24, Y+7	; 0x07
    13fe:	9e 81       	ldd	r25, Y+6	; 0x06

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1400:	01 97       	sbiw	r24, 0x01	; 1
    1402:	c9 f7       	brne	.-14     	; 0x13f6 <ARP_ProcessARPPacket+0x18>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1404:	44 e0       	ldi	r20, 0x04	; 4
    1406:	50 e0       	ldi	r21, 0x00	; 0
    1408:	69 ea       	ldi	r22, 0xA9	; 169
    140a:	71 e0       	ldi	r23, 0x01	; 1
    140c:	ce 01       	movw	r24, r28
    140e:	48 96       	adiw	r24, 0x18	; 24
    1410:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
    1414:	89 2b       	or	r24, r25
    1416:	51 f0       	breq	.+20     	; 0x142c <ARP_ProcessARPPacket+0x4e>
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
    1418:	46 e0       	ldi	r20, 0x06	; 6
    141a:	50 e0       	ldi	r21, 0x00	; 0
    141c:	6d ea       	ldi	r22, 0xAD	; 173
    141e:	71 e0       	ldi	r23, 0x01	; 1
    1420:	ce 01       	movw	r24, r28
    1422:	42 96       	adiw	r24, 0x12	; 18
    1424:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1428:	89 2b       	or	r24, r25
    142a:	29 f7       	brne	.-54     	; 0x13f6 <ARP_ProcessARPPacket+0x18>
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    142c:	88 81       	ld	r24, Y
    142e:	99 81       	ldd	r25, Y+1	; 0x01
    1430:	f8 01       	movw	r30, r16
    1432:	91 83       	std	Z+1, r25	; 0x01
    1434:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1436:	8a 81       	ldd	r24, Y+2	; 0x02
    1438:	9b 81       	ldd	r25, Y+3	; 0x03
    143a:	93 83       	std	Z+3, r25	; 0x03
    143c:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    143e:	8c 81       	ldd	r24, Y+4	; 0x04
    1440:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    1442:	8d 81       	ldd	r24, Y+5	; 0x05
    1444:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1446:	80 e0       	ldi	r24, 0x00	; 0
    1448:	92 e0       	ldi	r25, 0x02	; 2
    144a:	97 83       	std	Z+7, r25	; 0x07
    144c:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    144e:	86 e0       	ldi	r24, 0x06	; 6
    1450:	fe 01       	movw	r30, r28
    1452:	38 96       	adiw	r30, 0x08	; 8
    1454:	d8 01       	movw	r26, r16
    1456:	52 96       	adiw	r26, 0x12	; 18
    1458:	01 90       	ld	r0, Z+
    145a:	0d 92       	st	X+, r0
    145c:	8a 95       	dec	r24
    145e:	e1 f7       	brne	.-8      	; 0x1458 <ARP_ProcessARPPacket+0x7a>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    1460:	8e 85       	ldd	r24, Y+14	; 0x0e
    1462:	9f 85       	ldd	r25, Y+15	; 0x0f
    1464:	a8 89       	ldd	r26, Y+16	; 0x10
    1466:	b9 89       	ldd	r27, Y+17	; 0x11
    1468:	f8 01       	movw	r30, r16
    146a:	80 8f       	std	Z+24, r24	; 0x18
    146c:	91 8f       	std	Z+25, r25	; 0x19
    146e:	a2 8f       	std	Z+26, r26	; 0x1a
    1470:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    1472:	86 e0       	ldi	r24, 0x06	; 6
    1474:	ed ea       	ldi	r30, 0xAD	; 173
    1476:	f1 e0       	ldi	r31, 0x01	; 1
    1478:	d8 01       	movw	r26, r16
    147a:	18 96       	adiw	r26, 0x08	; 8
    147c:	01 90       	ld	r0, Z+
    147e:	0d 92       	st	X+, r0
    1480:	8a 95       	dec	r24
    1482:	e1 f7       	brne	.-8      	; 0x147c <ARP_ProcessARPPacket+0x9e>
			ARPHeaderOUT->SPA = ServerIPAddress;
    1484:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <ServerIPAddress>
    1488:	90 91 aa 01 	lds	r25, 0x01AA	; 0x8001aa <ServerIPAddress+0x1>
    148c:	a0 91 ab 01 	lds	r26, 0x01AB	; 0x8001ab <ServerIPAddress+0x2>
    1490:	b0 91 ac 01 	lds	r27, 0x01AC	; 0x8001ac <ServerIPAddress+0x3>
    1494:	f8 01       	movw	r30, r16
    1496:	86 87       	std	Z+14, r24	; 0x0e
    1498:	97 87       	std	Z+15, r25	; 0x0f
    149a:	a0 8b       	std	Z+16, r26	; 0x10
    149c:	b1 8b       	std	Z+17, r27	; 0x11

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    149e:	8c e1       	ldi	r24, 0x1C	; 28
    14a0:	90 e0       	ldi	r25, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    14a2:	df 91       	pop	r29
    14a4:	cf 91       	pop	r28
    14a6:	1f 91       	pop	r17
    14a8:	0f 91       	pop	r16
    14aa:	08 95       	ret

000014ac <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    14ac:	af 92       	push	r10
    14ae:	bf 92       	push	r11
    14b0:	cf 92       	push	r12
    14b2:	df 92       	push	r13
    14b4:	ef 92       	push	r14
    14b6:	ff 92       	push	r15
    14b8:	0f 93       	push	r16
    14ba:	1f 93       	push	r17
    14bc:	cf 93       	push	r28
    14be:	df 93       	push	r29
    14c0:	6c 01       	movw	r12, r24
    14c2:	7b 01       	movw	r14, r22
    14c4:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
    14c6:	cb 01       	movw	r24, r22
    14c8:	45 d9       	rcall	.-3446   	; 0x754 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    14ca:	f7 01       	movw	r30, r14
    14cc:	00 81       	ld	r16, Z
    14ce:	0f 70       	andi	r16, 0x0F	; 15
    14d0:	f4 e0       	ldi	r31, 0x04	; 4
    14d2:	0f 9f       	mul	r16, r31
    14d4:	80 01       	movw	r16, r0
    14d6:	11 24       	eor	r1, r1

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    14d8:	57 01       	movw	r10, r14
    14da:	80 e1       	ldi	r24, 0x10	; 16
    14dc:	a8 0e       	add	r10, r24
    14de:	b1 1c       	adc	r11, r1
    14e0:	44 e0       	ldi	r20, 0x04	; 4
    14e2:	50 e0       	ldi	r21, 0x00	; 0
    14e4:	69 ea       	ldi	r22, 0xA9	; 169
    14e6:	71 e0       	ldi	r23, 0x01	; 1
    14e8:	c5 01       	movw	r24, r10
    14ea:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
    14ee:	89 2b       	or	r24, r25
    14f0:	51 f0       	breq	.+20     	; 0x1506 <IP_ProcessIPPacket+0x5a>
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
    14f2:	44 e0       	ldi	r20, 0x04	; 4
    14f4:	50 e0       	ldi	r21, 0x00	; 0
    14f6:	6f e9       	ldi	r22, 0x9F	; 159
    14f8:	71 e0       	ldi	r23, 0x01	; 1
    14fa:	c5 01       	movw	r24, r10
    14fc:	0e 94 7d 14 	call	0x28fa	; 0x28fa <memcmp>
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1500:	89 2b       	or	r24, r25
    1502:	09 f0       	breq	.+2      	; 0x1506 <IP_ProcessIPPacket+0x5a>
    1504:	51 c0       	rjmp	.+162    	; 0x15a8 <IP_ProcessIPPacket+0xfc>
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1506:	f7 01       	movw	r30, r14
    1508:	81 85       	ldd	r24, Z+9	; 0x09
    150a:	86 30       	cpi	r24, 0x06	; 6
    150c:	71 f0       	breq	.+28     	; 0x152a <IP_ProcessIPPacket+0x7e>
    150e:	81 31       	cpi	r24, 0x11	; 17
    1510:	a9 f0       	breq	.+42     	; 0x153c <IP_ProcessIPPacket+0x90>
    1512:	81 30       	cpi	r24, 0x01	; 1
    1514:	09 f0       	breq	.+2      	; 0x1518 <IP_ProcessIPPacket+0x6c>
    1516:	48 c0       	rjmp	.+144    	; 0x15a8 <IP_ProcessIPPacket+0xfc>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    1518:	b7 01       	movw	r22, r14
    151a:	60 0f       	add	r22, r16
    151c:	71 1f       	adc	r23, r17
    151e:	ae 01       	movw	r20, r28
    1520:	4c 5e       	subi	r20, 0xEC	; 236
    1522:	5f 4f       	sbci	r21, 0xFF	; 255
    1524:	c6 01       	movw	r24, r12
    1526:	1b d9       	rcall	.-3530   	; 0x75e <ICMP_ProcessICMPPacket>
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    1528:	11 c0       	rjmp	.+34     	; 0x154c <IP_ProcessIPPacket+0xa0>
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    152a:	b7 01       	movw	r22, r14
    152c:	60 0f       	add	r22, r16
    152e:	71 1f       	adc	r23, r17
    1530:	ae 01       	movw	r20, r28
    1532:	4c 5e       	subi	r20, 0xEC	; 236
    1534:	5f 4f       	sbci	r21, 0xFF	; 255
    1536:	c7 01       	movw	r24, r14
    1538:	34 dc       	rcall	.-1944   	; 0xda2 <TCP_ProcessTCPPacket>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    153a:	08 c0       	rjmp	.+16     	; 0x154c <IP_ProcessIPPacket+0xa0>
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    153c:	b7 01       	movw	r22, r14
    153e:	60 0f       	add	r22, r16
    1540:	71 1f       	adc	r23, r17
    1542:	ae 01       	movw	r20, r28
    1544:	4c 5e       	subi	r20, 0xEC	; 236
    1546:	5f 4f       	sbci	r21, 0xFF	; 255
    1548:	c7 01       	movw	r24, r14
    154a:	52 de       	rcall	.-860    	; 0x11f0 <UDP_ProcessUDPPacket>
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    154c:	18 16       	cp	r1, r24
    154e:	19 06       	cpc	r1, r25
    1550:	6c f5       	brge	.+90     	; 0x15ac <IP_ProcessIPPacket+0x100>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1552:	8c 01       	movw	r16, r24
    1554:	0c 5e       	subi	r16, 0xEC	; 236
    1556:	1f 4f       	sbci	r17, 0xFF	; 255
    1558:	1a 83       	std	Y+2, r17	; 0x02
    155a:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    155c:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    155e:	85 e4       	ldi	r24, 0x45	; 69
    1560:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1562:	1e 82       	std	Y+6, r1	; 0x06
    1564:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    1566:	1d 82       	std	Y+5, r1	; 0x05
    1568:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    156a:	1b 86       	std	Y+11, r1	; 0x0b
    156c:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    156e:	f7 01       	movw	r30, r14
    1570:	81 85       	ldd	r24, Z+9	; 0x09
    1572:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1574:	80 e8       	ldi	r24, 0x80	; 128
    1576:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    1578:	80 89       	ldd	r24, Z+16	; 0x10
    157a:	91 89       	ldd	r25, Z+17	; 0x11
    157c:	a2 89       	ldd	r26, Z+18	; 0x12
    157e:	b3 89       	ldd	r27, Z+19	; 0x13
    1580:	8c 87       	std	Y+12, r24	; 0x0c
    1582:	9d 87       	std	Y+13, r25	; 0x0d
    1584:	ae 87       	std	Y+14, r26	; 0x0e
    1586:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1588:	84 85       	ldd	r24, Z+12	; 0x0c
    158a:	95 85       	ldd	r25, Z+13	; 0x0d
    158c:	a6 85       	ldd	r26, Z+14	; 0x0e
    158e:	b7 85       	ldd	r27, Z+15	; 0x0f
    1590:	88 8b       	std	Y+16, r24	; 0x10
    1592:	99 8b       	std	Y+17, r25	; 0x11
    1594:	aa 8b       	std	Y+18, r26	; 0x12

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1596:	bb 8b       	std	Y+19, r27	; 0x13
    1598:	64 e1       	ldi	r22, 0x14	; 20
    159a:	70 e0       	ldi	r23, 0x00	; 0
    159c:	ce 01       	movw	r24, r28
    159e:	a7 d8       	rcall	.-3762   	; 0x6ee <Ethernet_Checksum16>
    15a0:	9b 87       	std	Y+11, r25	; 0x0b
    15a2:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    15a4:	c8 01       	movw	r24, r16
    15a6:	02 c0       	rjmp	.+4      	; 0x15ac <IP_ProcessIPPacket+0x100>
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	90 e0       	ldi	r25, 0x00	; 0
		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
}
    15ac:	df 91       	pop	r29
    15ae:	cf 91       	pop	r28
    15b0:	1f 91       	pop	r17
    15b2:	0f 91       	pop	r16
    15b4:	ff 90       	pop	r15
    15b6:	ef 90       	pop	r14
    15b8:	df 90       	pop	r13
    15ba:	cf 90       	pop	r12
    15bc:	bf 90       	pop	r11
    15be:	af 90       	pop	r10
    15c0:	08 95       	ret

000015c2 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    15c2:	fb 01       	movw	r30, r22
    15c4:	01 90       	ld	r0, Z+
    15c6:	00 20       	and	r0, r0
    15c8:	e9 f7       	brne	.-6      	; 0x15c4 <IsHTTPCommand+0x2>
    15ca:	31 97       	sbiw	r30, 0x01	; 1
    15cc:	af 01       	movw	r20, r30
    15ce:	46 1b       	sub	r20, r22
    15d0:	57 0b       	sbc	r21, r23
    15d2:	0e 94 a4 14 	call	0x2948	; 0x2948 <strncmp>
    15d6:	21 e0       	ldi	r18, 0x01	; 1
    15d8:	89 2b       	or	r24, r25
    15da:	09 f0       	breq	.+2      	; 0x15de <IsHTTPCommand+0x1c>
    15dc:	20 e0       	ldi	r18, 0x00	; 0
}
    15de:	82 2f       	mov	r24, r18
    15e0:	08 95       	ret

000015e2 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    15e2:	4f 92       	push	r4
    15e4:	5f 92       	push	r5
    15e6:	6f 92       	push	r6
    15e8:	7f 92       	push	r7
    15ea:	8f 92       	push	r8
    15ec:	9f 92       	push	r9
    15ee:	af 92       	push	r10
    15f0:	bf 92       	push	r11
    15f2:	cf 92       	push	r12
    15f4:	df 92       	push	r13
    15f6:	ef 92       	push	r14
    15f8:	ff 92       	push	r15
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	7c 01       	movw	r14, r24
    1604:	8b 01       	movw	r16, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1606:	eb 01       	movw	r28, r22
    1608:	22 96       	adiw	r28, 0x02	; 2
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    160a:	6b 01       	movw	r12, r22
    160c:	2d ef       	ldi	r18, 0xFD	; 253
    160e:	c2 1a       	sub	r12, r18
    1610:	d2 0a       	sbc	r13, r18
    1612:	d6 01       	movw	r26, r12
    1614:	8c 91       	ld	r24, X
    1616:	88 23       	and	r24, r24
    1618:	09 f4       	brne	.+2      	; 0x161c <Webserver_ApplicationCallback+0x3a>
    161a:	60 c0       	rjmp	.+192    	; 0x16dc <Webserver_ApplicationCallback+0xfa>
    161c:	5b 01       	movw	r10, r22
    161e:	b2 e0       	ldi	r27, 0x02	; 2
    1620:	ab 0e       	add	r10, r27
    1622:	bb 1e       	adc	r11, r27
    1624:	f5 01       	movw	r30, r10
    1626:	80 81       	ld	r24, Z
    1628:	81 11       	cpse	r24, r1
    162a:	99 c0       	rjmp	.+306    	; 0x175e <Webserver_ApplicationCallback+0x17c>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    162c:	69 ed       	ldi	r22, 0xD9	; 217
    162e:	71 e0       	ldi	r23, 0x01	; 1
    1630:	ce 01       	movw	r24, r28
    1632:	c7 df       	rcall	.-114    	; 0x15c2 <IsHTTPCommand>
    1634:	88 23       	and	r24, r24
    1636:	f1 f0       	breq	.+60     	; 0x1674 <Webserver_ApplicationCallback+0x92>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1638:	6d ed       	ldi	r22, 0xDD	; 221
    163a:	71 e0       	ldi	r23, 0x01	; 1
    163c:	ce 01       	movw	r24, r28
    163e:	c1 df       	rcall	.-126    	; 0x15c2 <IsHTTPCommand>
    1640:	88 23       	and	r24, r24
    1642:	39 f1       	breq	.+78     	; 0x1692 <Webserver_ApplicationCallback+0xb0>
			{
				PageBlock = 0;
    1644:	10 92 b4 0d 	sts	0x0DB4, r1	; 0x800db4 <PageBlock.4252>

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1648:	66 e8       	ldi	r22, 0x86	; 134
    164a:	73 e0       	ldi	r23, 0x03	; 3
    164c:	ce 01       	movw	r24, r28
    164e:	0e 94 5e 14 	call	0x28bc	; 0x28bc <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1652:	81 e0       	ldi	r24, 0x01	; 1
    1654:	d5 01       	movw	r26, r10
    1656:	8c 93       	st	X, r24
    1658:	fe 01       	movw	r30, r28
    165a:	01 90       	ld	r0, Z+
    165c:	00 20       	and	r0, r0
    165e:	e9 f7       	brne	.-6      	; 0x165a <Webserver_ApplicationCallback+0x78>
    1660:	31 97       	sbiw	r30, 0x01	; 1
    1662:	ec 1b       	sub	r30, r28
    1664:	fd 0b       	sbc	r31, r29
    1666:	d8 01       	movw	r26, r16
    1668:	ed 93       	st	X+, r30
    166a:	fc 93       	st	X, r31
    166c:	f6 01       	movw	r30, r12
    166e:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1670:	31 96       	adiw	r30, 0x01	; 1
    1672:	74 c0       	rjmp	.+232    	; 0x175c <Webserver_ApplicationCallback+0x17a>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1674:	64 ee       	ldi	r22, 0xE4	; 228
    1676:	71 e0       	ldi	r23, 0x01	; 1
    1678:	ce 01       	movw	r24, r28
    167a:	a3 df       	rcall	.-186    	; 0x15c2 <IsHTTPCommand>
    167c:	88 23       	and	r24, r24
    167e:	f1 f0       	breq	.+60     	; 0x16bc <Webserver_ApplicationCallback+0xda>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1680:	69 ee       	ldi	r22, 0xE9	; 233
    1682:	71 e0       	ldi	r23, 0x01	; 1
    1684:	ce 01       	movw	r24, r28
    1686:	9d df       	rcall	.-198    	; 0x15c2 <IsHTTPCommand>
    1688:	88 23       	and	r24, r24
    168a:	19 f0       	breq	.+6      	; 0x1692 <Webserver_ApplicationCallback+0xb0>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    168c:	66 e8       	ldi	r22, 0x86	; 134
    168e:	73 e0       	ldi	r23, 0x03	; 3
    1690:	02 c0       	rjmp	.+4      	; 0x1696 <Webserver_ApplicationCallback+0xb4>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1692:	64 e4       	ldi	r22, 0x44	; 68
    1694:	73 e0       	ldi	r23, 0x03	; 3
    1696:	ce 01       	movw	r24, r28
    1698:	0e 94 5e 14 	call	0x28bc	; 0x28bc <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    169c:	81 e0       	ldi	r24, 0x01	; 1
    169e:	d5 01       	movw	r26, r10
    16a0:	8c 93       	st	X, r24
    16a2:	fe 01       	movw	r30, r28
    16a4:	01 90       	ld	r0, Z+
    16a6:	00 20       	and	r0, r0
    16a8:	e9 f7       	brne	.-6      	; 0x16a4 <Webserver_ApplicationCallback+0xc2>
    16aa:	31 97       	sbiw	r30, 0x01	; 1
    16ac:	ec 1b       	sub	r30, r28
    16ae:	fd 0b       	sbc	r31, r29
    16b0:	d8 01       	movw	r26, r16
    16b2:	ed 93       	st	X+, r30
    16b4:	fc 93       	st	X, r31
    16b6:	f6 01       	movw	r30, r12
    16b8:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    16ba:	4c c0       	rjmp	.+152    	; 0x1754 <Webserver_ApplicationCallback+0x172>
    16bc:	61 ef       	ldi	r22, 0xF1	; 241
    16be:	71 e0       	ldi	r23, 0x01	; 1
    16c0:	ce 01       	movw	r24, r28
    16c2:	7f df       	rcall	.-258    	; 0x15c2 <IsHTTPCommand>
    16c4:	88 23       	and	r24, r24
    16c6:	21 f0       	breq	.+8      	; 0x16d0 <Webserver_ApplicationCallback+0xee>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	d5 01       	movw	r26, r10
    16cc:	8c 93       	st	X, r24
    16ce:	f3 cf       	rjmp	.-26     	; 0x16b6 <Webserver_ApplicationCallback+0xd4>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    16d0:	d6 01       	movw	r26, r12
    16d2:	1c 92       	st	X, r1
    16d4:	f8 01       	movw	r30, r16
    16d6:	11 82       	std	Z+1, r1	; 0x01
    16d8:	10 82       	st	Z, r1
    16da:	41 c0       	rjmp	.+130    	; 0x175e <Webserver_ApplicationCallback+0x17c>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    16dc:	2b 01       	movw	r4, r22
    16de:	fc ef       	ldi	r31, 0xFC	; 252
    16e0:	4f 1a       	sub	r4, r31
    16e2:	fd ef       	ldi	r31, 0xFD	; 253
    16e4:	5f 0a       	sbc	r5, r31
    16e6:	d2 01       	movw	r26, r4
    16e8:	8c 91       	ld	r24, X
    16ea:	88 23       	and	r24, r24
    16ec:	c1 f1       	breq	.+112    	; 0x175e <Webserver_ApplicationCallback+0x17c>
    16ee:	3b 01       	movw	r6, r22
    16f0:	b2 e0       	ldi	r27, 0x02	; 2
    16f2:	6b 0e       	add	r6, r27
    16f4:	7b 1e       	adc	r7, r27
    16f6:	f3 01       	movw	r30, r6
    16f8:	80 81       	ld	r24, Z
    16fa:	88 23       	and	r24, r24
    16fc:	81 f1       	breq	.+96     	; 0x175e <Webserver_ApplicationCallback+0x17c>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    16fe:	a0 90 b4 0d 	lds	r10, 0x0DB4	; 0x800db4 <PageBlock.4252>
    1702:	f0 e8       	ldi	r31, 0x80	; 128
    1704:	af 9e       	mul	r10, r31
    1706:	c0 01       	movw	r24, r0
    1708:	11 24       	eor	r1, r1
    170a:	9c 01       	movw	r18, r24
    170c:	2c 5a       	subi	r18, 0xAC	; 172
    170e:	3e 4f       	sbci	r19, 0xFE	; 254
    1710:	59 01       	movw	r10, r18
#else
extern size_t __strlen_P(const char *) __ATTR_CONST__;  /* internal helper function */
__attribute__((__always_inline__)) static __inline__ size_t strlen_P(const char * s);
static __inline__ size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    1712:	c9 01       	movw	r24, r18
    1714:	0e 94 65 14 	call	0x28ca	; 0x28ca <__strlen_P>
    1718:	4c 01       	movw	r8, r24
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    171a:	81 38       	cpi	r24, 0x81	; 129
    171c:	91 05       	cpc	r25, r1
    171e:	18 f0       	brcs	.+6      	; 0x1726 <Webserver_ApplicationCallback+0x144>
    1720:	80 e8       	ldi	r24, 0x80	; 128
    1722:	88 2e       	mov	r8, r24
    1724:	91 2c       	mov	r9, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1726:	a4 01       	movw	r20, r8
    1728:	b5 01       	movw	r22, r10
    172a:	ce 01       	movw	r24, r28
    172c:	0e 94 6e 14 	call	0x28dc	; 0x28dc <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	d3 01       	movw	r26, r6
    1734:	8c 93       	st	X, r24
    1736:	f8 01       	movw	r30, r16
    1738:	91 82       	std	Z+1, r9	; 0x01
    173a:	80 82       	st	Z, r8
    173c:	d6 01       	movw	r26, r12
    173e:	8c 93       	st	X, r24

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1740:	80 91 b4 0d 	lds	r24, 0x0DB4	; 0x800db4 <PageBlock.4252>
    1744:	91 e0       	ldi	r25, 0x01	; 1
    1746:	98 0f       	add	r25, r24
    1748:	90 93 b4 0d 	sts	0x0DB4, r25	; 0x800db4 <PageBlock.4252>
    174c:	83 30       	cpi	r24, 0x03	; 3
    174e:	39 f4       	brne	.+14     	; 0x175e <Webserver_ApplicationCallback+0x17c>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1750:	f2 01       	movw	r30, r4
    1752:	10 82       	st	Z, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1754:	f7 01       	movw	r30, r14
    1756:	eb 5e       	subi	r30, 0xEB	; 235
    1758:	fd 4f       	sbci	r31, 0xFD	; 253
    175a:	87 e0       	ldi	r24, 0x07	; 7
    175c:	80 83       	st	Z, r24
		}
	}
}
    175e:	df 91       	pop	r29
    1760:	cf 91       	pop	r28
    1762:	1f 91       	pop	r17
    1764:	0f 91       	pop	r16
    1766:	ff 90       	pop	r15
    1768:	ef 90       	pop	r14
    176a:	df 90       	pop	r13
    176c:	cf 90       	pop	r12
    176e:	bf 90       	pop	r11
    1770:	af 90       	pop	r10
    1772:	9f 90       	pop	r9
    1774:	8f 90       	pop	r8
    1776:	7f 90       	pop	r7
    1778:	6f 90       	pop	r6
    177a:	5f 90       	pop	r5
    177c:	4f 90       	pop	r4
    177e:	08 95       	ret

00001780 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1780:	41 ef       	ldi	r20, 0xF1	; 241
    1782:	5a e0       	ldi	r21, 0x0A	; 10
    1784:	61 e0       	ldi	r22, 0x01	; 1
    1786:	80 e0       	ldi	r24, 0x00	; 0
    1788:	90 e5       	ldi	r25, 0x50	; 80
    178a:	b3 c9       	rjmp	.-3226   	; 0xaf2 <TCP_SetPortState>

0000178c <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    178c:	98 2f       	mov	r25, r24
    178e:	97 30       	cpi	r25, 0x07	; 7
    1790:	68 f5       	brcc	.+90     	; 0x17ec <Endpoint_ConfigureEndpoint_Prv+0x60>
    1792:	90 93 e9 00 	sts	0x00E9, r25	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1796:	98 17       	cp	r25, r24
    1798:	39 f0       	breq	.+14     	; 0x17a8 <Endpoint_ConfigureEndpoint_Prv+0x1c>
    179a:	70 91 ec 00 	lds	r23, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    179e:	20 91 ed 00 	lds	r18, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    17a2:	50 91 f0 00 	lds	r21, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    17a6:	03 c0       	rjmp	.+6      	; 0x17ae <Endpoint_ConfigureEndpoint_Prv+0x22>
    17a8:	24 2f       	mov	r18, r20
    17aa:	76 2f       	mov	r23, r22
    17ac:	50 e0       	ldi	r21, 0x00	; 0
    17ae:	21 fd       	sbrc	r18, 1
    17b0:	02 c0       	rjmp	.+4      	; 0x17b6 <Endpoint_ConfigureEndpoint_Prv+0x2a>
    17b2:	9f 5f       	subi	r25, 0xFF	; 255
    17b4:	ec cf       	rjmp	.-40     	; 0x178e <Endpoint_ConfigureEndpoint_Prv+0x2>
    17b6:	30 91 eb 00 	lds	r19, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    17ba:	3e 7f       	andi	r19, 0xFE	; 254
    17bc:	30 93 eb 00 	sts	0x00EB, r19	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    17c0:	30 91 ed 00 	lds	r19, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    17c4:	3d 7f       	andi	r19, 0xFD	; 253
    17c6:	30 93 ed 00 	sts	0x00ED, r19	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    17ca:	30 91 eb 00 	lds	r19, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    17ce:	31 60       	ori	r19, 0x01	; 1
    17d0:	30 93 eb 00 	sts	0x00EB, r19	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    17d4:	70 93 ec 00 	sts	0x00EC, r23	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    17d8:	20 93 ed 00 	sts	0x00ED, r18	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    17dc:	50 93 f0 00 	sts	0x00F0, r21	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    17e0:	20 91 ee 00 	lds	r18, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
    17e4:	27 fd       	sbrc	r18, 7
    17e6:	e5 cf       	rjmp	.-54     	; 0x17b2 <Endpoint_ConfigureEndpoint_Prv+0x26>
    17e8:	80 e0       	ldi	r24, 0x00	; 0
    17ea:	08 95       	ret
    17ec:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	08 95       	ret

000017f4 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    17f4:	80 91 01 14 	lds	r24, 0x1401	; 0x801401 <USB_ControlRequest>
    17f8:	87 ff       	sbrs	r24, 7
    17fa:	11 c0       	rjmp	.+34     	; 0x181e <Endpoint_ClearStatusStage+0x2a>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    17fc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		while (!(Endpoint_IsOUTReceived()))
    1800:	82 fd       	sbrc	r24, 2
    1802:	05 c0       	rjmp	.+10     	; 0x180e <Endpoint_ClearStatusStage+0x1a>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1804:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>
    1808:	81 11       	cpse	r24, r1
    180a:	f8 cf       	rjmp	.-16     	; 0x17fc <Endpoint_ClearStatusStage+0x8>
    180c:	11 c0       	rjmp	.+34     	; 0x1830 <Endpoint_ClearStatusStage+0x3c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    180e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1812:	8b 77       	andi	r24, 0x7B	; 123
    1814:	0b c0       	rjmp	.+22     	; 0x182c <Endpoint_ClearStatusStage+0x38>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1816:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>
    181a:	88 23       	and	r24, r24
    181c:	49 f0       	breq	.+18     	; 0x1830 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    181e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1822:	80 ff       	sbrs	r24, 0
    1824:	f8 cf       	rjmp	.-16     	; 0x1816 <Endpoint_ClearStatusStage+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1826:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    182a:	8e 77       	andi	r24, 0x7E	; 126
    182c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1830:	08 95       	ret

00001832 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1832:	20 91 e4 00 	lds	r18, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    1836:	30 91 e5 00 	lds	r19, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
    183a:	95 e6       	ldi	r25, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    183c:	40 91 ec 00 	lds	r20, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    1840:	84 2f       	mov	r24, r20
    1842:	81 70       	andi	r24, 0x01	; 1
    1844:	40 ff       	sbrs	r20, 0
    1846:	23 c0       	rjmp	.+70     	; 0x188e <Endpoint_WaitUntilReady+0x5c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1848:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    184c:	80 fd       	sbrc	r24, 0
    184e:	1d c0       	rjmp	.+58     	; 0x188a <Endpoint_WaitUntilReady+0x58>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1850:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1854:	88 23       	and	r24, r24
    1856:	99 f0       	breq	.+38     	; 0x187e <Endpoint_WaitUntilReady+0x4c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1858:	85 30       	cpi	r24, 0x05	; 5
    185a:	99 f0       	breq	.+38     	; 0x1882 <Endpoint_WaitUntilReady+0x50>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    185c:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1860:	85 fd       	sbrc	r24, 5
    1862:	11 c0       	rjmp	.+34     	; 0x1886 <Endpoint_WaitUntilReady+0x54>
    1864:	40 91 e4 00 	lds	r20, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    1868:	50 91 e5 00 	lds	r21, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    186c:	24 17       	cp	r18, r20
    186e:	35 07       	cpc	r19, r21
    1870:	29 f3       	breq	.-54     	; 0x183c <Endpoint_WaitUntilReady+0xa>
    1872:	91 50       	subi	r25, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1874:	11 f0       	breq	.+4      	; 0x187a <Endpoint_WaitUntilReady+0x48>
    1876:	9a 01       	movw	r18, r20
    1878:	e1 cf       	rjmp	.-62     	; 0x183c <Endpoint_WaitUntilReady+0xa>
			  return ENDPOINT_READYWAIT_Timeout;
    187a:	84 e0       	ldi	r24, 0x04	; 4
    187c:	08 95       	ret
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    187e:	82 e0       	ldi	r24, 0x02	; 2
    1880:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1882:	83 e0       	ldi	r24, 0x03	; 3
    1884:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    188a:	80 e0       	ldi	r24, 0x00	; 0
    188c:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    188e:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1892:	42 ff       	sbrs	r20, 2
    1894:	dd cf       	rjmp	.-70     	; 0x1850 <Endpoint_WaitUntilReady+0x1e>

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1896:	08 95       	ret

00001898 <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    1898:	0f 93       	push	r16
    189a:	1f 93       	push	r17
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    18a0:	49 d0       	rcall	.+146    	; 0x1934 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    18a2:	50 d0       	rcall	.+160    	; 0x1944 <USB_INT_ClearAllInterrupts>
    18a4:	c8 ed       	ldi	r28, 0xD8	; 216
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    18a6:	d0 e0       	ldi	r29, 0x00	; 0
    18a8:	88 81       	ld	r24, Y
    18aa:	8f 77       	andi	r24, 0x7F	; 127
    18ac:	88 83       	st	Y, r24
    18ae:	88 81       	ld	r24, Y
				USBCON |=  (1 << USBE);
    18b0:	80 68       	ori	r24, 0x80	; 128
    18b2:	88 83       	st	Y, r24
    18b4:	88 81       	ld	r24, Y
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    18b6:	8f 7d       	andi	r24, 0xDF	; 223
    18b8:	88 83       	st	Y, r24
    18ba:	e7 ed       	ldi	r30, 0xD7	; 215

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    18bc:	f0 e0       	ldi	r31, 0x00	; 0
    18be:	80 81       	ld	r24, Z
    18c0:	80 68       	ori	r24, 0x80	; 128
    18c2:	80 83       	st	Z, r24
    18c4:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    18c6:	10 92 00 14 	sts	0x1400, r1	; 0x801400 <USB_DeviceState>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    18ca:	10 92 fc 13 	sts	0x13FC, r1	; 0x8013fc <USB_Device_ConfigurationNumber>
	USB_Device_ConfigurationNumber  = 0;
    18ce:	10 92 fe 13 	sts	0x13FE, r1	; 0x8013fe <USB_Device_RemoteWakeupEnabled>

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    18d2:	10 92 fd 13 	sts	0x13FD, r1	; 0x8013fd <USB_Device_CurrentlySelfPowered>
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    18d6:	00 ee       	ldi	r16, 0xE0	; 224
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    18d8:	10 e0       	ldi	r17, 0x00	; 0
    18da:	f8 01       	movw	r30, r16
    18dc:	80 81       	ld	r24, Z
    18de:	8b 7f       	andi	r24, 0xFB	; 251
    18e0:	80 83       	st	Z, r24
    18e2:	88 81       	ld	r24, Y
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    18e4:	81 60       	ori	r24, 0x01	; 1
    18e6:	88 83       	st	Y, r24
    18e8:	42 e0       	ldi	r20, 0x02	; 2
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    18ea:	60 e0       	ldi	r22, 0x00	; 0
    18ec:	80 e0       	ldi	r24, 0x00	; 0
    18ee:	4e df       	rcall	.-356    	; 0x178c <Endpoint_ConfigureEndpoint_Prv>
    18f0:	e1 ee       	ldi	r30, 0xE1	; 225
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    18f2:	f0 e0       	ldi	r31, 0x00	; 0
    18f4:	80 81       	ld	r24, Z
    18f6:	8e 7f       	andi	r24, 0xFE	; 254
    18f8:	80 83       	st	Z, r24
    18fa:	e2 ee       	ldi	r30, 0xE2	; 226
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    18fc:	f0 e0       	ldi	r31, 0x00	; 0
    18fe:	80 81       	ld	r24, Z
    1900:	81 60       	ori	r24, 0x01	; 1
    1902:	80 83       	st	Z, r24
    1904:	80 81       	ld	r24, Z
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1906:	88 60       	ori	r24, 0x08	; 8
    1908:	80 83       	st	Z, r24
    190a:	f8 01       	movw	r30, r16
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    190c:	80 81       	ld	r24, Z
    190e:	8e 7f       	andi	r24, 0xFE	; 254
    1910:	80 83       	st	Z, r24
    1912:	88 81       	ld	r24, Y

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    1914:	80 61       	ori	r24, 0x10	; 16
    1916:	88 83       	st	Y, r24
    1918:	df 91       	pop	r29
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    191a:	cf 91       	pop	r28
    191c:	1f 91       	pop	r17
    191e:	0f 91       	pop	r16
    1920:	08 95       	ret

00001922 <USB_Init>:
    1922:	e7 ed       	ldi	r30, 0xD7	; 215

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    1924:	f0 e0       	ldi	r31, 0x00	; 0
    1926:	80 81       	ld	r24, Z
    1928:	81 60       	ori	r24, 0x01	; 1
    192a:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	80 93 ff 13 	sts	0x13FF, r24	; 0x8013ff <USB_IsInitialized>

	USB_ResetInterface();
    1932:	b2 cf       	rjmp	.-156    	; 0x1898 <USB_ResetInterface>

00001934 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1934:	e8 ed       	ldi	r30, 0xD8	; 216
    1936:	f0 e0       	ldi	r31, 0x00	; 0
    1938:	80 81       	ld	r24, Z
    193a:	8c 7f       	andi	r24, 0xFC	; 252
    193c:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    193e:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    1942:	08 95       	ret

00001944 <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1944:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1948:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    194c:	08 95       	ret

0000194e <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    194e:	1f 92       	push	r1
    1950:	0f 92       	push	r0
    1952:	0f b6       	in	r0, 0x3f	; 63
    1954:	0f 92       	push	r0
    1956:	11 24       	eor	r1, r1
    1958:	0b b6       	in	r0, 0x3b	; 59
    195a:	0f 92       	push	r0
    195c:	2f 93       	push	r18
    195e:	3f 93       	push	r19
    1960:	4f 93       	push	r20
    1962:	5f 93       	push	r21
    1964:	6f 93       	push	r22
    1966:	7f 93       	push	r23
    1968:	8f 93       	push	r24
    196a:	9f 93       	push	r25
    196c:	af 93       	push	r26
    196e:	bf 93       	push	r27
    1970:	ef 93       	push	r30
    1972:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1974:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1978:	82 ff       	sbrs	r24, 2
    197a:	0a c0       	rjmp	.+20     	; 0x1990 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    197c:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    1980:	82 ff       	sbrs	r24, 2
    1982:	06 c0       	rjmp	.+12     	; 0x1990 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1984:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    1988:	8b 7f       	andi	r24, 0xFB	; 251
    198a:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    198e:	7f d3       	rcall	.+1790   	; 0x208e <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1990:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1994:	80 ff       	sbrs	r24, 0
    1996:	1f c0       	rjmp	.+62     	; 0x19d6 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1998:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    199c:	80 ff       	sbrs	r24, 0
    199e:	1b c0       	rjmp	.+54     	; 0x19d6 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    19a0:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
    19a4:	8e 7f       	andi	r24, 0xFE	; 254
    19a6:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    19aa:	80 91 d9 00 	lds	r24, 0x00D9	; 0x8000d9 <__TEXT_REGION_LENGTH__+0x7e00d9>
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    19ae:	80 ff       	sbrs	r24, 0
    19b0:	0d c0       	rjmp	.+26     	; 0x19cc <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    19b2:	8c e0       	ldi	r24, 0x0C	; 12
    19b4:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    19b6:	8e e0       	ldi	r24, 0x0E	; 14
    19b8:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    19ba:	09 b4       	in	r0, 0x29	; 41
    19bc:	00 fe       	sbrs	r0, 0
    19be:	fd cf       	rjmp	.-6      	; 0x19ba <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    19c0:	81 e0       	ldi	r24, 0x01	; 1
    19c2:	80 93 00 14 	sts	0x1400, r24	; 0x801400 <USB_DeviceState>
			EVENT_USB_Device_Connect();
    19c6:	0e 94 cc 02 	call	0x598	; 0x598 <EVENT_USB_Device_Connect>
    19ca:	05 c0       	rjmp	.+10     	; 0x19d6 <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    19cc:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    19ce:	10 92 00 14 	sts	0x1400, r1	; 0x801400 <USB_DeviceState>
			EVENT_USB_Device_Disconnect();
    19d2:	0e 94 ce 02 	call	0x59c	; 0x59c <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    19d6:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    19da:	80 ff       	sbrs	r24, 0
    19dc:	18 c0       	rjmp	.+48     	; 0x1a0e <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    19de:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    19e2:	80 ff       	sbrs	r24, 0
    19e4:	14 c0       	rjmp	.+40     	; 0x1a0e <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    19e6:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    19ea:	8e 7f       	andi	r24, 0xFE	; 254
    19ec:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    19f0:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    19f4:	80 61       	ori	r24, 0x10	; 16
    19f6:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    19fa:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    19fe:	80 62       	ori	r24, 0x20	; 32
    1a00:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1a04:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1a06:	85 e0       	ldi	r24, 0x05	; 5
    1a08:	80 93 00 14 	sts	0x1400, r24	; 0x801400 <USB_DeviceState>
		EVENT_USB_Device_Suspend();
    1a0c:	40 d3       	rcall	.+1664   	; 0x208e <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1a0e:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1a12:	84 ff       	sbrs	r24, 4
    1a14:	2d c0       	rjmp	.+90     	; 0x1a70 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1a16:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    1a1a:	84 ff       	sbrs	r24, 4
    1a1c:	29 c0       	rjmp	.+82     	; 0x1a70 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1a1e:	8c e0       	ldi	r24, 0x0C	; 12
    1a20:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1a22:	8e e0       	ldi	r24, 0x0E	; 14
    1a24:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1a26:	09 b4       	in	r0, 0x29	; 41
    1a28:	00 fe       	sbrs	r0, 0
    1a2a:	fd cf       	rjmp	.-6      	; 0x1a26 <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1a2c:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    1a30:	8f 7d       	andi	r24, 0xDF	; 223
    1a32:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1a36:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    1a3a:	8f 7e       	andi	r24, 0xEF	; 239
    1a3c:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1a40:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    1a44:	8f 7e       	andi	r24, 0xEF	; 239
    1a46:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1a4a:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    1a4e:	81 60       	ori	r24, 0x01	; 1
    1a50:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    1a54:	80 91 fc 13 	lds	r24, 0x13FC	; 0x8013fc <USB_Device_ConfigurationNumber>
    1a58:	81 11       	cpse	r24, r1
    1a5a:	06 c0       	rjmp	.+12     	; 0x1a68 <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1a5c:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1a60:	87 fd       	sbrc	r24, 7
    1a62:	02 c0       	rjmp	.+4      	; 0x1a68 <__vector_10+0x11a>
    1a64:	81 e0       	ldi	r24, 0x01	; 1
    1a66:	01 c0       	rjmp	.+2      	; 0x1a6a <__vector_10+0x11c>
    1a68:	84 e0       	ldi	r24, 0x04	; 4
    1a6a:	80 93 00 14 	sts	0x1400, r24	; 0x801400 <USB_DeviceState>

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1a6e:	0f d3       	rcall	.+1566   	; 0x208e <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1a70:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1a74:	83 ff       	sbrs	r24, 3
    1a76:	22 c0       	rjmp	.+68     	; 0x1abc <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1a78:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    1a7c:	83 ff       	sbrs	r24, 3
    1a7e:	1e c0       	rjmp	.+60     	; 0x1abc <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1a80:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    1a84:	87 7f       	andi	r24, 0xF7	; 247
    1a86:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    1a8a:	82 e0       	ldi	r24, 0x02	; 2
    1a8c:	80 93 00 14 	sts	0x1400, r24	; 0x801400 <USB_DeviceState>
		USB_Device_ConfigurationNumber = 0;
    1a90:	10 92 fc 13 	sts	0x13FC, r1	; 0x8013fc <USB_Device_ConfigurationNumber>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1a94:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    1a98:	8e 7f       	andi	r24, 0xFE	; 254
    1a9a:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1a9e:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    1aa2:	8e 7f       	andi	r24, 0xFE	; 254
    1aa4:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1aa8:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    1aac:	80 61       	ori	r24, 0x10	; 16
    1aae:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    1ab2:	42 e0       	ldi	r20, 0x02	; 2
    1ab4:	60 e0       	ldi	r22, 0x00	; 0
    1ab6:	80 e0       	ldi	r24, 0x00	; 0

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1ab8:	69 de       	rcall	.-814    	; 0x178c <Endpoint_ConfigureEndpoint_Prv>
    1aba:	e9 d2       	rcall	.+1490   	; 0x208e <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1abc:	ff 91       	pop	r31
    1abe:	ef 91       	pop	r30
    1ac0:	bf 91       	pop	r27
    1ac2:	af 91       	pop	r26
    1ac4:	9f 91       	pop	r25
    1ac6:	8f 91       	pop	r24
    1ac8:	7f 91       	pop	r23
    1aca:	6f 91       	pop	r22
    1acc:	5f 91       	pop	r21
    1ace:	4f 91       	pop	r20
    1ad0:	3f 91       	pop	r19
    1ad2:	2f 91       	pop	r18
    1ad4:	0f 90       	pop	r0
    1ad6:	0b be       	out	0x3b, r0	; 59
    1ad8:	0f 90       	pop	r0
    1ada:	0f be       	out	0x3f, r0	; 63
    1adc:	0f 90       	pop	r0
    1ade:	1f 90       	pop	r1
    1ae0:	18 95       	reti

00001ae2 <Endpoint_Write_Stream_LE>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1ae2:	cf 92       	push	r12
    1ae4:	df 92       	push	r13
    1ae6:	ef 92       	push	r14
    1ae8:	ff 92       	push	r15
    1aea:	0f 93       	push	r16
    1aec:	1f 93       	push	r17
    1aee:	cf 93       	push	r28
    1af0:	df 93       	push	r29
    1af2:	ec 01       	movw	r28, r24
    1af4:	8b 01       	movw	r16, r22
    1af6:	7a 01       	movw	r14, r20
    1af8:	9c de       	rcall	.-712    	; 0x1832 <Endpoint_WaitUntilReady>
    1afa:	81 11       	cpse	r24, r1
    1afc:	33 c0       	rjmp	.+102    	; 0x1b64 <Endpoint_Write_Stream_LE+0x82>
    1afe:	e1 14       	cp	r14, r1
    1b00:	f1 04       	cpc	r15, r1
    1b02:	39 f0       	breq	.+14     	; 0x1b12 <Endpoint_Write_Stream_LE+0x30>
    1b04:	f7 01       	movw	r30, r14
    1b06:	80 81       	ld	r24, Z
    1b08:	91 81       	ldd	r25, Z+1	; 0x01
    1b0a:	08 1b       	sub	r16, r24
    1b0c:	19 0b       	sbc	r17, r25
    1b0e:	c8 0f       	add	r28, r24
    1b10:	d9 1f       	adc	r29, r25
    1b12:	c1 2c       	mov	r12, r1
    1b14:	d1 2c       	mov	r13, r1
    1b16:	01 15       	cp	r16, r1
    1b18:	11 05       	cpc	r17, r1
    1b1a:	19 f1       	breq	.+70     	; 0x1b62 <Endpoint_Write_Stream_LE+0x80>
    1b1c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1b20:	85 fd       	sbrc	r24, 5
    1b22:	16 c0       	rjmp	.+44     	; 0x1b50 <Endpoint_Write_Stream_LE+0x6e>
    1b24:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1b28:	8e 77       	andi	r24, 0x7E	; 126
    1b2a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1b2e:	b0 d2       	rcall	.+1376   	; 0x2090 <USB_USBTask>
    1b30:	e1 14       	cp	r14, r1
    1b32:	f1 04       	cpc	r15, r1
    1b34:	49 f0       	breq	.+18     	; 0x1b48 <Endpoint_Write_Stream_LE+0x66>
    1b36:	f7 01       	movw	r30, r14
    1b38:	80 81       	ld	r24, Z
    1b3a:	91 81       	ldd	r25, Z+1	; 0x01
    1b3c:	c8 0e       	add	r12, r24
    1b3e:	d9 1e       	adc	r13, r25
    1b40:	d1 82       	std	Z+1, r13	; 0x01
    1b42:	c0 82       	st	Z, r12
    1b44:	85 e0       	ldi	r24, 0x05	; 5
    1b46:	0e c0       	rjmp	.+28     	; 0x1b64 <Endpoint_Write_Stream_LE+0x82>
    1b48:	74 de       	rcall	.-792    	; 0x1832 <Endpoint_WaitUntilReady>
    1b4a:	88 23       	and	r24, r24
    1b4c:	21 f3       	breq	.-56     	; 0x1b16 <Endpoint_Write_Stream_LE+0x34>
    1b4e:	0a c0       	rjmp	.+20     	; 0x1b64 <Endpoint_Write_Stream_LE+0x82>
    1b50:	89 91       	ld	r24, Y+
    1b52:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    1b56:	01 50       	subi	r16, 0x01	; 1
    1b58:	11 09       	sbc	r17, r1
    1b5a:	ff ef       	ldi	r31, 0xFF	; 255
    1b5c:	cf 1a       	sub	r12, r31
    1b5e:	df 0a       	sbc	r13, r31
    1b60:	da cf       	rjmp	.-76     	; 0x1b16 <Endpoint_Write_Stream_LE+0x34>
    1b62:	80 e0       	ldi	r24, 0x00	; 0
    1b64:	df 91       	pop	r29
    1b66:	cf 91       	pop	r28
    1b68:	1f 91       	pop	r17
    1b6a:	0f 91       	pop	r16
    1b6c:	ff 90       	pop	r15
    1b6e:	ef 90       	pop	r14
    1b70:	df 90       	pop	r13
    1b72:	cf 90       	pop	r12
    1b74:	08 95       	ret

00001b76 <Endpoint_Read_Stream_LE>:
    1b76:	cf 92       	push	r12
    1b78:	df 92       	push	r13
    1b7a:	ef 92       	push	r14
    1b7c:	ff 92       	push	r15
    1b7e:	0f 93       	push	r16
    1b80:	1f 93       	push	r17
    1b82:	cf 93       	push	r28
    1b84:	df 93       	push	r29
    1b86:	ec 01       	movw	r28, r24
    1b88:	8b 01       	movw	r16, r22
    1b8a:	7a 01       	movw	r14, r20
    1b8c:	52 de       	rcall	.-860    	; 0x1832 <Endpoint_WaitUntilReady>
    1b8e:	81 11       	cpse	r24, r1
    1b90:	33 c0       	rjmp	.+102    	; 0x1bf8 <Endpoint_Read_Stream_LE+0x82>
    1b92:	e1 14       	cp	r14, r1
    1b94:	f1 04       	cpc	r15, r1
    1b96:	39 f0       	breq	.+14     	; 0x1ba6 <Endpoint_Read_Stream_LE+0x30>
    1b98:	f7 01       	movw	r30, r14
    1b9a:	80 81       	ld	r24, Z
    1b9c:	91 81       	ldd	r25, Z+1	; 0x01
    1b9e:	08 1b       	sub	r16, r24
    1ba0:	19 0b       	sbc	r17, r25
    1ba2:	c8 0f       	add	r28, r24
    1ba4:	d9 1f       	adc	r29, r25
    1ba6:	c1 2c       	mov	r12, r1
    1ba8:	d1 2c       	mov	r13, r1
    1baa:	01 15       	cp	r16, r1
    1bac:	11 05       	cpc	r17, r1
    1bae:	19 f1       	breq	.+70     	; 0x1bf6 <Endpoint_Read_Stream_LE+0x80>
    1bb0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1bb4:	85 fd       	sbrc	r24, 5
    1bb6:	16 c0       	rjmp	.+44     	; 0x1be4 <Endpoint_Read_Stream_LE+0x6e>
    1bb8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1bbc:	8b 77       	andi	r24, 0x7B	; 123
    1bbe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1bc2:	66 d2       	rcall	.+1228   	; 0x2090 <USB_USBTask>
    1bc4:	e1 14       	cp	r14, r1
    1bc6:	f1 04       	cpc	r15, r1
    1bc8:	49 f0       	breq	.+18     	; 0x1bdc <Endpoint_Read_Stream_LE+0x66>
    1bca:	f7 01       	movw	r30, r14
    1bcc:	80 81       	ld	r24, Z
    1bce:	91 81       	ldd	r25, Z+1	; 0x01
    1bd0:	c8 0e       	add	r12, r24
    1bd2:	d9 1e       	adc	r13, r25
    1bd4:	d1 82       	std	Z+1, r13	; 0x01
    1bd6:	c0 82       	st	Z, r12
    1bd8:	85 e0       	ldi	r24, 0x05	; 5
    1bda:	0e c0       	rjmp	.+28     	; 0x1bf8 <Endpoint_Read_Stream_LE+0x82>
    1bdc:	2a de       	rcall	.-940    	; 0x1832 <Endpoint_WaitUntilReady>
    1bde:	88 23       	and	r24, r24
    1be0:	21 f3       	breq	.-56     	; 0x1baa <Endpoint_Read_Stream_LE+0x34>
    1be2:	0a c0       	rjmp	.+20     	; 0x1bf8 <Endpoint_Read_Stream_LE+0x82>
    1be4:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    1be8:	89 93       	st	Y+, r24
    1bea:	01 50       	subi	r16, 0x01	; 1
    1bec:	11 09       	sbc	r17, r1
    1bee:	ff ef       	ldi	r31, 0xFF	; 255
    1bf0:	cf 1a       	sub	r12, r31
    1bf2:	df 0a       	sbc	r13, r31
    1bf4:	da cf       	rjmp	.-76     	; 0x1baa <Endpoint_Read_Stream_LE+0x34>
    1bf6:	80 e0       	ldi	r24, 0x00	; 0
    1bf8:	df 91       	pop	r29
    1bfa:	cf 91       	pop	r28
    1bfc:	1f 91       	pop	r17
    1bfe:	0f 91       	pop	r16
    1c00:	ff 90       	pop	r15
    1c02:	ef 90       	pop	r14
    1c04:	df 90       	pop	r13
    1c06:	cf 90       	pop	r12
    1c08:	08 95       	ret

00001c0a <Endpoint_Write_Control_Stream_LE>:
    1c0a:	20 91 07 14 	lds	r18, 0x1407	; 0x801407 <USB_ControlRequest+0x6>
    1c0e:	30 91 08 14 	lds	r19, 0x1408	; 0x801408 <USB_ControlRequest+0x7>
    1c12:	26 17       	cp	r18, r22
    1c14:	37 07       	cpc	r19, r23
    1c16:	48 f0       	brcs	.+18     	; 0x1c2a <Endpoint_Write_Control_Stream_LE+0x20>
    1c18:	61 15       	cp	r22, r1
    1c1a:	71 05       	cpc	r23, r1
    1c1c:	39 f4       	brne	.+14     	; 0x1c2c <Endpoint_Write_Control_Stream_LE+0x22>
    1c1e:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1c22:	2e 77       	andi	r18, 0x7E	; 126
    1c24:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1c28:	01 c0       	rjmp	.+2      	; 0x1c2c <Endpoint_Write_Control_Stream_LE+0x22>
    1c2a:	b9 01       	movw	r22, r18
    1c2c:	fc 01       	movw	r30, r24
    1c2e:	20 e0       	ldi	r18, 0x00	; 0
    1c30:	61 15       	cp	r22, r1
    1c32:	71 05       	cpc	r23, r1
    1c34:	69 f1       	breq	.+90     	; 0x1c90 <Endpoint_Write_Control_Stream_LE+0x86>
    1c36:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>
    1c3a:	88 23       	and	r24, r24
    1c3c:	d1 f1       	breq	.+116    	; 0x1cb2 <Endpoint_Write_Control_Stream_LE+0xa8>
    1c3e:	85 30       	cpi	r24, 0x05	; 5
    1c40:	d1 f1       	breq	.+116    	; 0x1cb6 <Endpoint_Write_Control_Stream_LE+0xac>
    1c42:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1c46:	83 fd       	sbrc	r24, 3
    1c48:	32 c0       	rjmp	.+100    	; 0x1cae <Endpoint_Write_Control_Stream_LE+0xa4>
    1c4a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1c4e:	82 fd       	sbrc	r24, 2
    1c50:	28 c0       	rjmp	.+80     	; 0x1ca2 <Endpoint_Write_Control_Stream_LE+0x98>
    1c52:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1c56:	80 ff       	sbrs	r24, 0
    1c58:	eb cf       	rjmp	.-42     	; 0x1c30 <Endpoint_Write_Control_Stream_LE+0x26>
    1c5a:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1c5e:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1c62:	61 15       	cp	r22, r1
    1c64:	71 05       	cpc	r23, r1
    1c66:	51 f0       	breq	.+20     	; 0x1c7c <Endpoint_Write_Control_Stream_LE+0x72>
    1c68:	88 30       	cpi	r24, 0x08	; 8
    1c6a:	91 05       	cpc	r25, r1
    1c6c:	38 f4       	brcc	.+14     	; 0x1c7c <Endpoint_Write_Control_Stream_LE+0x72>
    1c6e:	21 91       	ld	r18, Z+
    1c70:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    1c74:	61 50       	subi	r22, 0x01	; 1
    1c76:	71 09       	sbc	r23, r1
    1c78:	01 96       	adiw	r24, 0x01	; 1
    1c7a:	f3 cf       	rjmp	.-26     	; 0x1c62 <Endpoint_Write_Control_Stream_LE+0x58>
    1c7c:	21 e0       	ldi	r18, 0x01	; 1
    1c7e:	08 97       	sbiw	r24, 0x08	; 8
    1c80:	09 f0       	breq	.+2      	; 0x1c84 <Endpoint_Write_Control_Stream_LE+0x7a>
    1c82:	20 e0       	ldi	r18, 0x00	; 0
    1c84:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1c88:	8e 77       	andi	r24, 0x7E	; 126
    1c8a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1c8e:	d0 cf       	rjmp	.-96     	; 0x1c30 <Endpoint_Write_Control_Stream_LE+0x26>
    1c90:	21 11       	cpse	r18, r1
    1c92:	d1 cf       	rjmp	.-94     	; 0x1c36 <Endpoint_Write_Control_Stream_LE+0x2c>
    1c94:	06 c0       	rjmp	.+12     	; 0x1ca2 <Endpoint_Write_Control_Stream_LE+0x98>
    1c96:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>
    1c9a:	88 23       	and	r24, r24
    1c9c:	51 f0       	breq	.+20     	; 0x1cb2 <Endpoint_Write_Control_Stream_LE+0xa8>
    1c9e:	85 30       	cpi	r24, 0x05	; 5
    1ca0:	51 f0       	breq	.+20     	; 0x1cb6 <Endpoint_Write_Control_Stream_LE+0xac>
    1ca2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1ca6:	82 ff       	sbrs	r24, 2
    1ca8:	f6 cf       	rjmp	.-20     	; 0x1c96 <Endpoint_Write_Control_Stream_LE+0x8c>
    1caa:	80 e0       	ldi	r24, 0x00	; 0
    1cac:	08 95       	ret
    1cae:	81 e0       	ldi	r24, 0x01	; 1
    1cb0:	08 95       	ret
    1cb2:	82 e0       	ldi	r24, 0x02	; 2
    1cb4:	08 95       	ret
    1cb6:	83 e0       	ldi	r24, 0x03	; 3
    1cb8:	08 95       	ret

00001cba <Endpoint_Read_Control_Stream_LE>:
    1cba:	61 15       	cp	r22, r1
    1cbc:	71 05       	cpc	r23, r1
    1cbe:	29 f4       	brne	.+10     	; 0x1cca <Endpoint_Read_Control_Stream_LE+0x10>
    1cc0:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1cc4:	2b 77       	andi	r18, 0x7B	; 123
    1cc6:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1cca:	fc 01       	movw	r30, r24
    1ccc:	61 15       	cp	r22, r1
    1cce:	71 05       	cpc	r23, r1
    1cd0:	31 f1       	breq	.+76     	; 0x1d1e <Endpoint_Read_Control_Stream_LE+0x64>
    1cd2:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>
    1cd6:	88 23       	and	r24, r24
    1cd8:	51 f1       	breq	.+84     	; 0x1d2e <Endpoint_Read_Control_Stream_LE+0x74>
    1cda:	85 30       	cpi	r24, 0x05	; 5
    1cdc:	51 f1       	breq	.+84     	; 0x1d32 <Endpoint_Read_Control_Stream_LE+0x78>
    1cde:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1ce2:	83 fd       	sbrc	r24, 3
    1ce4:	22 c0       	rjmp	.+68     	; 0x1d2a <Endpoint_Read_Control_Stream_LE+0x70>
    1ce6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1cea:	82 ff       	sbrs	r24, 2
    1cec:	ef cf       	rjmp	.-34     	; 0x1ccc <Endpoint_Read_Control_Stream_LE+0x12>
    1cee:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1cf2:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1cf6:	89 2b       	or	r24, r25
    1cf8:	31 f0       	breq	.+12     	; 0x1d06 <Endpoint_Read_Control_Stream_LE+0x4c>
    1cfa:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    1cfe:	81 93       	st	Z+, r24
    1d00:	61 50       	subi	r22, 0x01	; 1
    1d02:	71 09       	sbc	r23, r1
    1d04:	a1 f7       	brne	.-24     	; 0x1cee <Endpoint_Read_Control_Stream_LE+0x34>
    1d06:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1d0a:	8b 77       	andi	r24, 0x7B	; 123
    1d0c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1d10:	dd cf       	rjmp	.-70     	; 0x1ccc <Endpoint_Read_Control_Stream_LE+0x12>
    1d12:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>
    1d16:	88 23       	and	r24, r24
    1d18:	51 f0       	breq	.+20     	; 0x1d2e <Endpoint_Read_Control_Stream_LE+0x74>
    1d1a:	85 30       	cpi	r24, 0x05	; 5
    1d1c:	51 f0       	breq	.+20     	; 0x1d32 <Endpoint_Read_Control_Stream_LE+0x78>
    1d1e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1d22:	80 ff       	sbrs	r24, 0
    1d24:	f6 cf       	rjmp	.-20     	; 0x1d12 <Endpoint_Read_Control_Stream_LE+0x58>
    1d26:	80 e0       	ldi	r24, 0x00	; 0
    1d28:	08 95       	ret
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	08 95       	ret
    1d2e:	82 e0       	ldi	r24, 0x02	; 2
    1d30:	08 95       	ret
    1d32:	83 e0       	ldi	r24, 0x03	; 3
    1d34:	08 95       	ret

00001d36 <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1d36:	20 91 07 14 	lds	r18, 0x1407	; 0x801407 <USB_ControlRequest+0x6>
    1d3a:	30 91 08 14 	lds	r19, 0x1408	; 0x801408 <USB_ControlRequest+0x7>
    1d3e:	26 17       	cp	r18, r22
    1d40:	37 07       	cpc	r19, r23
    1d42:	48 f0       	brcs	.+18     	; 0x1d56 <Endpoint_Write_Control_PStream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1d44:	61 15       	cp	r22, r1
    1d46:	71 05       	cpc	r23, r1
    1d48:	39 f4       	brne	.+14     	; 0x1d58 <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1d4a:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1d4e:	2e 77       	andi	r18, 0x7E	; 126
    1d50:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1d54:	01 c0       	rjmp	.+2      	; 0x1d58 <Endpoint_Write_Control_PStream_LE+0x22>
    1d56:	b9 01       	movw	r22, r18
    1d58:	fc 01       	movw	r30, r24
    1d5a:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1d5c:	61 15       	cp	r22, r1
    1d5e:	71 05       	cpc	r23, r1
    1d60:	71 f1       	breq	.+92     	; 0x1dbe <Endpoint_Write_Control_PStream_LE+0x88>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1d62:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1d66:	88 23       	and	r24, r24
    1d68:	d9 f1       	breq	.+118    	; 0x1de0 <Endpoint_Write_Control_PStream_LE+0xaa>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1d6a:	85 30       	cpi	r24, 0x05	; 5
    1d6c:	d9 f1       	breq	.+118    	; 0x1de4 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1d6e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1d72:	83 fd       	sbrc	r24, 3
    1d74:	33 c0       	rjmp	.+102    	; 0x1ddc <Endpoint_Write_Control_PStream_LE+0xa6>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1d76:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1d7a:	82 fd       	sbrc	r24, 2
    1d7c:	29 c0       	rjmp	.+82     	; 0x1dd0 <Endpoint_Write_Control_PStream_LE+0x9a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1d7e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  break;

		if (Endpoint_IsINReady())
    1d82:	80 ff       	sbrs	r24, 0
    1d84:	eb cf       	rjmp	.-42     	; 0x1d5c <Endpoint_Write_Control_PStream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    1d86:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1d8a:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1d8e:	61 15       	cp	r22, r1
    1d90:	71 05       	cpc	r23, r1
    1d92:	59 f0       	breq	.+22     	; 0x1daa <Endpoint_Write_Control_PStream_LE+0x74>
    1d94:	88 30       	cpi	r24, 0x08	; 8
    1d96:	91 05       	cpc	r25, r1
    1d98:	40 f4       	brcc	.+16     	; 0x1daa <Endpoint_Write_Control_PStream_LE+0x74>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1d9a:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1d9c:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1da0:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    1da2:	61 50       	subi	r22, 0x01	; 1
    1da4:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    1da6:	01 96       	adiw	r24, 0x01	; 1
    1da8:	f2 cf       	rjmp	.-28     	; 0x1d8e <Endpoint_Write_Control_PStream_LE+0x58>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1daa:	21 e0       	ldi	r18, 0x01	; 1
    1dac:	08 97       	sbiw	r24, 0x08	; 8
    1dae:	09 f0       	breq	.+2      	; 0x1db2 <Endpoint_Write_Control_PStream_LE+0x7c>
    1db0:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1db2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1db6:	8e 77       	andi	r24, 0x7E	; 126
    1db8:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1dbc:	cf cf       	rjmp	.-98     	; 0x1d5c <Endpoint_Write_Control_PStream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1dbe:	21 11       	cpse	r18, r1
    1dc0:	d0 cf       	rjmp	.-96     	; 0x1d62 <Endpoint_Write_Control_PStream_LE+0x2c>
    1dc2:	06 c0       	rjmp	.+12     	; 0x1dd0 <Endpoint_Write_Control_PStream_LE+0x9a>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1dc4:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1dc8:	88 23       	and	r24, r24
    1dca:	51 f0       	breq	.+20     	; 0x1de0 <Endpoint_Write_Control_PStream_LE+0xaa>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1dcc:	85 30       	cpi	r24, 0x05	; 5
    1dce:	51 f0       	breq	.+20     	; 0x1de4 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1dd0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1dd4:	82 ff       	sbrs	r24, 2
    1dd6:	f6 cf       	rjmp	.-20     	; 0x1dc4 <Endpoint_Write_Control_PStream_LE+0x8e>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1dd8:	80 e0       	ldi	r24, 0x00	; 0
    1dda:	08 95       	ret
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	08 95       	ret
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1de0:	82 e0       	ldi	r24, 0x02	; 2
    1de2:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1de4:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1de6:	08 95       	ret

00001de8 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1de8:	0f 93       	push	r16
    1dea:	1f 93       	push	r17
    1dec:	cf 93       	push	r28
    1dee:	df 93       	push	r29
    1df0:	cd b7       	in	r28, 0x3d	; 61
    1df2:	de b7       	in	r29, 0x3e	; 62
    1df4:	aa 97       	sbiw	r28, 0x2a	; 42
    1df6:	0f b6       	in	r0, 0x3f	; 63
    1df8:	f8 94       	cli
    1dfa:	de bf       	out	0x3e, r29	; 62
    1dfc:	0f be       	out	0x3f, r0	; 63
    1dfe:	cd bf       	out	0x3d, r28	; 61
    1e00:	e1 e0       	ldi	r30, 0x01	; 1
    1e02:	f4 e1       	ldi	r31, 0x14	; 20
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1e04:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    1e08:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1e0a:	24 e1       	ldi	r18, 0x14	; 20
    1e0c:	e9 30       	cpi	r30, 0x09	; 9
    1e0e:	f2 07       	cpc	r31, r18
    1e10:	c9 f7       	brne	.-14     	; 0x1e04 <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    1e12:	0e 94 da 02 	call	0x5b4	; 0x5b4 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1e16:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsSETUPReceived())
    1e1a:	83 ff       	sbrs	r24, 3
    1e1c:	1f c1       	rjmp	.+574    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1e1e:	80 91 01 14 	lds	r24, 0x1401	; 0x801401 <USB_ControlRequest>

		switch (USB_ControlRequest.bRequest)
    1e22:	90 91 02 14 	lds	r25, 0x1402	; 0x801402 <USB_ControlRequest+0x1>
    1e26:	49 2f       	mov	r20, r25
    1e28:	50 e0       	ldi	r21, 0x00	; 0
    1e2a:	4a 30       	cpi	r20, 0x0A	; 10
    1e2c:	51 05       	cpc	r21, r1
    1e2e:	08 f0       	brcs	.+2      	; 0x1e32 <USB_Device_ProcessControlRequest+0x4a>
    1e30:	15 c1       	rjmp	.+554    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
    1e32:	fa 01       	movw	r30, r20
    1e34:	ec 5a       	subi	r30, 0xAC	; 172
    1e36:	ff 4f       	sbci	r31, 0xFF	; 255
    1e38:	2f c5       	rjmp	.+2654   	; 0x2898 <__tablejump2__>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1e3a:	80 38       	cpi	r24, 0x80	; 128
    1e3c:	81 f0       	breq	.+32     	; 0x1e5e <USB_Device_ProcessControlRequest+0x76>
    1e3e:	82 38       	cpi	r24, 0x82	; 130
    1e40:	09 f0       	breq	.+2      	; 0x1e44 <USB_Device_ProcessControlRequest+0x5c>
    1e42:	0c c1       	rjmp	.+536    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1e44:	80 91 05 14 	lds	r24, 0x1405	; 0x801405 <USB_ControlRequest+0x4>
    1e48:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1e4a:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1e4e:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>

			CurrentStatus = Endpoint_IsStalled();
    1e52:	85 fb       	bst	r24, 5
    1e54:	88 27       	eor	r24, r24
    1e56:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1e58:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1e5c:	06 c0       	rjmp	.+12     	; 0x1e6a <USB_Device_ProcessControlRequest+0x82>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    1e5e:	80 91 fd 13 	lds	r24, 0x13FD	; 0x8013fd <USB_Device_CurrentlySelfPowered>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    1e62:	90 91 fe 13 	lds	r25, 0x13FE	; 0x8013fe <USB_Device_RemoteWakeupEnabled>
    1e66:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1e68:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1e6a:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1e6e:	97 7f       	andi	r25, 0xF7	; 247
    1e70:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    1e74:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
				UEDATX = (Data >> 8);
    1e78:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    1e7c:	c6 c0       	rjmp	.+396    	; 0x200a <__DATA_REGION_LENGTH__+0xa>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1e7e:	28 2f       	mov	r18, r24
    1e80:	2d 7f       	andi	r18, 0xFD	; 253
    1e82:	09 f0       	breq	.+2      	; 0x1e86 <USB_Device_ProcessControlRequest+0x9e>
    1e84:	eb c0       	rjmp	.+470    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    1e86:	88 23       	and	r24, r24
    1e88:	19 f0       	breq	.+6      	; 0x1e90 <USB_Device_ProcessControlRequest+0xa8>
    1e8a:	82 30       	cpi	r24, 0x02	; 2
    1e8c:	61 f0       	breq	.+24     	; 0x1ea6 <USB_Device_ProcessControlRequest+0xbe>
    1e8e:	e6 c0       	rjmp	.+460    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    1e90:	80 91 03 14 	lds	r24, 0x1403	; 0x801403 <USB_ControlRequest+0x2>
    1e94:	81 30       	cpi	r24, 0x01	; 1
    1e96:	09 f0       	breq	.+2      	; 0x1e9a <USB_Device_ProcessControlRequest+0xb2>
    1e98:	e1 c0       	rjmp	.+450    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    1e9a:	93 30       	cpi	r25, 0x03	; 3
    1e9c:	09 f0       	breq	.+2      	; 0x1ea0 <USB_Device_ProcessControlRequest+0xb8>
    1e9e:	80 e0       	ldi	r24, 0x00	; 0
    1ea0:	80 93 fe 13 	sts	0x13FE, r24	; 0x8013fe <USB_Device_RemoteWakeupEnabled>
    1ea4:	2b c0       	rjmp	.+86     	; 0x1efc <USB_Device_ProcessControlRequest+0x114>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    1ea6:	80 91 03 14 	lds	r24, 0x1403	; 0x801403 <USB_ControlRequest+0x2>
    1eaa:	81 11       	cpse	r24, r1
    1eac:	27 c0       	rjmp	.+78     	; 0x1efc <USB_Device_ProcessControlRequest+0x114>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1eae:	80 91 05 14 	lds	r24, 0x1405	; 0x801405 <USB_ControlRequest+0x4>
    1eb2:	87 70       	andi	r24, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    1eb4:	09 f4       	brne	.+2      	; 0x1eb8 <USB_Device_ProcessControlRequest+0xd0>
    1eb6:	d2 c0       	rjmp	.+420    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1eb8:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    1ebc:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    1ec0:	20 ff       	sbrs	r18, 0
    1ec2:	1c c0       	rjmp	.+56     	; 0x1efc <USB_Device_ProcessControlRequest+0x114>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    1ec4:	93 30       	cpi	r25, 0x03	; 3
    1ec6:	21 f4       	brne	.+8      	; 0x1ed0 <USB_Device_ProcessControlRequest+0xe8>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    1ec8:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    1ecc:	80 62       	ori	r24, 0x20	; 32
    1ece:	14 c0       	rjmp	.+40     	; 0x1ef8 <USB_Device_ProcessControlRequest+0x110>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    1ed0:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    1ed4:	90 61       	ori	r25, 0x10	; 16
    1ed6:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    1eda:	21 e0       	ldi	r18, 0x01	; 1
    1edc:	30 e0       	ldi	r19, 0x00	; 0
    1ede:	a9 01       	movw	r20, r18
    1ee0:	02 c0       	rjmp	.+4      	; 0x1ee6 <USB_Device_ProcessControlRequest+0xfe>
    1ee2:	44 0f       	add	r20, r20
    1ee4:	55 1f       	adc	r21, r21
    1ee6:	8a 95       	dec	r24
    1ee8:	e2 f7       	brpl	.-8      	; 0x1ee2 <USB_Device_ProcessControlRequest+0xfa>
    1eea:	40 93 ea 00 	sts	0x00EA, r20	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>
				UERST = 0;
    1eee:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__TEXT_REGION_LENGTH__+0x7e00ea>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    1ef2:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    1ef6:	88 60       	ori	r24, 0x08	; 8
    1ef8:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1efc:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1f00:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1f04:	87 7f       	andi	r24, 0xF7	; 247
    1f06:	84 c0       	rjmp	.+264    	; 0x2010 <__DATA_REGION_LENGTH__+0x10>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1f08:	81 11       	cpse	r24, r1
    1f0a:	a8 c0       	rjmp	.+336    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    1f0c:	10 91 03 14 	lds	r17, 0x1403	; 0x801403 <USB_ControlRequest+0x2>
    1f10:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    1f12:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    1f14:	f8 94       	cli
    1f16:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1f1a:	87 7f       	andi	r24, 0xF7	; 247
    1f1c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    1f20:	69 dc       	rcall	.-1838   	; 0x17f4 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1f22:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	while (!(Endpoint_IsINReady()));
    1f26:	80 ff       	sbrs	r24, 0
    1f28:	fc cf       	rjmp	.-8      	; 0x1f22 <USB_Device_ProcessControlRequest+0x13a>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    1f2a:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
    1f2e:	80 78       	andi	r24, 0x80	; 128
    1f30:	81 2b       	or	r24, r17

				UDADDR = Temp;
    1f32:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
				UDADDR = Temp | (1 << ADDEN);
    1f36:	80 68       	ori	r24, 0x80	; 128
    1f38:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    1f3c:	11 11       	cpse	r17, r1
    1f3e:	02 c0       	rjmp	.+4      	; 0x1f44 <USB_Device_ProcessControlRequest+0x15c>
    1f40:	82 e0       	ldi	r24, 0x02	; 2
    1f42:	01 c0       	rjmp	.+2      	; 0x1f46 <USB_Device_ProcessControlRequest+0x15e>
    1f44:	83 e0       	ldi	r24, 0x03	; 3
    1f46:	80 93 00 14 	sts	0x1400, r24	; 0x801400 <USB_DeviceState>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    1f4a:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    1f4c:	87 c0       	rjmp	.+270    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1f4e:	80 58       	subi	r24, 0x80	; 128
    1f50:	82 30       	cpi	r24, 0x02	; 2
    1f52:	08 f0       	brcs	.+2      	; 0x1f56 <USB_Device_ProcessControlRequest+0x16e>
    1f54:	83 c0       	rjmp	.+262    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    1f56:	80 91 03 14 	lds	r24, 0x1403	; 0x801403 <USB_ControlRequest+0x2>
    1f5a:	90 91 04 14 	lds	r25, 0x1404	; 0x801404 <USB_ControlRequest+0x3>
    1f5e:	8c 3d       	cpi	r24, 0xDC	; 220
    1f60:	53 e0       	ldi	r21, 0x03	; 3
    1f62:	95 07       	cpc	r25, r21
    1f64:	71 f5       	brne	.+92     	; 0x1fc2 <USB_Device_ProcessControlRequest+0x1da>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    1f66:	83 e0       	ldi	r24, 0x03	; 3
    1f68:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    1f6a:	8a e2       	ldi	r24, 0x2A	; 42
    1f6c:	89 83       	std	Y+1, r24	; 0x01
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    1f6e:	4f b7       	in	r20, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    1f70:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    1f72:	de 01       	movw	r26, r28
    1f74:	13 96       	adiw	r26, 0x03	; 3
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1f76:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    1f78:	3e e0       	ldi	r19, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    1f7a:	51 e2       	ldi	r21, 0x21	; 33
    1f7c:	e3 2f       	mov	r30, r19
    1f7e:	f0 e0       	ldi	r31, 0x00	; 0
    1f80:	50 93 57 00 	sts	0x0057, r21	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    1f84:	e4 91       	lpm	r30, Z

					if (SerialCharNum & 0x01)
    1f86:	20 ff       	sbrs	r18, 0
    1f88:	03 c0       	rjmp	.+6      	; 0x1f90 <USB_Device_ProcessControlRequest+0x1a8>
					{
						SerialByte >>= 4;
    1f8a:	e2 95       	swap	r30
    1f8c:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    1f8e:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    1f90:	ef 70       	andi	r30, 0x0F	; 15
    1f92:	8e 2f       	mov	r24, r30
    1f94:	90 e0       	ldi	r25, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    1f96:	ea 30       	cpi	r30, 0x0A	; 10
    1f98:	10 f0       	brcs	.+4      	; 0x1f9e <USB_Device_ProcessControlRequest+0x1b6>
    1f9a:	c7 96       	adiw	r24, 0x37	; 55
    1f9c:	01 c0       	rjmp	.+2      	; 0x1fa0 <USB_Device_ProcessControlRequest+0x1b8>
    1f9e:	c0 96       	adiw	r24, 0x30	; 48
    1fa0:	8d 93       	st	X+, r24
    1fa2:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1fa4:	2f 5f       	subi	r18, 0xFF	; 255
    1fa6:	24 31       	cpi	r18, 0x14	; 20
    1fa8:	49 f7       	brne	.-46     	; 0x1f7c <USB_Device_ProcessControlRequest+0x194>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    1faa:	4f bf       	out	0x3f, r20	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1fac:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1fb0:	87 7f       	andi	r24, 0xF7	; 247
    1fb2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    1fb6:	6a e2       	ldi	r22, 0x2A	; 42
    1fb8:	70 e0       	ldi	r23, 0x00	; 0
    1fba:	ce 01       	movw	r24, r28
    1fbc:	01 96       	adiw	r24, 0x01	; 1
    1fbe:	25 de       	rcall	.-950    	; 0x1c0a <Endpoint_Write_Control_Stream_LE>
    1fc0:	13 c0       	rjmp	.+38     	; 0x1fe8 <USB_Device_ProcessControlRequest+0x200>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    1fc2:	ae 01       	movw	r20, r28
    1fc4:	4f 5f       	subi	r20, 0xFF	; 255
    1fc6:	5f 4f       	sbci	r21, 0xFF	; 255
    1fc8:	60 91 05 14 	lds	r22, 0x1405	; 0x801405 <USB_ControlRequest+0x4>
    1fcc:	0e 94 de 02 	call	0x5bc	; 0x5bc <CALLBACK_USB_GetDescriptor>
    1fd0:	bc 01       	movw	r22, r24
    1fd2:	89 2b       	or	r24, r25
    1fd4:	09 f4       	brne	.+2      	; 0x1fd8 <USB_Device_ProcessControlRequest+0x1f0>
    1fd6:	42 c0       	rjmp	.+132    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
    1fd8:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1fdc:	97 7f       	andi	r25, 0xF7	; 247
    1fde:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    1fe2:	89 81       	ldd	r24, Y+1	; 0x01
    1fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe6:	a7 de       	rcall	.-690    	; 0x1d36 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1fe8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1fec:	8b 77       	andi	r24, 0x7B	; 123
    1fee:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1ff2:	34 c0       	rjmp	.+104    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    1ff4:	80 38       	cpi	r24, 0x80	; 128
    1ff6:	91 f5       	brne	.+100    	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1ff8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    1ffc:	87 7f       	andi	r24, 0xF7	; 247
    1ffe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2002:	80 91 fc 13 	lds	r24, 0x13FC	; 0x8013fc <USB_Device_ConfigurationNumber>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2006:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    200a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    200e:	8e 77       	andi	r24, 0x7E	; 126
    2010:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2014:	ef db       	rcall	.-2082   	; 0x17f4 <Endpoint_ClearStatusStage>
    2016:	22 c0       	rjmp	.+68     	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2018:	81 11       	cpse	r24, r1
    201a:	20 c0       	rjmp	.+64     	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    201c:	80 91 03 14 	lds	r24, 0x1403	; 0x801403 <USB_ControlRequest+0x2>
    2020:	90 91 04 14 	lds	r25, 0x1404	; 0x801404 <USB_ControlRequest+0x3>
    2024:	99 27       	eor	r25, r25
    2026:	02 97       	sbiw	r24, 0x02	; 2
    2028:	cc f4       	brge	.+50     	; 0x205c <__DATA_REGION_LENGTH__+0x5c>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    202a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    202e:	87 7f       	andi	r24, 0xF7	; 247
    2030:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2034:	80 91 03 14 	lds	r24, 0x1403	; 0x801403 <USB_ControlRequest+0x2>
    2038:	80 93 fc 13 	sts	0x13FC, r24	; 0x8013fc <USB_Device_ConfigurationNumber>

	Endpoint_ClearStatusStage();
    203c:	db db       	rcall	.-2122   	; 0x17f4 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    203e:	80 91 fc 13 	lds	r24, 0x13FC	; 0x8013fc <USB_Device_ConfigurationNumber>
    2042:	81 11       	cpse	r24, r1
    2044:	06 c0       	rjmp	.+12     	; 0x2052 <__DATA_REGION_LENGTH__+0x52>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2046:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    204a:	87 fd       	sbrc	r24, 7
    204c:	02 c0       	rjmp	.+4      	; 0x2052 <__DATA_REGION_LENGTH__+0x52>
    204e:	81 e0       	ldi	r24, 0x01	; 1
    2050:	01 c0       	rjmp	.+2      	; 0x2054 <__DATA_REGION_LENGTH__+0x54>
    2052:	84 e0       	ldi	r24, 0x04	; 4
    2054:	80 93 00 14 	sts	0x1400, r24	; 0x801400 <USB_DeviceState>

	EVENT_USB_Device_ConfigurationChanged();
    2058:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    205c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2060:	83 ff       	sbrs	r24, 3
    2062:	0a c0       	rjmp	.+20     	; 0x2078 <__DATA_REGION_LENGTH__+0x78>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2064:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    2068:	80 62       	ori	r24, 0x20	; 32
    206a:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    206e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2072:	87 7f       	andi	r24, 0xF7	; 247
    2074:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    2078:	aa 96       	adiw	r28, 0x2a	; 42
    207a:	0f b6       	in	r0, 0x3f	; 63
    207c:	f8 94       	cli
    207e:	de bf       	out	0x3e, r29	; 62
    2080:	0f be       	out	0x3f, r0	; 63
    2082:	cd bf       	out	0x3d, r28	; 61
    2084:	df 91       	pop	r29
    2086:	cf 91       	pop	r28
    2088:	1f 91       	pop	r17
    208a:	0f 91       	pop	r16
    208c:	08 95       	ret

0000208e <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    208e:	08 95       	ret

00002090 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    2090:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    2092:	80 91 00 14 	lds	r24, 0x1400	; 0x801400 <USB_DeviceState>
    2096:	88 23       	and	r24, r24
    2098:	59 f0       	breq	.+22     	; 0x20b0 <USB_USBTask+0x20>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    209a:	c0 91 e9 00 	lds	r28, 0x00E9	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    209e:	c7 70       	andi	r28, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    20a0:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    20a4:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    20a8:	83 fd       	sbrc	r24, 3
		  USB_Device_ProcessControlRequest();
    20aa:	9e de       	rcall	.-708    	; 0x1de8 <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    20ac:	c0 93 e9 00 	sts	0x00E9, r28	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    20b0:	cf 91       	pop	r28
    20b2:	08 95       	ret

000020b4 <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    20b4:	0f 93       	push	r16
    20b6:	1f 93       	push	r17
    20b8:	cf 93       	push	r28
    20ba:	df 93       	push	r29
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    20bc:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	if (!(Endpoint_IsSETUPReceived()))
    20c0:	23 ff       	sbrs	r18, 3
    20c2:	64 c2       	rjmp	.+1224   	; 0x258c <__stack+0x48d>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    20c4:	fc 01       	movw	r30, r24
    20c6:	20 81       	ld	r18, Z
    20c8:	30 e0       	ldi	r19, 0x00	; 0
    20ca:	40 91 05 14 	lds	r20, 0x1405	; 0x801405 <USB_ControlRequest+0x4>
    20ce:	50 91 06 14 	lds	r21, 0x1406	; 0x801406 <USB_ControlRequest+0x5>
    20d2:	42 17       	cp	r20, r18
    20d4:	53 07       	cpc	r21, r19
    20d6:	09 f0       	breq	.+2      	; 0x20da <RNDIS_Device_ProcessControlRequest+0x26>
    20d8:	59 c2       	rjmp	.+1202   	; 0x258c <__stack+0x48d>
    20da:	ec 01       	movw	r28, r24
	  return;

	switch (USB_ControlRequest.bRequest)
    20dc:	80 91 02 14 	lds	r24, 0x1402	; 0x801402 <USB_ControlRequest+0x1>
    20e0:	88 23       	and	r24, r24
    20e2:	21 f0       	breq	.+8      	; 0x20ec <RNDIS_Device_ProcessControlRequest+0x38>
    20e4:	81 30       	cpi	r24, 0x01	; 1
    20e6:	09 f4       	brne	.+2      	; 0x20ea <RNDIS_Device_ProcessControlRequest+0x36>
    20e8:	f3 c1       	rjmp	.+998    	; 0x24d0 <__stack+0x3d1>
    20ea:	50 c2       	rjmp	.+1184   	; 0x258c <__stack+0x48d>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    20ec:	80 91 01 14 	lds	r24, 0x1401	; 0x801401 <USB_ControlRequest>
    20f0:	81 32       	cpi	r24, 0x21	; 33
    20f2:	09 f0       	breq	.+2      	; 0x20f6 <RNDIS_Device_ProcessControlRequest+0x42>
    20f4:	4b c2       	rjmp	.+1174   	; 0x258c <__stack+0x48d>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    20f6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    20fa:	87 7f       	andi	r24, 0xF7	; 247
    20fc:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    2100:	60 91 07 14 	lds	r22, 0x1407	; 0x801407 <USB_ControlRequest+0x6>
    2104:	70 91 08 14 	lds	r23, 0x1408	; 0x801408 <USB_ControlRequest+0x7>
    2108:	cf 01       	movw	r24, r30
    210a:	45 96       	adiw	r24, 0x15	; 21
    210c:	d6 dd       	rcall	.-1108   	; 0x1cba <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    210e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2112:	8e 77       	andi	r24, 0x7E	; 126
    2114:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    2118:	8d 89       	ldd	r24, Y+21	; 0x15
    211a:	9e 89       	ldd	r25, Y+22	; 0x16
    211c:	af 89       	ldd	r26, Y+23	; 0x17
    211e:	b8 8d       	ldd	r27, Y+24	; 0x18
    2120:	84 30       	cpi	r24, 0x04	; 4
    2122:	91 05       	cpc	r25, r1
    2124:	a1 05       	cpc	r26, r1
    2126:	b1 05       	cpc	r27, r1
    2128:	09 f4       	brne	.+2      	; 0x212c <__stack+0x2d>
    212a:	87 c0       	rjmp	.+270    	; 0x223a <__stack+0x13b>
    212c:	b0 f4       	brcc	.+44     	; 0x215a <__stack+0x5b>
    212e:	82 30       	cpi	r24, 0x02	; 2
    2130:	91 05       	cpc	r25, r1
    2132:	a1 05       	cpc	r26, r1
    2134:	b1 05       	cpc	r27, r1
    2136:	a1 f1       	breq	.+104    	; 0x21a0 <__stack+0xa1>
    2138:	03 97       	sbiw	r24, 0x03	; 3
    213a:	a1 05       	cpc	r26, r1
    213c:	b1 05       	cpc	r27, r1
    213e:	09 f0       	breq	.+2      	; 0x2142 <__stack+0x43>
    2140:	25 c2       	rjmp	.+1098   	; 0x258c <__stack+0x48d>
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    2142:	fe 01       	movw	r30, r28
    2144:	eb 56       	subi	r30, 0x6B	; 107
    2146:	ff 4f       	sbci	r31, 0xFF	; 255
    2148:	10 82       	st	Z, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    214a:	19 8e       	std	Y+25, r1	; 0x19
    214c:	1a 8e       	std	Y+26, r1	; 0x1a
    214e:	1b 8e       	std	Y+27, r1	; 0x1b
    2150:	1c 8e       	std	Y+28, r1	; 0x1c

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    2152:	ca 56       	subi	r28, 0x6A	; 106
    2154:	df 4f       	sbci	r29, 0xFF	; 255
    2156:	18 82       	st	Y, r1
    2158:	19 c2       	rjmp	.+1074   	; 0x258c <__stack+0x48d>
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    215a:	86 30       	cpi	r24, 0x06	; 6
    215c:	91 05       	cpc	r25, r1
    215e:	a1 05       	cpc	r26, r1
    2160:	b1 05       	cpc	r27, r1
    2162:	09 f4       	brne	.+2      	; 0x2166 <__stack+0x67>
    2164:	97 c1       	rjmp	.+814    	; 0x2494 <__stack+0x395>
    2166:	08 f4       	brcc	.+2      	; 0x216a <__stack+0x6b>
    2168:	4c c1       	rjmp	.+664    	; 0x2402 <__stack+0x303>
    216a:	08 97       	sbiw	r24, 0x08	; 8
    216c:	a1 05       	cpc	r26, r1
    216e:	b1 05       	cpc	r27, r1
    2170:	09 f0       	breq	.+2      	; 0x2174 <__stack+0x75>
    2172:	0c c2       	rjmp	.+1048   	; 0x258c <__stack+0x48d>
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2174:	fe 01       	movw	r30, r28
    2176:	eb 56       	subi	r30, 0x6B	; 107
    2178:	ff 4f       	sbci	r31, 0xFF	; 255
    217a:	81 e0       	ldi	r24, 0x01	; 1
    217c:	80 83       	st	Z, r24
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    217e:	88 e0       	ldi	r24, 0x08	; 8
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	a0 e0       	ldi	r26, 0x00	; 0
    2184:	b0 e8       	ldi	r27, 0x80	; 128
    2186:	8d 8b       	std	Y+21, r24	; 0x15
    2188:	9e 8b       	std	Y+22, r25	; 0x16
    218a:	af 8b       	std	Y+23, r26	; 0x17
    218c:	b8 8f       	std	Y+24, r27	; 0x18
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    218e:	80 e1       	ldi	r24, 0x10	; 16
    2190:	90 e0       	ldi	r25, 0x00	; 0
    2192:	a0 e0       	ldi	r26, 0x00	; 0
    2194:	b0 e0       	ldi	r27, 0x00	; 0
    2196:	89 8f       	std	Y+25, r24	; 0x19
    2198:	9a 8f       	std	Y+26, r25	; 0x1a
    219a:	ab 8f       	std	Y+27, r26	; 0x1b
    219c:	bc 8f       	std	Y+28, r27	; 0x1c
    219e:	93 c1       	rjmp	.+806    	; 0x24c6 <__stack+0x3c7>
	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    21a0:	fe 01       	movw	r30, r28
    21a2:	eb 56       	subi	r30, 0x6B	; 107
    21a4:	ff 4f       	sbci	r31, 0xFF	; 255
    21a6:	21 e0       	ldi	r18, 0x01	; 1
    21a8:	20 83       	st	Z, r18
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    21aa:	82 e0       	ldi	r24, 0x02	; 2
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	a0 e0       	ldi	r26, 0x00	; 0
    21b0:	b0 e8       	ldi	r27, 0x80	; 128
    21b2:	8d 8b       	std	Y+21, r24	; 0x15
    21b4:	9e 8b       	std	Y+22, r25	; 0x16
    21b6:	af 8b       	std	Y+23, r26	; 0x17
    21b8:	b8 8f       	std	Y+24, r27	; 0x18
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    21ba:	84 e3       	ldi	r24, 0x34	; 52
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	a0 e0       	ldi	r26, 0x00	; 0
    21c0:	b0 e0       	ldi	r27, 0x00	; 0
    21c2:	89 8f       	std	Y+25, r24	; 0x19
    21c4:	9a 8f       	std	Y+26, r25	; 0x1a
    21c6:	ab 8f       	std	Y+27, r26	; 0x1b
    21c8:	bc 8f       	std	Y+28, r27	; 0x1c
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    21ca:	19 a2       	std	Y+33, r1	; 0x21
    21cc:	1a a2       	std	Y+34, r1	; 0x22
    21ce:	1b a2       	std	Y+35, r1	; 0x23
    21d0:	1c a2       	std	Y+36, r1	; 0x24

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    21d2:	81 e0       	ldi	r24, 0x01	; 1
    21d4:	90 e0       	ldi	r25, 0x00	; 0
    21d6:	a0 e0       	ldi	r26, 0x00	; 0
    21d8:	b0 e0       	ldi	r27, 0x00	; 0
    21da:	8d a3       	std	Y+37, r24	; 0x25
    21dc:	9e a3       	std	Y+38, r25	; 0x26
    21de:	af a3       	std	Y+39, r26	; 0x27
    21e0:	b8 a7       	std	Y+40, r27	; 0x28
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    21e2:	19 a6       	std	Y+41, r1	; 0x29
    21e4:	1a a6       	std	Y+42, r1	; 0x2a
    21e6:	1b a6       	std	Y+43, r1	; 0x2b
    21e8:	1c a6       	std	Y+44, r1	; 0x2c
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    21ea:	8d a7       	std	Y+45, r24	; 0x2d
    21ec:	9e a7       	std	Y+46, r25	; 0x2e
    21ee:	af a7       	std	Y+47, r26	; 0x2f
    21f0:	b8 ab       	std	Y+48, r27	; 0x30
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    21f2:	19 aa       	std	Y+49, r1	; 0x31
    21f4:	1a aa       	std	Y+50, r1	; 0x32
    21f6:	1b aa       	std	Y+51, r1	; 0x33
    21f8:	1c aa       	std	Y+52, r1	; 0x34
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    21fa:	8d ab       	std	Y+53, r24	; 0x35
    21fc:	9e ab       	std	Y+54, r25	; 0x36
    21fe:	af ab       	std	Y+55, r26	; 0x37
    2200:	b8 af       	std	Y+56, r27	; 0x38
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    2202:	88 e0       	ldi	r24, 0x08	; 8
    2204:	96 e0       	ldi	r25, 0x06	; 6
    2206:	a0 e0       	ldi	r26, 0x00	; 0
    2208:	b0 e0       	ldi	r27, 0x00	; 0
    220a:	89 af       	std	Y+57, r24	; 0x39
    220c:	9a af       	std	Y+58, r25	; 0x3a
    220e:	ab af       	std	Y+59, r26	; 0x3b
    2210:	bc af       	std	Y+60, r27	; 0x3c
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    2212:	e8 55       	subi	r30, 0x58	; 88
    2214:	f1 09       	sbc	r31, r1
    2216:	10 82       	st	Z, r1
    2218:	11 82       	std	Z+1, r1	; 0x01
    221a:	12 82       	std	Z+2, r1	; 0x02
    221c:	13 82       	std	Z+3, r1	; 0x03
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    221e:	34 96       	adiw	r30, 0x04	; 4
    2220:	10 82       	st	Z, r1
    2222:	11 82       	std	Z+1, r1	; 0x01
    2224:	12 82       	std	Z+2, r1	; 0x02
    2226:	13 82       	std	Z+3, r1	; 0x03
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    2228:	34 96       	adiw	r30, 0x04	; 4
    222a:	10 82       	st	Z, r1
    222c:	11 82       	std	Z+1, r1	; 0x01
    222e:	12 82       	std	Z+2, r1	; 0x02
    2230:	13 82       	std	Z+3, r1	; 0x03

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    2232:	ca 56       	subi	r28, 0x6A	; 106
    2234:	df 4f       	sbci	r29, 0xFF	; 255
    2236:	28 83       	st	Y, r18
    2238:	a9 c1       	rjmp	.+850    	; 0x258c <__stack+0x48d>
			MessageHeader->MessageLength                = CPU_TO_LE32(0);

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    223a:	81 e0       	ldi	r24, 0x01	; 1
    223c:	fe 01       	movw	r30, r28
    223e:	eb 56       	subi	r30, 0x6B	; 107
    2240:	ff 4f       	sbci	r31, 0xFF	; 255
    2242:	80 83       	st	Z, r24

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    2244:	49 a1       	ldd	r20, Y+33	; 0x21
    2246:	5a a1       	ldd	r21, Y+34	; 0x22
    2248:	6b a1       	ldd	r22, Y+35	; 0x23
    224a:	7c a1       	ldd	r23, Y+36	; 0x24

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    224c:	ce 01       	movw	r24, r28
    224e:	8d 96       	adiw	r24, 0x2d	; 45
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    2250:	04 e0       	ldi	r16, 0x04	; 4
    2252:	10 e0       	ldi	r17, 0x00	; 0
    2254:	20 e0       	ldi	r18, 0x00	; 0
    2256:	30 e8       	ldi	r19, 0x80	; 128
    2258:	0d 8b       	std	Y+21, r16	; 0x15
    225a:	1e 8b       	std	Y+22, r17	; 0x16
    225c:	2f 8b       	std	Y+23, r18	; 0x17
    225e:	38 8f       	std	Y+24, r19	; 0x18
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2260:	4e 30       	cpi	r20, 0x0E	; 14
    2262:	f1 e0       	ldi	r31, 0x01	; 1
    2264:	5f 07       	cpc	r21, r31
    2266:	6f 07       	cpc	r22, r31
    2268:	71 05       	cpc	r23, r1
    226a:	09 f4       	brne	.+2      	; 0x226e <__stack+0x16f>
    226c:	b6 c0       	rjmp	.+364    	; 0x23da <__stack+0x2db>
    226e:	08 f0       	brcs	.+2      	; 0x2272 <__stack+0x173>
    2270:	56 c0       	rjmp	.+172    	; 0x231e <__stack+0x21f>
    2272:	46 30       	cpi	r20, 0x06	; 6
    2274:	e1 e0       	ldi	r30, 0x01	; 1
    2276:	5e 07       	cpc	r21, r30
    2278:	6e 07       	cpc	r22, r30
    227a:	71 05       	cpc	r23, r1
    227c:	09 f4       	brne	.+2      	; 0x2280 <__stack+0x181>
    227e:	a3 c0       	rjmp	.+326    	; 0x23c6 <__stack+0x2c7>
    2280:	e8 f4       	brcc	.+58     	; 0x22bc <__stack+0x1bd>
    2282:	42 30       	cpi	r20, 0x02	; 2
    2284:	21 e0       	ldi	r18, 0x01	; 1
    2286:	52 07       	cpc	r21, r18
    2288:	62 07       	cpc	r22, r18
    228a:	71 05       	cpc	r23, r1
    228c:	09 f4       	brne	.+2      	; 0x2290 <__stack+0x191>
    228e:	ad c0       	rjmp	.+346    	; 0x23ea <__stack+0x2eb>
    2290:	70 f4       	brcc	.+28     	; 0x22ae <__stack+0x1af>
    2292:	41 30       	cpi	r20, 0x01	; 1
    2294:	51 40       	sbci	r21, 0x01	; 1
    2296:	61 40       	sbci	r22, 0x01	; 1
    2298:	71 05       	cpc	r23, r1
    229a:	09 f0       	breq	.+2      	; 0x229e <__stack+0x19f>
    229c:	5f c1       	rjmp	.+702    	; 0x255c <__stack+0x45d>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    229e:	4c e6       	ldi	r20, 0x6C	; 108
    22a0:	50 e0       	ldi	r21, 0x00	; 0
    22a2:	6a ed       	ldi	r22, 0xDA	; 218
    22a4:	73 e0       	ldi	r23, 0x03	; 3
    22a6:	01 d3       	rcall	.+1538   	; 0x28aa <memcpy_P>
	(void)QuerySize;

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    22a8:	0c e6       	ldi	r16, 0x6C	; 108
    22aa:	10 e0       	ldi	r17, 0x00	; 0
    22ac:	3b c1       	rjmp	.+630    	; 0x2524 <__stack+0x425>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    22ae:	45 30       	cpi	r20, 0x05	; 5
    22b0:	51 40       	sbci	r21, 0x01	; 1
    22b2:	61 40       	sbci	r22, 0x01	; 1
    22b4:	71 05       	cpc	r23, r1
    22b6:	08 f4       	brcc	.+2      	; 0x22ba <__stack+0x1bb>
    22b8:	98 c0       	rjmp	.+304    	; 0x23ea <__stack+0x2eb>
    22ba:	50 c1       	rjmp	.+672    	; 0x255c <__stack+0x45d>
    22bc:	4c 30       	cpi	r20, 0x0C	; 12
    22be:	e1 e0       	ldi	r30, 0x01	; 1
    22c0:	5e 07       	cpc	r21, r30
    22c2:	6e 07       	cpc	r22, r30
    22c4:	71 05       	cpc	r23, r1
    22c6:	90 f4       	brcc	.+36     	; 0x22ec <__stack+0x1ed>
    22c8:	4a 30       	cpi	r20, 0x0A	; 10
    22ca:	f1 e0       	ldi	r31, 0x01	; 1
    22cc:	5f 07       	cpc	r21, r31
    22ce:	6f 07       	cpc	r22, r31
    22d0:	71 05       	cpc	r23, r1
    22d2:	08 f0       	brcs	.+2      	; 0x22d6 <__stack+0x1d7>
    22d4:	78 c0       	rjmp	.+240    	; 0x23c6 <__stack+0x2c7>
    22d6:	47 30       	cpi	r20, 0x07	; 7
    22d8:	51 40       	sbci	r21, 0x01	; 1
    22da:	61 40       	sbci	r22, 0x01	; 1
    22dc:	71 05       	cpc	r23, r1
    22de:	09 f0       	breq	.+2      	; 0x22e2 <__stack+0x1e3>
    22e0:	3d c1       	rjmp	.+634    	; 0x255c <__stack+0x45d>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    22e2:	80 ea       	ldi	r24, 0xA0	; 160
    22e4:	96 e8       	ldi	r25, 0x86	; 134
    22e6:	a1 e0       	ldi	r26, 0x01	; 1
    22e8:	b0 e0       	ldi	r27, 0x00	; 0
    22ea:	84 c0       	rjmp	.+264    	; 0x23f4 <__stack+0x2f5>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    22ec:	4c 30       	cpi	r20, 0x0C	; 12
    22ee:	e1 e0       	ldi	r30, 0x01	; 1
    22f0:	5e 07       	cpc	r21, r30
    22f2:	6e 07       	cpc	r22, r30
    22f4:	71 05       	cpc	r23, r1
    22f6:	09 f4       	brne	.+2      	; 0x22fa <__stack+0x1fb>
    22f8:	61 c0       	rjmp	.+194    	; 0x23bc <__stack+0x2bd>
    22fa:	4d 30       	cpi	r20, 0x0D	; 13
    22fc:	51 40       	sbci	r21, 0x01	; 1
    22fe:	61 40       	sbci	r22, 0x01	; 1
    2300:	71 05       	cpc	r23, r1
    2302:	09 f0       	breq	.+2      	; 0x2306 <__stack+0x207>
    2304:	2b c1       	rjmp	.+598    	; 0x255c <__stack+0x45d>

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    2306:	6d 85       	ldd	r22, Y+13	; 0x0d
    2308:	7e 85       	ldd	r23, Y+14	; 0x0e
    230a:	fb 01       	movw	r30, r22
    230c:	01 90       	ld	r0, Z+
    230e:	00 20       	and	r0, r0
    2310:	e9 f7       	brne	.-6      	; 0x230c <__stack+0x20d>
    2312:	8f 01       	movw	r16, r30
    2314:	06 1b       	sub	r16, r22

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    2316:	17 0b       	sbc	r17, r23
    2318:	a8 01       	movw	r20, r16
    231a:	fc d2       	rcall	.+1528   	; 0x2914 <memcpy>
    231c:	03 c1       	rjmp	.+518    	; 0x2524 <__stack+0x425>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    231e:	46 30       	cpi	r20, 0x06	; 6
    2320:	21 e0       	ldi	r18, 0x01	; 1
    2322:	52 07       	cpc	r21, r18
    2324:	22 e0       	ldi	r18, 0x02	; 2
    2326:	62 07       	cpc	r22, r18
    2328:	71 05       	cpc	r23, r1
    232a:	10 f5       	brcc	.+68     	; 0x2370 <__stack+0x271>
    232c:	41 30       	cpi	r20, 0x01	; 1
    232e:	81 e0       	ldi	r24, 0x01	; 1
    2330:	58 07       	cpc	r21, r24
    2332:	82 e0       	ldi	r24, 0x02	; 2
    2334:	68 07       	cpc	r22, r24
    2336:	71 05       	cpc	r23, r1
    2338:	08 f0       	brcs	.+2      	; 0x233c <__stack+0x23d>
    233a:	57 c0       	rjmp	.+174    	; 0x23ea <__stack+0x2eb>
    233c:	44 31       	cpi	r20, 0x14	; 20
    233e:	e1 e0       	ldi	r30, 0x01	; 1
    2340:	5e 07       	cpc	r21, r30
    2342:	6e 07       	cpc	r22, r30
    2344:	71 05       	cpc	r23, r1
    2346:	09 f4       	brne	.+2      	; 0x234a <__stack+0x24b>
    2348:	50 c0       	rjmp	.+160    	; 0x23ea <__stack+0x2eb>
    234a:	42 30       	cpi	r20, 0x02	; 2
    234c:	f2 e0       	ldi	r31, 0x02	; 2
    234e:	5f 07       	cpc	r21, r31
    2350:	f1 e0       	ldi	r31, 0x01	; 1
    2352:	6f 07       	cpc	r22, r31
    2354:	71 05       	cpc	r23, r1
    2356:	09 f4       	brne	.+2      	; 0x235a <__stack+0x25b>
    2358:	48 c0       	rjmp	.+144    	; 0x23ea <__stack+0x2eb>
    235a:	41 31       	cpi	r20, 0x11	; 17
    235c:	51 40       	sbci	r21, 0x01	; 1
    235e:	61 40       	sbci	r22, 0x01	; 1
    2360:	71 05       	cpc	r23, r1
    2362:	09 f0       	breq	.+2      	; 0x2366 <__stack+0x267>
    2364:	fb c0       	rjmp	.+502    	; 0x255c <__stack+0x45d>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    2366:	8c e5       	ldi	r24, 0x5C	; 92
    2368:	96 e0       	ldi	r25, 0x06	; 6
    236a:	a0 e0       	ldi	r26, 0x00	; 0
    236c:	b0 e0       	ldi	r27, 0x00	; 0
    236e:	42 c0       	rjmp	.+132    	; 0x23f4 <__stack+0x2f5>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2370:	44 30       	cpi	r20, 0x04	; 4
    2372:	e1 e0       	ldi	r30, 0x01	; 1
    2374:	5e 07       	cpc	r21, r30
    2376:	6e 07       	cpc	r22, r30
    2378:	7e 07       	cpc	r23, r30
    237a:	51 f1       	breq	.+84     	; 0x23d0 <__stack+0x2d1>
    237c:	a8 f4       	brcc	.+42     	; 0x23a8 <__stack+0x2a9>
    237e:	41 50       	subi	r20, 0x01	; 1
    2380:	51 40       	sbci	r21, 0x01	; 1
    2382:	61 40       	sbci	r22, 0x01	; 1
    2384:	71 40       	sbci	r23, 0x01	; 1
    2386:	42 30       	cpi	r20, 0x02	; 2
    2388:	51 05       	cpc	r21, r1
    238a:	61 05       	cpc	r22, r1
    238c:	71 05       	cpc	r23, r1
    238e:	08 f0       	brcs	.+2      	; 0x2392 <__stack+0x293>
    2390:	e5 c0       	rjmp	.+458    	; 0x255c <__stack+0x45d>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    2392:	26 e0       	ldi	r18, 0x06	; 6
    2394:	fe 01       	movw	r30, r28
    2396:	3f 96       	adiw	r30, 0x0f	; 15
    2398:	dc 01       	movw	r26, r24
    239a:	01 90       	ld	r0, Z+
    239c:	0d 92       	st	X+, r0
    239e:	2a 95       	dec	r18
    23a0:	e1 f7       	brne	.-8      	; 0x239a <__stack+0x29b>
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    23a2:	06 e0       	ldi	r16, 0x06	; 6
    23a4:	10 e0       	ldi	r17, 0x00	; 0
    23a6:	be c0       	rjmp	.+380    	; 0x2524 <__stack+0x425>
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    23a8:	41 50       	subi	r20, 0x01	; 1
    23aa:	51 40       	sbci	r21, 0x01	; 1
    23ac:	62 40       	sbci	r22, 0x02	; 2
    23ae:	71 40       	sbci	r23, 0x01	; 1
    23b0:	43 30       	cpi	r20, 0x03	; 3
    23b2:	51 05       	cpc	r21, r1
    23b4:	61 05       	cpc	r22, r1
    23b6:	71 05       	cpc	r23, r1
    23b8:	c0 f0       	brcs	.+48     	; 0x23ea <__stack+0x2eb>
    23ba:	d0 c0       	rjmp	.+416    	; 0x255c <__stack+0x45d>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    23bc:	8f ef       	ldi	r24, 0xFF	; 255
    23be:	9f ef       	ldi	r25, 0xFF	; 255
    23c0:	af ef       	ldi	r26, 0xFF	; 255
    23c2:	b0 e0       	ldi	r27, 0x00	; 0
    23c4:	17 c0       	rjmp	.+46     	; 0x23f4 <__stack+0x2f5>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    23c6:	8c ed       	ldi	r24, 0xDC	; 220
    23c8:	95 e0       	ldi	r25, 0x05	; 5
    23ca:	a0 e0       	ldi	r26, 0x00	; 0
    23cc:	b0 e0       	ldi	r27, 0x00	; 0
    23ce:	12 c0       	rjmp	.+36     	; 0x23f4 <__stack+0x2f5>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    23d0:	81 e0       	ldi	r24, 0x01	; 1
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	a0 e0       	ldi	r26, 0x00	; 0
    23d6:	b0 e0       	ldi	r27, 0x00	; 0
    23d8:	0d c0       	rjmp	.+26     	; 0x23f4 <__stack+0x2f5>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    23da:	fe 01       	movw	r30, r28
    23dc:	e9 56       	subi	r30, 0x69	; 105
    23de:	ff 4f       	sbci	r31, 0xFF	; 255
    23e0:	80 81       	ld	r24, Z
    23e2:	91 81       	ldd	r25, Z+1	; 0x01
    23e4:	a2 81       	ldd	r26, Z+2	; 0x02
    23e6:	b3 81       	ldd	r27, Z+3	; 0x03
    23e8:	05 c0       	rjmp	.+10     	; 0x23f4 <__stack+0x2f5>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    23ea:	1d a6       	std	Y+45, r1	; 0x2d
    23ec:	1e a6       	std	Y+46, r1	; 0x2e
    23ee:	1f a6       	std	Y+47, r1	; 0x2f
    23f0:	18 aa       	std	Y+48, r1	; 0x30
    23f2:	04 c0       	rjmp	.+8      	; 0x23fc <__stack+0x2fd>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    23f4:	8d a7       	std	Y+45, r24	; 0x2d
    23f6:	9e a7       	std	Y+46, r25	; 0x2e
    23f8:	af a7       	std	Y+47, r26	; 0x2f
    23fa:	b8 ab       	std	Y+48, r27	; 0x30
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    23fc:	04 e0       	ldi	r16, 0x04	; 4
    23fe:	10 e0       	ldi	r17, 0x00	; 0
    2400:	91 c0       	rjmp	.+290    	; 0x2524 <__stack+0x425>
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2402:	81 e0       	ldi	r24, 0x01	; 1
    2404:	fe 01       	movw	r30, r28
    2406:	eb 56       	subi	r30, 0x6B	; 107
    2408:	ff 4f       	sbci	r31, 0xFF	; 255
    240a:	80 83       	st	Z, r24

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    240c:	89 a1       	ldd	r24, Y+33	; 0x21
    240e:	9a a1       	ldd	r25, Y+34	; 0x22
    2410:	ab a1       	ldd	r26, Y+35	; 0x23
    2412:	bc a1       	ldd	r27, Y+36	; 0x24

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    2414:	45 e0       	ldi	r20, 0x05	; 5
    2416:	50 e0       	ldi	r21, 0x00	; 0
    2418:	60 e0       	ldi	r22, 0x00	; 0
    241a:	70 e8       	ldi	r23, 0x80	; 128
    241c:	4d 8b       	std	Y+21, r20	; 0x15
    241e:	5e 8b       	std	Y+22, r21	; 0x16
    2420:	6f 8b       	std	Y+23, r22	; 0x17
    2422:	78 8f       	std	Y+24, r23	; 0x18
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    2424:	40 e1       	ldi	r20, 0x10	; 16
    2426:	50 e0       	ldi	r21, 0x00	; 0
    2428:	60 e0       	ldi	r22, 0x00	; 0
    242a:	70 e0       	ldi	r23, 0x00	; 0
    242c:	49 8f       	std	Y+25, r20	; 0x19
    242e:	5a 8f       	std	Y+26, r21	; 0x1a
    2430:	6b 8f       	std	Y+27, r22	; 0x1b
    2432:	7c 8f       	std	Y+28, r23	; 0x1c
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    2434:	8e 30       	cpi	r24, 0x0E	; 14
    2436:	21 e0       	ldi	r18, 0x01	; 1
    2438:	92 07       	cpc	r25, r18
    243a:	a2 07       	cpc	r26, r18
    243c:	b1 05       	cpc	r27, r1
    243e:	51 f0       	breq	.+20     	; 0x2454 <__stack+0x355>
    2440:	83 30       	cpi	r24, 0x03	; 3
    2442:	91 40       	sbci	r25, 0x01	; 1
    2444:	a1 40       	sbci	r26, 0x01	; 1
    2446:	b1 40       	sbci	r27, 0x01	; 1
    2448:	e9 f0       	breq	.+58     	; 0x2484 <__stack+0x385>
			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    244a:	8b eb       	ldi	r24, 0xBB	; 187
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	a0 e0       	ldi	r26, 0x00	; 0
    2450:	b0 ec       	ldi	r27, 0xC0	; 192
    2452:	1b c0       	rjmp	.+54     	; 0x248a <__stack+0x38b>

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
    2454:	89 a5       	ldd	r24, Y+41	; 0x29
    2456:	9a a5       	ldd	r25, Y+42	; 0x2a
    2458:	ab a5       	ldd	r26, Y+43	; 0x2b
    245a:	bc a5       	ldd	r27, Y+44	; 0x2c
    245c:	08 96       	adiw	r24, 0x08	; 8
    245e:	a1 1d       	adc	r26, r1
    2460:	b1 1d       	adc	r27, r1
	(void)SetSize;

	switch (OId)
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    2462:	fe 01       	movw	r30, r28
    2464:	e8 0f       	add	r30, r24
    2466:	f9 1f       	adc	r31, r25
    2468:	85 89       	ldd	r24, Z+21	; 0x15
    246a:	96 89       	ldd	r25, Z+22	; 0x16
    246c:	a7 89       	ldd	r26, Z+23	; 0x17
    246e:	b0 8d       	ldd	r27, Z+24	; 0x18
    2470:	fe 01       	movw	r30, r28
    2472:	e9 56       	subi	r30, 0x69	; 105
    2474:	ff 4f       	sbci	r31, 0xFF	; 255
    2476:	80 83       	st	Z, r24
    2478:	91 83       	std	Z+1, r25	; 0x01
    247a:	a2 83       	std	Z+2, r26	; 0x02
    247c:	b3 83       	std	Z+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState   = le32_to_cpu((RNDISInterfaceInfo->State.CurrPacketFilter) ?
    247e:	82 e0       	ldi	r24, 0x02	; 2
    2480:	31 97       	sbiw	r30, 0x01	; 1
    2482:	80 83       	st	Z, r24
			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    2484:	80 e0       	ldi	r24, 0x00	; 0
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	dc 01       	movw	r26, r24
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    248a:	89 a3       	std	Y+33, r24	; 0x21
    248c:	9a a3       	std	Y+34, r25	; 0x22
    248e:	ab a3       	std	Y+35, r26	; 0x23
    2490:	bc a3       	std	Y+36, r27	; 0x24
    2492:	7c c0       	rjmp	.+248    	; 0x258c <__stack+0x48d>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2494:	fe 01       	movw	r30, r28
    2496:	eb 56       	subi	r30, 0x6B	; 107
    2498:	ff 4f       	sbci	r31, 0xFF	; 255
    249a:	81 e0       	ldi	r24, 0x01	; 1
    249c:	80 83       	st	Z, r24

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    249e:	86 e0       	ldi	r24, 0x06	; 6
    24a0:	90 e0       	ldi	r25, 0x00	; 0
    24a2:	a0 e0       	ldi	r26, 0x00	; 0
    24a4:	b0 e8       	ldi	r27, 0x80	; 128
    24a6:	8d 8b       	std	Y+21, r24	; 0x15
    24a8:	9e 8b       	std	Y+22, r25	; 0x16
    24aa:	af 8b       	std	Y+23, r26	; 0x17
    24ac:	b8 8f       	std	Y+24, r27	; 0x18
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    24ae:	80 e1       	ldi	r24, 0x10	; 16
    24b0:	90 e0       	ldi	r25, 0x00	; 0
    24b2:	a0 e0       	ldi	r26, 0x00	; 0
    24b4:	b0 e0       	ldi	r27, 0x00	; 0
    24b6:	89 8f       	std	Y+25, r24	; 0x19
    24b8:	9a 8f       	std	Y+26, r25	; 0x1a
    24ba:	ab 8f       	std	Y+27, r26	; 0x1b
    24bc:	bc 8f       	std	Y+28, r27	; 0x1c
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    24be:	1d 8e       	std	Y+29, r1	; 0x1d
    24c0:	1e 8e       	std	Y+30, r1	; 0x1e
    24c2:	1f 8e       	std	Y+31, r1	; 0x1f
    24c4:	18 a2       	std	Y+32, r1	; 0x20
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    24c6:	19 a2       	std	Y+33, r1	; 0x21
    24c8:	1a a2       	std	Y+34, r1	; 0x22
    24ca:	1b a2       	std	Y+35, r1	; 0x23
    24cc:	1c a2       	std	Y+36, r1	; 0x24
    24ce:	5e c0       	rjmp	.+188    	; 0x258c <__stack+0x48d>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    24d0:	80 91 01 14 	lds	r24, 0x1401	; 0x801401 <USB_ControlRequest>
    24d4:	81 3a       	cpi	r24, 0xA1	; 161
    24d6:	09 f0       	breq	.+2      	; 0x24da <__stack+0x3db>
    24d8:	59 c0       	rjmp	.+178    	; 0x258c <__stack+0x48d>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

				if (!(MessageHeader->MessageLength))
    24da:	81 8d       	ldd	r24, Z+25	; 0x19
    24dc:	92 8d       	ldd	r25, Z+26	; 0x1a
    24de:	a3 8d       	ldd	r26, Z+27	; 0x1b
    24e0:	b4 8d       	ldd	r27, Z+28	; 0x1c
    24e2:	89 2b       	or	r24, r25
    24e4:	8a 2b       	or	r24, r26
    24e6:	8b 2b       	or	r24, r27
    24e8:	49 f4       	brne	.+18     	; 0x24fc <__stack+0x3fd>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    24ea:	15 8a       	std	Z+21, r1	; 0x15
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	90 e0       	ldi	r25, 0x00	; 0
    24f0:	a0 e0       	ldi	r26, 0x00	; 0
    24f2:	b0 e0       	ldi	r27, 0x00	; 0
    24f4:	81 8f       	std	Z+25, r24	; 0x19
    24f6:	92 8f       	std	Z+26, r25	; 0x1a
    24f8:	a3 8f       	std	Z+27, r26	; 0x1b
    24fa:	b4 8f       	std	Z+28, r27	; 0x1c
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    24fc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2500:	87 7f       	andi	r24, 0xF7	; 247
    2502:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    2506:	69 8d       	ldd	r22, Y+25	; 0x19
    2508:	7a 8d       	ldd	r23, Y+26	; 0x1a
    250a:	ce 01       	movw	r24, r28
    250c:	45 96       	adiw	r24, 0x15	; 21
    250e:	7d db       	rcall	.-2310   	; 0x1c0a <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2510:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2514:	8b 77       	andi	r24, 0x7B	; 123
    2516:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    251a:	19 8e       	std	Y+25, r1	; 0x19
    251c:	1a 8e       	std	Y+26, r1	; 0x1a
    251e:	1b 8e       	std	Y+27, r1	; 0x1b
    2520:	1c 8e       	std	Y+28, r1	; 0x1c
    2522:	34 c0       	rjmp	.+104    	; 0x258c <__stack+0x48d>
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
			
			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2524:	19 a2       	std	Y+33, r1	; 0x21
    2526:	1a a2       	std	Y+34, r1	; 0x22
    2528:	1b a2       	std	Y+35, r1	; 0x23
    252a:	1c a2       	std	Y+36, r1	; 0x24
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    252c:	c8 01       	movw	r24, r16
    252e:	48 96       	adiw	r24, 0x18	; 24
    2530:	a0 e0       	ldi	r26, 0x00	; 0
    2532:	b0 e0       	ldi	r27, 0x00	; 0
    2534:	89 8f       	std	Y+25, r24	; 0x19
    2536:	9a 8f       	std	Y+26, r25	; 0x1a
    2538:	ab 8f       	std	Y+27, r26	; 0x1b
    253a:	bc 8f       	std	Y+28, r27	; 0x1c

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    253c:	a8 01       	movw	r20, r16
    253e:	60 e0       	ldi	r22, 0x00	; 0
    2540:	70 e0       	ldi	r23, 0x00	; 0
    2542:	4d a3       	std	Y+37, r20	; 0x25
    2544:	5e a3       	std	Y+38, r21	; 0x26
    2546:	6f a3       	std	Y+39, r22	; 0x27
    2548:	78 a7       	std	Y+40, r23	; 0x28
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    254a:	80 e1       	ldi	r24, 0x10	; 16
    254c:	90 e0       	ldi	r25, 0x00	; 0
    254e:	a0 e0       	ldi	r26, 0x00	; 0
    2550:	b0 e0       	ldi	r27, 0x00	; 0
    2552:	89 a7       	std	Y+41, r24	; 0x29
    2554:	9a a7       	std	Y+42, r25	; 0x2a
    2556:	ab a7       	std	Y+43, r26	; 0x2b
    2558:	bc a7       	std	Y+44, r27	; 0x2c
    255a:	18 c0       	rjmp	.+48     	; 0x258c <__stack+0x48d>
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    255c:	8b eb       	ldi	r24, 0xBB	; 187
    255e:	90 e0       	ldi	r25, 0x00	; 0
    2560:	a0 e0       	ldi	r26, 0x00	; 0
    2562:	b0 ec       	ldi	r27, 0xC0	; 192
    2564:	89 a3       	std	Y+33, r24	; 0x21
    2566:	9a a3       	std	Y+34, r25	; 0x22
    2568:	ab a3       	std	Y+35, r26	; 0x23
    256a:	bc a3       	std	Y+36, r27	; 0x24
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    256c:	88 e1       	ldi	r24, 0x18	; 24
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	a0 e0       	ldi	r26, 0x00	; 0
    2572:	b0 e0       	ldi	r27, 0x00	; 0
    2574:	89 8f       	std	Y+25, r24	; 0x19
    2576:	9a 8f       	std	Y+26, r25	; 0x1a
    2578:	ab 8f       	std	Y+27, r26	; 0x1b
    257a:	bc 8f       	std	Y+28, r27	; 0x1c

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    257c:	1d a2       	std	Y+37, r1	; 0x25
    257e:	1e a2       	std	Y+38, r1	; 0x26
    2580:	1f a2       	std	Y+39, r1	; 0x27
    2582:	18 a6       	std	Y+40, r1	; 0x28
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    2584:	19 a6       	std	Y+41, r1	; 0x29
    2586:	1a a6       	std	Y+42, r1	; 0x2a
    2588:	1b a6       	std	Y+43, r1	; 0x2b
    258a:	1c a6       	std	Y+44, r1	; 0x2c
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    258c:	df 91       	pop	r29
    258e:	cf 91       	pop	r28
    2590:	1f 91       	pop	r17
    2592:	0f 91       	pop	r16
    2594:	08 95       	ret

00002596 <RNDIS_Device_ConfigureEndpoints>:

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    2596:	1f 93       	push	r17
    2598:	cf 93       	push	r28
    259a:	df 93       	push	r29
    259c:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    259e:	fc 01       	movw	r30, r24
    25a0:	75 96       	adiw	r30, 0x15	; 21
    25a2:	86 e8       	ldi	r24, 0x86	; 134
    25a4:	df 01       	movw	r26, r30
    25a6:	1d 92       	st	X+, r1
    25a8:	8a 95       	dec	r24
    25aa:	e9 f7       	brne	.-6      	; 0x25a6 <RNDIS_Device_ConfigureEndpoints+0x10>

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    25ac:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
    25ae:	89 81       	ldd	r24, Y+1	; 0x01
    25b0:	81 13       	cpse	r24, r17
    25b2:	05 c0       	rjmp	.+10     	; 0x25be <RNDIS_Device_ConfigureEndpoints+0x28>
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
    25b4:	ea 81       	ldd	r30, Y+2	; 0x02
    25b6:	fb 81       	ldd	r31, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
    25b8:	9c 81       	ldd	r25, Y+4	; 0x04
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
			Direction    = ENDPOINT_DIR_IN;
    25ba:	20 e8       	ldi	r18, 0x80	; 128
    25bc:	07 c0       	rjmp	.+14     	; 0x25cc <RNDIS_Device_ConfigureEndpoints+0x36>
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
    25be:	8d 81       	ldd	r24, Y+5	; 0x05
    25c0:	81 13       	cpse	r24, r17
    25c2:	06 c0       	rjmp	.+12     	; 0x25d0 <RNDIS_Device_ConfigureEndpoints+0x3a>
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
    25c4:	ee 81       	ldd	r30, Y+6	; 0x06
    25c6:	ff 81       	ldd	r31, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    25c8:	98 85       	ldd	r25, Y+8	; 0x08
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
			Direction    = ENDPOINT_DIR_OUT;
    25ca:	20 e0       	ldi	r18, 0x00	; 0
			Type         = EP_TYPE_BULK;
    25cc:	82 e0       	ldi	r24, 0x02	; 2
    25ce:	0d c0       	rjmp	.+26     	; 0x25ea <RNDIS_Device_ConfigureEndpoints+0x54>
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
    25d0:	89 85       	ldd	r24, Y+9	; 0x09
    25d2:	81 17       	cp	r24, r17
    25d4:	29 f0       	breq	.+10     	; 0x25e0 <RNDIS_Device_ConfigureEndpoints+0x4a>

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    25d6:	1f 5f       	subi	r17, 0xFF	; 255
    25d8:	17 30       	cpi	r17, 0x07	; 7
    25da:	49 f7       	brne	.-46     	; 0x25ae <RNDIS_Device_ConfigureEndpoints+0x18>
		{
			return false;
		}
	}

	return true;
    25dc:	81 e0       	ldi	r24, 0x01	; 1
    25de:	22 c0       	rjmp	.+68     	; 0x2624 <RNDIS_Device_ConfigureEndpoints+0x8e>
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
    25e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    25e2:	fb 85       	ldd	r31, Y+11	; 0x0b
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_INTERRUPT;
			DoubleBanked = RNDISInterfaceInfo->Config.NotificationEndpointDoubleBank;
    25e4:	9c 85       	ldd	r25, Y+12	; 0x0c
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
			Direction    = ENDPOINT_DIR_IN;
    25e6:	20 e8       	ldi	r18, 0x80	; 128
			Type         = EP_TYPE_INTERRUPT;
    25e8:	83 e0       	ldi	r24, 0x03	; 3
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    25ea:	91 11       	cpse	r25, r1
    25ec:	94 e0       	ldi	r25, 0x04	; 4
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    25ee:	68 e0       	ldi	r22, 0x08	; 8
    25f0:	70 e0       	ldi	r23, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    25f2:	40 e0       	ldi	r20, 0x00	; 0
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    25f4:	6e 17       	cp	r22, r30
    25f6:	7f 07       	cpc	r23, r31
    25f8:	20 f4       	brcc	.+8      	; 0x2602 <RNDIS_Device_ConfigureEndpoints+0x6c>
				{
					MaskVal++;
    25fa:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    25fc:	66 0f       	add	r22, r22
    25fe:	77 1f       	adc	r23, r23
    2600:	f9 cf       	rjmp	.-14     	; 0x25f4 <RNDIS_Device_ConfigureEndpoints+0x5e>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    2602:	42 95       	swap	r20
    2604:	40 7f       	andi	r20, 0xF0	; 240
    2606:	92 60       	ori	r25, 0x02	; 2
    2608:	49 2b       	or	r20, r25
    260a:	b0 e4       	ldi	r27, 0x40	; 64
    260c:	8b 9f       	mul	r24, r27
    260e:	c0 01       	movw	r24, r0
    2610:	11 24       	eor	r1, r1
    2612:	61 e0       	ldi	r22, 0x01	; 1
    2614:	21 11       	cpse	r18, r1
    2616:	01 c0       	rjmp	.+2      	; 0x261a <RNDIS_Device_ConfigureEndpoints+0x84>
    2618:	60 e0       	ldi	r22, 0x00	; 0
    261a:	68 2b       	or	r22, r24
    261c:	81 2f       	mov	r24, r17
    261e:	b6 d8       	rcall	.-3732   	; 0x178c <Endpoint_ConfigureEndpoint_Prv>
    2620:	81 11       	cpse	r24, r1
    2622:	d9 cf       	rjmp	.-78     	; 0x25d6 <RNDIS_Device_ConfigureEndpoints+0x40>
			return false;
		}
	}

	return true;
}
    2624:	df 91       	pop	r29
    2626:	cf 91       	pop	r28
    2628:	1f 91       	pop	r17
    262a:	08 95       	ret

0000262c <RNDIS_Device_USBTask>:

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    262c:	0f 93       	push	r16
    262e:	1f 93       	push	r17
    2630:	cf 93       	push	r28
    2632:	df 93       	push	r29
    2634:	cd b7       	in	r28, 0x3d	; 61
    2636:	de b7       	in	r29, 0x3e	; 62
    2638:	28 97       	sbiw	r28, 0x08	; 8
    263a:	0f b6       	in	r0, 0x3f	; 63
    263c:	f8 94       	cli
    263e:	de bf       	out	0x3e, r29	; 62
    2640:	0f be       	out	0x3f, r0	; 63
    2642:	cd bf       	out	0x3d, r28	; 61
	if (USB_DeviceState != DEVICE_STATE_Configured)
    2644:	20 91 00 14 	lds	r18, 0x1400	; 0x801400 <USB_DeviceState>
    2648:	24 30       	cpi	r18, 0x04	; 4
    264a:	31 f5       	brne	.+76     	; 0x2698 <RNDIS_Device_USBTask+0x6c>
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpointNumber);
    264c:	fc 01       	movw	r30, r24
    264e:	21 85       	ldd	r18, Z+9	; 0x09
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2650:	20 93 e9 00 	sts	0x00E9, r18	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2654:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    2658:	20 ff       	sbrs	r18, 0
    265a:	1e c0       	rjmp	.+60     	; 0x2698 <RNDIS_Device_USBTask+0x6c>
    265c:	8c 01       	movw	r16, r24
    265e:	0b 56       	subi	r16, 0x6B	; 107
    2660:	1f 4f       	sbci	r17, 0xFF	; 255
    2662:	f8 01       	movw	r30, r16
    2664:	80 81       	ld	r24, Z
    2666:	88 23       	and	r24, r24
    2668:	b9 f0       	breq	.+46     	; 0x2698 <RNDIS_Device_USBTask+0x6c>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    266a:	88 e0       	ldi	r24, 0x08	; 8
    266c:	e9 eb       	ldi	r30, 0xB9	; 185
    266e:	f1 e0       	ldi	r31, 0x01	; 1
    2670:	de 01       	movw	r26, r28
    2672:	11 96       	adiw	r26, 0x01	; 1
    2674:	01 90       	ld	r0, Z+
    2676:	0d 92       	st	X+, r0
    2678:	8a 95       	dec	r24
    267a:	e1 f7       	brne	.-8      	; 0x2674 <RNDIS_Device_USBTask+0x48>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    267c:	40 e0       	ldi	r20, 0x00	; 0
    267e:	50 e0       	ldi	r21, 0x00	; 0
    2680:	68 e0       	ldi	r22, 0x08	; 8
    2682:	70 e0       	ldi	r23, 0x00	; 0
    2684:	ce 01       	movw	r24, r28
    2686:	01 96       	adiw	r24, 0x01	; 1
    2688:	2c da       	rcall	.-2984   	; 0x1ae2 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    268a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    268e:	8e 77       	andi	r24, 0x7E	; 126
    2690:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    2694:	f8 01       	movw	r30, r16
    2696:	10 82       	st	Z, r1
	}
}
    2698:	28 96       	adiw	r28, 0x08	; 8
    269a:	0f b6       	in	r0, 0x3f	; 63
    269c:	f8 94       	cli
    269e:	de bf       	out	0x3e, r29	; 62
    26a0:	0f be       	out	0x3f, r0	; 63
    26a2:	cd bf       	out	0x3d, r28	; 61
    26a4:	df 91       	pop	r29
    26a6:	cf 91       	pop	r28
    26a8:	1f 91       	pop	r17
    26aa:	0f 91       	pop	r16
    26ac:	08 95       	ret

000026ae <RNDIS_Device_IsPacketReceived>:
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    26ae:	20 91 00 14 	lds	r18, 0x1400	; 0x801400 <USB_DeviceState>
    26b2:	24 30       	cpi	r18, 0x04	; 4
    26b4:	81 f4       	brne	.+32     	; 0x26d6 <RNDIS_Device_IsPacketReceived+0x28>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    26b6:	fc 01       	movw	r30, r24
    26b8:	ea 56       	subi	r30, 0x6A	; 106
    26ba:	ff 4f       	sbci	r31, 0xFF	; 255
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    26bc:	20 81       	ld	r18, Z
    26be:	22 30       	cpi	r18, 0x02	; 2
    26c0:	51 f4       	brne	.+20     	; 0x26d6 <RNDIS_Device_IsPacketReceived+0x28>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    26c2:	fc 01       	movw	r30, r24
    26c4:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    26c6:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    26ca:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    26ce:	82 fb       	bst	r24, 2
    26d0:	88 27       	eor	r24, r24
    26d2:	80 f9       	bld	r24, 0
	return Endpoint_IsOUTReceived();
    26d4:	08 95       	ret
bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    26d6:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
	return Endpoint_IsOUTReceived();
}
    26d8:	08 95       	ret

000026da <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    26da:	ef 92       	push	r14
    26dc:	ff 92       	push	r15
    26de:	0f 93       	push	r16
    26e0:	1f 93       	push	r17
    26e2:	cf 93       	push	r28
    26e4:	df 93       	push	r29
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	ac 97       	sbiw	r28, 0x2c	; 44
    26ec:	0f b6       	in	r0, 0x3f	; 63
    26ee:	f8 94       	cli
    26f0:	de bf       	out	0x3e, r29	; 62
    26f2:	0f be       	out	0x3f, r0	; 63
    26f4:	cd bf       	out	0x3d, r28	; 61
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    26f6:	20 91 00 14 	lds	r18, 0x1400	; 0x801400 <USB_DeviceState>
    26fa:	24 30       	cpi	r18, 0x04	; 4
    26fc:	d9 f5       	brne	.+118    	; 0x2774 <RNDIS_Device_ReadPacket+0x9a>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    26fe:	fc 01       	movw	r30, r24
    2700:	ea 56       	subi	r30, 0x6A	; 106
    2702:	ff 4f       	sbci	r31, 0xFF	; 255

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2704:	20 81       	ld	r18, Z
    2706:	22 30       	cpi	r18, 0x02	; 2
    2708:	a9 f5       	brne	.+106    	; 0x2774 <RNDIS_Device_ReadPacket+0x9a>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    270a:	fc 01       	movw	r30, r24
    270c:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    270e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
	
	*PacketLength = 0;
    2712:	fa 01       	movw	r30, r20
    2714:	11 82       	std	Z+1, r1	; 0x01
    2716:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2718:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (!(Endpoint_IsOUTReceived()))
    271c:	89 2f       	mov	r24, r25
    271e:	84 70       	andi	r24, 0x04	; 4
    2720:	92 ff       	sbrs	r25, 2
    2722:	29 c0       	rjmp	.+82     	; 0x2776 <RNDIS_Device_ReadPacket+0x9c>
    2724:	8a 01       	movw	r16, r20
    2726:	7b 01       	movw	r14, r22
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;	
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2728:	40 e0       	ldi	r20, 0x00	; 0
    272a:	50 e0       	ldi	r21, 0x00	; 0
    272c:	6c e2       	ldi	r22, 0x2C	; 44
    272e:	70 e0       	ldi	r23, 0x00	; 0
    2730:	ce 01       	movw	r24, r28
    2732:	01 96       	adiw	r24, 0x01	; 1
    2734:	20 da       	rcall	.-3008   	; 0x1b76 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    2736:	6d 85       	ldd	r22, Y+13	; 0x0d
    2738:	7e 85       	ldd	r23, Y+14	; 0x0e
    273a:	8f 85       	ldd	r24, Y+15	; 0x0f
    273c:	98 89       	ldd	r25, Y+16	; 0x10
    273e:	6d 3d       	cpi	r22, 0xDD	; 221
    2740:	f5 e0       	ldi	r31, 0x05	; 5
    2742:	7f 07       	cpc	r23, r31
    2744:	81 05       	cpc	r24, r1
    2746:	91 05       	cpc	r25, r1
    2748:	38 f0       	brcs	.+14     	; 0x2758 <RNDIS_Device_ReadPacket+0x7e>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    274a:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    274e:	80 62       	ori	r24, 0x20	; 32
    2750:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    2754:	80 e8       	ldi	r24, 0x80	; 128
    2756:	0f c0       	rjmp	.+30     	; 0x2776 <RNDIS_Device_ReadPacket+0x9c>
	}
	
	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    2758:	f8 01       	movw	r30, r16
    275a:	71 83       	std	Z+1, r23	; 0x01
    275c:	60 83       	st	Z, r22

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    275e:	40 e0       	ldi	r20, 0x00	; 0
    2760:	50 e0       	ldi	r21, 0x00	; 0
    2762:	c7 01       	movw	r24, r14
    2764:	08 da       	rcall	.-3056   	; 0x1b76 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2766:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    276a:	8b 77       	andi	r24, 0x7B	; 123
    276c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearOUT();
	
	return ENDPOINT_RWSTREAM_NoError;
    2770:	80 e0       	ldi	r24, 0x00	; 0
    2772:	01 c0       	rjmp	.+2      	; 0x2776 <RNDIS_Device_ReadPacket+0x9c>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    2774:	82 e0       	ldi	r24, 0x02	; 2

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();
	
	return ENDPOINT_RWSTREAM_NoError;
}
    2776:	ac 96       	adiw	r28, 0x2c	; 44
    2778:	0f b6       	in	r0, 0x3f	; 63
    277a:	f8 94       	cli
    277c:	de bf       	out	0x3e, r29	; 62
    277e:	0f be       	out	0x3f, r0	; 63
    2780:	cd bf       	out	0x3d, r28	; 61
    2782:	df 91       	pop	r29
    2784:	cf 91       	pop	r28
    2786:	1f 91       	pop	r17
    2788:	0f 91       	pop	r16
    278a:	ff 90       	pop	r15
    278c:	ef 90       	pop	r14
    278e:	08 95       	ret

00002790 <RNDIS_Device_SendPacket>:

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    2790:	ef 92       	push	r14
    2792:	ff 92       	push	r15
    2794:	0f 93       	push	r16
    2796:	1f 93       	push	r17
    2798:	cf 93       	push	r28
    279a:	df 93       	push	r29
    279c:	cd b7       	in	r28, 0x3d	; 61
    279e:	de b7       	in	r29, 0x3e	; 62
    27a0:	ac 97       	sbiw	r28, 0x2c	; 44
    27a2:	0f b6       	in	r0, 0x3f	; 63
    27a4:	f8 94       	cli
    27a6:	de bf       	out	0x3e, r29	; 62
    27a8:	0f be       	out	0x3f, r0	; 63
    27aa:	cd bf       	out	0x3d, r28	; 61
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    27ac:	20 91 00 14 	lds	r18, 0x1400	; 0x801400 <USB_DeviceState>
    27b0:	24 30       	cpi	r18, 0x04	; 4
    27b2:	09 f0       	breq	.+2      	; 0x27b6 <RNDIS_Device_SendPacket+0x26>
    27b4:	48 c0       	rjmp	.+144    	; 0x2846 <RNDIS_Device_SendPacket+0xb6>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    27b6:	fc 01       	movw	r30, r24
    27b8:	ea 56       	subi	r30, 0x6A	; 106
    27ba:	ff 4f       	sbci	r31, 0xFF	; 255
                                void* Buffer,
                                const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    27bc:	20 81       	ld	r18, Z
    27be:	22 30       	cpi	r18, 0x02	; 2
    27c0:	09 f0       	breq	.+2      	; 0x27c4 <RNDIS_Device_SendPacket+0x34>
    27c2:	41 c0       	rjmp	.+130    	; 0x2846 <RNDIS_Device_SendPacket+0xb6>
    27c4:	8a 01       	movw	r16, r20
    27c6:	7b 01       	movw	r14, r22
    27c8:	fc 01       	movw	r30, r24
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpointNumber);
    27ca:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    27cc:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    27d0:	30 d8       	rcall	.-4000   	; 0x1832 <Endpoint_WaitUntilReady>
    27d2:	81 11       	cpse	r24, r1
    27d4:	39 c0       	rjmp	.+114    	; 0x2848 <RNDIS_Device_SendPacket+0xb8>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    27d6:	ce 01       	movw	r24, r28
    27d8:	01 96       	adiw	r24, 0x01	; 1
    27da:	2c e2       	ldi	r18, 0x2C	; 44
    27dc:	fc 01       	movw	r30, r24
    27de:	11 92       	st	Z+, r1
    27e0:	2a 95       	dec	r18
    27e2:	e9 f7       	brne	.-6      	; 0x27de <RNDIS_Device_SendPacket+0x4e>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    27e4:	41 e0       	ldi	r20, 0x01	; 1
    27e6:	50 e0       	ldi	r21, 0x00	; 0
    27e8:	60 e0       	ldi	r22, 0x00	; 0
    27ea:	70 e0       	ldi	r23, 0x00	; 0
    27ec:	49 83       	std	Y+1, r20	; 0x01
    27ee:	5a 83       	std	Y+2, r21	; 0x02
    27f0:	6b 83       	std	Y+3, r22	; 0x03
    27f2:	7c 83       	std	Y+4, r23	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    27f4:	a8 01       	movw	r20, r16
    27f6:	44 5d       	subi	r20, 0xD4	; 212
    27f8:	5f 4f       	sbci	r21, 0xFF	; 255
    27fa:	60 e0       	ldi	r22, 0x00	; 0
    27fc:	70 e0       	ldi	r23, 0x00	; 0
    27fe:	4d 83       	std	Y+5, r20	; 0x05
    2800:	5e 83       	std	Y+6, r21	; 0x06
    2802:	6f 83       	std	Y+7, r22	; 0x07
    2804:	78 87       	std	Y+8, r23	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    2806:	44 e2       	ldi	r20, 0x24	; 36
    2808:	50 e0       	ldi	r21, 0x00	; 0
    280a:	60 e0       	ldi	r22, 0x00	; 0
    280c:	70 e0       	ldi	r23, 0x00	; 0
    280e:	49 87       	std	Y+9, r20	; 0x09
    2810:	5a 87       	std	Y+10, r21	; 0x0a
    2812:	6b 87       	std	Y+11, r22	; 0x0b
    2814:	7c 87       	std	Y+12, r23	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    2816:	a8 01       	movw	r20, r16
    2818:	60 e0       	ldi	r22, 0x00	; 0
    281a:	70 e0       	ldi	r23, 0x00	; 0
    281c:	4d 87       	std	Y+13, r20	; 0x0d
    281e:	5e 87       	std	Y+14, r21	; 0x0e
    2820:	6f 87       	std	Y+15, r22	; 0x0f
    2822:	78 8b       	std	Y+16, r23	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2824:	40 e0       	ldi	r20, 0x00	; 0
    2826:	50 e0       	ldi	r21, 0x00	; 0
    2828:	6c e2       	ldi	r22, 0x2C	; 44
    282a:	70 e0       	ldi	r23, 0x00	; 0
    282c:	5a d9       	rcall	.-3404   	; 0x1ae2 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    282e:	40 e0       	ldi	r20, 0x00	; 0
    2830:	50 e0       	ldi	r21, 0x00	; 0
    2832:	b8 01       	movw	r22, r16
    2834:	c7 01       	movw	r24, r14
    2836:	55 d9       	rcall	.-3414   	; 0x1ae2 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2838:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    283c:	8e 77       	andi	r24, 0x7E	; 126
    283e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    2842:	80 e0       	ldi	r24, 0x00	; 0
    2844:	01 c0       	rjmp	.+2      	; 0x2848 <RNDIS_Device_SendPacket+0xb8>
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    2846:	82 e0       	ldi	r24, 0x02	; 2
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    2848:	ac 96       	adiw	r28, 0x2c	; 44
    284a:	0f b6       	in	r0, 0x3f	; 63
    284c:	f8 94       	cli
    284e:	de bf       	out	0x3e, r29	; 62
    2850:	0f be       	out	0x3f, r0	; 63
    2852:	cd bf       	out	0x3d, r28	; 61
    2854:	df 91       	pop	r29
    2856:	cf 91       	pop	r28
    2858:	1f 91       	pop	r17
    285a:	0f 91       	pop	r16
    285c:	ff 90       	pop	r15
    285e:	ef 90       	pop	r14
    2860:	08 95       	ret

00002862 <Serial_putchar>:
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2862:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
    2866:	95 ff       	sbrs	r25, 5
    2868:	fc cf       	rjmp	.-8      	; 0x2862 <Serial_putchar>
				UDR1 = DataByte;
    286a:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
{
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    286e:	80 e0       	ldi	r24, 0x00	; 0
    2870:	90 e0       	ldi	r25, 0x00	; 0
    2872:	08 95       	ret

00002874 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2874:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2878:	87 ff       	sbrs	r24, 7
    287a:	08 c0       	rjmp	.+16     	; 0x288c <Serial_getchar+0x18>
    287c:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2880:	87 ff       	sbrs	r24, 7
    2882:	07 c0       	rjmp	.+14     	; 0x2892 <Serial_getchar+0x1e>
				  return -1;
				
				return UDR1;
    2884:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    2888:	90 e0       	ldi	r25, 0x00	; 0
    288a:	08 95       	ret
	  return _FDEV_EOF;
    288c:	8e ef       	ldi	r24, 0xFE	; 254
    288e:	9f ef       	ldi	r25, 0xFF	; 255
    2890:	08 95       	ret
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
				  return -1;
    2892:	8f ef       	ldi	r24, 0xFF	; 255
    2894:	9f ef       	ldi	r25, 0xFF	; 255

	return Serial_ReceiveByte();
}
    2896:	08 95       	ret

00002898 <__tablejump2__>:
    2898:	ee 0f       	add	r30, r30
    289a:	ff 1f       	adc	r31, r31
    289c:	00 24       	eor	r0, r0
    289e:	00 1c       	adc	r0, r0
    28a0:	0b be       	out	0x3b, r0	; 59
    28a2:	07 90       	elpm	r0, Z+
    28a4:	f6 91       	elpm	r31, Z
    28a6:	e0 2d       	mov	r30, r0
    28a8:	09 94       	ijmp

000028aa <memcpy_P>:
    28aa:	fb 01       	movw	r30, r22
    28ac:	dc 01       	movw	r26, r24
    28ae:	02 c0       	rjmp	.+4      	; 0x28b4 <memcpy_P+0xa>
    28b0:	05 90       	lpm	r0, Z+
    28b2:	0d 92       	st	X+, r0
    28b4:	41 50       	subi	r20, 0x01	; 1
    28b6:	50 40       	sbci	r21, 0x00	; 0
    28b8:	d8 f7       	brcc	.-10     	; 0x28b0 <memcpy_P+0x6>
    28ba:	08 95       	ret

000028bc <strcpy_P>:
    28bc:	fb 01       	movw	r30, r22
    28be:	dc 01       	movw	r26, r24
    28c0:	05 90       	lpm	r0, Z+
    28c2:	0d 92       	st	X+, r0
    28c4:	00 20       	and	r0, r0
    28c6:	e1 f7       	brne	.-8      	; 0x28c0 <strcpy_P+0x4>
    28c8:	08 95       	ret

000028ca <__strlen_P>:
    28ca:	fc 01       	movw	r30, r24
    28cc:	05 90       	lpm	r0, Z+
    28ce:	00 20       	and	r0, r0
    28d0:	e9 f7       	brne	.-6      	; 0x28cc <__strlen_P+0x2>
    28d2:	80 95       	com	r24
    28d4:	90 95       	com	r25
    28d6:	8e 0f       	add	r24, r30
    28d8:	9f 1f       	adc	r25, r31
    28da:	08 95       	ret

000028dc <strncpy_P>:
    28dc:	fb 01       	movw	r30, r22
    28de:	dc 01       	movw	r26, r24
    28e0:	41 50       	subi	r20, 0x01	; 1
    28e2:	50 40       	sbci	r21, 0x00	; 0
    28e4:	48 f0       	brcs	.+18     	; 0x28f8 <strncpy_P+0x1c>
    28e6:	05 90       	lpm	r0, Z+
    28e8:	0d 92       	st	X+, r0
    28ea:	00 20       	and	r0, r0
    28ec:	c9 f7       	brne	.-14     	; 0x28e0 <strncpy_P+0x4>
    28ee:	01 c0       	rjmp	.+2      	; 0x28f2 <strncpy_P+0x16>
    28f0:	1d 92       	st	X+, r1
    28f2:	41 50       	subi	r20, 0x01	; 1
    28f4:	50 40       	sbci	r21, 0x00	; 0
    28f6:	e0 f7       	brcc	.-8      	; 0x28f0 <strncpy_P+0x14>
    28f8:	08 95       	ret

000028fa <memcmp>:
    28fa:	fb 01       	movw	r30, r22
    28fc:	dc 01       	movw	r26, r24
    28fe:	04 c0       	rjmp	.+8      	; 0x2908 <memcmp+0xe>
    2900:	8d 91       	ld	r24, X+
    2902:	01 90       	ld	r0, Z+
    2904:	80 19       	sub	r24, r0
    2906:	21 f4       	brne	.+8      	; 0x2910 <memcmp+0x16>
    2908:	41 50       	subi	r20, 0x01	; 1
    290a:	50 40       	sbci	r21, 0x00	; 0
    290c:	c8 f7       	brcc	.-14     	; 0x2900 <memcmp+0x6>
    290e:	88 1b       	sub	r24, r24
    2910:	99 0b       	sbc	r25, r25
    2912:	08 95       	ret

00002914 <memcpy>:
    2914:	fb 01       	movw	r30, r22
    2916:	dc 01       	movw	r26, r24
    2918:	02 c0       	rjmp	.+4      	; 0x291e <memcpy+0xa>
    291a:	01 90       	ld	r0, Z+
    291c:	0d 92       	st	X+, r0
    291e:	41 50       	subi	r20, 0x01	; 1
    2920:	50 40       	sbci	r21, 0x00	; 0
    2922:	d8 f7       	brcc	.-10     	; 0x291a <memcpy+0x6>
    2924:	08 95       	ret

00002926 <memmove>:
    2926:	68 17       	cp	r22, r24
    2928:	79 07       	cpc	r23, r25
    292a:	68 f4       	brcc	.+26     	; 0x2946 <memmove+0x20>
    292c:	fb 01       	movw	r30, r22
    292e:	dc 01       	movw	r26, r24
    2930:	e4 0f       	add	r30, r20
    2932:	f5 1f       	adc	r31, r21
    2934:	a4 0f       	add	r26, r20
    2936:	b5 1f       	adc	r27, r21
    2938:	02 c0       	rjmp	.+4      	; 0x293e <memmove+0x18>
    293a:	02 90       	ld	r0, -Z
    293c:	0e 92       	st	-X, r0
    293e:	41 50       	subi	r20, 0x01	; 1
    2940:	50 40       	sbci	r21, 0x00	; 0
    2942:	d8 f7       	brcc	.-10     	; 0x293a <memmove+0x14>
    2944:	08 95       	ret
    2946:	e6 cf       	rjmp	.-52     	; 0x2914 <memcpy>

00002948 <strncmp>:
    2948:	fb 01       	movw	r30, r22
    294a:	dc 01       	movw	r26, r24
    294c:	41 50       	subi	r20, 0x01	; 1
    294e:	50 40       	sbci	r21, 0x00	; 0
    2950:	30 f0       	brcs	.+12     	; 0x295e <strncmp+0x16>
    2952:	8d 91       	ld	r24, X+
    2954:	01 90       	ld	r0, Z+
    2956:	80 19       	sub	r24, r0
    2958:	19 f4       	brne	.+6      	; 0x2960 <strncmp+0x18>
    295a:	00 20       	and	r0, r0
    295c:	b9 f7       	brne	.-18     	; 0x294c <strncmp+0x4>
    295e:	88 1b       	sub	r24, r24
    2960:	99 0b       	sbc	r25, r25
    2962:	08 95       	ret

00002964 <_exit>:
    2964:	f8 94       	cli

00002966 <__stop_program>:
    2966:	ff cf       	rjmp	.-2      	; 0x2966 <__stop_program>
