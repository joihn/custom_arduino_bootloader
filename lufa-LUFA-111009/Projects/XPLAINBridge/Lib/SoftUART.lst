   1               		.file	"SoftUART.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.SoftUART_Init,"ax",@progbits
  12               	.global	SoftUART_Init
  14               	SoftUART_Init:
  15               	.LFB136:
  16               		.file 1 "Lib/SoftUART.c"
   1:Lib/SoftUART.c **** /*
   2:Lib/SoftUART.c ****              LUFA Library
   3:Lib/SoftUART.c ****      Copyright (C) Dean Camera, 2011.
   4:Lib/SoftUART.c **** 
   5:Lib/SoftUART.c ****   dean [at] fourwalledcubicle [dot] com
   6:Lib/SoftUART.c ****            www.lufa-lib.org
   7:Lib/SoftUART.c **** */
   8:Lib/SoftUART.c **** 
   9:Lib/SoftUART.c **** /*
  10:Lib/SoftUART.c ****   Copyright 2010  David Prentice (david.prentice [at] farming [dot] uk)
  11:Lib/SoftUART.c ****   Copyright 2010  Peter Danneger
  12:Lib/SoftUART.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  13:Lib/SoftUART.c **** 
  14:Lib/SoftUART.c ****   Permission to use, copy, modify, distribute, and sell this
  15:Lib/SoftUART.c ****   software and its documentation for any purpose is hereby granted
  16:Lib/SoftUART.c ****   without fee, provided that the above copyright notice appear in
  17:Lib/SoftUART.c ****   all copies and that both that the copyright notice and this
  18:Lib/SoftUART.c ****   permission notice and warranty disclaimer appear in supporting
  19:Lib/SoftUART.c ****   documentation, and that the name of the author not be used in
  20:Lib/SoftUART.c ****   advertising or publicity pertaining to distribution of the
  21:Lib/SoftUART.c ****   software without specific, written prior permission.
  22:Lib/SoftUART.c **** 
  23:Lib/SoftUART.c ****   The author disclaim all warranties with regard to this
  24:Lib/SoftUART.c ****   software, including all implied warranties of merchantability
  25:Lib/SoftUART.c ****   and fitness.  In no event shall the author be liable for any
  26:Lib/SoftUART.c ****   special, indirect or consequential damages or any damages
  27:Lib/SoftUART.c ****   whatsoever resulting from loss of use, data or profits, whether
  28:Lib/SoftUART.c ****   in an action of contract, negligence or other tortious action,
  29:Lib/SoftUART.c ****   arising out of or in connection with the use or performance of
  30:Lib/SoftUART.c ****   this software.
  31:Lib/SoftUART.c **** */
  32:Lib/SoftUART.c **** 
  33:Lib/SoftUART.c **** /** \file
  34:Lib/SoftUART.c ****  *
  35:Lib/SoftUART.c ****  *  Software UART for both data transmission and reception. This
  36:Lib/SoftUART.c ****  *  code continuously monitors the ring buffers set up by the main
  37:Lib/SoftUART.c ****  *  project source file and reads/writes data as it becomes available.
  38:Lib/SoftUART.c ****  */
  39:Lib/SoftUART.c **** 
  40:Lib/SoftUART.c **** #include "SoftUART.h"
  41:Lib/SoftUART.c **** 
  42:Lib/SoftUART.c **** /** Total number of bits remaining to be sent in the current frame */
  43:Lib/SoftUART.c **** static uint8_t TX_BitsRemaining;
  44:Lib/SoftUART.c **** 
  45:Lib/SoftUART.c **** /** Temporary data variable to hold the byte being transmitted as it is shifted out */
  46:Lib/SoftUART.c **** static uint8_t TX_Data;
  47:Lib/SoftUART.c **** 
  48:Lib/SoftUART.c **** /** Total number of bits remaining to be received in the current frame */
  49:Lib/SoftUART.c **** static uint8_t RX_BitsRemaining;
  50:Lib/SoftUART.c **** 
  51:Lib/SoftUART.c **** /** Temporary data variable to hold the byte being received as it is shifted in */
  52:Lib/SoftUART.c **** static uint8_t RX_Data;
  53:Lib/SoftUART.c **** 
  54:Lib/SoftUART.c **** 
  55:Lib/SoftUART.c **** /** Initializes the software UART, ready for data transmission and reception into the global ring b
  56:Lib/SoftUART.c **** void SoftUART_Init(void)
  57:Lib/SoftUART.c **** {
  17               		.loc 1 57 0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  58:Lib/SoftUART.c **** 	/* Set TX pin to output high, enable RX pull-up */
  59:Lib/SoftUART.c **** 	STXPORT |= (1 << STX);
  23               		.loc 1 59 0
  24 0000 599A      		sbi 0xb,1
  60:Lib/SoftUART.c **** 	STXDDR  |= (1 << STX);
  25               		.loc 1 60 0
  26 0002 519A      		sbi 0xa,1
  61:Lib/SoftUART.c **** 	SRXPORT |= (1 << SRX);
  27               		.loc 1 61 0
  28 0004 589A      		sbi 0xb,0
  62:Lib/SoftUART.c **** 
  63:Lib/SoftUART.c **** 	/* Enable INT0 for the detection of incoming start bits that signal the start of a byte */
  64:Lib/SoftUART.c **** 	EICRA  = (1 << ISC01);
  29               		.loc 1 64 0
  30 0006 82E0      		ldi r24,lo8(2)
  31 0008 8093 6900 		sts 105,r24
  65:Lib/SoftUART.c **** 	EIMSK  = (1 << INT0);
  32               		.loc 1 65 0
  33 000c 91E0      		ldi r25,lo8(1)
  34 000e 9DBB      		out 0x1d,r25
  35               	.LVL0:
  36               	.LBB40:
  37               	.LBB41:
  38               		.file 2 "Lib/SoftUART.h"
   1:Lib/SoftUART.h **** /*
   2:Lib/SoftUART.h ****              LUFA Library
   3:Lib/SoftUART.h ****      Copyright (C) Dean Camera, 2011.
   4:Lib/SoftUART.h **** 
   5:Lib/SoftUART.h ****   dean [at] fourwalledcubicle [dot] com
   6:Lib/SoftUART.h ****            www.lufa-lib.org
   7:Lib/SoftUART.h **** */
   8:Lib/SoftUART.h **** 
   9:Lib/SoftUART.h **** /*
  10:Lib/SoftUART.h ****   Copyright 2010  David Prentice (david.prentice [at] farming [dot] uk)
  11:Lib/SoftUART.h ****   Copyright 2010  Peter Danneger
  12:Lib/SoftUART.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  13:Lib/SoftUART.h **** 
  14:Lib/SoftUART.h ****   Permission to use, copy, modify, distribute, and sell this
  15:Lib/SoftUART.h ****   software and its documentation for any purpose is hereby granted
  16:Lib/SoftUART.h ****   without fee, provided that the above copyright notice appear in
  17:Lib/SoftUART.h ****   all copies and that both that the copyright notice and this
  18:Lib/SoftUART.h ****   permission notice and warranty disclaimer appear in supporting
  19:Lib/SoftUART.h ****   documentation, and that the name of the author not be used in
  20:Lib/SoftUART.h ****   advertising or publicity pertaining to distribution of the
  21:Lib/SoftUART.h ****   software without specific, written prior permission.
  22:Lib/SoftUART.h **** 
  23:Lib/SoftUART.h ****   The author disclaim all warranties with regard to this
  24:Lib/SoftUART.h ****   software, including all implied warranties of merchantability
  25:Lib/SoftUART.h ****   and fitness.  In no event shall the author be liable for any
  26:Lib/SoftUART.h ****   special, indirect or consequential damages or any damages
  27:Lib/SoftUART.h ****   whatsoever resulting from loss of use, data or profits, whether
  28:Lib/SoftUART.h ****   in an action of contract, negligence or other tortious action,
  29:Lib/SoftUART.h ****   arising out of or in connection with the use or performance of
  30:Lib/SoftUART.h ****   this software.
  31:Lib/SoftUART.h **** */
  32:Lib/SoftUART.h **** 
  33:Lib/SoftUART.h **** /** \file
  34:Lib/SoftUART.h ****  *
  35:Lib/SoftUART.h ****  *  Header file for SoftUART.c.
  36:Lib/SoftUART.h ****  */
  37:Lib/SoftUART.h **** 
  38:Lib/SoftUART.h **** #ifndef _SOFT_UART_
  39:Lib/SoftUART.h **** #define _SOFT_UART_
  40:Lib/SoftUART.h **** 
  41:Lib/SoftUART.h **** 	/* Includes: */
  42:Lib/SoftUART.h **** 		#include <avr/io.h>
  43:Lib/SoftUART.h **** 		#include <avr/interrupt.h>
  44:Lib/SoftUART.h **** 		#include <stdbool.h>
  45:Lib/SoftUART.h **** 
  46:Lib/SoftUART.h **** 		#include "../XPLAINBridge.h"
  47:Lib/SoftUART.h **** 
  48:Lib/SoftUART.h **** 	/* Macros: */
  49:Lib/SoftUART.h **** 		#define SRX        PD0
  50:Lib/SoftUART.h **** 		#define SRXPIN     PIND
  51:Lib/SoftUART.h **** 		#define SRXPORT    PORTD
  52:Lib/SoftUART.h **** 
  53:Lib/SoftUART.h **** 		#define STX        PD1
  54:Lib/SoftUART.h **** 		#define STXPORT    PORTD
  55:Lib/SoftUART.h **** 		#define STXDDR     DDRD
  56:Lib/SoftUART.h **** 
  57:Lib/SoftUART.h **** 	/* Inline Functions: */
  58:Lib/SoftUART.h **** 		static inline void SoftUART_SetBaud(const uint32_t Baud)
  59:Lib/SoftUART.h **** 		{
  60:Lib/SoftUART.h **** 			uint16_t BitTime = ((F_CPU / Baud) - 1);
  61:Lib/SoftUART.h **** 
  62:Lib/SoftUART.h **** 			OCR1A = BitTime;
  39               		.loc 2 62 0
  40 0010 20E4      		ldi r18,lo8(64)
  41 0012 33E0      		ldi r19,lo8(3)
  42 0014 3093 8900 		sts 136+1,r19
  43 0018 2093 8800 		sts 136,r18
  63:Lib/SoftUART.h **** 			OCR3A = BitTime;
  44               		.loc 2 63 0
  45 001c 3093 9900 		sts 152+1,r19
  46 0020 2093 9800 		sts 152,r18
  47               	.LVL1:
  48               	.LBE41:
  49               	.LBE40:
  66:Lib/SoftUART.c **** 
  67:Lib/SoftUART.c **** 	/* Set the transmission and reception timer compare values for the default baud rate */
  68:Lib/SoftUART.c **** 	SoftUART_SetBaud(9600);
  69:Lib/SoftUART.c **** 
  70:Lib/SoftUART.c **** 	/* Setup reception timer compare ISR */
  71:Lib/SoftUART.c **** 	TIMSK1 = (1 << OCIE1A);
  50               		.loc 1 71 0
  51 0024 8093 6F00 		sts 111,r24
  72:Lib/SoftUART.c **** 
  73:Lib/SoftUART.c **** 	/* Setup transmission timer compare ISR and start the timer */
  74:Lib/SoftUART.c **** 	TIMSK3 = (1 << OCIE3A);
  52               		.loc 1 74 0
  53 0028 8093 7100 		sts 113,r24
  75:Lib/SoftUART.c **** 	TCCR3B = ((1 << CS30) | (1 << WGM32));
  54               		.loc 1 75 0
  55 002c 89E0      		ldi r24,lo8(9)
  56 002e 8093 9100 		sts 145,r24
  57 0032 0895      		ret
  58               		.cfi_endproc
  59               	.LFE136:
  61               		.section	.text.__vector_1,"ax",@progbits
  62               	.global	__vector_1
  64               	__vector_1:
  65               	.LFB137:
  76:Lib/SoftUART.c **** }
  77:Lib/SoftUART.c **** 
  78:Lib/SoftUART.c **** /** ISR to detect the start of a bit being sent to the software UART. */
  79:Lib/SoftUART.c **** ISR(INT0_vect, ISR_BLOCK)
  80:Lib/SoftUART.c **** {
  66               		.loc 1 80 0
  67               		.cfi_startproc
  68 0000 1F92      		push r1
  69               	.LCFI0:
  70               		.cfi_def_cfa_offset 3
  71               		.cfi_offset 1, -2
  72 0002 0F92      		push r0
  73               	.LCFI1:
  74               		.cfi_def_cfa_offset 4
  75               		.cfi_offset 0, -3
  76 0004 0FB6      		in r0,__SREG__
  77 0006 0F92      		push r0
  78 0008 1124      		clr __zero_reg__
  79 000a 8F93      		push r24
  80               	.LCFI2:
  81               		.cfi_def_cfa_offset 5
  82               		.cfi_offset 24, -4
  83 000c 9F93      		push r25
  84               	.LCFI3:
  85               		.cfi_def_cfa_offset 6
  86               		.cfi_offset 25, -5
  87               	/* prologue: Signal */
  88               	/* frame size = 0 */
  89               	/* stack size = 5 */
  90               	.L__stack_usage = 5
  81:Lib/SoftUART.c **** 	/* Reset the number of reception bits remaining counter */
  82:Lib/SoftUART.c **** 	RX_BitsRemaining = 8;
  91               		.loc 1 82 0
  92 000e 88E0      		ldi r24,lo8(8)
  93 0010 8093 0000 		sts RX_BitsRemaining,r24
  83:Lib/SoftUART.c **** 
  84:Lib/SoftUART.c **** 	/* Reset the bit reception timer to -(1/2) of the total bit time, so that the first data bit is
  85:Lib/SoftUART.c **** 	 * sampled mid way through the total bit time, making reception more robust.
  86:Lib/SoftUART.c **** 	 */
  87:Lib/SoftUART.c **** 	TCNT1 = -(OCR1A >> 1);
  94               		.loc 1 87 0
  95 0014 8091 8800 		lds r24,136
  96 0018 9091 8900 		lds r25,136+1
  97 001c 9695      		lsr r25
  98 001e 8795      		ror r24
  99 0020 9195      		neg r25
 100 0022 8195      		neg r24
 101 0024 9109      		sbc r25,__zero_reg__
 102 0026 9093 8500 		sts 132+1,r25
 103 002a 8093 8400 		sts 132,r24
  88:Lib/SoftUART.c **** 
  89:Lib/SoftUART.c **** 	/* Check to see that the pin is still low (prevents glitches from starting a frame reception) */
  90:Lib/SoftUART.c **** 	if (!(SRXPIN & (1 << SRX)))
 104               		.loc 1 90 0
 105 002e 4899      		sbic 0x9,0
 106 0030 00C0      		rjmp .L2
  91:Lib/SoftUART.c **** 	{
  92:Lib/SoftUART.c **** 		/* Disable start bit detection ISR while the next byte is received */
  93:Lib/SoftUART.c **** 		EIMSK = 0;
 107               		.loc 1 93 0
 108 0032 1DBA      		out 0x1d,__zero_reg__
  94:Lib/SoftUART.c **** 
  95:Lib/SoftUART.c **** 		/* Start the reception timer */
  96:Lib/SoftUART.c **** 		TCCR1B = ((1 << CS10) | (1 << WGM12));
 109               		.loc 1 96 0
 110 0034 89E0      		ldi r24,lo8(9)
 111 0036 8093 8100 		sts 129,r24
 112               	.L2:
 113               	/* epilogue start */
  97:Lib/SoftUART.c **** 	}
  98:Lib/SoftUART.c **** }
 114               		.loc 1 98 0
 115 003a 9F91      		pop r25
 116 003c 8F91      		pop r24
 117 003e 0F90      		pop r0
 118 0040 0FBE      		out __SREG__,r0
 119 0042 0F90      		pop r0
 120 0044 1F90      		pop r1
 121 0046 1895      		reti
 122               		.cfi_endproc
 123               	.LFE137:
 125               		.section	.text.__vector_17,"ax",@progbits
 126               	.global	__vector_17
 128               	__vector_17:
 129               	.LFB138:
  99:Lib/SoftUART.c **** 
 100:Lib/SoftUART.c **** /** ISR to manage the reception of bits to the software UART. */
 101:Lib/SoftUART.c **** ISR(TIMER1_COMPA_vect, ISR_BLOCK)
 102:Lib/SoftUART.c **** {
 130               		.loc 1 102 0
 131               		.cfi_startproc
 132 0000 1F92      		push r1
 133               	.LCFI4:
 134               		.cfi_def_cfa_offset 3
 135               		.cfi_offset 1, -2
 136 0002 0F92      		push r0
 137               	.LCFI5:
 138               		.cfi_def_cfa_offset 4
 139               		.cfi_offset 0, -3
 140 0004 0FB6      		in r0,__SREG__
 141 0006 0F92      		push r0
 142 0008 1124      		clr __zero_reg__
 143 000a 0BB6      		in r0,__RAMPZ__
 144 000c 0F92      		push r0
 145 000e 2F93      		push r18
 146               	.LCFI6:
 147               		.cfi_def_cfa_offset 5
 148               		.cfi_offset 18, -4
 149 0010 3F93      		push r19
 150               	.LCFI7:
 151               		.cfi_def_cfa_offset 6
 152               		.cfi_offset 19, -5
 153 0012 8F93      		push r24
 154               	.LCFI8:
 155               		.cfi_def_cfa_offset 7
 156               		.cfi_offset 24, -6
 157 0014 9F93      		push r25
 158               	.LCFI9:
 159               		.cfi_def_cfa_offset 8
 160               		.cfi_offset 25, -7
 161 0016 AF93      		push r26
 162               	.LCFI10:
 163               		.cfi_def_cfa_offset 9
 164               		.cfi_offset 26, -8
 165 0018 BF93      		push r27
 166               	.LCFI11:
 167               		.cfi_def_cfa_offset 10
 168               		.cfi_offset 27, -9
 169 001a EF93      		push r30
 170               	.LCFI12:
 171               		.cfi_def_cfa_offset 11
 172               		.cfi_offset 30, -10
 173 001c FF93      		push r31
 174               	.LCFI13:
 175               		.cfi_def_cfa_offset 12
 176               		.cfi_offset 31, -11
 177               	/* prologue: Signal */
 178               	/* frame size = 0 */
 179               	/* stack size = 12 */
 180               	.L__stack_usage = 12
 103:Lib/SoftUART.c **** 	/* Cache the current RX pin value for later checking */
 104:Lib/SoftUART.c **** 	uint8_t SRX_Cached = (SRXPIN & (1 << SRX));
 181               		.loc 1 104 0
 182 001e 99B1      		in r25,0x9
 183 0020 9170      		andi r25,lo8(1)
 184               	.LVL2:
 105:Lib/SoftUART.c **** 
 106:Lib/SoftUART.c **** 	/* Check if reception has finished */
 107:Lib/SoftUART.c **** 	if (RX_BitsRemaining)
 185               		.loc 1 107 0
 186 0022 2091 0000 		lds r18,RX_BitsRemaining
 187 0026 2223      		tst r18
 188 0028 01F0      		breq .L6
 108:Lib/SoftUART.c **** 	{
 109:Lib/SoftUART.c **** 		/* Shift the current received bit mask to the next bit position */
 110:Lib/SoftUART.c **** 		RX_Data >>= 1;
 189               		.loc 1 110 0
 190 002a 8091 0000 		lds r24,RX_Data
 191 002e 8695      		lsr r24
 192 0030 8093 0000 		sts RX_Data,r24
 111:Lib/SoftUART.c **** 		RX_BitsRemaining--;
 193               		.loc 1 111 0
 194 0034 2150      		subi r18,lo8(-(-1))
 195 0036 2093 0000 		sts RX_BitsRemaining,r18
 112:Lib/SoftUART.c **** 
 113:Lib/SoftUART.c **** 		/* Store next bit into the received data variable */
 114:Lib/SoftUART.c **** 		if (SRX_Cached)
 196               		.loc 1 114 0
 197 003a 9923      		tst r25
 198 003c 01F0      		breq .L5
 115:Lib/SoftUART.c **** 		  RX_Data |= (1 << 7);
 199               		.loc 1 115 0
 200 003e 8068      		ori r24,lo8(-128)
 201 0040 8093 0000 		sts RX_Data,r24
 202 0044 00C0      		rjmp .L5
 203               	.L6:
 116:Lib/SoftUART.c **** 	}
 117:Lib/SoftUART.c **** 	else
 118:Lib/SoftUART.c **** 	{
 119:Lib/SoftUART.c **** 		/* Disable the reception timer as all data has now been received, re-enable start bit detection I
 120:Lib/SoftUART.c **** 		TCCR1B = 0;
 204               		.loc 1 120 0
 205 0046 1092 8100 		sts 129,__zero_reg__
 121:Lib/SoftUART.c **** 		EIFR   = (1 << INTF0);
 206               		.loc 1 121 0
 207 004a 81E0      		ldi r24,lo8(1)
 208 004c 8CBB      		out 0x1c,r24
 122:Lib/SoftUART.c **** 		EIMSK  = (1 << INT0);
 209               		.loc 1 122 0
 210 004e 8DBB      		out 0x1d,r24
 123:Lib/SoftUART.c **** 
 124:Lib/SoftUART.c **** 		/* Reception complete, store the received byte if stop bit valid */
 125:Lib/SoftUART.c **** 		if (SRX_Cached)
 211               		.loc 1 125 0
 212 0050 9923      		tst r25
 213 0052 01F0      		breq .L5
 214               	.LVL3:
 215               	.LBB50:
 216               	.LBB51:
 217               		.file 3 "../../LUFA/Drivers/Misc/RingBuffer.h"
   1:../../LUFA/Drivers/Misc/RingBuffer.h **** /*
   2:../../LUFA/Drivers/Misc/RingBuffer.h ****              LUFA Library
   3:../../LUFA/Drivers/Misc/RingBuffer.h ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA/Drivers/Misc/RingBuffer.h **** 
   5:../../LUFA/Drivers/Misc/RingBuffer.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/Misc/RingBuffer.h ****            www.lufa-lib.org
   7:../../LUFA/Drivers/Misc/RingBuffer.h **** */
   8:../../LUFA/Drivers/Misc/RingBuffer.h **** 
   9:../../LUFA/Drivers/Misc/RingBuffer.h **** /*
  10:../../LUFA/Drivers/Misc/RingBuffer.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/Misc/RingBuffer.h **** 
  12:../../LUFA/Drivers/Misc/RingBuffer.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA/Drivers/Misc/RingBuffer.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/Misc/RingBuffer.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA/Drivers/Misc/RingBuffer.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/Misc/RingBuffer.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA/Drivers/Misc/RingBuffer.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA/Drivers/Misc/RingBuffer.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA/Drivers/Misc/RingBuffer.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/Misc/RingBuffer.h **** 
  21:../../LUFA/Drivers/Misc/RingBuffer.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/Misc/RingBuffer.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/Misc/RingBuffer.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/Misc/RingBuffer.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/Misc/RingBuffer.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/Misc/RingBuffer.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/Misc/RingBuffer.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/Misc/RingBuffer.h ****   this software.
  29:../../LUFA/Drivers/Misc/RingBuffer.h **** */
  30:../../LUFA/Drivers/Misc/RingBuffer.h **** 
  31:../../LUFA/Drivers/Misc/RingBuffer.h **** /** \file
  32:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  \brief Lightweight ring (circular) buffer, for fast insertion/deletion of bytes.
  33:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  34:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  Lightweight ring buffer, for fast insertion/deletion. Multiple buffers can be created of
  35:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  different sizes to suit different needs.
  36:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  37:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  Note that for each buffer, insertion and removal operations may occur at the same time (via
  38:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  a multi-threaded ISR based system) however the same kind of operation (two or more insertions
  39:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  or deletions) must not overlap. If there is possibility of two or more of the same kind of
  40:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  operating occurring at the same point in time, atomic (mutex) locking should be used.
  41:../../LUFA/Drivers/Misc/RingBuffer.h ****  */
  42:../../LUFA/Drivers/Misc/RingBuffer.h ****  
  43:../../LUFA/Drivers/Misc/RingBuffer.h **** /** \ingroup Group_MiscDrivers
  44:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  \defgroup Group_RingBuff Generic Byte Ring Buffer - LUFA/Drivers/Misc/RingBuffer.h
  45:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  \brief Lightweight ring buffer, for fast insertion/deletion of bytes.
  46:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  47:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  \section Sec_Dependencies Module Source Dependencies
  48:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  The following files must be built with any user project that uses this module:
  49:../../LUFA/Drivers/Misc/RingBuffer.h ****  *    - None
  50:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  51:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  \section Sec_ModDescription Module Description
  52:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  Lightweight ring buffer, for fast insertion/deletion. Multiple buffers can be created of
  53:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  different sizes to suit different needs.
  54:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  55:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  Note that for each buffer, insertion and removal operations may occur at the same time (via
  56:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  a multi-threaded ISR based system) however the same kind of operation (two or more insertions
  57:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  or deletions) must not overlap. If there is possibility of two or more of the same kind of
  58:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  operating occurring at the same point in time, atomic (mutex) locking should be used.
  59:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  60:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  \section Sec_ExampleUsage Example Usage
  61:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  The following snippet is an example of how this module may be used within a typical
  62:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  application.
  63:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  64:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  \code
  65:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      // Create the buffer structure and its underlying storage array
  66:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      RingBuffer_t Buffer;
  67:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      uint8_t      BufferData[128];
  68:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  69:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      // Initialize the buffer with the created storage array
  70:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      RingBuffer_InitBuffer(&Buffer, BufferData, sizeof(BufferData));
  71:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  72:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      // Insert some data into the buffer
  73:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      RingBuffer_Insert(Buffer, 'H');
  74:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      RingBuffer_Insert(Buffer, 'E');
  75:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      RingBuffer_Insert(Buffer, 'L');
  76:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      RingBuffer_Insert(Buffer, 'L');
  77:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      RingBuffer_Insert(Buffer, 'O');
  78:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  79:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      // Cache the number of stored bytes in the buffer
  80:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      uint16_t BufferCount = RingBuffer_GetCount(&Buffer);
  81:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  82:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      // Printer stored data length
  83:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      printf("Buffer Length: %d, Buffer Data: \r\n", BufferCount);
  84:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  85:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      // Print contents of the buffer one character at a time
  86:../../LUFA/Drivers/Misc/RingBuffer.h ****  *      while (BufferCount--)
  87:../../LUFA/Drivers/Misc/RingBuffer.h ****  *        putc(RingBuffer_Remove(&Buffer));
  88:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  \endcode
  89:../../LUFA/Drivers/Misc/RingBuffer.h ****  *
  90:../../LUFA/Drivers/Misc/RingBuffer.h ****  *  @{
  91:../../LUFA/Drivers/Misc/RingBuffer.h ****  */
  92:../../LUFA/Drivers/Misc/RingBuffer.h **** 
  93:../../LUFA/Drivers/Misc/RingBuffer.h **** #ifndef __RING_BUFFER_H__
  94:../../LUFA/Drivers/Misc/RingBuffer.h **** #define __RING_BUFFER_H__
  95:../../LUFA/Drivers/Misc/RingBuffer.h **** 
  96:../../LUFA/Drivers/Misc/RingBuffer.h **** 	/* Includes: */
  97:../../LUFA/Drivers/Misc/RingBuffer.h **** 		#include "../../Common/Common.h"
  98:../../LUFA/Drivers/Misc/RingBuffer.h **** 
  99:../../LUFA/Drivers/Misc/RingBuffer.h **** 	/* Enable C linkage for C++ Compilers: */
 100:../../LUFA/Drivers/Misc/RingBuffer.h **** 		#if defined(__cplusplus)
 101:../../LUFA/Drivers/Misc/RingBuffer.h **** 			extern "C" {
 102:../../LUFA/Drivers/Misc/RingBuffer.h **** 		#endif
 103:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 104:../../LUFA/Drivers/Misc/RingBuffer.h **** 	/* Type Defines: */
 105:../../LUFA/Drivers/Misc/RingBuffer.h **** 		/** \brief Ring Buffer Management Structure.
 106:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 107:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  Type define for a new ring buffer object. Buffers should be initialized via a call to
 108:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \ref RingBuffer_InitBuffer() before use.
 109:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 */
 110:../../LUFA/Drivers/Misc/RingBuffer.h **** 		typedef struct
 111:../../LUFA/Drivers/Misc/RingBuffer.h **** 		{
 112:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint8_t* In; /**< Current storage location in the circular buffer. */
 113:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint8_t* Out; /**< Current retrieval location in the circular buffer. */
 114:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint8_t* Start; /**< Pointer to the start of the buffer's underlying storage array. */
 115:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint8_t* End; /**< Pointer to the end of the buffer's underlying storage array. */
 116:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint8_t  Size; /**< Size of the buffer's underlying storage array. */
 117:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint16_t Count; /**< Number of bytes currently stored in the buffer. */
 118:../../LUFA/Drivers/Misc/RingBuffer.h **** 		} RingBuffer_t;
 119:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 120:../../LUFA/Drivers/Misc/RingBuffer.h **** 	/* Inline Functions: */
 121:../../LUFA/Drivers/Misc/RingBuffer.h **** 		/** Initializes a ring buffer ready for use. Buffers must be initialized via this function
 122:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  before any operations are called upon them. Already initialized buffers may be reset
 123:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  by re-initializing them using this function.
 124:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 125:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[out] Buffer   Pointer to a ring buffer structure to initialize.
 126:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[out] DataPtr  Pointer to a global array that will hold the data stored into the ring b
 127:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[out] Size     Maximum number of bytes that can be stored in the underlying data array.
 128:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 */
 129:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline void RingBuffer_InitBuffer(RingBuffer_t* Buffer, uint8_t* const DataPtr, const uint
 130:../../LUFA/Drivers/Misc/RingBuffer.h **** 		                                         ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2);
 131:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline void RingBuffer_InitBuffer(RingBuffer_t* Buffer, uint8_t* const DataPtr, const uint
 132:../../LUFA/Drivers/Misc/RingBuffer.h **** 		{
 133:../../LUFA/Drivers/Misc/RingBuffer.h **** 			GCC_FORCE_POINTER_ACCESS(Buffer);
 134:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 135:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
 136:../../LUFA/Drivers/Misc/RingBuffer.h **** 			GlobalInterruptDisable();
 137:../../LUFA/Drivers/Misc/RingBuffer.h **** 	
 138:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Buffer->In     = DataPtr;
 139:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Buffer->Out    = DataPtr;
 140:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Buffer->Start  = &DataPtr[0];
 141:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Buffer->End    = &DataPtr[Size];
 142:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Buffer->Size   = Size;
 143:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Buffer->Count  = 0;
 144:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 145:../../LUFA/Drivers/Misc/RingBuffer.h **** 			SetGlobalInterruptMask(CurrentGlobalInt);
 146:../../LUFA/Drivers/Misc/RingBuffer.h **** 		}
 147:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 148:../../LUFA/Drivers/Misc/RingBuffer.h **** 		/** Retrieves the current number of bytes stored in a particular buffer. This value is computed
 149:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  by entering an atomic lock on the buffer, so that the buffer cannot be modified while the
 150:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  computation takes place. This value should be cached when reading out the contents of the buf
 151:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  so that as small a time as possible is spent in an atomic lock.
 152:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 153:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \note The value returned by this function is guaranteed to only be the minimum number of byte
 154:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        stored in the given buffer; this value may change as other threads write new data, thus
 155:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        the returned number should be used only to determine how many successive reads may safe
 156:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        be performed on the buffer.
 157:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 158:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[in] Buffer  Pointer to a ring buffer structure whose count is to be computed.
 159:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 160:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \return Number of bytes currently stored in the buffer.
 161:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 */
 162:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline uint16_t RingBuffer_GetCount(RingBuffer_t* const Buffer) ATTR_WARN_UNUSED_RESULT AT
 163:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline uint16_t RingBuffer_GetCount(RingBuffer_t* const Buffer)
 164:../../LUFA/Drivers/Misc/RingBuffer.h **** 		{
 165:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint16_t Count;
 166:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 167:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
 168:../../LUFA/Drivers/Misc/RingBuffer.h **** 			GlobalInterruptDisable();
 169:../../LUFA/Drivers/Misc/RingBuffer.h **** 			
 170:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Count = Buffer->Count;
 171:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 172:../../LUFA/Drivers/Misc/RingBuffer.h **** 			SetGlobalInterruptMask(CurrentGlobalInt);
 173:../../LUFA/Drivers/Misc/RingBuffer.h **** 			return Count;
 174:../../LUFA/Drivers/Misc/RingBuffer.h **** 		}
 175:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 176:../../LUFA/Drivers/Misc/RingBuffer.h **** 		/** Retrieves the free space in a particular buffer. This value is computed by entering an atomic
 177:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  on the buffer, so that the buffer cannot be modified while the computation takes place.
 178:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 179:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \note The value returned by this function is guaranteed to only be the maximum number of byte
 180:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        free in the given buffer; this value may change as other threads write new data, thus
 181:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        the returned number should be used only to determine how many successive writes may saf
 182:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        be performed on the buffer when there is a single writer thread.
 183:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 184:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[in] Buffer  Pointer to a ring buffer structure whose free count is to be computed.
 185:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 186:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \return Number of free bytes in the buffer.
 187:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 */
 188:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline uint16_t RingBuffer_GetFreeCount(RingBuffer_t* const Buffer) ATTR_WARN_UNUSED_RESUL
 189:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline uint16_t RingBuffer_GetFreeCount(RingBuffer_t* const Buffer)
 190:../../LUFA/Drivers/Misc/RingBuffer.h **** 		{
 191:../../LUFA/Drivers/Misc/RingBuffer.h **** 			return (Buffer->Size - RingBuffer_GetCount(Buffer));
 192:../../LUFA/Drivers/Misc/RingBuffer.h **** 		}
 193:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 194:../../LUFA/Drivers/Misc/RingBuffer.h **** 		/** Atomically determines if the specified ring buffer contains any data. This should
 195:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  be tested before removing data from the buffer, to ensure that the buffer does not
 196:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  underflow.
 197:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 198:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  If the data is to be removed in a loop, store the total number of bytes stored in the
 199:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  buffer (via a call to the \ref RingBuffer_GetCount() function) in a temporary variable
 200:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  to reduce the time spent in atomicity locks.
 201:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 202:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to insert into.
 203:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 204:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \return Boolean \c true if the buffer contains no free space, false otherwise.
 205:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 */
 206:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline bool RingBuffer_IsEmpty(RingBuffer_t* const Buffer) ATTR_WARN_UNUSED_RESULT ATTR_NO
 207:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline bool RingBuffer_IsEmpty(RingBuffer_t* const Buffer)
 208:../../LUFA/Drivers/Misc/RingBuffer.h **** 		{
 209:../../LUFA/Drivers/Misc/RingBuffer.h **** 			return (RingBuffer_GetCount(Buffer) == 0);
 210:../../LUFA/Drivers/Misc/RingBuffer.h **** 		}
 211:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 212:../../LUFA/Drivers/Misc/RingBuffer.h **** 		/** Atomically determines if the specified ring buffer contains any free space. This should
 213:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  be tested before storing data to the buffer, to ensure that no data is lost due to a
 214:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  buffer overrun.
 215:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 216:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to insert into.
 217:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 218:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \return Boolean \c true if the buffer contains no free space, false otherwise.
 219:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 */
 220:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline bool RingBuffer_IsFull(RingBuffer_t* const Buffer) ATTR_WARN_UNUSED_RESULT ATTR_NON
 221:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline bool RingBuffer_IsFull(RingBuffer_t* const Buffer)
 222:../../LUFA/Drivers/Misc/RingBuffer.h **** 		{
 223:../../LUFA/Drivers/Misc/RingBuffer.h **** 			return (RingBuffer_GetCount(Buffer) == Buffer->Size);
 224:../../LUFA/Drivers/Misc/RingBuffer.h **** 		}
 225:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 226:../../LUFA/Drivers/Misc/RingBuffer.h **** 		/** Inserts an element into the ring buffer.
 227:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 228:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \note Only one execution thread (main program thread or an ISR) may insert into a single buff
 229:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        otherwise data corruption may occur. Insertion and removal may occur from different exe
 230:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        threads.
 231:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 232:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to insert into.
 233:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[in]     Data    Data element to insert into the buffer.
 234:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 */
 235:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline void RingBuffer_Insert(RingBuffer_t* Buffer, const uint8_t Data) ATTR_NON_NULL_PTR_
 236:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline void RingBuffer_Insert(RingBuffer_t* Buffer, const uint8_t Data)
 237:../../LUFA/Drivers/Misc/RingBuffer.h **** 		{
 238:../../LUFA/Drivers/Misc/RingBuffer.h **** 			GCC_FORCE_POINTER_ACCESS(Buffer);
 218               		.loc 3 238 0
 219 0054 E0E0      		ldi r30,lo8(UARTtoUSB_Buffer)
 220 0056 F0E0      		ldi r31,hi8(UARTtoUSB_Buffer)
 221               	.LVL4:
 239:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 240:../../LUFA/Drivers/Misc/RingBuffer.h **** 			*Buffer->In = Data;
 222               		.loc 3 240 0
 223 0058 A081      		ld r26,Z
 224 005a B181      		ldd r27,Z+1
 225 005c 8091 0000 		lds r24,RX_Data
 226 0060 8C93      		st X,r24
 241:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 242:../../LUFA/Drivers/Misc/RingBuffer.h **** 			if (++Buffer->In == Buffer->End)
 227               		.loc 3 242 0
 228 0062 8081      		ld r24,Z
 229 0064 9181      		ldd r25,Z+1
 230 0066 0196      		adiw r24,1
 231 0068 9183      		std Z+1,r25
 232 006a 8083      		st Z,r24
 233 006c 2681      		ldd r18,Z+6
 234 006e 3781      		ldd r19,Z+7
 235 0070 8217      		cp r24,r18
 236 0072 9307      		cpc r25,r19
 237 0074 01F4      		brne .L10
 243:../../LUFA/Drivers/Misc/RingBuffer.h **** 			  Buffer->In = Buffer->Start;
 238               		.loc 3 243 0
 239 0076 8481      		ldd r24,Z+4
 240 0078 9581      		ldd r25,Z+5
 241 007a 9183      		std Z+1,r25
 242 007c 8083      		st Z,r24
 243               	.L10:
 244               	.LBB52:
 245               	.LBB53:
 246               		.file 4 "../../LUFA/Drivers/USB/../../Common/Common.h"
   1:../../LUFA/Drivers/USB/../../Common/Common.h **** /*
   2:../../LUFA/Drivers/USB/../../Common/Common.h ****              LUFA Library
   3:../../LUFA/Drivers/USB/../../Common/Common.h ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA/Drivers/USB/../../Common/Common.h **** 
   5:../../LUFA/Drivers/USB/../../Common/Common.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/USB/../../Common/Common.h ****            www.lufa-lib.org
   7:../../LUFA/Drivers/USB/../../Common/Common.h **** */
   8:../../LUFA/Drivers/USB/../../Common/Common.h **** 
   9:../../LUFA/Drivers/USB/../../Common/Common.h **** /*
  10:../../LUFA/Drivers/USB/../../Common/Common.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/USB/../../Common/Common.h **** 
  12:../../LUFA/Drivers/USB/../../Common/Common.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA/Drivers/USB/../../Common/Common.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/USB/../../Common/Common.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA/Drivers/USB/../../Common/Common.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/USB/../../Common/Common.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA/Drivers/USB/../../Common/Common.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA/Drivers/USB/../../Common/Common.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA/Drivers/USB/../../Common/Common.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/USB/../../Common/Common.h **** 
  21:../../LUFA/Drivers/USB/../../Common/Common.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/USB/../../Common/Common.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/USB/../../Common/Common.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/USB/../../Common/Common.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/USB/../../Common/Common.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/USB/../../Common/Common.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/USB/../../Common/Common.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/USB/../../Common/Common.h ****   this software.
  29:../../LUFA/Drivers/USB/../../Common/Common.h **** */
  30:../../LUFA/Drivers/USB/../../Common/Common.h **** 
  31:../../LUFA/Drivers/USB/../../Common/Common.h **** /** \file
  32:../../LUFA/Drivers/USB/../../Common/Common.h ****  *  \brief Common library convenience headers, macros and functions.
  33:../../LUFA/Drivers/USB/../../Common/Common.h ****  *
  34:../../LUFA/Drivers/USB/../../Common/Common.h ****  *  \copydetails Group_Common
  35:../../LUFA/Drivers/USB/../../Common/Common.h ****  */
  36:../../LUFA/Drivers/USB/../../Common/Common.h **** 
  37:../../LUFA/Drivers/USB/../../Common/Common.h **** /** \defgroup Group_Common Common Utility Headers - LUFA/Drivers/Common/Common.h
  38:../../LUFA/Drivers/USB/../../Common/Common.h ****  *  \brief Common library convenience headers, macros and functions.
  39:../../LUFA/Drivers/USB/../../Common/Common.h ****  *
  40:../../LUFA/Drivers/USB/../../Common/Common.h ****  *  Common utility headers containing macros, functions, enums and types which are common to all
  41:../../LUFA/Drivers/USB/../../Common/Common.h ****  *  aspects of the library.
  42:../../LUFA/Drivers/USB/../../Common/Common.h ****  *
  43:../../LUFA/Drivers/USB/../../Common/Common.h ****  *  @{
  44:../../LUFA/Drivers/USB/../../Common/Common.h ****  */
  45:../../LUFA/Drivers/USB/../../Common/Common.h ****  
  46:../../LUFA/Drivers/USB/../../Common/Common.h **** /** \defgroup Group_GlobalInt Global Interrupt Macros
  47:../../LUFA/Drivers/USB/../../Common/Common.h ****  *  \brief Convenience macros for the management of interrupts globally within the device.
  48:../../LUFA/Drivers/USB/../../Common/Common.h ****  *
  49:../../LUFA/Drivers/USB/../../Common/Common.h ****  *  Macros and functions to create and control global interrupts within the device.
  50:../../LUFA/Drivers/USB/../../Common/Common.h ****  */
  51:../../LUFA/Drivers/USB/../../Common/Common.h **** 
  52:../../LUFA/Drivers/USB/../../Common/Common.h **** #ifndef __LUFA_COMMON_H__
  53:../../LUFA/Drivers/USB/../../Common/Common.h **** #define __LUFA_COMMON_H__
  54:../../LUFA/Drivers/USB/../../Common/Common.h **** 
  55:../../LUFA/Drivers/USB/../../Common/Common.h **** 	/* Macros: */
  56:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#define __INCLUDE_FROM_COMMON_H
  57:../../LUFA/Drivers/USB/../../Common/Common.h **** 		
  58:../../LUFA/Drivers/USB/../../Common/Common.h **** 	/* Includes: */
  59:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include <stdint.h>
  60:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include <stdbool.h>
  61:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include <string.h>
  62:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include <stddef.h>
  63:../../LUFA/Drivers/USB/../../Common/Common.h **** 		
  64:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#if defined(USE_LUFA_CONFIG_HEADER)
  65:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include "LUFAConfig.h"
  66:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#endif
  67:../../LUFA/Drivers/USB/../../Common/Common.h **** 
  68:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include "ArchitectureSpecific.h"
  69:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include "CompilerSpecific.h"
  70:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include "Architectures.h"
  71:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include "Attributes.h"
  72:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#include "BoardTypes.h"
  73:../../LUFA/Drivers/USB/../../Common/Common.h **** 		
  74:../../LUFA/Drivers/USB/../../Common/Common.h **** 	/* Enable C linkage for C++ Compilers: */
  75:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#if defined(__cplusplus)
  76:../../LUFA/Drivers/USB/../../Common/Common.h **** 			extern "C" {
  77:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#endif
  78:../../LUFA/Drivers/USB/../../Common/Common.h **** 
  79:../../LUFA/Drivers/USB/../../Common/Common.h **** 	/* Architecture specific utility includes: */
  80:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#if defined(__DOXYGEN__)
  81:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Type define for an unsigned integer the same width as the selected architecture's machine re
  82:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  This is distinct from the non-specific standard int data type, whose width is machine depend
  83:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  which may not reflect the actual machine register width on some targets (e.g. AVR8).
  84:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
  85:../../LUFA/Drivers/USB/../../Common/Common.h **** 			typedef MACHINE_REG_t uint_reg_t;
  86:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#elif (ARCH == ARCH_AVR8)
  87:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/io.h>
  88:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/interrupt.h>
  89:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/pgmspace.h>
  90:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/eeprom.h>
  91:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/boot.h>
  92:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <util/delay.h>
  93:../../LUFA/Drivers/USB/../../Common/Common.h **** 			
  94:../../LUFA/Drivers/USB/../../Common/Common.h **** 			typedef uint8_t uint_reg_t;
  95:../../LUFA/Drivers/USB/../../Common/Common.h **** 			
  96:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_HAS_EEPROM_ADDRESS_SPACE
  97:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_HAS_FLASH_ADDRESS_SPACE
  98:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_HAS_MULTI_ADDRESS_SPACE
  99:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_LITTLE_ENDIAN
 100:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 101:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include "Endianness.h"
 102:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#elif (ARCH == ARCH_UC3)
 103:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr32/io.h>
 104:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 105:../../LUFA/Drivers/USB/../../Common/Common.h **** 			// === TODO: Find abstracted way to handle these ===
 106:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define PROGMEM                  const
 107:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define pgm_read_byte(x)         *x
 108:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define memcmp_P(...)            memcmp(__VA_ARGS__)
 109:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define memcpy_P(...)            memcpy(__VA_ARGS__)
 110:../../LUFA/Drivers/USB/../../Common/Common.h **** 			// =================================================
 111:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 112:../../LUFA/Drivers/USB/../../Common/Common.h **** 			typedef uint32_t uint_reg_t;
 113:../../LUFA/Drivers/USB/../../Common/Common.h **** 			
 114:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_BIG_ENDIAN
 115:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 116:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include "Endianness.h"
 117:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#elif (ARCH == ARCH_XMEGA)
 118:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/io.h>
 119:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/interrupt.h>
 120:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/pgmspace.h>
 121:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <avr/eeprom.h>
 122:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include <util/delay.h>
 123:../../LUFA/Drivers/USB/../../Common/Common.h **** 			
 124:../../LUFA/Drivers/USB/../../Common/Common.h **** 			typedef uint8_t uint_reg_t;
 125:../../LUFA/Drivers/USB/../../Common/Common.h **** 			
 126:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_HAS_EEPROM_ADDRESS_SPACE
 127:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_HAS_FLASH_ADDRESS_SPACE
 128:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_HAS_MULTI_ADDRESS_SPACE
 129:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define ARCH_LITTLE_ENDIAN
 130:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 131:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#include "Endianness.h"		
 132:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#else
 133:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#error Unknown device architecture specified.
 134:../../LUFA/Drivers/USB/../../Common/Common.h **** 		#endif
 135:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 136:../../LUFA/Drivers/USB/../../Common/Common.h **** 	/* Public Interface - May be used in end-application: */
 137:../../LUFA/Drivers/USB/../../Common/Common.h **** 		/* Macros: */
 138:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Macro for encasing other multi-statement macros. This should be used along with an opening b
 139:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  before the start of any multi-statement macro, so that the macros contents as a whole are tr
 140:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  as a discrete block and not as a list of separate statements which may cause problems when u
 141:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  a block (such as inline \c if statements).
 142:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 143:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define MACROS                  do
 144:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 145:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Macro for encasing other multi-statement macros. This should be used along with a preceding 
 146:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  brace at the end of any multi-statement macro, so that the macros contents as a whole are tr
 147:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  as a discrete block and not as a list of separate statements which may cause problems when u
 148:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  a block (such as inline \c if statements).
 149:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 150:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#define MACROE                  while (0)
 151:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 152:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Convenience macro to determine the larger of two values.
 153:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 154:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \note This macro should only be used with operands that do not have side effects from being 
 155:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *        multiple times.
 156:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 157:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \param[in] x  First value to compare
 158:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \param[in] y  First value to compare
 159:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 160:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \return The larger of the two input parameters
 161:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 162:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#if !defined(MAX) || defined(__DOXYGEN__)
 163:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#define MAX(x, y)               (((x) > (y)) ? (x) : (y))
 164:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#endif
 165:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 166:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Convenience macro to determine the smaller of two values.
 167:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 168:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \note This macro should only be used with operands that do not have side effects from being 
 169:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *        multiple times.
 170:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 171:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \param[in] x  First value to compare
 172:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \param[in] y  First value to compare
 173:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 174:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \return The smaller of the two input parameters
 175:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 176:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#if !defined(MIN) || defined(__DOXYGEN__)
 177:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#define MIN(x, y)               (((x) < (y)) ? (x) : (y))
 178:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#endif
 179:../../LUFA/Drivers/USB/../../Common/Common.h **** 			
 180:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#if !defined(STRINGIFY) || defined(__DOXYGEN__)
 181:../../LUFA/Drivers/USB/../../Common/Common.h **** 				/** Converts the given input into a string, via the C Preprocessor. This macro puts literal quo
 182:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  marks around the input, converting the source into a string literal.
 183:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *
 184:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  \param[in] x  Input to convert into a string literal.
 185:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *
 186:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  \return String version of the input.
 187:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 */
 188:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#define STRINGIFY(x)            #x
 189:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 190:../../LUFA/Drivers/USB/../../Common/Common.h **** 				/** Converts the given input into a string after macro expansion, via the C Preprocessor. This 
 191:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  literal quotation marks around the expanded input, converting the source into a string lite
 192:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *
 193:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  \param[in] x  Input to expand and convert into a string literal.
 194:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *
 195:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  \return String version of the expanded input.
 196:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 */
 197:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#define STRINGIFY_EXPANDED(x)   STRINGIFY(x)
 198:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#endif
 199:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 200:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#if !defined(ISR) || defined(__DOXYGEN__)
 201:../../LUFA/Drivers/USB/../../Common/Common.h **** 				/** Macro for the definition of interrupt service routines, so that the compiler can insert the
 202:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  prologue and epilogue code to properly manage the interrupt routine without affecting the m
 203:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  state with unintentional side-effects.
 204:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *
 205:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  Interrupt handlers written using this macro may still need to be registered with the microc
 206:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  Interrupt Controller (if present) before they will properly handle incoming interrupt event
 207:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *
 208:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  \note This macro is only supplied on some architectures, where the standard library does no
 209:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *        definition. If an existing definition exists, the alternative definition here will be
 210:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *
 211:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  \ingroup Group_GlobalInt
 212:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *
 213:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 *  \param Name  Unique name of the interrupt service routine.
 214:../../LUFA/Drivers/USB/../../Common/Common.h **** 				 */
 215:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#define ISR(Name, ...)                  void Name (void) __attribute__((__interrupt__)) __VA_AR
 216:../../LUFA/Drivers/USB/../../Common/Common.h **** 			#endif
 217:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 218:../../LUFA/Drivers/USB/../../Common/Common.h **** 		/* Inline Functions: */
 219:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Function to reverse the individual bits in a byte - i.e. bit 7 is moved to bit 0, bit 6 to b
 220:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  etc.
 221:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 222:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \param[in] Byte  Byte of data whose bits are to be reversed.
 223:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 224:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \return Input data with the individual bits reversed (mirrored).
 225:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 226:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline uint8_t BitReverse(uint8_t Byte) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
 227:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline uint8_t BitReverse(uint8_t Byte)
 228:../../LUFA/Drivers/USB/../../Common/Common.h **** 			{
 229:../../LUFA/Drivers/USB/../../Common/Common.h **** 				Byte = (((Byte & 0xF0) >> 4) | ((Byte & 0x0F) << 4));
 230:../../LUFA/Drivers/USB/../../Common/Common.h **** 				Byte = (((Byte & 0xCC) >> 2) | ((Byte & 0x33) << 2));
 231:../../LUFA/Drivers/USB/../../Common/Common.h **** 				Byte = (((Byte & 0xAA) >> 1) | ((Byte & 0x55) << 1));
 232:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 233:../../LUFA/Drivers/USB/../../Common/Common.h **** 				return Byte;
 234:../../LUFA/Drivers/USB/../../Common/Common.h **** 			}
 235:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 236:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Function to perform a blocking delay for a specified number of milliseconds. The actual dela
 237:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  at a minimum the specified number of milliseconds, however due to loop overhead and internal
 238:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  may be slightly higher.
 239:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 240:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \param[in] Milliseconds  Number of milliseconds to delay
 241:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 242:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline void Delay_MS(uint16_t Milliseconds) ATTR_ALWAYS_INLINE;
 243:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline void Delay_MS(uint16_t Milliseconds)
 244:../../LUFA/Drivers/USB/../../Common/Common.h **** 			{
 245:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#if (ARCH == ARCH_AVR8)
 246:../../LUFA/Drivers/USB/../../Common/Common.h **** 				if (GCC_IS_COMPILE_CONST(Milliseconds))
 247:../../LUFA/Drivers/USB/../../Common/Common.h **** 				{
 248:../../LUFA/Drivers/USB/../../Common/Common.h **** 					_delay_ms(Milliseconds);
 249:../../LUFA/Drivers/USB/../../Common/Common.h **** 				}
 250:../../LUFA/Drivers/USB/../../Common/Common.h **** 				else
 251:../../LUFA/Drivers/USB/../../Common/Common.h **** 				{
 252:../../LUFA/Drivers/USB/../../Common/Common.h **** 					while (Milliseconds--)
 253:../../LUFA/Drivers/USB/../../Common/Common.h **** 					  _delay_ms(1);
 254:../../LUFA/Drivers/USB/../../Common/Common.h **** 				}
 255:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 256:../../LUFA/Drivers/USB/../../Common/Common.h **** 				while (Milliseconds--)
 257:../../LUFA/Drivers/USB/../../Common/Common.h **** 				{
 258:../../LUFA/Drivers/USB/../../Common/Common.h **** 					__builtin_mtsr(AVR32_COUNT, 0);
 259:../../LUFA/Drivers/USB/../../Common/Common.h **** 					while (__builtin_mfsr(AVR32_COUNT) < (F_CPU / 1000));				
 260:../../LUFA/Drivers/USB/../../Common/Common.h **** 				}
 261:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_XMEGA)
 262:../../LUFA/Drivers/USB/../../Common/Common.h **** 				if (GCC_IS_COMPILE_CONST(Milliseconds))
 263:../../LUFA/Drivers/USB/../../Common/Common.h **** 				{
 264:../../LUFA/Drivers/USB/../../Common/Common.h **** 					_delay_ms(Milliseconds);
 265:../../LUFA/Drivers/USB/../../Common/Common.h **** 				}
 266:../../LUFA/Drivers/USB/../../Common/Common.h **** 				else
 267:../../LUFA/Drivers/USB/../../Common/Common.h **** 				{
 268:../../LUFA/Drivers/USB/../../Common/Common.h **** 					while (Milliseconds--)
 269:../../LUFA/Drivers/USB/../../Common/Common.h **** 					  _delay_ms(1);
 270:../../LUFA/Drivers/USB/../../Common/Common.h **** 				}				
 271:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#endif
 272:../../LUFA/Drivers/USB/../../Common/Common.h **** 			}
 273:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 274:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Retrieves a mask which contains the current state of the global interrupts for the device. T
 275:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  value can be stored before altering the global interrupt enable state, before restoring the
 276:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  flag(s) back to their previous values after a critical section using \ref SetGlobalInterrupt
 277:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 278:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \ingroup Group_GlobalInt
 279:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 280:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \return  Mask containing the current Global Interrupt Enable Mask bit(s).
 281:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 282:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline uint_reg_t GetGlobalInterruptMask(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT
 283:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline uint_reg_t GetGlobalInterruptMask(void)
 284:../../LUFA/Drivers/USB/../../Common/Common.h **** 			{
 285:../../LUFA/Drivers/USB/../../Common/Common.h **** 				GCC_MEMORY_BARRIER();
 247               		.loc 4 285 0
 286:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 287:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#if (ARCH == ARCH_AVR8)
 288:../../LUFA/Drivers/USB/../../Common/Common.h **** 				return SREG;
 248               		.loc 4 288 0
 249 007e 2FB7      		in r18,__SREG__
 250               	.LBE53:
 251               	.LBE52:
 252               	.LBB54:
 253               	.LBB55:
 289:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 290:../../LUFA/Drivers/USB/../../Common/Common.h **** 				return __builtin_mfsr(AVR32_SR);
 291:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_XMEGA)
 292:../../LUFA/Drivers/USB/../../Common/Common.h **** 				return SREG;
 293:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#endif
 294:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 295:../../LUFA/Drivers/USB/../../Common/Common.h **** 				GCC_MEMORY_BARRIER();
 296:../../LUFA/Drivers/USB/../../Common/Common.h **** 			}
 297:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 298:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Sets the global interrupt enable state of the microcontroller to the mask passed into the fu
 299:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  This can be combined with \ref GetGlobalInterruptMask() to save and restore the Global Inter
 300:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  Mask bit(s) of the device after a critical section has completed.
 301:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 302:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \ingroup Group_GlobalInt
 303:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 304:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \param[in] GlobalIntState  Global Interrupt Enable Mask value to use
 305:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 306:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState) ATTR_ALWAYS_INLINE;
 307:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
 308:../../LUFA/Drivers/USB/../../Common/Common.h **** 			{
 309:../../LUFA/Drivers/USB/../../Common/Common.h **** 				GCC_MEMORY_BARRIER();
 310:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 311:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#if (ARCH == ARCH_AVR8)
 312:../../LUFA/Drivers/USB/../../Common/Common.h **** 				SREG = GlobalIntState;
 313:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 314:../../LUFA/Drivers/USB/../../Common/Common.h **** 				if (GlobalIntState & AVR32_SR_GM)
 315:../../LUFA/Drivers/USB/../../Common/Common.h **** 				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
 316:../../LUFA/Drivers/USB/../../Common/Common.h **** 				else
 317:../../LUFA/Drivers/USB/../../Common/Common.h **** 				  __builtin_csrf(AVR32_SR_GM_OFFSET);
 318:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_XMEGA)
 319:../../LUFA/Drivers/USB/../../Common/Common.h **** 				SREG = GlobalIntState;				
 320:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#endif
 321:../../LUFA/Drivers/USB/../../Common/Common.h **** 				
 322:../../LUFA/Drivers/USB/../../Common/Common.h **** 				GCC_MEMORY_BARRIER();
 323:../../LUFA/Drivers/USB/../../Common/Common.h **** 			}
 324:../../LUFA/Drivers/USB/../../Common/Common.h **** 		
 325:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Enables global interrupt handling for the device, allowing interrupts to be handled.
 326:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 327:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \ingroup Group_GlobalInt
 328:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 329:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline void GlobalInterruptEnable(void) ATTR_ALWAYS_INLINE;
 330:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline void GlobalInterruptEnable(void)
 331:../../LUFA/Drivers/USB/../../Common/Common.h **** 			{
 332:../../LUFA/Drivers/USB/../../Common/Common.h **** 				GCC_MEMORY_BARRIER();
 333:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 334:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#if (ARCH == ARCH_AVR8)
 335:../../LUFA/Drivers/USB/../../Common/Common.h **** 				sei();
 336:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 337:../../LUFA/Drivers/USB/../../Common/Common.h **** 				__builtin_csrf(AVR32_SR_GM_OFFSET);
 338:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_XMEGA)
 339:../../LUFA/Drivers/USB/../../Common/Common.h **** 				sei();
 340:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#endif
 341:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 342:../../LUFA/Drivers/USB/../../Common/Common.h **** 				GCC_MEMORY_BARRIER();
 343:../../LUFA/Drivers/USB/../../Common/Common.h **** 			}		
 344:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 345:../../LUFA/Drivers/USB/../../Common/Common.h **** 			/** Disabled global interrupt handling for the device, preventing interrupts from being handled.
 346:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *
 347:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 *  \ingroup Group_GlobalInt
 348:../../LUFA/Drivers/USB/../../Common/Common.h **** 			 */
 349:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline void GlobalInterruptDisable(void) ATTR_ALWAYS_INLINE;
 350:../../LUFA/Drivers/USB/../../Common/Common.h **** 			static inline void GlobalInterruptDisable(void)
 351:../../LUFA/Drivers/USB/../../Common/Common.h **** 			{
 352:../../LUFA/Drivers/USB/../../Common/Common.h **** 				GCC_MEMORY_BARRIER();
 254               		.loc 4 352 0
 353:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 354:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#if (ARCH == ARCH_AVR8)
 355:../../LUFA/Drivers/USB/../../Common/Common.h **** 				cli();
 255               		.loc 4 355 0
 256               	/* #APP */
 257               	 ;  355 "../../LUFA/Drivers/USB/../../Common/Common.h" 1
 258 0080 F894      		cli
 259               	 ;  0 "" 2
 356:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 357:../../LUFA/Drivers/USB/../../Common/Common.h **** 				__builtin_ssrf(AVR32_SR_GM_OFFSET);
 358:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_XMEGA)
 359:../../LUFA/Drivers/USB/../../Common/Common.h **** 				cli();
 360:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#endif
 361:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 362:../../LUFA/Drivers/USB/../../Common/Common.h **** 				GCC_MEMORY_BARRIER();
 260               		.loc 4 362 0
 261               	/* #NOAPP */
 262               	.LBE55:
 263               	.LBE54:
 244:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 245:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
 246:../../LUFA/Drivers/Misc/RingBuffer.h **** 			GlobalInterruptDisable();
 247:../../LUFA/Drivers/Misc/RingBuffer.h **** 			
 248:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Buffer->Count++;
 264               		.loc 3 248 0
 265 0082 8185      		ldd r24,Z+9
 266 0084 9285      		ldd r25,Z+10
 267 0086 0196      		adiw r24,1
 268 0088 9287      		std Z+10,r25
 269 008a 8187      		std Z+9,r24
 270               	.LBB56:
 271               	.LBB57:
 309:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 272               		.loc 4 309 0
 312:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 273               		.loc 4 312 0
 274 008c 2FBF      		out __SREG__,r18
 275               	.LVL5:
 322:../../LUFA/Drivers/USB/../../Common/Common.h **** 			}
 276               		.loc 4 322 0
 277               	.LVL6:
 278               	.L5:
 279               	/* epilogue start */
 280               	.LBE57:
 281               	.LBE56:
 282               	.LBE51:
 283               	.LBE50:
 126:Lib/SoftUART.c **** 		  RingBuffer_Insert(&UARTtoUSB_Buffer, RX_Data);
 127:Lib/SoftUART.c **** 	}
 128:Lib/SoftUART.c **** }
 284               		.loc 1 128 0
 285 008e FF91      		pop r31
 286 0090 EF91      		pop r30
 287 0092 BF91      		pop r27
 288 0094 AF91      		pop r26
 289 0096 9F91      		pop r25
 290               	.LVL7:
 291 0098 8F91      		pop r24
 292 009a 3F91      		pop r19
 293 009c 2F91      		pop r18
 294 009e 0F90      		pop r0
 295 00a0 0BBE      		out __RAMPZ__,r0
 296 00a2 0F90      		pop r0
 297 00a4 0FBE      		out __SREG__,r0
 298 00a6 0F90      		pop r0
 299 00a8 1F90      		pop r1
 300 00aa 1895      		reti
 301               		.cfi_endproc
 302               	.LFE138:
 304               		.section	.text.__vector_32,"ax",@progbits
 305               	.global	__vector_32
 307               	__vector_32:
 308               	.LFB139:
 129:Lib/SoftUART.c **** 
 130:Lib/SoftUART.c **** /** ISR to manage the transmission of bits via the software UART. */
 131:Lib/SoftUART.c **** ISR(TIMER3_COMPA_vect, ISR_BLOCK)
 132:Lib/SoftUART.c **** {
 309               		.loc 1 132 0
 310               		.cfi_startproc
 311 0000 1F92      		push r1
 312               	.LCFI14:
 313               		.cfi_def_cfa_offset 3
 314               		.cfi_offset 1, -2
 315 0002 0F92      		push r0
 316               	.LCFI15:
 317               		.cfi_def_cfa_offset 4
 318               		.cfi_offset 0, -3
 319 0004 0FB6      		in r0,__SREG__
 320 0006 0F92      		push r0
 321 0008 1124      		clr __zero_reg__
 322 000a 0BB6      		in r0,__RAMPZ__
 323 000c 0F92      		push r0
 324 000e 2F93      		push r18
 325               	.LCFI16:
 326               		.cfi_def_cfa_offset 5
 327               		.cfi_offset 18, -4
 328 0010 3F93      		push r19
 329               	.LCFI17:
 330               		.cfi_def_cfa_offset 6
 331               		.cfi_offset 19, -5
 332 0012 8F93      		push r24
 333               	.LCFI18:
 334               		.cfi_def_cfa_offset 7
 335               		.cfi_offset 24, -6
 336 0014 9F93      		push r25
 337               	.LCFI19:
 338               		.cfi_def_cfa_offset 8
 339               		.cfi_offset 25, -7
 340 0016 AF93      		push r26
 341               	.LCFI20:
 342               		.cfi_def_cfa_offset 9
 343               		.cfi_offset 26, -8
 344 0018 BF93      		push r27
 345               	.LCFI21:
 346               		.cfi_def_cfa_offset 10
 347               		.cfi_offset 27, -9
 348 001a EF93      		push r30
 349               	.LCFI22:
 350               		.cfi_def_cfa_offset 11
 351               		.cfi_offset 30, -10
 352 001c FF93      		push r31
 353               	.LCFI23:
 354               		.cfi_def_cfa_offset 12
 355               		.cfi_offset 31, -11
 356               	/* prologue: Signal */
 357               	/* frame size = 0 */
 358               	/* stack size = 12 */
 359               	.L__stack_usage = 12
 133:Lib/SoftUART.c **** 	/* Check if transmission has finished */
 134:Lib/SoftUART.c **** 	if (TX_BitsRemaining)
 360               		.loc 1 134 0
 361 001e 8091 0000 		lds r24,TX_BitsRemaining
 362 0022 8823      		tst r24
 363 0024 01F0      		breq .L15
 135:Lib/SoftUART.c **** 	{
 136:Lib/SoftUART.c **** 		/* Set the TX line to the value of the next bit in the byte to send */
 137:Lib/SoftUART.c **** 		if (TX_Data & (1 << 0))
 364               		.loc 1 137 0
 365 0026 8091 0000 		lds r24,TX_Data
 366 002a 80FF      		sbrs r24,0
 367 002c 00C0      		rjmp .L16
 138:Lib/SoftUART.c **** 		  STXPORT &= ~(1 << STX);
 368               		.loc 1 138 0
 369 002e 5998      		cbi 0xb,1
 370 0030 00C0      		rjmp .L17
 371               	.L16:
 139:Lib/SoftUART.c **** 		else
 140:Lib/SoftUART.c **** 		  STXPORT |=  (1 << STX);
 372               		.loc 1 140 0
 373 0032 599A      		sbi 0xb,1
 374               	.L17:
 141:Lib/SoftUART.c **** 
 142:Lib/SoftUART.c **** 		/* Shift the transmission byte to move the next bit into position and decrement the bits remainin
 143:Lib/SoftUART.c **** 		TX_Data >>= 1;
 375               		.loc 1 143 0
 376 0034 8091 0000 		lds r24,TX_Data
 377 0038 8695      		lsr r24
 378 003a 8093 0000 		sts TX_Data,r24
 144:Lib/SoftUART.c **** 		TX_BitsRemaining--;
 379               		.loc 1 144 0
 380 003e 8091 0000 		lds r24,TX_BitsRemaining
 381 0042 8150      		subi r24,lo8(-(-1))
 382 0044 00C0      		rjmp .L25
 383               	.L15:
 145:Lib/SoftUART.c **** 	}
 146:Lib/SoftUART.c **** 	else if (!(RX_BitsRemaining) && !(RingBuffer_IsEmpty(&USBtoUART_Buffer)))
 384               		.loc 1 146 0
 385 0046 8091 0000 		lds r24,RX_BitsRemaining
 386 004a 8111      		cpse r24,__zero_reg__
 387 004c 00C0      		rjmp .L14
 388               	.LVL8:
 389               	.LBB76:
 390               	.LBB77:
 391               	.LBB78:
 392               	.LBB79:
 393               	.LBB80:
 285:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 394               		.loc 4 285 0
 288:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 395               		.loc 4 288 0
 396 004e 2FB7      		in r18,__SREG__
 397               	.LBE80:
 398               	.LBE79:
 399               	.LBB81:
 400               	.LBB82:
 352:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 401               		.loc 4 352 0
 355:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 402               		.loc 4 355 0
 403               	/* #APP */
 404               	 ;  355 "../../LUFA/Drivers/USB/../../Common/Common.h" 1
 405 0050 F894      		cli
 406               	 ;  0 "" 2
 407               		.loc 4 362 0
 408               	/* #NOAPP */
 409               	.LBE82:
 410               	.LBE81:
 170:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 411               		.loc 3 170 0
 412 0052 8091 0000 		lds r24,USBtoUART_Buffer+9
 413 0056 9091 0000 		lds r25,USBtoUART_Buffer+9+1
 414               	.LVL9:
 415               	.LBB83:
 416               	.LBB84:
 309:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 417               		.loc 4 309 0
 312:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 418               		.loc 4 312 0
 419 005a 2FBF      		out __SREG__,r18
 322:../../LUFA/Drivers/USB/../../Common/Common.h **** 			}
 420               		.loc 4 322 0
 421               	.LVL10:
 422               	.LBE84:
 423               	.LBE83:
 424               	.LBE78:
 425               	.LBE77:
 426               	.LBE76:
 427               		.loc 1 146 0
 428 005c 892B      		or r24,r25
 429 005e 01F0      		breq .L14
 147:Lib/SoftUART.c **** 	{
 148:Lib/SoftUART.c **** 		/* Start bit - TX line low */
 149:Lib/SoftUART.c **** 		STXPORT &= ~(1 << STX);
 430               		.loc 1 149 0
 431 0060 5998      		cbi 0xb,1
 432               	.LVL11:
 433               	.LBB85:
 434               	.LBB86:
 249:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 250:../../LUFA/Drivers/Misc/RingBuffer.h **** 			SetGlobalInterruptMask(CurrentGlobalInt);
 251:../../LUFA/Drivers/Misc/RingBuffer.h **** 		}
 252:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 253:../../LUFA/Drivers/Misc/RingBuffer.h **** 		/** Removes an element from the ring buffer.
 254:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 255:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \note Only one execution thread (main program thread or an ISR) may remove from a single buff
 256:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        otherwise data corruption may occur. Insertion and removal may occur from different exe
 257:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *        threads.
 258:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 259:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to retrieve from.
 260:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *
 261:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 *  \return Next data element stored in the buffer.
 262:../../LUFA/Drivers/Misc/RingBuffer.h **** 		 */
 263:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline uint8_t RingBuffer_Remove(RingBuffer_t* Buffer) ATTR_NON_NULL_PTR_ARG(1);
 264:../../LUFA/Drivers/Misc/RingBuffer.h **** 		static inline uint8_t RingBuffer_Remove(RingBuffer_t* Buffer)
 265:../../LUFA/Drivers/Misc/RingBuffer.h **** 		{
 266:../../LUFA/Drivers/Misc/RingBuffer.h **** 			GCC_FORCE_POINTER_ACCESS(Buffer);
 435               		.loc 3 266 0
 436 0062 E0E0      		ldi r30,lo8(USBtoUART_Buffer)
 437 0064 F0E0      		ldi r31,hi8(USBtoUART_Buffer)
 438               	.LVL12:
 267:../../LUFA/Drivers/Misc/RingBuffer.h **** 		
 268:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint8_t Data = *Buffer->Out;
 439               		.loc 3 268 0
 440 0066 A281      		ldd r26,Z+2
 441 0068 B381      		ldd r27,Z+3
 442 006a 8D91      		ld r24,X+
 443               	.LVL13:
 269:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 270:../../LUFA/Drivers/Misc/RingBuffer.h **** 			if (++Buffer->Out == Buffer->End)
 444               		.loc 3 270 0
 445 006c B383      		std Z+3,r27
 446 006e A283      		std Z+2,r26
 447 0070 2681      		ldd r18,Z+6
 448 0072 3781      		ldd r19,Z+7
 449 0074 A217      		cp r26,r18
 450 0076 B307      		cpc r27,r19
 451 0078 01F4      		brne .L21
 271:../../LUFA/Drivers/Misc/RingBuffer.h **** 			  Buffer->Out = Buffer->Start;
 452               		.loc 3 271 0
 453 007a 2481      		ldd r18,Z+4
 454 007c 3581      		ldd r19,Z+5
 455 007e 3383      		std Z+3,r19
 456 0080 2283      		std Z+2,r18
 457               	.L21:
 458               	.LBB87:
 459               	.LBB88:
 285:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 460               		.loc 4 285 0
 288:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 461               		.loc 4 288 0
 462 0082 9FB7      		in r25,__SREG__
 463               	.LBE88:
 464               	.LBE87:
 465               	.LBB89:
 466               	.LBB90:
 352:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 467               		.loc 4 352 0
 355:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 468               		.loc 4 355 0
 469               	/* #APP */
 470               	 ;  355 "../../LUFA/Drivers/USB/../../Common/Common.h" 1
 471 0084 F894      		cli
 472               	 ;  0 "" 2
 473               		.loc 4 362 0
 474               	/* #NOAPP */
 475               	.LBE90:
 476               	.LBE89:
 272:../../LUFA/Drivers/Misc/RingBuffer.h **** 
 273:../../LUFA/Drivers/Misc/RingBuffer.h **** 			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
 274:../../LUFA/Drivers/Misc/RingBuffer.h **** 			GlobalInterruptDisable();
 275:../../LUFA/Drivers/Misc/RingBuffer.h **** 			
 276:../../LUFA/Drivers/Misc/RingBuffer.h **** 			Buffer->Count--;
 477               		.loc 3 276 0
 478 0086 2185      		ldd r18,Z+9
 479 0088 3285      		ldd r19,Z+10
 480 008a 2150      		subi r18,1
 481 008c 3109      		sbc r19,__zero_reg__
 482 008e 3287      		std Z+10,r19
 483 0090 2187      		std Z+9,r18
 484               	.LBB91:
 485               	.LBB92:
 309:../../LUFA/Drivers/USB/../../Common/Common.h **** 
 486               		.loc 4 309 0
 312:../../LUFA/Drivers/USB/../../Common/Common.h **** 				#elif (ARCH == ARCH_UC3)
 487               		.loc 4 312 0
 488 0092 9FBF      		out __SREG__,r25
 322:../../LUFA/Drivers/USB/../../Common/Common.h **** 			}
 489               		.loc 4 322 0
 490               	.LVL14:
 491               	.LBE92:
 492               	.LBE91:
 493               	.LBE86:
 494               	.LBE85:
 150:Lib/SoftUART.c **** 
 151:Lib/SoftUART.c **** 		/* Transmission complete, get the next byte to send (if available) */
 152:Lib/SoftUART.c **** 		TX_Data          = ~RingBuffer_Remove(&USBtoUART_Buffer);
 495               		.loc 1 152 0
 496 0094 8095      		com r24
 497 0096 8093 0000 		sts TX_Data,r24
 153:Lib/SoftUART.c **** 		TX_BitsRemaining = 9;
 498               		.loc 1 153 0
 499 009a 89E0      		ldi r24,lo8(9)
 500               	.LVL15:
 501               	.L25:
 502 009c 8093 0000 		sts TX_BitsRemaining,r24
 503               	.L14:
 504               	/* epilogue start */
 154:Lib/SoftUART.c **** 	}
 155:Lib/SoftUART.c **** }
 505               		.loc 1 155 0
 506 00a0 FF91      		pop r31
 507 00a2 EF91      		pop r30
 508 00a4 BF91      		pop r27
 509 00a6 AF91      		pop r26
 510 00a8 9F91      		pop r25
 511 00aa 8F91      		pop r24
 512 00ac 3F91      		pop r19
 513 00ae 2F91      		pop r18
 514 00b0 0F90      		pop r0
 515 00b2 0BBE      		out __RAMPZ__,r0
 516 00b4 0F90      		pop r0
 517 00b6 0FBE      		out __SREG__,r0
 518 00b8 0F90      		pop r0
 519 00ba 1F90      		pop r1
 520 00bc 1895      		reti
 521               		.cfi_endproc
 522               	.LFE139:
 524               		.local	RX_Data
 525               		.comm	RX_Data,1,1
 526               		.local	RX_BitsRemaining
 527               		.comm	RX_BitsRemaining,1,1
 528               		.local	TX_Data
 529               		.comm	TX_Data,1,1
 530               		.local	TX_BitsRemaining
 531               		.comm	TX_BitsRemaining,1,1
 532               		.text
 533               	.Letext0:
 534               		.file 5 "/usr/lib/avr/include/stdint.h"
 535               		.file 6 "../AVRISP-MKII/Lib/ISP/ISPTarget.h"
 536               		.file 7 "Lib/../XPLAINBridge.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 SoftUART.c
     /tmp/ccNwoWbl.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccNwoWbl.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccNwoWbl.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccNwoWbl.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccNwoWbl.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccNwoWbl.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccNwoWbl.s:14     .text.SoftUART_Init:0000000000000000 SoftUART_Init
     /tmp/ccNwoWbl.s:64     .text.__vector_1:0000000000000000 __vector_1
     /tmp/ccNwoWbl.s:525    .bss:0000000000000001 RX_BitsRemaining
     /tmp/ccNwoWbl.s:128    .text.__vector_17:0000000000000000 __vector_17
                             .bss:0000000000000000 RX_Data
     /tmp/ccNwoWbl.s:307    .text.__vector_32:0000000000000000 __vector_32
     /tmp/ccNwoWbl.s:529    .bss:0000000000000003 TX_BitsRemaining
     /tmp/ccNwoWbl.s:527    .bss:0000000000000002 TX_Data

UNDEFINED SYMBOLS
UARTtoUSB_Buffer
USBtoUART_Buffer
__do_clear_bss
